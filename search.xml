<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Embedded Programming with the GNU Toolchain</title>
      <link href="/2024/10/17/GNUToolchain/"/>
      <url>/2024/10/17/GNUToolchain/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Origin online url: <a href="https://www.bravegnu.org/gnu-eprog/">https://www.bravegnu.org/gnu-eprog/</a></p><p>github repo: <a href="https://github.com/bravegnu/gnu-eprog/blob/master/gnu-eprog.asciidoc">https://github.com/bravegnu/gnu-eprog/blob/master/gnu-eprog.asciidoc</a></p></blockquote><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>GNU工具链越来越多地被用于深度嵌入式软件开发。这种类型的软件开发也被称为独立C编程和裸机C编程。独立C编程带来了新的问题，处理这些问题需要对GNU工具链有更深入的理解。GNU工具链的手册提供了关于工具链的极好信息，但从工具链的角度，而不是问题的角度。好吧，无论如何，手册应该是这样写的。结果是常见问题的答案分散在各处，GNU工具链的新用户感到困惑。</p><p>本教程试图通过从问题的角度解释工具来弥合差距。希望这能让更多人能够使用 GNU 工具链进行嵌入式项目开发。</p><p>在本教程中，使用Qemu模拟基于ARM的嵌入式系统。有了这个，您可以在舒适的桌面上学习GNU工具链，而无需投资硬件。本教程本身不教授ARM指令集。它应该与其他书籍和在线教程一起使用，例如：</p><ul><li>ARM Assembler - <a href="http://www.heyrick.co.uk/assembler/">http://www.heyrick.co.uk/assembler/</a></li><li>ARM汇编程序-<a href="http://www.heyrick.co.uk/assembler/">http://www.heyrick.co.uk/assembler/</a></li><li>ARM Assembly Language Programming - <a href="http://www.arm.com/miscPDFs/9658.pdf">http://www.arm.com/miscPDFs/9658.pdf</a></li><li>ARM汇编语言编程-<a href="http://www.arm.com/miscPDFs/9658.pdf">http://www.arm.com/miscPDFs/9658.pdf</a></li></ul><p>但为了方便读者，附录中列出了常用的ARM指令。顺序看文中代码时，有 arm 指令不清楚可以跳转到附录查看。</p><hr><h2 id="2-Setting-up-the-ARM-Lab"><a href="#2-Setting-up-the-ARM-Lab" class="headerlink" title="2. Setting up the ARM Lab"></a>2. Setting up the ARM Lab</h2><p>本节介绍如何在你的电脑上使用 Qemu 和 GNU 工具链设置一个简单的 ARM 开发和测试环境。Qemu 是一款可以模拟多种机器（包括基于 ARM 的机器）的机器模拟器。你可以编写 ARM 汇编程序，使用 GNU 工具链进行编译，并在 Qemu 中执行和测试这些程序。</p><h3 id="2-1-Qemu-ARM"><a href="#2-1-Qemu-ARM" class="headerlink" title="2.1. Qemu ARM"></a>2.1. Qemu ARM</h3><p>Qemu 将用于模拟来自 Gumstix 的基于 PXA255 的 <em>connex</em> 开发板。要运行本教程，你需要至少 0.9.1 版本的 Qemu。</p><p>PXA255 处理器具有符合 ARMv5TE 指令集的 ARM 核心。PXA255 还包含多个片上外设。在本教程中，将介绍其中的一些外设。.</p><h3 id="2-2-Installing-Qemu-in-Debian"><a href="#2-2-Installing-Qemu-in-Debian" class="headerlink" title="2.2. Installing Qemu in Debian"></a>2.2. Installing Qemu in Debian</h3><p>This tutorial requires qemu version 0.9.1 or above. The qemu package available in Debian Squeeze&#x2F;Wheezy, meets this requirement. Install <code>qemu</code> using <code>apt-get</code>.</p><blockquote><p>Ubuntu 22.04 上测试，后续使用的，应该通过 <code>apt install qemu-system-arm</code></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install qemu-system-arm</span><br></pre></td></tr></table></figure><h3 id="2-3-Installing-GNU-Toolchain-for-ARM"><a href="#2-3-Installing-GNU-Toolchain-for-ARM" class="headerlink" title="2.3. Installing GNU Toolchain for ARM"></a>2.3. Installing GNU Toolchain for ARM</h3><ol><li><p>Folks at CodeSourcery (part of Mentor Graphics) have been kind enough to make GNU toolchains available for various architectures. Download the GNU toolchain for ARM, available from from <a href="http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/">http://www.mentor.com/embedded-software/sourcery-tools/sourcery-codebench/editions/lite-edition/</a></p><blockquote><p>⛔ 上诉链接早已失效，官方工具链下载地址：<a href="https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads%E3%80%82">https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads。</a></p><p>不过上面链接下载的工具链也有问题，部分工具链接异常。改用 <a href="https://github.com/sophgo/host-tools">https://github.com/sophgo/host-tools</a> 下的工具链。</p></blockquote></li><li><p>Extract the tar archive, to <code>~/toolchains</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> ~/toolchains</span><br><span class="line">$ <span class="built_in">cd</span> ~/toolchains</span><br><span class="line">$ tar -jxf ~/downloads/arm-2008q1-126-arm-linux-gnueabihf-i686-pc-linux-gnu.tar.bz2</span><br></pre></td></tr></table></figure></li><li><p>Add the toolchain to your <code>PATH</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=/home/yogurt/Documents/sophgo/host-tools/gcc/gcc-linaro-6.3.1-2017.05-x86_64_arm-linux-gnueabihf/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li><li><p>You might want to add the previous line to your <code>.bashrc</code>.</p></li></ol><hr><h2 id="3-Hello-ARM"><a href="#3-Hello-ARM" class="headerlink" title="3. Hello ARM"></a>3. Hello ARM</h2><p>在本节中，你将学习如何汇编一个简单的 ARM 程序，并在由 Qemu 模拟的裸机 connex 开发板上进行测试。</p><p>汇编程序的源文件由一系列语句组成，每行一条语句。每条语句的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label:    instruction         @ comment</span><br></pre></td></tr></table></figure><p>上面三个部分都是可选的。</p><ul><li><p>📌 <code>label</code>: 标签是一个方便的方式，<strong>用于指代内存中指令的位置</strong>。标签可以在任何地址可以出现的地方使用，例如作为分支指令的操作数。标签名称应由字母、数字、下划线（<code>_</code>）和美元符号（<code>$</code>）组成。</p><blockquote><p>The label is a convenient way to refer to the location of the instruction in memory. The label can be used where ever an address can appear, for example as an operand of the branch instruction. The label name should consist of alphabets, digits, <code>_</code> and <code>$</code>.</p></blockquote></li><li><p>📝 <code>comment</code>: 注释以 <code>@</code> 开始，<code>@</code> 后出现的字符将被忽略。</p></li><li><p>📜 <code>instruction</code>: 可以是 ARM 指令或汇编指令。汇编指令是给汇编器的命令，💡💡 <strong>汇编指令总是以 <code>.</code>（句点）开头</strong>。</p><blockquote><p>The <code>instruction</code> could be an ARM instruction or an assembler directive. Assembler directives are commands to the assembler. Assembler directives always start with a <code>.</code> (period).</p></blockquote></li></ul><blockquote><p>💡💡 注意后续区分汇编指令与 ARM 指令！！！</p></blockquote><p>以下是一个非常简单的 ARM 汇编程序，用于将两个数字相加：</p><p><strong>Listing 1. Adding Two Numbers</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">start:                       @ Label, not really required</span><br><span class="line">        mov   r0, #5         @ Load register r0 with the value 5</span><br><span class="line">        mov   r1, #4         @ Load register r1 with the value 4</span><br><span class="line">        add   r2, r1, r0     @ Add r0 and r1 and store in r2</span><br><span class="line"></span><br><span class="line">stop:   b stop               @ Infinite loop to stop execution</span><br></pre></td></tr></table></figure><p><code>.text</code> 是一个<strong>汇编指令</strong>，表示接下来的指令应被汇编到代码段，而不是 <code>.data</code> 段。关于段的内容将在后面的教程中详细介绍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The `.text` is an assembler directive, which says that the following instructions</span><br><span class="line">have to be assembled into the code section, rather than the `.data` section.</span><br><span class="line">Sections will be covered in detail, later in the tutorial.</span><br></pre></td></tr></table></figure><h3 id="3-1-Building-the-Binary"><a href="#3-1-Building-the-Binary" class="headerlink" title="3.1. Building the Binary"></a>3.1. Building the Binary</h3><p>将下面的程序保存到一个名为 <code>add.s</code> 的文件中。要汇编该文件，可以使用 GNU 工具链的汇编器 <code>as</code>，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-as -o add.o add.s</span><br></pre></td></tr></table></figure><p><code>-o</code>选项指定输出 文件名。</p><blockquote><p>交叉工具链总是以目标架构的前缀命名，以避免与主机工具链的名称冲突。为了可读性，文本中将不带前缀地提及这些工具。</p></blockquote><p>要生成可执行文件，可以使用 GNU 工具链中的链接器 <code>ld</code>，如下所示的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-ld -Ttext=0x0 -o add.elf add.o</span><br><span class="line">arm-linux-gnueabihf-ld: warning: cannot find entry symbol _start; defaulting to 0000000000000000</span><br></pre></td></tr></table></figure><p>这里同样地，<code>-o</code> 选项用于指定输出文件名。<code>-Ttext=0x0</code> 指定了标签 <code>text</code> 应被分配的地址，使得指令从地址 <code>0x0</code> 开始。要查看各个标签的地址分配，可以使用 <code>nm</code> 命令，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Here again, the `-o` option specifies the output filename.</span></span><br><span class="line"><span class="comment"># The `-Ttext=0x0`, specifies that addresses should be assigned to the labels,</span></span><br><span class="line"><span class="comment"># such that the instructions were starting from address `0x0`.</span></span><br><span class="line"><span class="comment"># To view the address assignment for various labels, the `nm` command can be used as shown below.</span></span><br><span class="line"></span><br><span class="line">$ arm-linux-gnueabihf-nm add.elf</span><br><span class="line">00010010 T __bss_end__</span><br><span class="line">00010010 T _bss_end__</span><br><span class="line">00010010 T __bss_start</span><br><span class="line">00010010 T __bss_start__</span><br><span class="line">00010010 T _edata</span><br><span class="line">00010010 T __end__</span><br><span class="line">00010010 T _end</span><br><span class="line">00000000 t start</span><br><span class="line">0000000c t stop</span><br></pre></td></tr></table></figure><p>请注意标签 <code>start</code> 和 <code>stop</code> 的地址分配。<code>start</code> 的地址被分配为 <code>0x0</code>，因为它是第一条指令的标签。<code>stop</code> 标签在 3 条指令之后。每条指令占用 4 字节，因此 <code>stop</code> 被分配的地址是 12（<code>0xC</code>）。</p><p>使用不同的基地址进行链接将导致标签被分配到不同的地址集。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Note the address assignment for the labels `start` and `stop`. The address assigned</span></span><br><span class="line"><span class="comment"># for `start` is `0x0`. Since it is the label of the first instruction.</span></span><br><span class="line"><span class="comment"># The label `stop` is after 3 instructions. Each instructions is 4 bytes.</span></span><br><span class="line"><span class="comment"># Hence `stop` is assigned an address `12` (`0xC`).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Linking with a different base address for the instructions will result in</span></span><br><span class="line"><span class="comment"># a different set of addresses being assigned to the labels.</span></span><br><span class="line"></span><br><span class="line">$ arm-linux-gnueabihf-ld -Ttext=0x20000000 -o add.elf add.o</span><br><span class="line">$ arm-linux-gnueabihf-nm add.elf</span><br><span class="line">... clip ...</span><br><span class="line">20000000 t start</span><br><span class="line">2000000c t stop</span><br></pre></td></tr></table></figure><p><code>ld</code> 创建的输出文件格式称为 <code>ELF</code>。有多种文件格式可用于存储可执行代码。ELF 格式在有操作系统时运行良好，但由于我们将要在裸机上运行程序，因此需要将其转换为一种更简单的文件格式，称为 <code>binary</code> 格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The output file created by `ld` is in a format called `ELF`. Various file formats are available</span><br><span class="line"> for storing executable code. The ELF format works fine when you have an OS around,</span><br><span class="line"> but since we are going to run the program on bare metal,</span><br><span class="line"> we will have to convert it to a simpler file format called the `binary` format.</span><br></pre></td></tr></table></figure><p><code>binary</code> 格式的文件包含从特定内存地址开始的连续字节。该文件中不存储任何其他附加信息。<strong>这对于 Flash 烧录工具来说非常方便</strong>，因为编程时只需将文件中的每个字节复制到从指定基地址开始的连续地址中即可。</p><blockquote><p>有点像烧录固件时，提前将固件打包为的整包工具。</p></blockquote><p>GNU 工具链中的 <code>objcopy</code> 命令可用于在不同的目标文件格式之间进行转换。以下是该命令的一种常见用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A file in `binary` format contains consecutive bytes from a specific memory address.</span></span><br><span class="line"><span class="comment"># No other additional information is stored in the file. This is convenient for Flash programming tools,</span></span><br><span class="line"><span class="comment"># since all that has to be done when programming is to copy each byte in the file,</span></span><br><span class="line"><span class="comment"># to consecutive address starting from a specified base address in memory.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The GNU toolchain’s `objcopy` command can be used to convert between different object file formats.</span></span><br><span class="line"><span class="comment"># A common usage of the command is given below.</span></span><br><span class="line"></span><br><span class="line">objcopy -O &lt;output-format&gt; &lt;in-file&gt; &lt;out-file&gt;</span><br></pre></td></tr></table></figure><p>将<code>add.elf</code>转换为 <code>binary</code> 格式 可以使用以下命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-objcopy -O binary add.elf add.bin</span><br></pre></td></tr></table></figure><p>检查文件的大小。该文件正好是16个字节。因为有4条指令，每条指令占用4个字节。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al add.bin</span><br><span class="line">-rw-r--r-- 1 vijaykumar vijaykumar 16 2008-10-03 23:56 add.bin</span><br></pre></td></tr></table></figure><h3 id="3-2-Executing-in-Qemu"><a href="#3-2-Executing-in-Qemu" class="headerlink" title="3.2. Executing in Qemu"></a>3.2. Executing in Qemu</h3><p>当 ARM 处理器复位时，它从地址 <code>0x0</code> 开始执行。在 connex 开发板上，16MB 的 Flash 存储器位于地址 <code>0x0</code>。Flash 开始处的指令将被执行。</p><p>当 <code>qemu</code> 模拟 connex 开发板时，必须指定一个文件，该文件将被视为 Flash 存储器。Flash 文件格式非常简单。要从 Flash 中的地址 X 获取字节，<code>qemu</code> 从文件的偏移量 X 读取字节。实际上，这与二进制文件格式是相同的。</p><p>为了在模拟的 Gumstix connex 开发板上测试程序，我们首先创建一个 16MB 的文件来表示 Flash。我们使用 <code>dd</code> 命令从 <code>/dev/zero</code> 复制 16MB 的零字节到文件 <code>flash.bin</code>。数据以 4K 块的形式复制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=flash.bin bs=4096 count=4096</span><br></pre></td></tr></table></figure><p>然后，可以使用以下命令将 <code>add.bin</code> 文件复制到 Flash 的开头：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">dd</span> <span class="keyword">if</span>=add.bin of=flash.bin bs=4096 conv=notrunc</span><br></pre></td></tr></table></figure><p>这相当于将<code>bin</code>文件烧录到闪存上。</p><p>在复位后，处理器将从地址 <code>0x0</code> 开始执行，程序中的指令将被执行。调用 <code>qemu</code> 的命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null</span><br></pre></td></tr></table></figure><p><code>-M connex</code> 选项指定要模拟的机器为 <code>connex</code>。<code>-pflash</code> 选项指定 <code>flash.bin</code> 文件表示 Flash 存储器。<code>-nographic</code> 表示不需要图形显示的模拟。<code>-serial /dev/null</code> 指定 connex 开发板的串口连接到 <code>/dev/null</code>，以便丢弃串口数据。</p><p>系统执行指令后，会在 <code>stop: b stop</code> 指令处无限循环。要查看寄存器的内容，可以使用 <code>qemu</code> 的监视器接口。监视器接口是一个命令行界面，通过它可以控制模拟的系统并查看系统状态。当 <code>qemu</code> 以上述命令启动时，监视器接口将通过 <code>qemu</code> 的标准输入&#x2F;输出提供。</p><p>要查看寄存器的内容，可以使用<code>info registers</code>监视器命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null</span><br><span class="line">WARNING: Image format was not specified <span class="keyword">for</span> <span class="string">&#x27;flash.bin&#x27;</span> and probing guessed raw.</span><br><span class="line">         Automatically detecting the format is dangerous <span class="keyword">for</span> raw images, write operations on block 0 will be restricted.</span><br><span class="line">         Specify the <span class="string">&#x27;raw&#x27;</span> format explicitly to remove the restrictions.</span><br><span class="line">QEMU 6.2.0 monitor - <span class="built_in">type</span> <span class="string">&#x27;help&#x27;</span> <span class="keyword">for</span> more information</span><br><span class="line">(qemu) info registers</span><br><span class="line">R00=00000005 R01=00000004 R02=00000009 R03=00000000</span><br><span class="line">R04=00000000 R05=00000000 R06=00000000 R07=00000000</span><br><span class="line">R08=00000000 R09=00000000 R10=00000000 R11=00000000</span><br><span class="line">R12=00000000 R13=00000000 R14=00000000 R15=0000000c</span><br><span class="line">PSR=400001d3 -Z-- A svc32</span><br><span class="line">FPSCR: 00000000</span><br><span class="line">(qemu)</span><br></pre></td></tr></table></figure><p>请注意寄存器 <code>R02</code> 的值。该寄存器包含加法的结果，应该与预期值 9 相符。</p><h3 id="3-3-More-Monitor-Commands"><a href="#3-3-More-Monitor-Commands" class="headerlink" title="3.3. More Monitor Commands"></a>3.3. More Monitor Commands</h3><p>一些有用的<code>qemu</code>监控命令 列在下表中。</p><table><thead><tr><th>Command</th><th>Purpose</th></tr></thead><tbody><tr><td></td><td></td></tr><tr><td><code>help</code></td><td>List available commands</td></tr><tr><td><code>quit</code></td><td>Quits the emulator</td></tr><tr><td><code>xp /fmt addr</code></td><td>Dump 物理内存中 <code>addr</code> 处的内容</td></tr><tr><td><code>system_reset</code></td><td>Reset the system.</td></tr></tbody></table><p><code>xp</code> 命令需要更多的解释。<code>/fmt</code> 作为参数指定内存内容的显示方式。<code>fmt</code> 的语法为 <code>&lt;count&gt;&lt;format&gt;&lt;size&gt;</code>。</p><ul><li><p><code>count</code>: 表示要显示的 <code>item</code> 数量，例如要显示 4 个字节可以写为 <code>4</code></p></li><li><p><code>format</code>: 指定显示格式。<code>x</code> 代表十六进制，<code>d</code>代表有符号十进制， <code>u</code>代表无符号十进制，<code>o</code>代表八进制，<code>c</code>代表 char和<code>i</code>用于asm指令。</p></li><li><p><code>size</code>: 表示每个 <code>item</code> 的大小，<code>b</code>表示8位，<code>h</code>表示 16位，<code>w</code>代表32位 <code>g</code>为64位。</p></li></ul><p>这个 <code>xp</code> 命令使用 <code>i</code> 格式可以用于反汇编内存中存在的指令。如要反汇编位于 <code>0x0</code> 的指令，可以使用以下 <code>xp</code> 命令，<code>fmt</code> 指定为 <code>4iw</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(qemu) xp /4iw 0x0</span><br><span class="line">0x00000000:  mov        r0, <span class="comment">#5  ; 0x5</span></span><br><span class="line">0x00000004:  mov        r1, <span class="comment">#4  ; 0x4</span></span><br><span class="line">0x00000008:  add        r2, r1, r0</span><br><span class="line">0x0000000c:  b  0xc</span><br></pre></td></tr></table></figure><p>在这个命令中：</p><ul><li><code>4</code> 指定要显示 4 个 <code>item</code>。</li><li><code>i</code> 指定这些项目将以指令形式打印（是的，这个命令内置了反汇编功能！）。</li><li><code>w</code> 指定每个项目的大小为 32 位。</li></ul><p>该命令的输出将显示从地址 <code>0x0</code> 开始的 4 条指令的反汇编结果。</p><hr><h2 id="4-More-Assembler-Directives"><a href="#4-More-Assembler-Directives" class="headerlink" title="4. More Assembler Directives"></a>4. More Assembler Directives</h2><p>在本节中，我们将描述一些常用的<strong>汇编指令</strong>，并使用两个示例程序进行说明。</p><blockquote><p>💡💡 <strong>汇编指令总是以 <code>.</code> 开头</strong>。</p></blockquote><ol><li>一个计算数组总和的程序</li><li>一个计算字符串长度的程序</li></ol><h3 id="4-1-Sum-an-Array"><a href="#4-1-Sum-an-Array" class="headerlink" title="4.1. Sum an Array"></a>4.1. Sum an Array</h3><p>以下代码对一个字节数组进行求和，并将结果存储在 <code>r3</code> 中。</p><p><strong>Listing 2. Sum an Array</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">entry:  b start                 @ Skip over the data</span><br><span class="line">arr:    .byte 10, 20, 25        @ Read-only array of bytes</span><br><span class="line">eoa:                            @ Address of end of array + 1</span><br><span class="line"></span><br><span class="line">        .align</span><br><span class="line">start:</span><br><span class="line">        ldr   r0, =eoa          @ r0 = &amp;eoa</span><br><span class="line">        ldr   r1, =arr          @ r1 = &amp;arr</span><br><span class="line">        mov   r3, #0            @ r3 = 0</span><br><span class="line">loop:   ldrb  r2, [r1], #1      @ r2 = *r1++</span><br><span class="line">        add   r3, r2, r3        @ r3 += r2</span><br><span class="line">        cmp   r1, r0            @ if (r1 != r2)</span><br><span class="line">        bne   loop              @    goto loop</span><br><span class="line">stop:   b stop</span><br></pre></td></tr></table></figure><p>该代码引入了两个新的<strong>汇编指令</strong>——<code>.byte</code> 和 <code>.align</code>。以下是对这些汇编指令的描述。</p><h4 id="4-1-1-byte-Directive"><a href="#4-1-1-byte-Directive" class="headerlink" title="4.1.1. .byte Directive"></a>4.1.1. <code>.byte</code> Directive</h4><p><code>.byte</code> 的字节大小参数<strong>在内存中被组装成连续的字节</strong>。还有类似的指令 <code>.2byte</code> 和 <code>.4byte</code> 分别用于存储 16 位值和 32 位值。一般的语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The byte sized arguments of `.byte` are assembled into consecutive bytes in memory.</span><br><span class="line">There are similar directives `.2byte` and `.4byte` for storing 16 bit values and 32 bit values, respectively.</span><br><span class="line">The general syntax is given below.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.byte   exp1, exp2, ...</span><br><span class="line">.2byte  exp1, exp2, ...</span><br><span class="line">.4byte  exp1, exp2, ...</span><br></pre></td></tr></table></figure><p>参数可以是简单的整数字面量，可以用二进制（以 <code>0b</code> 或 <code>0B</code> 为前缀）、八进制（以 <code>0</code> 为前缀）、十进制或十六进制（以 <code>0x</code> 或 <code>0X</code> 为前缀）表示。整数也可以用字符常量表示（字符用单引号括起来），在这种情况下将使用字符的 ASCII 值。</p><p>参数还可以是<strong>由字面量和其他符号构成的 C 表达式</strong>。下面给出了示例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The arguments could be simple integer literal, represented as binary (prefixed by `0b` or `0B`),</span><br><span class="line">octal (prefixed by `0`), decimal or hexadecimal (prefixed by `0x` or `0X`).</span><br><span class="line">The integers could also be represented as character constants (character surrounded by single quotes),</span><br><span class="line">in which case the ASCII value of the character will be used.</span><br><span class="line"></span><br><span class="line">The arguments could also be C expressions constructed out of literals and other symbols. Examples are shown below.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pattern:  .byte 0b01010101, 0b00110011, 0b00001111</span><br><span class="line">npattern: .byte npattern - pattern</span><br><span class="line">halpha:   .byte &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;</span><br><span class="line">dummy:    .4byte 0xDEADBEEF</span><br><span class="line">nalpha:   .byte &#x27;Z&#x27; - &#x27;A&#x27; + 1</span><br></pre></td></tr></table></figure><h4 id="4-1-2-align-Directive"><a href="#4-1-2-align-Directive" class="headerlink" title="4.1.2. .align Directive"></a>4.1.2. <code>.align</code> Directive</h4><p>ARM 要求<strong>指令</strong>必须位于 32 位对齐的内存位置。指令中的 4 个字节的第一个字节的地址应该是 4 的倍数。为了满足这一要求，可以使用 <code>.align</code> 指令插入填充字节，直到下一个字节地址为 4 的倍数。这仅在代码中插入数据字节或半字时需要。</p><blockquote><p>💡💡注意是 arm 指令，不是数据（或者说标签），也不是 <strong>汇编指令</strong>（不然 .align 本身就得先对齐才能使用了）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ARM requires that the instructions be present in 32-bit aligned memory locations.</span><br><span class="line">The address of the first byte, of the 4 bytes in an instruction, should be a multiple of 4.</span><br><span class="line">To adhere to this, the `.align` directive can be used to insert padding bytes</span><br><span class="line">till the next byte address will be a multiple of 4.</span><br><span class="line">This is required only when data bytes or half words are inserted within code.</span><br></pre></td></tr></table></figure><h3 id="4-2-String-Length"><a href="#4-2-String-Length" class="headerlink" title="4.2. String Length"></a>4.2. String Length</h3><p>以下代码计算字符串的长度，并将长度存储在寄存器 <code>r1</code> 中。</p><p><strong>Listing 3. String Length</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">        b start</span><br><span class="line"></span><br><span class="line">str:    .asciz &quot;Hello World&quot;</span><br><span class="line"></span><br><span class="line">        .equ   nul, 0</span><br><span class="line"></span><br><span class="line">        .align</span><br><span class="line">start:  ldr   r0, =str          @ r0 = &amp;str</span><br><span class="line">        mov   r1, #0</span><br><span class="line"></span><br><span class="line">loop:   ldrb  r2, [r0], #1      @ r2 = *(r0++)</span><br><span class="line">        add   r1, r1, #1        @ r1 += 1</span><br><span class="line">        cmp   r2, #nul          @ if (r2 != nul)</span><br><span class="line">        bne   loop              @    goto loop</span><br><span class="line"></span><br><span class="line">        sub   r1, r1, #1        @ r1 -= 1</span><br><span class="line">stop:   b stop</span><br></pre></td></tr></table></figure><p>该代码引入了两个新的汇编指令——<code>.asciz</code> 和 <code>.equ</code>。以下是对这些汇编指令的描述。</p><h4 id="4-2-1-asciz-Directive"><a href="#4-2-1-asciz-Directive" class="headerlink" title="4.2.1. .asciz Directive"></a>4.2.1. <code>.asciz</code> Directive</h4><p><code>.asciz</code> 指令接受字符串字面量作为参数。<strong>字符串字面量是用双引号括起来的字符序列</strong>。这些字符串字面量被组装到连续的内存位置。汇编程序会自动在每个字符串后插入一个 <code>nul</code> 字符（<code>\0</code> 字符）。</p><p><code>.ascii</code> 指令与 <code>.asciz</code> 相同，但<strong>汇编程序不会在每个字符串后插入 <code>nul</code> 字符</strong>。</p><blockquote><p>⛔⛔⛔ 注意二者区别。</p></blockquote><h4 id="4-2-2-equ-Directive"><a href="#4-2-2-equ-Directive" class="headerlink" title="4.2.2. .equ Directive"></a>4.2.2. <code>.equ</code> Directive</h4><p>汇编程序维护一个称为符号表的结构。符号表将标签名称映射到地址。<strong>每当汇编程序遇到标签定义时，它会在符号表中创建一个条目</strong>。每当汇编程序遇到标签引用时，它会用符号表中对应的地址替换该标签。</p><p>💡💡<strong>使用汇编指令 <code>.equ</code>，也可以手动向符号表中插入条目，将名称映射到不一定是地址的值</strong>。每当汇编程序遇到这些名称时，它会用相应的值替换它们。这些名称和标签名称统称为<strong>符号名称</strong>。</p><p>该指令的一般语法如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The assembler maintains something called a symbol table. The symbol table maps label names to addresses.</span><br><span class="line">Whenever the assembler encounters a label definition, the assembler makes an entry in the symbol table.</span><br><span class="line">And whenever the assembler encounters a label reference, it replaces the label by the corresponding</span><br><span class="line">address from the symbol table.</span><br><span class="line"></span><br><span class="line">Using the assembler directive `.equ`, it is also possible to manually insert entries in the symbol table,</span><br><span class="line">to map names to values, which are not necessarily addresses. Whenever the assembler encounters these names,</span><br><span class="line">it replaces them by their corresponding values. These names and label names are together called symbol names.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.equ name, expression</span><br></pre></td></tr></table></figure><ul><li><code>name</code> 是一个符号名称，其限制与标签名称相同。</li><li><code>expression</code> 可以是简单的字面量，也可以是如 <code>.byte</code> 指令中所解释的表达式。</li></ul><blockquote><p>与 <code>.byte</code> 指令不同，<code>.equ</code> 指令本身并不分配任何内存。它们只是创建符号表中的条目。</p></blockquote><h2 id="5-Using-RAM"><a href="#5-Using-RAM" class="headerlink" title="5. Using RAM"></a>5. Using RAM</h2><p>Flash 存储器中存储的前面的示例程序是一种 EEPROM。它是一种有用的二级存储，类似于硬盘，但在 Flash 中存储变量并不方便。变量应存储在 RAM 中，以便可以轻松修改。</p><p>Connex 板具有 64 MB 的 RAM，从地址 <code>0xA0000000</code> 开始，可以在其中存储变量。Connex 板的内存映射可以如下图所示。</p><p><strong>Figure 1. Memory Map</strong></p><p><img src="/../images/GNUToolchain/flash-ram-mm.png" alt="Memory Map"></p><p>需要进行必要的设置，以将变量放置在该地址。要理解需要做什么，就必须了解汇编器和链接器的角色。</p><blockquote><p>个人理解：汇编器将单个文件解释为机器指令。链接器将这些机器指令组合在一起，形成最终的可执行文件。</p></blockquote><h2 id="6-Linker"><a href="#6-Linker" class="headerlink" title="6. Linker"></a>6. Linker</h2><p>在编写多文件程序时，每个文件会单独汇编成目标文件。链接器将这些目标文件组合在一起，形成最终的可执行文件。</p><p><strong>Figure 2. Role of the Linker</strong></p><p><img src="/../images/GNUToolchain/linker.png" alt="Role of the Linker"></p><p>在合并目标文件时，<strong>链接器</strong>执行以下操作：</p><ol><li>Symbol Resolution 符号解析</li><li>Relocation 重定位</li></ol><p>在本节中，我们将详细介绍这些操作。</p><h3 id="6-1-Symbol-Resolution"><a href="#6-1-Symbol-Resolution" class="headerlink" title="6.1. Symbol Resolution"></a>6.1. Symbol Resolution</h3><p>在单文件程序中，在生成目标文件时，汇编器将所有标签的引用替换为相应的地址。但在多文件程序中，如果存在对其他文件中定义的标签的引用，汇编器将这些引用标记为“<strong>未解决</strong>”。当这些目标文件被传递给链接器时，链接器从其他目标文件中确定这些引用的值，并使用正确的值修补代码。</p><blockquote><p>想想动态库的例子，板端运行程序时才去使用链接器进行链接，而汇编器仅在编译时使用。链接器也可以在编译时使用，静态链接 <code>-static</code>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In a single file program, while producing the object file, all references to labels are replaced by</span><br><span class="line">their corresponding addresses by the assembler. But in a multi-file program, if there are any references</span><br><span class="line">to labels defined in another file, the assembler marks these references as &quot;unresolved&quot;.</span><br><span class="line">When these object files are passed to the linker, the linker determines the values for</span><br><span class="line">these references from the other object files, and patches the code with the correct values.</span><br></pre></td></tr></table></figure><p>为了演示链接器执行的<strong>符号解析</strong>，数组求和示例被分为两个文件。这两个文件将被汇编，并检查它们的符号表，以显示未解决引用的存在。</p><p>文件 <code>sum-sub.s</code> 包含 <code>sum</code> 子程序，而文件 <code>main.s</code> 使用所需的参数调用该子程序。文件的源代码如下所示。</p><p><strong>Listing 4. <code>main.s</code> - Subroutine Invocation</strong> 子程序调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">        .text</span><br><span class="line">        b start                 @ Skip over the data</span><br><span class="line">arr:    .byte 10, 20, 25        @ Read-only array of bytes</span><br><span class="line">eoa:                            @ Address of end of array + 1</span><br><span class="line"></span><br><span class="line">        .align</span><br><span class="line">start:</span><br><span class="line">        ldr   r0, =arr          @ r0 = &amp;arr</span><br><span class="line">        ldr   r1, =eoa          @ r1 = &amp;eoa</span><br><span class="line"></span><br><span class="line">        bl    sum               @ Invoke the sum subroutine</span><br><span class="line"></span><br><span class="line">stop:   b stop</span><br></pre></td></tr></table></figure><p>**Listing 5. <code>sum-sub.s</code> - Subroutine Definition **子程序定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">        @ Args</span><br><span class="line">        @ r0: Start address of array</span><br><span class="line">        @ r1: End address of array</span><br><span class="line">        @</span><br><span class="line">        @ Result</span><br><span class="line">        @ r3: Sum of Array</span><br><span class="line"></span><br><span class="line">        .global sum</span><br><span class="line"></span><br><span class="line">sum:    mov   r3, #0            @ r3 = 0</span><br><span class="line">loop:   ldrb  r2, [r0], #1      @ r2 = *r0++    ; Get array element</span><br><span class="line">        add   r3, r2, r3        @ r3 += r2      ; Calculate sum</span><br><span class="line">        cmp   r0, r1            @ if (r0 != r1) ; Check if hit end-of-array</span><br><span class="line">        bne   loop              @    goto loop  ; Loop</span><br><span class="line">        mov   pc, lr            @ pc = lr       ; Return when done</span><br></pre></td></tr></table></figure><p>关于 <code>.global</code> 指令需要说明一下。在 C 语言中，所有在函数外部声明的变量对其他文件可见，直到明确声明为 <code>static</code>。<br><strong>但</strong>在汇编语言中，所有标签都是 <code>static</code>（即本地文件的），直到明确声明它们应该对其他文件可见，使用 <code>.global</code> 指令。</p><p>这些文件被汇编，并使用 <code>nm</code> 命令查看符号表。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-as -o main.o main.s</span><br><span class="line">$ arm-linux-gnueabihf-as -o sum-sub.o sum-sub.s</span><br><span class="line">$ arm-linux-gnueabihf-nm main.o</span><br><span class="line">00000004 t arr</span><br><span class="line">00000007 t eoa <span class="comment"># 注意看这里并没有对齐，回顾上面 `.align` 指令</span></span><br><span class="line">00000008 t start</span><br><span class="line">00000018 t stop</span><br><span class="line">         U <span class="built_in">sum</span></span><br><span class="line">$ arm-linux-gnueabihf-nm sum-sub.o</span><br><span class="line">00000004 t loop</span><br><span class="line">00000000 T <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><p>关注第二列中的字母，它指定了符号类型。<code>t</code> 表示符号在文本段中定义。<code>u</code> 表示符号未定义。**:fire: 大写字母表示符号是** <code>.global</code>。</p><p>显然，符号 <code>sum</code> 在 <code>sum-sub.o</code> 中定义，在 <code>main.o</code> 中尚未解析。当链接器被调用时，符号引用将被解析，并生成可执行文件。</p><h3 id="6-2-Relocation"><a href="#6-2-Relocation" class="headerlink" title="6.2. Relocation"></a>6.2. Relocation</h3><p>Relocation is the process of changing addresses already assigned to labels. This will also involve patching up all label references to reflect the newly assigned address. Primarily, relocation is performed for the following two reasons:</p><p>重定位是更改已分配给标签的地址的过程。这也涉及修补所有标签引用以反映新分配的地址。主要，重定位是出于以下两个原因：</p><ol><li>Section Merging 段合并</li><li>Section Placement 段放置</li></ol><p>To understand the process of relocation, an understanding of the concept of sections is essential.</p><p>要理解重定位的过程，必须理解段的概念。</p><p>Code and data have different run time requirements. For example code can be placed in read-only memory, and data might require read-write memory. It would be convenient, if code and data is <strong>not</strong> interleaved. For this purpose, programs are divided into sections. Most programs have at least two sections, <code>.text</code> for code and <code>.data</code> for data. Assembler directives <code>.text</code> and <code>.data</code>, are used to switch back and forth between the two sections.</p><p>代码和数据在运行时有不同的要求。例如，代码可以放置在只读内存中，而数据可能需要读写内存。如果代码和数据<strong>不</strong>交错放置，将会更方便。为此，程序被分为不同的段。大多数程序至少有两个段，<code>.text</code> 用于代码，<code>.data</code> 用于数据。汇编指令 <code>.text</code> 和 <code>.data</code> 用于在这两个段之间切换。</p><p>It helps to imagine each section as a bucket. When the assembler hits a section directive, it puts the code&#x2F;data following the directive in the selected bucket. Thus the code&#x2F;data that belong to particular section appear in contiguous locations. The following figures show how the assembler re-arranges data into sections.</p><p>想象每个段都是一个桶。当汇编器遇到段指令时，它会将段指令后面的代码&#x2F;数据放入所选的桶中。因此，属于特定段的代码&#x2F;数据会出现在连续的位置。以下图显示了汇编器如何将数据重新排列到段中。</p><p><strong>Figure 3. Sections</strong></p><p><img src="/../images/GNUToolchain/sections.png" alt="Sections"></p><p>Now that we have an understanding of sections, let us look into the primary reasons for which relocation is performed.</p><p>现在我们理解了段的概念，让我们看一下重定位的主要原因。</p><h4 id="6-2-1-Section-Merging"><a href="#6-2-1-Section-Merging" class="headerlink" title="6.2.1. Section Merging"></a>6.2.1. Section Merging</h4><p>When dealing with multi-file programs, the sections with the same name (example <code>.text</code>) might appear, in each file. The linker is responsible for merging sections from the input files, into sections of the output file. By default, the sections, with the same name, from each file is placed contiguously and the label references are patched to reflect the new address.</p><p>处理多文件程序时，每个文件中可能出现同名的段（例如 <code>.text</code>）。链接器负责将输入文件中的相同名称的段合并到输出文件的段中。默认情况下，来自每个文件的同名段被连续放置，标签引用也会修补以反映新地址。</p><p>The effects of section merging can be seen by looking at the symbol table of the object files and the corresponding executable file. The multi-file sum of array program can be used to illustrate section merging. The symbol table of the object files <code>main.o</code> and <code>sum-sub.o</code> and the symbol table of the executable file <code>sum.elf</code> is shown below.</p><p>可以通过查看目标文件的符号表以及可执行文件的符号表，看到段合并的效果。可以使用多文件的数组求和程序来说明段合并的过程。目标文件 <code>main.o</code> 和 <code>sum-sub.o</code> 的符号表以及可执行文件 <code>sum.elf</code> 的符号表如下所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-nm main.o</span><br><span class="line">00000004 t arr</span><br><span class="line">00000007 t eoa</span><br><span class="line">00000008 t start</span><br><span class="line">00000018 t stop</span><br><span class="line">         U <span class="built_in">sum</span></span><br><span class="line">$ arm-linux-gnueabihf-nm sum-sub.o</span><br><span class="line">00000004 t loop ❶</span><br><span class="line">00000000 T <span class="built_in">sum</span></span><br><span class="line">$ arm-linux-gnueabihf-ld -Ttext=0x0 -o sum.elf main.o sum-sub.o</span><br><span class="line">$ arm-linux-gnueabihf-nm sum.elf</span><br><span class="line">...</span><br><span class="line">00000004 t arr</span><br><span class="line">00000007 t eoa</span><br><span class="line">00000008 t start</span><br><span class="line">00000018 t stop</span><br><span class="line">00000028 t loop ❶</span><br><span class="line">00000024 T <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><ol><li><p>The <code>loop</code> symbol has address <code>0x4</code> in <code>sum-sub.o</code>, and <code>0x28</code> in <code>sum.elf</code>, since the <code>.text</code> section of <code>sum-sub.o</code> is placed right after the <code>.text</code> section of <code>main.o</code>.</p><p>该<code>loop</code>符号的地址<code>0x4</code>在<code>sum-sub.o</code>，<code>0x28</code>在 <code>sum.elf</code>o的<code>.text</code>部分<code>sum-sub.o</code>右边 在main. o的<code>.text</code>部分<code>main.o</code>。</p></li></ol><h4 id="6-2-2-Section-Placement"><a href="#6-2-2-Section-Placement" class="headerlink" title="6.2.2. Section Placement"></a>6.2.2. Section Placement</h4><p>当程序被汇编时，每个段被假定从地址 0 开始。因此，标签相对于段的起始位置分配值。当最终可执行文件创建时，该段被放置在某个地址 X。所有在该段内定义的标签的引用都将增加 X，以使它们指向新位置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">When a program is assembled, each section is assumed to start from address 0. And thus labels are assigned values relative to start of the section. When the final executable is created, the section is placed at some address X. And all references to the labels defined within the section, are incremented by X, so that they point to the new location.</span><br></pre></td></tr></table></figure><p>每个段在内存中特定位置的放置以及对段中标签的所有引用的修补，由链接器完成。</p><p>The placement of each section at a particular location in memory and the patching of all references to the labels in the section, is done by the linker.</p><p>可以通过查看目标文件的符号表以及可执行文件的符号表，看到段放置的效果。可以使用单文件的数组求和程序来说明段放置的过程。为了更清楚起见，我们将把 .text 段放置在地址 0x100。</p><p>The effects of section placement can be seen by looking at the symbol table of the object file and the corresponding executable file. The single file sum of array program can be used to illustrate section placement. To make things clearer, we will place the <code>.text</code> section at address <code>0x100</code>.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-as -o sum.o sum.s</span><br><span class="line">$ arm-linux-gnueabihf-nm -n sum.o</span><br><span class="line">00000000 t entry ❶</span><br><span class="line">00000004 t arr</span><br><span class="line">00000007 t eoa</span><br><span class="line">00000008 t start</span><br><span class="line">00000014 t loop</span><br><span class="line">00000024 t stop</span><br><span class="line">$ arm-linux-gnueabihf-ld -Ttext=0x100 -o sum.elf sum.o ❷</span><br><span class="line">$ arm-linux-gnueabihf-nm -n sum.elf</span><br><span class="line">00000100 t entry ❸</span><br><span class="line">00000104 t arr</span><br><span class="line">00000107 t eoa</span><br><span class="line">00000108 t start</span><br><span class="line">00000114 t loop</span><br><span class="line">00000124 t stop</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><a href="https://www.bravegnu.org/gnu-eprog/linker.html#CO2-1">❶</a> | The address for labels are assigned starting from <code>0</code> within a section. 段内标签的地址从 0 开始分配。 |<br>| <a href="https://www.bravegnu.org/gnu-eprog/linker.html#CO2-2">❷</a> | When the executable is created the linker is instructed to place the text section at address <code>0x100</code>. 当可执行文件创建时，链接器被指示将文本段放置在地址 0x100。 |<br>| <a href="https://www.bravegnu.org/gnu-eprog/linker.html#CO2-3">❸</a> | The address for labels in the <code>.text</code> section are re-assigned starting from <code>0x100</code>, and all label references will be patched to reflect this. <code>.text</code> 段中的标签的地址被重新分配，起始地址为 0x100，所有标签引用将被修补以反映此更改。 |</p><p>The process of section merging and placement is shown in the following figure.</p><p>段合并和放置的过程如下图所示。</p><p><strong>Figure 4. Section Merging and Placement</strong></p><p><img src="/../images/GNUToolchain/relocation.png" alt="Section Merging and Placement"></p><hr><h2 id="7-Linker-Script-File"><a href="#7-Linker-Script-File" class="headerlink" title="7. Linker Script File"></a>7. Linker Script File</h2><p>As mentioned in the previous section, section merging and placement is done by the linker. The programmer can control how the sections are merged, and at what locations they are placed in memory through a linker script file. A very simple linker script file, is shown below.</p><p>如上一节所述，节合并和放置是由链接器完成的。程序员可以通过链接器脚本文件控制部分的合并方式，以及它们在内存中的位置。一个非常简单的链接器脚本文件，如下所示。</p><p><strong>Listing 6. Basic linker script</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123; ❶</span><br><span class="line">        . = 0x00000000; ❷</span><br><span class="line">        .text : &#123; ❸</span><br><span class="line">                abc.o (.text);</span><br><span class="line">                def.o (.text);</span><br><span class="line">        &#125; ❹</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>The <code>SECTIONS</code> command is the most important linker command, it specifies how the sections are to be merged and at what location they are to be placed.<br>该<code>SECTIONS</code>命令是最重要的链接器 命令，它指定如何合并部分以及合并到什么位置 它们要放置的位置。</li><li>Within the block following the <code>SECTIONS</code> command, the <code>.</code> (period) represents the location counter. The location is always initialised to <code>0x0</code>. It can be modified by assigning a new value to it. Setting the value to <code>0x0</code> at the beginning is superfluous.<br>在后面的块内 <code>SECTIONS</code>命令中，<code>.</code>（句点）表示位置计数器 位置总是初始化为<code>0x0</code>。 可以通过为其分配一个新值来修改它。设置 开头<code>0x0</code>的值是 多余的。</li><li>This part of the script specifies that, the <code>.text</code> section from the input files <code>abc.o</code> and <code>def.o</code> should go to the <code>.text</code> section of the output file.<br>脚本的这一部分指定 输入中的<code>.text</code>部分 文件<code>abc.o</code>和<code>def.o</code>应该转到输出文件的<code>.text</code>部分。</li></ol><p>The linker script can be further simplified and generalised by using the wild card character <code>*</code> instead of individually specifying the file names.</p><p>链接器脚本可以通过以下方式进一步简化和概括 使用通配符<code>*</code> 而不是单独指定文件名。</p><p><strong>Listing 7. Wildcard in linker scripts</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">        . = 0x00000000;</span><br><span class="line">        .text : &#123; * (.text); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If the program contains both <code>.text</code> and <code>.data</code> sections, the <code>.data</code> section merging and location can be specified as shown below.</p><p>如果程序同时包含<code>.text</code> 和<code>.data</code>部分，<code>.data</code>部分合并和位置可以是 指定如下所示。</p><p><strong>Listing 8. Multiple sections in linker scripts</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">         . = 0x00000000;</span><br><span class="line">         .text : &#123; * (.text); &#125;</span><br><span class="line"></span><br><span class="line">         . = 0x00000400;</span><br><span class="line">         .data : &#123; * (.data); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, the <code>.text</code> section is located at <code>0x0</code> and <code>.data</code> is located at <code>0x400</code>. Note that, if the location counter is not assigned a different value, the <code>.text</code> and <code>.data</code> sections will be located at adjacent memory locations.</p><p>在这里，<code>.text</code>部分位于 at<code>0x0</code>和<code>.data</code>位于<code>0x400</code>。请注意，如果位置计数器不是 分配了不同的值，<code>.text</code> 和<code>.data</code>部分将位于 相邻的内存位置。</p><h3 id="7-1-Linker-Script-Example"><a href="#7-1-Linker-Script-Example" class="headerlink" title="7.1. Linker Script Example"></a>7.1. Linker Script Example</h3><p>To demonstrate the use of linker scripts, we will use the linker script shown in <a href="https://www.bravegnu.org/gnu-eprog/lds.html#linker1">Listing 8, “Multiple sections in linker scripts”</a> to control the placement of a program’s <code>.text</code> and <code>.data</code> section. We will use a slightly modified version of the sum of array program for this purpose. The code is shown below.</p><p>为了演示链接器脚本的使用，我们将使用链接器 脚本如<a href="https://www.bravegnu.org/gnu-eprog/lds.html#linker1">清单8所示，“链接器脚本中的多个部分”</a>来控制 程序<code>.text</code>和<code>.data</code> 部分。我们将使用总和的稍微修改的版本 用于此目的的数组程序。代码如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">arr:    .byte 10, 20, 25        @ Read-only array of bytes</span><br><span class="line">eoa:                            @ Address of end of array + 1</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">start:</span><br><span class="line">        ldr   r0, =eoa          @ r0 = &amp;eoa</span><br><span class="line">        ldr   r1, =arr          @ r1 = &amp;arr</span><br><span class="line">        mov   r3, #0            @ r3 = 0</span><br><span class="line">loop:   ldrb  r2, [r1], #1      @ r2 = *r1++</span><br><span class="line">        add   r3, r2, r3        @ r3 += r2</span><br><span class="line">        cmp   r1, r0            @ if (r1 != r2)</span><br><span class="line">        bne   loop              @    goto loop</span><br><span class="line">stop:   b stop</span><br></pre></td></tr></table></figure><p>The only change here is that the array is now in the <code>.data</code> section. Also note that the nasty branch instruction to skip over the data is also not required, since the linker script will place the <code>.text</code> section and <code>.data</code> section appropriately. As a result, statements can be placed in the program, in any convenient way, and the linker script will take care of placing the sections correctly in memory.</p><p>这里唯一的变化是数组现在在 <code>.data</code>部分。还要注意 讨厌的分支指令跳过数据也不是 必需，因为链接器脚本将适当地放置<code>.text</code>部分和<code>.data</code>部分。结果， 语句可以以任何方便的方式放置在程序中，并且 链接器脚本将负责正确放置部分 在记忆中。</p><p>When the program is linked, the linker script is passed as an input to the linker, as shown in the following command.</p><p>链接程序时，链接器脚本作为输入传递给链接器，如以下命令所示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-as -o sum-data.o sum-data.s</span><br><span class="line">$ arm-linux-gnueabihf-ld -T sum-data.lds -o sum-data.elf sum-data.o</span><br></pre></td></tr></table></figure><p>The option <code>-T sum-data.lds</code> specifies that <code>sum-data.lds</code> is to be used as the linker script. Dumping the symbol table, will provide an insight into how the sections are placed in memory.</p><p>选项 <code>-T sum-data.lds</code> 指定 <code>sum-data.lds</code> 将被用作链接脚本。转储符号表可以让我们了解各个段是如何放置在内存中的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-nm -n sum-data.elf</span><br><span class="line">00000000 t start</span><br><span class="line">0000000c t loop</span><br><span class="line">0000001c t stop</span><br><span class="line">00000400 d arr</span><br><span class="line">00000403 d eoa</span><br></pre></td></tr></table></figure><p>From the symbol table it is obvious that the <code>.text</code> is placed starting from address <code>0x0</code> and <code>.data</code> section is placed starting from address <code>0x400</code>.</p><p>从符号表中可以明显看出<code>.text</code>是从地址<code>0x0</code>和<code>.data</code>部分开始放置的 从地址<code>0x400</code>开始放置。</p><h2 id="8-Data-in-RAM-Example"><a href="#8-Data-in-RAM-Example" class="headerlink" title="8. Data in RAM, Example"></a>8. Data in RAM, Example</h2><p>Now that we know, how to write linker scripts, we will attempt to write a program, and place the <code>.data</code> section in RAM.</p><p>The add program is modified to load two values from RAM, add them and store the result back to RAM. The two values and the space for result is placed in the <code>.data</code> section.</p><p><strong>Listing 9. Add Data in RAM</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">val1:   .4byte 10               @ First number</span><br><span class="line">val2:   .4byte 30               @ Second number</span><br><span class="line">result: .4byte 0                @ 4 byte space for result</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">        .align</span><br><span class="line">start:</span><br><span class="line">        ldr   r0, =val1         @ r0 = &amp;val1</span><br><span class="line">        ldr   r1, =val2         @ r1 = &amp;val2</span><br><span class="line"></span><br><span class="line">        ldr   r2, [r0]          @ r2 = *r0</span><br><span class="line">        ldr   r3, [r1]          @ r3 = *r1</span><br><span class="line"></span><br><span class="line">        add   r4, r2, r3        @ r4 = r2 + r3</span><br><span class="line"></span><br><span class="line">        ldr   r0, =result       @ r0 = &amp;result</span><br><span class="line">        str   r4, [r0]          @ *r0 = r4</span><br><span class="line"></span><br><span class="line">stop:   b stop</span><br></pre></td></tr></table></figure><p>When the program is linked, the linker script shown below is used.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">        . = 0x00000000;</span><br><span class="line">        .text : &#123; * (.text); &#125;</span><br><span class="line"></span><br><span class="line">        . = 0xA0000000;</span><br><span class="line">        .data : &#123; * (.data); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The dump of the symbol table of <code>.elf</code> is shown below.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-nm -n add-mem.elf</span><br><span class="line">00000000 t start</span><br><span class="line">0000001c t stop</span><br><span class="line">a0000000 d val1</span><br><span class="line">a0000001 d val2</span><br><span class="line">a0000002 d result</span><br></pre></td></tr></table></figure><p>The linker script seems to have solved the problem of placing the <code>.data</code> section in RAM. But wait, the solution is not complete yet!</p><h3 id="8-1-RAM-is-Volatile"><a href="#8-1-RAM-is-Volatile" class="headerlink" title="8.1. RAM is Volatile!"></a>8.1. RAM is Volatile!</h3><p>RAM is volatile memory, and hence it is not possible to directly make the data available in RAM, on power up.</p><p>All code and data <strong>should</strong> be stored in Flash before power-up. On power-up, a startup code is supposed to copy the data from Flash to RAM, and then proceed with the execution of the program. So the program’s <code>.data</code> section has two addresses, a <strong>load address</strong> in Flash and a <strong>run-time address</strong> in RAM.</p><blockquote><p>💡TIP</p><p>In <code>ld</code> parlance, the load address is called LMA (Load Memory Address), and the run-time address is called VMA (Virtual Memory Address.).</p></blockquote><p>The following two modifications have to be done, to make the program work correctly.</p><ol><li>The linker script has to be modified to specify both the load address and the run-time address, for the <code>.data</code> section.</li><li>A small piece of code should copy the <code>.data</code> section from Flash (load address) to RAM (run-time address).</li></ol><h3 id="8-2-Specifying-Load-Address"><a href="#8-2-Specifying-Load-Address" class="headerlink" title="8.2. Specifying Load Address"></a>8.2. Specifying Load Address</h3><p>The run-time address is what that should be used for determining the address of labels. In the previous linker script, we have specified the run-time address for the <code>.data</code> section. The load address is not explicitly specified, and defaults to the run-time address. This is OK, with the previous examples, since the programs were executed directly from Flash. But, if data is to be placed in RAM during execution, the load address should correspond to Flash and the run-time address should correspond to RAM.</p><p>A load address different from the run-time address can be specified using the <code>AT</code> keyword. The modified linker script is shown below.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">        . = 0x00000000;</span><br><span class="line">        .text : &#123; * (.text); &#125;</span><br><span class="line">        etext = .; ❶</span><br><span class="line"></span><br><span class="line">        . = 0xA0000000;</span><br><span class="line">        .data : AT (etext) &#123; * (.data); &#125; ❷</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><a href="https://www.bravegnu.org/gnu-eprog/data-in-ram.html#CO4-1">❶</a></th><th>Symbols can be created on the fly within the <code>SECTIONS</code> command by assigning values to them. Here <code>etext</code> is assigned the value of the location counter at that position. <code>etext</code> contains the address of the next free location in Flash right after all the code. This will be used later on to specify where the <code>.data</code> section is to be placed in Flash. Note that <code>etext</code> itself will not be allocated any memory, it is just an entry in the symbol table.</th></tr></thead><tbody><tr><td><a href="https://www.bravegnu.org/gnu-eprog/data-in-ram.html#CO4-2">❷</a></td><td>The <code>AT</code> keyword specifies the load address of the <code>.data</code> section. An address or symbol (whose value is a valid address) could be passed as argument to <code>AT</code>. Here the load address of <code>.data</code> is specified as the location right after all the code in Flash.</td></tr></tbody></table><h3 id="8-3-Copying-data-to-RAM"><a href="#8-3-Copying-data-to-RAM" class="headerlink" title="8.3. Copying .data to RAM"></a>8.3. Copying <code>.data</code> to RAM</h3><p>To copy the data from Flash to RAM, the following information is required.</p><ol><li>Address of data in Flash (<code>flash_sdata</code>)</li><li>Address of data in RAM (<code>ram_sdata</code>)</li><li>Size of the <code>.data</code> section. (<code>data_size</code>)</li></ol><p>With this information the data can be copied from Flash to RAM using the following code snippet.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        ldr   r0, =flash_sdata</span><br><span class="line">        ldr   r1, =ram_sdata</span><br><span class="line">        ldr   r2, =data_size</span><br><span class="line"></span><br><span class="line">copy:</span><br><span class="line">        ldrb  r4, [r0], #1</span><br><span class="line">        strb  r4, [r1], #1</span><br><span class="line">        subs  r2, r2, #1</span><br><span class="line">        bne   copy</span><br></pre></td></tr></table></figure><p>The linker script can be slightly modified to provide these information.</p><p><strong>Listing 10. Linker Script with Section Copy Symbols</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">        . = 0x00000000;</span><br><span class="line">        .text : &#123;</span><br><span class="line">              * (.text);</span><br><span class="line">        &#125;</span><br><span class="line">        flash_sdata = .; ❶</span><br><span class="line"></span><br><span class="line">        . = 0xA0000000;</span><br><span class="line">        ram_sdata = .; ❷</span><br><span class="line">        .data : AT (flash_sdata) &#123;</span><br><span class="line">              * (.data);</span><br><span class="line">        &#125;;</span><br><span class="line">        ram_edata = .; ❸</span><br><span class="line">        data_size = ram_edata - ram_sdata; ❹</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><a href="https://www.bravegnu.org/gnu-eprog/data-in-ram.html#CO5-1">❶</a></th><th>Start of data in Flash is right after all the code in Flash.</th></tr></thead><tbody><tr><td><a href="https://www.bravegnu.org/gnu-eprog/data-in-ram.html#CO5-2">❷</a></td><td>Start of data in RAM is at the base address of RAM.</td></tr><tr><td><a href="https://www.bravegnu.org/gnu-eprog/data-in-ram.html#CO5-3">❸</a> <a href="https://www.bravegnu.org/gnu-eprog/data-in-ram.html#CO5-4">❹</a></td><td>Obtaining the size of data is not straight forward. The data size is calculated from the difference in the start of data in RAM and the end of data in RAM. Yes, simple expressions are allowed within the linker script.</td></tr></tbody></table><p>The add program with data copied to RAM from Flash is listed below.</p><p><strong>Listing 11. Add Data in RAM (with copy)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">        .data</span><br><span class="line">val1:   .4byte 10               @ First number</span><br><span class="line">val2:   .4byte 30               @ Second number</span><br><span class="line">result: .space 4                @ 1 byte space for result</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line"></span><br><span class="line">        ;; Copy data to RAM.</span><br><span class="line">start:</span><br><span class="line">        ldr   r0, =flash_sdata</span><br><span class="line">        ldr   r1, =ram_sdata</span><br><span class="line">        ldr   r2, =data_size</span><br><span class="line"></span><br><span class="line">copy:</span><br><span class="line">        ldrb  r4, [r0], #1</span><br><span class="line">        strb  r4, [r1], #1</span><br><span class="line">        subs  r2, r2, #1</span><br><span class="line">        bne   copy</span><br><span class="line"></span><br><span class="line">        ;; Add and store result.</span><br><span class="line">        ldr   r0, =val1         @ r0 = &amp;val1</span><br><span class="line">        ldr   r1, =val2         @ r1 = &amp;val2</span><br><span class="line"></span><br><span class="line">        ldr   r2, [r0]          @ r2 = *r0</span><br><span class="line">        ldr   r3, [r1]          @ r3 = *r1</span><br><span class="line"></span><br><span class="line">        add   r4, r2, r3        @ r4 = r2 + r3</span><br><span class="line"></span><br><span class="line">        ldr   r0, =result       @ r0 = &amp;result</span><br><span class="line">        str   r4, [r0]          @ *r0 = r4</span><br><span class="line"></span><br><span class="line">stop:   b stop</span><br></pre></td></tr></table></figure><p>The program is assembled and linked using the linker script listed in <a href="https://www.bravegnu.org/gnu-eprog/data-in-ram.html#linker2">Listing 10, “Linker Script with Section Copy Symbols”</a>. The program is executed and tested within Qemu.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null</span><br><span class="line">(qemu) xp /4dw 0xA0000000</span><br><span class="line">a0000000:         10         30         40          0</span><br></pre></td></tr></table></figure><blockquote><p>Note:<br>In a real system with an SDRAM, the memory should not be accessed right-away. The memory controller will have to be initialised before performing a memory access. Our code works because the simulated memory does not require the memory controller to be initialised.</p></blockquote><h2 id="9-Exception-Handling"><a href="#9-Exception-Handling" class="headerlink" title="9. Exception Handling"></a>9. Exception Handling</h2><p>The examples given so far have a major bug. The first 8 words in the memory map are reserved for the exception vectors. When an exception occurs the control is transferred to one these 8 locations. The exceptions and their exception vector addresses are show in the following table.</p><p><strong>Table 1. Exception Vector Addresses</strong></p><table><thead><tr><th>Exception</th><th>Address</th></tr></thead><tbody><tr><td>Reset</td><td>0x00</td></tr><tr><td>Undefined Instruction</td><td>0x04</td></tr><tr><td>Software Interrupt (SWI)</td><td>0x08</td></tr><tr><td>Prefetch Abort</td><td>0x0C</td></tr><tr><td>Data Abort</td><td>0x10</td></tr><tr><td>Reserved, not used</td><td>0x14</td></tr><tr><td>IRQ</td><td>0x18</td></tr><tr><td>FIQ</td><td>0x1C</td></tr></tbody></table><p>These locations are supposed to contain a branch that will transfer control the appropriate exception handler. In the examples we have seen so far, we haven’t inserted branch instructions at the exception vector addresses. We got away without issues since these exceptions did not occur. All the above programs can be fixed, by linking them with the following assembly code.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        .section &quot;vectors&quot;</span><br><span class="line">reset:  b     start</span><br><span class="line">undef:  b     undef</span><br><span class="line">swi:    b     swi</span><br><span class="line">pabt:   b     pabt</span><br><span class="line">dabt:   b     dabt</span><br><span class="line">        nop</span><br><span class="line">irq:    b     irq</span><br><span class="line">fiq:    b     fiq</span><br></pre></td></tr></table></figure><p>Only the reset exception is vectored to a different address <code>start</code>. All other exceptions are vectored to the same address. So if any exception other that reset occurs, the processor will be spinning in the same location. The exception can then be identified by looking at the value of <code>pc</code> through a debugger (the monitor interface in our case).</p><p>To ensure that these instruction are placed at the exception vector addresses, the linker script should look something like below.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">        . = 0x00000000;</span><br><span class="line">        .text : &#123;</span><br><span class="line">                * (vectors);</span><br><span class="line">                * (.text);</span><br><span class="line">                ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice how the <code>vectors</code> section is placed before all other code, ensuring that the <code>vectors</code> is located at address starting from 0x0.</p><h2 id="10-C-Startup"><a href="#10-C-Startup" class="headerlink" title="10. C Startup"></a>10. C Startup</h2><p>It is not possible to directly execute C code, when the processor comes out of reset. Since, unlike assembly language, C programs need some basic pre-requisites to be satisfied. This section will describe the pre-requisites and how to meet the pre-requisites.</p><p>We will take the example of C program that calculates the sum of an array as an example. And by the end of this section, we will be able to perform the necessary setup, transfer control to the C code and execute it.</p><p><strong>Listing 12. Sum of Array in C</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static int arr[] = &#123; 1, 10, 4, 5, 6, 7 &#125;;</span><br><span class="line">static int sum;</span><br><span class="line">static const int n = sizeof(arr) / sizeof(arr[0]);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">        int i;</span><br><span class="line"></span><br><span class="line">        for (i = 0; i &lt; n; i++)</span><br><span class="line">                sum += arr[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Before transferring control to C code, the following have to be setup correctly.</p><ol><li>Stack</li><li>Global variables<ol><li>Initialized</li><li>Uninitialized</li></ol></li><li>Read-only data</li></ol><h3 id="10-1-Stack"><a href="#10-1-Stack" class="headerlink" title="10.1. Stack"></a>10.1. Stack</h3><p>C uses the stack for storing local (auto) variables, passing function arguments, storing return address, etc. So it is essential that the stack be setup correctly, before transferring control to C code.</p><p>Stacks are highly flexible in the ARM architecture, since the implementation is completely left to the software. For people not familiar with the ARM architecture a overview is provided in <a href="https://www.bravegnu.org/gnu-eprog/arm-stacks.html">Appendix C, <em>ARM Stacks</em></a>.</p><p>To make sure that code generated by different compilers is interroperable, ARM has created the <a href="http://infocenter.arm.com/help/topic/com.arm.doc.ihi0042a/IHI0042A_aapcs.pdf">ARM Architecture Procedure Call Standard (AAPCS)</a>. The register to be used as the stack pointer and the direction in which the stack grows is all dictated by the AAPCS. According to the AAPCS, <strong>register <code>r13</code></strong> is to be used as the stack pointer. Also the stack should be <strong>full-descending</strong>.</p><p>One way of placing global variables and the stack is shown in the following diagram.</p><p><strong>Figure 5. Stack Placement</strong></p><p><img src="/../images/GNUToolchain/stack.png" alt="stack.png"></p><p>So all that has to be done in the startup code is to point <code>r13</code> at the highest RAM address, so that the stack can grow downwards (towards lower addresses). For the <code>connex</code> board this can be acheived using the following ARM instruction.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldr sp, =0xA4000000</span><br></pre></td></tr></table></figure><p>Note that the the assembler provides an alias <code>sp</code> for the <code>r13</code> register.</p><table><thead><tr><th><img src="/../images/GNUToolchain/note.png" alt="[Note]"></th><th>Note</th></tr></thead><tbody><tr><td>The address <code>0xA4000000</code> itself does not correspond to RAM. The RAM ends at <code>0xA3FFFFFF</code>. But that is OK, since the stack is <strong>full</strong>-descending, during the first push the stack pointer will be decremented first and the value will be stored.</td><td></td></tr></tbody></table><h3 id="10-2-Global-Variables"><a href="#10-2-Global-Variables" class="headerlink" title="10.2. Global Variables"></a>10.2. Global Variables</h3><p>When C code is compiled, the compiler places initialized global variables in the <code>.data</code> section. So just as with the assembly, the <code>.data</code> has to be copied from Flash to RAM.</p><p>The C language guarantees that all uninitialized global variables will be initialized to zero. When C programs are compiled, a separate section called <code>.bss</code> is used for uninitialized variables. Since the value of these variables are all zeroes to start with, they do not have to be stored in Flash. Before transferring control to C code, the memory locations corresponding to these variables have to be initialized to zero.</p><h3 id="10-3-Read-only-Data"><a href="#10-3-Read-only-Data" class="headerlink" title="10.3. Read-only Data"></a>10.3. Read-only Data</h3><p>GCC places global variables marked as <code>const</code> in a separate section, called <code>.rodata</code>. The <code>.rodata</code> is also used for storing string constants.</p><p>Since contents of <code>.rodata</code> section will not be modified, they can be placed in Flash. The linker script has to modified to accomodate this.</p><h3 id="10-4-Startup-Code"><a href="#10-4-Startup-Code" class="headerlink" title="10.4. Startup Code"></a>10.4. Startup Code</h3><p>Now that we know the pre-requisites we can create the linker script and the startup code. The linker script <a href="https://www.bravegnu.org/gnu-eprog/data-in-ram.html#linker2">Listing 10, “Linker Script with Section Copy Symbols”</a> is modified to accomodate the following.</p><ol><li><code>.bss</code> section placement</li><li><code>vectors</code> section placement</li><li><code>.rodata</code> section placement</li></ol><p>The <code>.bss</code> is placed right after <code>.data</code> section in RAM. Symbols to locate the start of <code>.bss</code> and end of <code>.bss</code> are also created in the linker script. The <code>.rodata</code> is placed right after <code>.text</code> section in Flash. The following diagram shows the placement of the various sections.</p><p><strong>Figure 6. Section Placement</strong></p><p><img src="/../images/GNUToolchain/csections.png" alt="csections.png"></p><p><strong>Listing 13. Linker Script for C code</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">        . = 0x00000000;</span><br><span class="line">        .text : &#123;</span><br><span class="line">              * (vectors);</span><br><span class="line">              * (.text);</span><br><span class="line">        &#125;</span><br><span class="line">        .rodata : &#123;</span><br><span class="line">              * (.rodata);</span><br><span class="line">        &#125;</span><br><span class="line">        flash_sdata = .;</span><br><span class="line"></span><br><span class="line">        . = 0xA0000000;</span><br><span class="line">        ram_sdata = .;</span><br><span class="line">        .data : AT (flash_sdata) &#123;</span><br><span class="line">              * (.data);</span><br><span class="line">        &#125;</span><br><span class="line">        ram_edata = .;</span><br><span class="line">        data_size = ram_edata - ram_sdata;</span><br><span class="line"></span><br><span class="line">        sbss = .;</span><br><span class="line">        .bss : &#123;</span><br><span class="line">             * (.bss);</span><br><span class="line">        &#125;</span><br><span class="line">        ebss = .;</span><br><span class="line">        bss_size = ebss - sbss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The startup code has the following parts</p><ol><li>exception vectors</li><li>code to copy the <code>.data</code> from Flash to RAM</li><li>code to zero out the <code>.bss</code></li><li>code to setup the stack pointer</li><li>branch to main</li></ol><p><strong>Listing 14. C Startup Assembly</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">        .section &quot;vectors&quot;</span><br><span class="line">reset:  b     start</span><br><span class="line">undef:  b     undef</span><br><span class="line">swi:    b     swi</span><br><span class="line">pabt:   b     pabt</span><br><span class="line">dabt:   b     dabt</span><br><span class="line">        nop</span><br><span class="line">irq:    b     irq</span><br><span class="line">fiq:    b     fiq</span><br><span class="line"></span><br><span class="line">        .text</span><br><span class="line">start:</span><br><span class="line">        @@ Copy data to RAM.</span><br><span class="line">        ldr   r0, =flash_sdata</span><br><span class="line">        ldr   r1, =ram_sdata</span><br><span class="line">        ldr   r2, =data_size</span><br><span class="line"></span><br><span class="line">        @@ Handle data_size == 0</span><br><span class="line">        cmp   r2, #0</span><br><span class="line">        beq   init_bss</span><br><span class="line">copy:</span><br><span class="line">        ldrb   r4, [r0], #1</span><br><span class="line">        strb   r4, [r1], #1</span><br><span class="line">        subs   r2, r2, #1</span><br><span class="line">        bne    copy</span><br><span class="line"></span><br><span class="line">init_bss:</span><br><span class="line">        @@ Initialize .bss</span><br><span class="line">        ldr   r0, =sbss</span><br><span class="line">        ldr   r1, =ebss</span><br><span class="line">        ldr   r2, =bss_size</span><br><span class="line"></span><br><span class="line">        @@ Handle bss_size == 0</span><br><span class="line">        cmp   r2, #0</span><br><span class="line">        beq   init_stack</span><br><span class="line"></span><br><span class="line">        mov   r4, #0</span><br><span class="line">zero:</span><br><span class="line">        strb  r4, [r0], #1</span><br><span class="line">        subs  r2, r2, #1</span><br><span class="line">        bne   zero</span><br><span class="line"></span><br><span class="line">init_stack:</span><br><span class="line">        @@ Initialize the stack pointer</span><br><span class="line">        ldr   sp, =0xA4000000</span><br><span class="line"></span><br><span class="line">        bl    main</span><br><span class="line"></span><br><span class="line">stop:   b     stop</span><br></pre></td></tr></table></figure><p>To compile the code, it is not necessary to invoke the assembler, compiler and linker individually. <code>gcc</code> is intelligent enough to do that for us.</p><p>As promised before, we will compile and execute the C code shown in <a href="https://www.bravegnu.org/gnu-eprog/c-startup.html#csum">Listing 12, “Sum of Array in C”</a>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-gcc -nostdlib -o csum.elf -T csum.lds csum.c startup.s</span><br></pre></td></tr></table></figure><p>The <code>-nostdlib</code> option is used to specify that the standard C library should not be linked in. A little extra care has to be taken when the C library is linked in. This is discussed in <a href="https://www.bravegnu.org/gnu-eprog/c-library.html">Section 11, “Using the C Library”</a>.</p><p>A dump of the symbol table will give a better picture of how things have been placed in memory.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-nm -n csum.elf</span><br><span class="line">00000000 t reset        ❶</span><br><span class="line">00000004 A bss_size</span><br><span class="line">00000004 t undef</span><br><span class="line">00000008 t swi</span><br><span class="line">0000000c t pabt</span><br><span class="line">00000010 t dabt</span><br><span class="line">00000018 A data_size</span><br><span class="line">00000018 t irq</span><br><span class="line">0000001c t fiq</span><br><span class="line">00000020 T main</span><br><span class="line">00000090 t start        ❷</span><br><span class="line">000000a0 t copy</span><br><span class="line">000000b0 t init_bss</span><br><span class="line">000000c4 t zero</span><br><span class="line">000000d0 t init_stack</span><br><span class="line">000000d8 t stop</span><br><span class="line">000000f4 r n            ❸</span><br><span class="line">000000f8 A flash_sdata</span><br><span class="line">a0000000 d arr          ❹</span><br><span class="line">a0000000 A ram_sdata</span><br><span class="line">a0000018 A ram_edata</span><br><span class="line">a0000018 A sbss</span><br><span class="line">a0000018 b sum          ❺</span><br><span class="line">a000001c A ebss</span><br></pre></td></tr></table></figure><table><thead><tr><th><a href="https://www.bravegnu.org/gnu-eprog/c-startup.html#CO6-1">❶</a></th><th><code>reset</code> and the rest of the exception vectors are placed starting from <code>0x0</code>.</th></tr></thead><tbody><tr><td><a href="https://www.bravegnu.org/gnu-eprog/c-startup.html#CO6-2">❷</a></td><td>The assembly code is placed right after the 8 exception vectors (<code>8 * 4 = 32 = 0x20</code>).</td></tr><tr><td><a href="https://www.bravegnu.org/gnu-eprog/c-startup.html#CO6-3">❸</a></td><td>The read-only data <code>n</code>, is placed in Flash after the code.</td></tr><tr><td><a href="https://www.bravegnu.org/gnu-eprog/c-startup.html#CO6-4">❹</a></td><td>The initialized data <code>arr</code>, an array of 6 integers, is placed at the start of RAM <code>0xA0000000</code>.</td></tr><tr><td><a href="https://www.bravegnu.org/gnu-eprog/c-startup.html#CO6-5">❺</a></td><td>The uninitialized data <code>sum</code> is placed after the array of 6 integers. (<code>6 * 4 = 24 = 0x18</code>)</td></tr></tbody></table><p>To execute the program, convert the program to <code>.bin</code> format, execute in Qemu, and dump the <code>sum</code> variable located at <code>0xA0000018</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gnueabihf-objcopy -O binary csum.elf csum.bin</span><br><span class="line">$ dd if=csum.bin of=flash.bin bs=4096 conv=notrunc</span><br><span class="line">$ qemu-system-arm -M connex -pflash flash.bin -nographic -serial /dev/null</span><br><span class="line">(qemu) xp /6dw 0xa0000000</span><br><span class="line">a0000000:          1         10          4          5</span><br><span class="line">a0000010:          6          7</span><br><span class="line">(qemu) xp /1dw 0xa0000018</span><br><span class="line">a0000018:         33</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Assembler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> arm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cvitek-v4.2.0 编译流程</title>
      <link href="/2024/10/09/Cvitek-%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/10/09/Cvitek-%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="编译流程说明"><a href="#编译流程说明" class="headerlink" title="编译流程说明"></a>编译流程说明</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. source build/envsetup_soc.sh（设置环境变量）</span></span><br><span class="line">yogurt@s:v4.2.x$ <span class="built_in">source</span> build/envsetup_soc.sh</span><br><span class="line">  -------------------------------------------------------------------------------------------------------</span><br><span class="line">    Usage:</span><br><span class="line">    (1) menuconfig - Use menu to configure your board.</span><br><span class="line">        ex: $ menuconfig</span><br><span class="line"></span><br><span class="line">    (2) defconfig <span class="variable">$CHIP_ARCH</span> - List EVB boards(<span class="variable">$BOARD</span>) by CHIP_ARCH.</span><br><span class="line">       ** cv181x ** -&gt; [<span class="string">&#x27;cv181x&#x27;</span>, <span class="string">&#x27;cv1823a&#x27;</span>, <span class="string">&#x27;cv1821a&#x27;</span>, <span class="string">&#x27;cv1820a&#x27;</span>, <span class="string">&#x27;cv1811h&#x27;</span>, <span class="string">&#x27;cv1811ha&#x27;</span>, <span class="string">&#x27;cv1812ha&#x27;</span>, <span class="string">&#x27;cv1811c&#x27;</span>, <span class="string">&#x27;cv1810c&#x27;</span>, <span class="string">&#x27;cv1810ca&#x27;</span>, <span class="string">&#x27;cv1812h&#x27;</span>, <span class="string">&#x27;cv1812cp&#x27;</span>, <span class="string">&#x27;cv1813h&#x27;</span>, <span class="string">&#x27;cv1813ha&#x27;</span>]</span><br><span class="line">       ** cv180x ** -&gt; [<span class="string">&#x27;cv180x&#x27;</span>, <span class="string">&#x27;cv1800b&#x27;</span>, <span class="string">&#x27;cv1800c&#x27;</span>, <span class="string">&#x27;cv1801b&#x27;</span>, <span class="string">&#x27;cv1801c&#x27;</span>, <span class="string">&#x27;cv180zb&#x27;</span>]</span><br><span class="line">        ex: $ defconfig cv183x</span><br><span class="line"></span><br><span class="line">    (3) defconfig <span class="variable">$BOARD</span> - Choose EVB board settings.</span><br><span class="line">        ex: $ defconfig cv1835_wevb_0002a</span><br><span class="line">        ex: $ defconfig cv1826_wevb_0005a_spinand</span><br><span class="line">        ex: $ defconfig cv181x_fpga_c906</span><br><span class="line">  -------------------------------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用 defconfig 选定板卡配置</span></span><br><span class="line">yogurt@s:v4.2.x$ defconfig cv1811c_wevb_0006a_emmc</span><br><span class="line"> Run defconfig <span class="keyword">function</span></span><br><span class="line">Loaded configuration <span class="string">&#x27;/home/yogurt/Documents/sophgo/v4.2.x/build/boards/cv181x/cv1811c_wevb_0006a_emmc/cv1811c_wevb_0006a_emmc_defconfig&#x27;</span></span><br><span class="line">Configuration saved to <span class="string">&#x27;.config&#x27;</span></span><br><span class="line">Loaded configuration <span class="string">&#x27;.config&#x27;</span></span><br><span class="line">Minimal configuration saved to <span class="string">&#x27;/home/yogurt/Documents/sophgo/v4.2.x/build/.defconfig&#x27;</span></span><br><span class="line">~/Documents/sophgo/v4.2.x/build ~/Documents/sophgo/v4.2.x</span><br><span class="line">~/Documents/sophgo/v4.2.x</span><br><span class="line"></span><br><span class="line">====== Environment Variables =======</span><br><span class="line"></span><br><span class="line">  PROJECT: cv1811c_wevb_0006a_emmc, DDR_CFG=ddr3_1866_x16</span><br><span class="line">  CHIP_ARCH: CV181X, DEBUG=0</span><br><span class="line">  SDK VERSION: musl_riscv64, RPC=0</span><br><span class="line">  ATF options: ATF_KEY_SEL=default, BL32=1</span><br><span class="line">  Linux <span class="built_in">source</span> folder:linux_5.10, Uboot <span class="built_in">source</span> folder: u-boot-2021.10</span><br><span class="line">  CROSS_COMPILE_PREFIX: riscv64-unknown-linux-musl-</span><br><span class="line">  ENABLE_BOOTLOGO: 0</span><br><span class="line">  Flash layout xml: /home/yogurt/Documents/sophgo/v4.2.x/build/boards/cv181x/cv1811c_wevb_0006a_emmc/partition/partition_emmc.xml</span><br><span class="line">  Support EMMC large part size: n</span><br><span class="line">  Sensor tuning bin: gcore_gc4653</span><br><span class="line">  Output path: /home/yogurt/Documents/sophgo/v4.2.x/install/soc_cv1811c_wevb_0006a_emmc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 运行 build_all 开始编译</span></span><br><span class="line">yogurt@s:v4.2.x$ build_all</span><br></pre></td></tr></table></figure><ol><li>🐾设置环境变量：主要是提供相关 <code>shell</code> 函数，比如 <code>defconfig</code>, <code>menuconfig</code>, <code>build_kernel</code>, <code>build_uboot</code>, <code>build_all</code> 等，给用户手动调用。</li><li>🐾选定板卡配置：不同板卡会有不同的配置，包含：<ol><li>🌱 设备树</li><li>🌱 linux kernel 配置</li><li>🌱 uboot 配置</li><li>🌱 flash 分区表</li><li>🌱 内存布局</li><li>🌱 其他配置</li></ol></li><li>🐾开始编译：可以运行 <code>build_all</code> 编译完整 SDK，也可以运行 <code>build_uboot</code>&#x2F;<code>build_kernel</code> 等编译单个模块。</li></ol><p>📌 对正常启动系统来说，需要编译得到的文件有：</p><ul><li><code>fip.bin/fip_spl.bin</code>：<code>Bootloader</code>，包含 <code>fsbl</code>, <code>opensbi</code>(riscv only), <code>u-boot</code>；</li><li><code>boot.&#123;flash_type&#125;</code>：<code>Linux</code> 内核；</li><li><code>rootfs.&#123;flash_type&#125;</code>：大核用的文件系统；</li><li><code>yoc.bin</code>：小核 Alios 的固件。</li></ul><table><thead><tr><th>文件夹</th><th>编译命令</th><th>生成文件</th></tr></thead><tbody><tr><td><code>fsbl</code></td><td><code>build_uboot</code></td><td><code>bl2.bin</code> -&gt; <code>fip.bin</code></td></tr><tr><td><code>opensbi</code></td><td><code>build_uboot</code></td><td><code>fw_dynamic.bin</code>  + <code>ddr_param.bin</code> -&gt; <code>fip.bin</code></td></tr><tr><td><code>u-boot-2021.10</code></td><td><code>build_uboot</code></td><td><code>u-boot-raw_spl.bin</code> &#x2F; <code>u-boot-raw.bin</code> -&gt; <code>fip.bin</code></td></tr><tr><td><code>cvi_alios</code></td><td><code>build_uboot</code> 或 <code>build_alios</code> 单独编译</td><td><code>yoc.bin</code>  -&gt; <code>fip.bin</code></td></tr><tr><td><code>linux_5.10</code></td><td><code>build_kernel(arm)</code>&#x2F;<code>build_opensbi_kernel(riscv)</code></td><td><code>boot.xxx</code> 内核</td></tr><tr><td><code>ramdisk</code></td><td><code>pack_rootfs</code></td><td><code>rootfs.xxx</code> 文件系统</td></tr><tr><td><code>ramdisk</code></td><td><code>build_ramboot</code></td><td><code>ramboot</code> 用做 <code>recovery</code></td></tr></tbody></table><p>下面以 <code>cv1811c_wevb_0006a_emmc</code> 板卡为例，分析上诉各个文件的编译流程。</p><h2 id="v4-2-x-编译流程"><a href="#v4-2-x-编译流程" class="headerlink" title="v4.2.x 编译流程"></a>v4.2.x 编译流程</h2><p><img src="/./images/Cvitek-%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/v4.2.x-%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.svg" alt="v4.2.x 编译流程"></p>]]></content>
      
      
      <categories>
          
          <category> Cvitek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> fsbl </tag>
            
            <tag> opensbi </tag>
            
            <tag> uboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cvitek SDK 编译环境</title>
      <link href="/2024/10/06/Cvitek-SDK%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/"/>
      <url>/2024/10/06/Cvitek-SDK%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h2 id="SDK-下载"><a href="#SDK-下载" class="headerlink" title="SDK 下载"></a>SDK 下载</h2><p>利用 sophpi 中的脚本下载 SDK 到当前目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b sg200x-evb git@github.com:sophgo/sophpi.git</span><br></pre></td></tr></table></figure><p>sophpi 中的脚本是将需要的仓库拉取到当前目录，为了区分，专门新建 v4.1.x 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> v4.1.x &amp;&amp; <span class="built_in">cd</span> v4.1.x</span><br><span class="line"></span><br><span class="line">../sophpi/scripts/repo_clone.sh --gitclone ../sophpi/scripts/subtree.xml</span><br></pre></td></tr></table></figure><p>如需使用双系统快启分支，则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> v4.2.x &amp;&amp; <span class="built_in">cd</span> v4.2.x</span><br><span class="line"></span><br><span class="line">../sophpi/scripts/repo_clone.sh --gitclone ../sophpi/scripts/subtree_cv18xx-v4.2.x.xml</span><br></pre></td></tr></table></figure><blockquote><p>🙃可能遇到的问题：</p><ol><li>没有权限拉取仓库。<br>sophpi 的脚本中是用的 git clone ssh@xxx 走的 ssh，需要配置好 ssh key，否则会报错。<br>可以替换 xml 中的 <a href="mailto:&#x67;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#98;&#46;&#99;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#104;&#117;&#98;&#46;&#99;&#x6f;&#x6d;</a>:sophgo&#x2F; 为 <a href="https://github.com/sophgo/">https://github.com/sophgo/</a></li></ol></blockquote><h2 id="v4-1-x-编译环境配置"><a href="#v4-1-x-编译环境配置" class="headerlink" title="v4.1.x 编译环境配置"></a>v4.1.x 编译环境配置</h2><blockquote><p>下面以 ubuntu 22.04 为例。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y pkg-config build-essential ninja-build automake autoconf libtool wget curl git gcc libssl-dev bc slib squashfs-tools android-sdk-libsparse-utils android-sdk-ext4-utils jq cmake python3-distutils tclsh scons parallel ssh-client tree python3-dev python3-pip device-tree-compiler libssl-dev ssh cpio squashfs-tools fakeroot libncurses5 flex bison</span><br></pre></td></tr></table></figure><blockquote><p>🙃可能遇到的问题：</p><ol><li><p>找不到软件包 android-sdk-ext4-utils</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install -y android-sdk-ext4-utils</span><br></pre></td></tr></table></figure><p> ubuntu 20.04 可能找不到该软件包</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo apt-get install -y android-sdk-ext4-utils</span><br><span class="line"></span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树... 完成</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">E: 无法定位软件包 android-sdk-ext4-utils</span><br></pre></td></tr></table></figure><p> 解决方法如下：</p><p> wget <a href="http://mirrors.kernel.org/ubuntu/pool/universe/a/android-platform-system-extras/android-sdk-ext4-utils_8.1.0+r23-2_amd64.deb">http://mirrors.kernel.org/ubuntu/pool/universe/a/android-platform-system-extras/android-sdk-ext4-utils_8.1.0+r23-2_amd64.deb</a></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install android-libcutils android-libext4-utils android-libselinux android-libsepol</span><br><span class="line"></span><br><span class="line">sudo dpkg -i android-sdk-ext4-utils_8.1.0+r23-2_amd64.deb</span><br></pre></td></tr></table></figure></li><li><p>在执行 source build&#x2F;cvisetup.sh 时出现以下情况：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/proc/self/fd/17:9: athena2_board_sel: assignment to invalid subscript range</span><br></pre></td></tr></table></figure><p> （其中 17:9 可能是其他数字）</p><p> cvisetup.sh 脚本未执行成功。执行 defconfig cv1812h_wevb_0007a_emmc_huashan 结果如下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ defconfig cv1812h_wevb_0007a_emmc</span><br><span class="line"> Run  <span class="keyword">function</span></span><br><span class="line">_call_kconfig_script:11: no such file or directory: /mnt/e/wsl/v4.1.0.3/v4.1.0.3_source/build/scripts/.py</span><br></pre></td></tr></table></figure><p> 原因：使用的 shell 并非 bash。且出 invalid subcript range（下标范围问题）可能是使用 zsh 执行 shell 脚本导致的。zsh 数组的下标索从 1 开始，与 bash 不同（bash 从 0 开始）。<br> 更多讨论请参考：<a href="https://unix.stackexchange.com/questions/562561/bash-script-throws-assignment-to-invalid-subscript-range-when-running-from-zsh">https://unix.stackexchange.com/questions/562561/bash-script-throws-assignment-to-invalid-subscript-range-when-running-from-zsh</a></p><p> 解决方法：终端键入 bash，在 bash 环境下执行source build&#x2F;cvisetup.sh</p></li><li><p>找不到 python。</p><p> &#x2F;bin&#x2F;sh: 1: python: not found</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">ln</span> -s /usr/bin/python3 /usr/bin/python</span><br></pre></td></tr></table></figure></li><li><p><strong>python 库缺少</strong></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/home/yogurt/Documents/sophgo/v4.1.x/cvi_mpi/modules/isp/common/toolJsonGenerator</span><br><span class="line">Updated 0 paths from the index</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;/home/yogurt/Documents/sophgo/v4.1.x/cvi_mpi/modules/isp/common/toolJsonGenerator/hFile2json.py&quot;</span>, line 5, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from jinja2 import Template</span><br><span class="line">ModuleNotFoundError: No module named <span class="string">&#x27;jinja2&#x27;</span></span><br><span class="line">Updated 1 path from the index</span><br><span class="line"><span class="built_in">cat</span>: pqtool_definition.json: No such file or directory</span><br><span class="line">the json file is a invalid, error is : Expecting value: line 1 column 1 (char 0)!!!</span><br><span class="line">make[3]: *** [Makefile:11: all] Error 255</span><br><span class="line">make[3]: Leaving directory <span class="string">&#x27;/home/yogurt/Documents/sophgo/v4.1.x/cvi_mpi/modules/isp/cv181x&#x27;</span></span><br><span class="line">make[2]: *** [Makefile:8: all] Error 1</span><br><span class="line">make[2]: Leaving directory <span class="string">&#x27;/home/yogurt/Documents/sophgo/v4.1.x/cvi_mpi/modules/isp&#x27;</span></span><br><span class="line">make[1]: *** [Makefile:18: all] Error 1</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/yogurt/Documents/sophgo/v4.1.x/cvi_mpi/modules&#x27;</span></span><br><span class="line">make: *** [Makefile:35: module] Error 2</span><br><span class="line"> build middleware failed !!</span><br></pre></td></tr></table></figure><p> 解决方法：执行 <code>pip install jinja2</code></p></li></ol></blockquote><h2 id="v4-2-x-x2F-Alios-编译"><a href="#v4-2-x-x2F-Alios-编译" class="headerlink" title="v4.2.x&#x2F;Alios 编译"></a>v4.2.x&#x2F;Alios 编译</h2><blockquote><p>下面以 ubuntu 22.04 为例，其他版本可能会有差异。</p><p>v4.2.x 在 v4.1.x 的基础上，增加了小核 alios 的编译环境配置。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install yoctools -i https://pypi.tuna.tsinghua.edu.cn/simple/</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cvitek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cvitek </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux sysfs</title>
      <link href="/2024/09/24/Linux-sysfs/"/>
      <url>/2024/09/24/Linux-sysfs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>chatgpt translate from <a href="https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt">https://www.kernel.org/doc/Documentation/filesystems/sysfs.txt</a></p></blockquote><h3 id="sysfs-内核对象导出的文件系统"><a href="#sysfs-内核对象导出的文件系统" class="headerlink" title="sysfs - 内核对象导出的文件系统"></a>sysfs - 内核对象导出的文件系统</h3><p>Patrick Mochel <a href="mailto:&#109;&#111;&#x63;&#x68;&#101;&#108;&#64;&#x6f;&#115;&#x64;&#108;&#46;&#x6f;&#114;&#x67;">&#109;&#111;&#x63;&#x68;&#101;&#108;&#64;&#x6f;&#115;&#x64;&#108;&#46;&#x6f;&#114;&#x67;</a></p><p>Mike Murphy <a href="mailto:&#109;&#x61;&#x6d;&#x75;&#x72;&#112;&#104;&#64;&#99;&#115;&#46;&#x63;&#x6c;&#x65;&#109;&#115;&#x6f;&#x6e;&#x2e;&#x65;&#x64;&#x75;">&#109;&#x61;&#x6d;&#x75;&#x72;&#112;&#104;&#64;&#99;&#115;&#46;&#x63;&#x6c;&#x65;&#109;&#115;&#x6f;&#x6e;&#x2e;&#x65;&#x64;&#x75;</a></p><h3 id="什么是-sysfs"><a href="#什么是-sysfs" class="headerlink" title="什么是 sysfs:"></a>什么是 sysfs:</h3><p><strong>sysfs 是一个基于内存的文件系统，最初基于 ramfs。它提供了一种将内核数据结构、其属性及其之间的链接导出到用户空间的方法</strong>。</p><p>sysfs 本质上与 kobject 基础结构紧密相关。请阅读 <code>Documentation/core-api/kobject.rst</code> 以获取有关 kobject 接口的更多信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysfs is a ram-based filesystem initially based on ramfs. It provides</span><br><span class="line">a means to export kernel data structures, their attributes, and the</span><br><span class="line">linkages between them to userspace.</span><br><span class="line"></span><br><span class="line">sysfs is tied inherently to the kobject infrastructure. Please read</span><br><span class="line">Documentation/core-api/kobject.rst for more information concerning the kobject</span><br><span class="line">interface.</span><br></pre></td></tr></table></figure><h3 id="使用-sysfs"><a href="#使用-sysfs" class="headerlink" title="使用 sysfs"></a>使用 sysfs</h3><p>如果定义了 <code>CONFIG_SYSFS</code>，sysfs 总是被编译进去。你可以通过以下命令访问它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysfs is always compiled in if CONFIG_SYSFS is defined. You can access</span><br><span class="line">it by doing::</span><br><span class="line"></span><br><span class="line">    mount -t sysfs sysfs /sys</span><br></pre></td></tr></table></figure><h3 id="目录创建"><a href="#目录创建" class="headerlink" title="目录创建"></a>目录创建</h3><p>每当一个 kobject 注册到系统中时，会在 sysfs 中为其创建一个目录。该目录是在 kobject 的父对象的子目录中创建的，这向用户空间表达了内部对象的层次结构。sysfs 中的顶级目录代表对象层次结构的共同祖先；即对象所属的子系统。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">For every kobject that is registered with the system, a directory is</span><br><span class="line">created for it in sysfs. That directory is created as a subdirectory</span><br><span class="line">of the kobject&#x27;s parent, expressing internal object hierarchies to</span><br><span class="line">userspace. Top-level directories in sysfs represent the common</span><br><span class="line">ancestors of object hierarchies; i.e. the subsystems the objects</span><br><span class="line">belong to.</span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>属性可以以文件系统中的常规文件形式导出给 kobject。sysfs 将文件 I&#x2F;O 操作转发给为这些属性定义的方法，从而提供读写内核属性的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Attributes can be exported for kobjects in the form of regular files in</span><br><span class="line">the filesystem. Sysfs forwards file I/O operations to methods defined</span><br><span class="line">for the attributes, providing a means to read and write kernel</span><br><span class="line">attributes.</span><br></pre></td></tr></table></figure><p>属性应该是 ASCII 文本文件，最好每个文件只包含一个值。尽管如此，包含多个同类型值的数组也是可以接受的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Attributes should be ASCII text files, preferably with only one value</span><br><span class="line">per file. It is noted that it may not be efficient to contain only one</span><br><span class="line">value per file, so it is socially acceptable to express an array of</span><br><span class="line">values of the same type.</span><br></pre></td></tr></table></figure><p>混合类型、表达多行数据以及进行花哨的数据格式化是被强烈反对的。这些做法可能会让你在公开场合受到羞辱，并且你的代码可能会在没有通知的情况下被重写。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mixing types, expressing multiple lines of data, and doing fancy</span><br><span class="line">formatting of data is heavily frowned upon. Doing these things may get</span><br><span class="line">you publicly humiliated and your code rewritten without notice.</span><br></pre></td></tr></table></figure><p>一个属性定义非常简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">An attribute definition is simply::</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span> &#123;</span></span><br><span class="line">    <span class="type">char</span>                    * name;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span>*<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">umode_t</span>                 mode;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">sysfs_create_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">sysfs_remove_file</span><span class="params">(<span class="keyword">struct</span> kobject * kobj, <span class="type">const</span> <span class="keyword">struct</span> attribute * attr)</span>;</span><br></pre></td></tr></table></figure><p>一个裸属性不包含读取或写入属性值的方法。子系统被鼓励为特定对象类型定义自己的属性结构和包装函数，以添加和删除属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A bare attribute contains no means to read or write the value of the</span><br><span class="line">attribute. Subsystems are encouraged to define their own attribute</span><br><span class="line">structure and wrapper functions for adding and removing attributes for</span><br><span class="line">a specific object type.</span><br></pre></td></tr></table></figure><p>例如，驱动模型定义了 <code>struct device_attribute</code> 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">For example, the driver model defines <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> <span class="title">like</span>:</span>:</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span><span class="title">attr</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">    <span class="type">char</span> *buf);</span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *, <span class="type">const</span> <span class="keyword">struct</span> device_attribute *)</span>;</span><br></pre></td></tr></table></figure><p>它还定义了用于定义设备属性的辅助函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">It also defines this helper <span class="keyword">for</span> defining device attributes::</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DEVICE_ATTR(_name, _mode, _show, _store) \</span></span><br><span class="line"><span class="meta">    struct device_attribute dev_attr_##_name = __ATTR(_name, _mode, _show, _store)</span></span><br></pre></td></tr></table></figure><p>例如，声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, declaring::</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="title function_">DEVICE_ATTR</span><span class="params">(foo, S_IWUSR | S_IRUGO, show_foo, store_foo)</span>;</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">is equivalent to doing::</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> <span class="title">dev_attr_foo</span> =</span> &#123;</span><br><span class="line">    .attr = &#123;</span><br><span class="line">    .name = <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    .mode = S_IWUSR | S_IRUGO,</span><br><span class="line">    &#125;,</span><br><span class="line">    .show = show_foo,</span><br><span class="line">    .store = store_foo,</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>在 <code>include/linux/kernel.h</code> 中提到“OTHER_WRITABLE? 通常被认为是一个坏主意。”所以尝试为所有人设置一个可写的 sysfs 文件将失败，并会恢复为只读模式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Note as stated in include/linux/kernel.h <span class="string">&quot;OTHER_WRITABLE?  Generally</span></span><br><span class="line"><span class="string">considered a bad idea.&quot;</span> so trying to <span class="built_in">set</span> a sysfs file writable <span class="keyword">for</span></span><br><span class="line">everyone will fail reverting to RO mode <span class="keyword">for</span> <span class="string">&quot;Others&quot;</span>.</span><br></pre></td></tr></table></figure><p>对于常见情况，<code>sysfs.h</code> 提供了便捷的宏来简化属性定义，使代码更简洁和易读。上述情况可以简化为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">For the common cases sysfs.h provides convenience macros to make</span><br><span class="line">defining attributes easier as well as making code more concise and</span><br><span class="line">readable. The above <span class="keyword">case</span> could be shortened to:</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> <span class="title">dev_attr_foo</span> =</span> __ATTR_RW(foo);</span><br></pre></td></tr></table></figure><p>可用来定义包装函数的辅助函数列表如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">the list of helpers available to define your wrapper function is:</span><br><span class="line"></span><br><span class="line">__ATTR_RO(name):</span><br><span class="line"> assumes default name_show and mode 0444</span><br><span class="line">__ATTR_WO(name):</span><br><span class="line"> assumes a name_store only and is restricted to mode</span><br><span class="line">                 0200 that is root write access only.</span><br><span class="line">__ATTR_RO_MODE(name, mode):</span><br><span class="line">         fore more restrictive RO access currently</span><br><span class="line">                 only use case is the EFI System Resource Table</span><br><span class="line">                 (see drivers/firmware/efi/esrt.c)</span><br><span class="line">__ATTR_RW(name):</span><br><span class="line">         assumes default name_show, name_store and setting</span><br><span class="line">                 mode to 0644.</span><br><span class="line">__ATTR_NULL:</span><br><span class="line">         which sets the name to NULL and is used as end of list</span><br><span class="line">                 indicator (see: kernel/workqueue.c)</span><br></pre></td></tr></table></figure><h3 id="子系统特定的回调"><a href="#子系统特定的回调" class="headerlink" title="子系统特定的回调"></a>子系统特定的回调</h3><p>当子系统定义一个新的属性类型时，它必须实现一组 sysfs 操作，用于将读写调用转发给属性所有者的 <code>show</code> 和 <code>store</code> 方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Subsystem-Specific Callbacks</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">When a subsystem defines a new attribute type, it must implement a</span><br><span class="line"><span class="built_in">set</span> of sysfs operations <span class="keyword">for</span> forwarding read and write calls to the</span><br><span class="line">show and store methods of the attribute owners::</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> sysfs_ops &#123;</span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> kobject *, <span class="keyword">struct</span> attribute *, <span class="type">char</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> kobject *, <span class="keyword">struct</span> attribute *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>[子系统应该已经定义了一个 <code>struct kobj_type</code> 作为此类型的描述符，<code>sysfs_ops</code> 指针存储在其中。有关更多信息，请参阅 kobject 文档。]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ Subsystems should have already defined a struct kobj_type as a</span><br><span class="line">descriptor for this type, which is where the sysfs_ops pointer is</span><br><span class="line">stored. See the kobject documentation for more information. ]</span><br></pre></td></tr></table></figure><p>当文件被读取或写入时，sysfs 调用适当的方法。该方法然后将通用的 <code>struct kobject</code> 和 <code>struct attribute</code> 指针转换为适当的指针类型，并调用相关的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">When a file is read or written, sysfs calls the appropriate method</span><br><span class="line">for the type. The method then translates the generic struct kobject</span><br><span class="line">and struct attribute pointers to the appropriate pointer types, and</span><br><span class="line">calls the associated methods.</span><br></pre></td></tr></table></figure><p>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">To illustrate::</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> to_dev_attr(_attr) container_of(_attr, struct device_attribute, attr)</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">dev_attr_show</span><span class="params">(<span class="keyword">struct</span> kobject *kobj, <span class="keyword">struct</span> attribute *attr,</span></span><br><span class="line"><span class="params"><span class="type">char</span> *buf)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> *<span class="title">dev_attr</span> =</span> to_dev_attr(attr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> kobj_to_dev(kobj);</span><br><span class="line">    <span class="type">ssize_t</span> ret = -EIO;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev_attr-&gt;show)</span><br><span class="line">    ret = dev_attr-&gt;show(dev, dev_attr, buf);</span><br><span class="line">    <span class="keyword">if</span> (ret &gt;= (<span class="type">ssize_t</span>)PAGE_SIZE) &#123;</span><br><span class="line">    printk(<span class="string">&quot;dev_attr_show: %pS returned bad count\n&quot;</span>,</span><br><span class="line">    dev_attr-&gt;show);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="读取-x2F-写入属性数据"><a href="#读取-x2F-写入属性数据" class="headerlink" title="读取&#x2F;写入属性数据"></a>读取&#x2F;写入属性数据</h3><p>要读取或写入属性，必须在声明属性时指定 <code>show()</code> 或 <code>store()</code> 方法。方法类型应该像为设备属性定义的那样简单：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Reading/Writing Attribute Data</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">To read or write attributes, show() or <span class="title function_">store</span><span class="params">()</span> methods must be</span><br><span class="line">specified when declaring the attribute. The method types should be as</span><br><span class="line">simple as those defined <span class="keyword">for</span> device attributes::</span><br><span class="line"></span><br><span class="line">    <span class="title function_">ssize_t</span> <span class="params">(*show)</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr, <span class="type">char</span> *buf)</span>;</span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br></pre></td></tr></table></figure><p>换句话说，它们应该只接收一个对象、一个属性和一个缓冲区作为参数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IOW, they should take only an object, an attribute, and a buffer as parameters.</span><br></pre></td></tr></table></figure><p>sysfs 分配一个大小为 <code>PAGE_SIZE</code> 的缓冲区并将其传递给该方法。sysfs 将对每次读取或写入调用该方法一次。这迫使方法实现遵循以下行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sysfs allocates a buffer of size (PAGE_SIZE) and passes it to the</span><br><span class="line">method. Sysfs will call the method exactly once for each read or</span><br><span class="line">write. This forces the following behavior on the method</span><br><span class="line">implementations:</span><br></pre></td></tr></table></figure><ul><li>在 <code>read(2)</code> 调用时，<code>show()</code> 方法应该填满整个缓冲区。请记住，一个属性应该只导出一个值或类似值的数组，因此这不应该太昂贵。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- On read(2), the show() method should fill the entire buffer.</span><br><span class="line">  Recall that an attribute should only be exporting one value, or an</span><br><span class="line">  array of similar values, so this shouldn&#x27;t be that expensive.</span><br></pre></td></tr></table></figure><ul><li>这允许用户空间任意地对整个文件进行部分读取和前向查找。如果用户空间回到零位置或使用偏移量为 <code>0</code> 的 <code>pread(2)</code>，<code>show()</code> 方法将再次被调用，重新填充缓冲区。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">This allows userspace to do partial reads and forward seeks</span><br><span class="line">arbitrarily over the entire file at will. If userspace seeks back to</span><br><span class="line">zero or does a pread(2) with an offset of &#x27;0&#x27; the show() method will</span><br><span class="line">be called again, rearmed, to fill the buffer.</span><br></pre></td></tr></table></figure><ul><li>在 <code>write(2)</code> 调用时，sysfs 期望在第一次写入时传递整个缓冲区。然后 sysfs 将整个缓冲区传递给 <code>store()</code> 方法。在存储时，数据后会添加一个终止空字符。这使得像 <code>sysfs_streq()</code> 这样的函数可以安全使用。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- On write(2), sysfs expects the entire buffer to be passed during the</span><br><span class="line">  first write. Sysfs then passes the entire buffer to the store() method.</span><br><span class="line">  A terminating null is added after the data on stores. This makes</span><br><span class="line">  functions like sysfs_streq() safe to use.</span><br></pre></td></tr></table></figure><ul><li>在写入 sysfs 文件时，用户空间进程应该首先读取整个文件，修改它希望更改的值，然后将整个缓冲区写回。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">When writing sysfs files, userspace processes should first read the</span><br><span class="line">entire file, modify the values it wishes to change, then write the</span><br><span class="line">entire buffer back.</span><br></pre></td></tr></table></figure><ul><li>属性方法实现应该在读取和写入值时操作相同的缓冲区。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Attribute method implementations should operate on an identical</span><br><span class="line">buffer when reading and writing values.</span><br></pre></td></tr></table></figure><p>其他注意事项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Other notes:</span><br></pre></td></tr></table></figure><ul><li><strong>写入会导致 <code>show()</code> 方法重新激活，无论当前文件位置如何</strong>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Writing causes the show() method to be rearmed regardless of current</span><br><span class="line">  file position.</span><br></pre></td></tr></table></figure><blockquote><p>在正常连续 <code>read</code> 读取的时候，<code>show()</code> 方法的调用行为取决于读取的方式和文件位置。</p><p>在 sysfs 中，每次 <code>read</code> 操作都会调用 <code>show()</code> 方法来填充缓冲区。具体行为如下：</p><ol><li><strong>首次读取</strong>：当你第一次读取 sysfs 文件时，<code>show()</code> 方法会被调用，填充缓冲区。</li><li><strong>连续读取</strong>：如果读取操作没有改变文件偏移量（即连续读取），那么 <code>show()</code> 方法不会被再次调用。缓冲区中的数据会被直接返回，直到缓冲区的数据被读取完毕。</li><li><strong>重新读取</strong>：如果文件偏移量被改变（例如，用户空间程序通过 <code>lseek</code> 调用将文件指针移动到文件开头），再次读取时，<code>show()</code> 方法会被重新调用，重新填充缓冲区。</li></ol></blockquote><ul><li>缓冲区的长度总是 <code>PAGE_SIZE</code> 字节。在 i386 上，这个值是 4096。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- The buffer will always be PAGE_SIZE bytes in length. On i386, this</span><br><span class="line">  is 4096.</span><br></pre></td></tr></table></figure><ul><li><code>show()</code> 方法应返回填充到缓冲区中的字节数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- show() methods should return the number of bytes printed into the</span><br><span class="line">  buffer.</span><br></pre></td></tr></table></figure><ul><li><code>show()</code> 方法在格式化返回给用户空间的值时应仅使用 <code>sysfs_emit()</code> 或 <code>sysfs_emit_at()</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- show() should only use sysfs_emit() or sysfs_emit_at() when formatting</span><br><span class="line">  the value to be returned to user space.</span><br></pre></td></tr></table></figure><ul><li><code>store()</code> 方法应返回缓冲区中使用的字节数。如果整个缓冲区都已使用，只返回 <code>count</code> 参数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- store() should return the number of bytes used from the buffer. If the</span><br><span class="line">  entire buffer has been used, just return the count argument.</span><br></pre></td></tr></table></figure><ul><li><code>show()</code> 或 <code>store()</code> 方法总是可以返回错误。如果有一个错误值传入，请务必返回一个错误。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- show() or store() can always return errors. If a bad value comes</span><br><span class="line">  through, be sure to return an error.</span><br></pre></td></tr></table></figure><ul><li>传递给方法的对象将通过 sysfs 引用计数其嵌入对象固定在内存中。然而，该对象代表的物理实体（例如设备）可能不存在。如果必要，请确保有一种方法来检查这一点。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- The object passed to the methods will be pinned in memory via sysfs</span><br><span class="line">  referencing counting its embedded object. However, the physical</span><br><span class="line">  entity (e.g. device) the object represents may not be present. Be</span><br><span class="line">  sure to have a way to check this, if necessary.</span><br></pre></td></tr></table></figure><p>一个非常简单（且天真的）设备属性实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">A very <span class="title function_">simple</span> <span class="params">(and naive)</span> implementation of a device attribute is::</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">show_name</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span></span><br><span class="line"><span class="params">    <span class="type">char</span> *buf)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> scnprintf(buf, PAGE_SIZE, <span class="string">&quot;%s\n&quot;</span>, dev-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">store_name</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count)</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">snprintf</span>(dev-&gt;name, <span class="keyword">sizeof</span>(dev-&gt;name), <span class="string">&quot;%.*s&quot;</span>,</span><br><span class="line">    (<span class="type">int</span>)min(count, <span class="keyword">sizeof</span>(dev-&gt;name) - <span class="number">1</span>), buf);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="title function_">DEVICE_ATTR</span><span class="params">(name, S_IRUGO, show_name, store_name)</span>;</span><br></pre></td></tr></table></figure><p>（注意，真实实现不允许用户空间设置设备的名称。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Note that the real implementation doesn&#x27;t allow userspace to set the</span><br><span class="line">name for a device.)</span><br></pre></td></tr></table></figure><h3 id="顶级目录布局"><a href="#顶级目录布局" class="headerlink" title="顶级目录布局"></a>顶级目录布局</h3><p>sysfs 目录结构暴露了内核数据结构的关系。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Top Level Directory Layout</span><br><span class="line">~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">The sysfs directory arrangement exposes the relationship of kernel</span><br><span class="line">data structures.</span><br></pre></td></tr></table></figure><p>顶级 sysfs 目录如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The top level sysfs directory looks like::</span><br><span class="line"></span><br><span class="line">    block/</span><br><span class="line">    bus/</span><br><span class="line">    class/</span><br><span class="line">    dev/</span><br><span class="line">    devices/</span><br><span class="line">    firmware/</span><br><span class="line">    net/</span><br><span class="line">    fs/</span><br></pre></td></tr></table></figure><p><code>devices/</code> 包含设备树的文件系统表示。它直接映射到内核设备树，这是一个 <code>struct device</code> 的层次结构。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">devices/ contains a filesystem representation of the device tree. It maps</span><br><span class="line">directly to the internal kernel device tree, which is a hierarchy of</span><br><span class="line">struct device.</span><br></pre></td></tr></table></figure><p><code>bus/</code> 包含各种总线类型的扁平目录布局。每个总线的目录包含两个子目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bus/ contains flat directory layout of the various bus types in the</span><br><span class="line">kernel. Each bus&#x27;s directory contains two subdirectories::</span><br><span class="line"></span><br><span class="line">devices/</span><br><span class="line">drivers/</span><br></pre></td></tr></table></figure><p><code>devices/</code> 包含系统中发现的每个设备的符号链接，指向设备在根目录下的目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">devices/ contains symlinks for each device discovered in the system</span><br><span class="line">that point to the device&#x27;s directory under root/.</span><br></pre></td></tr></table></figure><p><code>drivers/</code> 包含每个设备驱动程序的目录，这些驱动程序是为该总线上的设备加载的（这假设驱动程序不会跨多个总线类型）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">drivers/ contains a directory for each device driver that is loaded</span><br><span class="line">for devices on that particular bus (this assumes that drivers do not</span><br><span class="line">span multiple bus types).</span><br></pre></td></tr></table></figure><p><code>fs/</code> 包含一些文件系统的目录。目前，每个希望导出属性的文件系统必须在 <code>fs/</code> 下创建自己的层次结构（参见 <code>./fuse.txt</code> 了解示例）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs/ contains a directory for some filesystems.  Currently each</span><br><span class="line">filesystem wanting to export attributes must create its own hierarchy</span><br><span class="line">below fs/ (see ./fuse.txt for an example).</span><br></pre></td></tr></table></figure><p><code>dev/</code> 包含两个目录 <code>char/</code> 和 <code>block/</code>。在这两个目录中，有名为 <code>&lt;major&gt;:&lt;minor&gt;</code> 的符号链接。这些符号链接指向给定设备的 sysfs 目录。<code>/sys/dev</code> 提供了一种从 <code>stat(2)</code> 操作的结果快速查找设备的 sysfs 接口的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dev/ contains two directories char/ and block/. Inside these two</span><br><span class="line">directories there are symlinks named &lt;major&gt;:&lt;minor&gt;.  These symlinks</span><br><span class="line">point to the sysfs directory for the given device.  /sys/dev provides a</span><br><span class="line">quick way to lookup the sysfs interface for a device from the result of</span><br><span class="line">a stat(2) operation.</span><br></pre></td></tr></table></figure><p>更多有关驱动模型特定功能的信息可以在 <code>Documentation/driver-api/driver-model/</code> 中找到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">More information can driver-model specific features can be found in</span><br><span class="line">Documentation/driver-api/driver-model/.</span><br></pre></td></tr></table></figure><h3 id="当前接口"><a href="#当前接口" class="headerlink" title="当前接口"></a>当前接口</h3><p>以下接口层目前存在于 sysfs 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Current Interfaces</span><br><span class="line">~~~~~~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">The following interface layers currently exist in sysfs:</span><br></pre></td></tr></table></figure><h4 id="设备（include-linux-device-h）"><a href="#设备（include-linux-device-h）" class="headerlink" title="设备（include/linux/device.h）"></a>设备（<code>include/linux/device.h</code>）</h4><p>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">devices (include/linux/device.h)</span><br><span class="line">--------------------------------</span><br><span class="line">Structure::</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device_attribute</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span><span class="title">attr</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">    <span class="type">char</span> *buf);</span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_attribute *attr,</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> count);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Declaring::</span><br><span class="line"></span><br><span class="line">    DEVICE_ATTR(_name, _mode, _show, _store);</span><br></pre></td></tr></table></figure><p>创建&#x2F;删除：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Creation/Removal::</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">device_create_file</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="keyword">struct</span> device_attribute * attr)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">device_remove_file</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="type">const</span> <span class="keyword">struct</span> device_attribute * attr)</span>;</span><br></pre></td></tr></table></figure><h4 id="总线驱动程序（include-linux-device-h）"><a href="#总线驱动程序（include-linux-device-h）" class="headerlink" title="总线驱动程序（include/linux/device.h）"></a>总线驱动程序（<code>include/linux/device.h</code>）</h4><p>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bus <span class="title function_">drivers</span> <span class="params">(include/linux/device.h)</span></span><br><span class="line">------------------------------------</span><br><span class="line">Structure::</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> bus_attribute &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>        <span class="title">attr</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> bus_type *, <span class="type">char</span> * buf);</span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> bus_type *, <span class="type">const</span> <span class="type">char</span> * buf, <span class="type">size_t</span> count);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Declaring::</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="title function_">BUS_ATTR_RW</span><span class="params">(name)</span>;</span><br><span class="line">    <span class="type">static</span> <span class="title function_">BUS_ATTR_RO</span><span class="params">(name)</span>;</span><br><span class="line">    <span class="type">static</span> <span class="title function_">BUS_ATTR_WO</span><span class="params">(name)</span>;</span><br></pre></td></tr></table></figure><p>创建&#x2F;删除：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Creation/Removal::</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">bus_create_file</span><span class="params">(<span class="keyword">struct</span> bus_type *, <span class="keyword">struct</span> bus_attribute *)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">bus_remove_file</span><span class="params">(<span class="keyword">struct</span> bus_type *, <span class="keyword">struct</span> bus_attribute *)</span>;</span><br></pre></td></tr></table></figure><h4 id="设备驱动程序（include-linux-device-h）"><a href="#设备驱动程序（include-linux-device-h）" class="headerlink" title="设备驱动程序（include/linux/device.h）"></a>设备驱动程序（<code>include/linux/device.h</code>）</h4><p>结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">device <span class="title function_">drivers</span> <span class="params">(include/linux/device.h)</span></span><br><span class="line">---------------------------------------</span><br><span class="line"></span><br><span class="line">Structure::</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> driver_attribute &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">attribute</span>        <span class="title">attr</span>;</span></span><br><span class="line">    <span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> device_driver *, <span class="type">char</span> * buf);</span><br><span class="line">    <span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> device_driver *, <span class="type">const</span> <span class="type">char</span> * buf,</span><br><span class="line">    <span class="type">size_t</span> count);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Declaring::</span><br><span class="line"></span><br><span class="line">    DRIVER_ATTR_RO(_name)</span><br><span class="line">    DRIVER_ATTR_RW(_name)</span><br></pre></td></tr></table></figure><p>创建&#x2F;删除：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Creation/Removal::</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">driver_create_file</span><span class="params">(<span class="keyword">struct</span> device_driver *, <span class="type">const</span> <span class="keyword">struct</span> driver_attribute *)</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">driver_remove_file</span><span class="params">(<span class="keyword">struct</span> device_driver *, <span class="type">const</span> <span class="keyword">struct</span> driver_attribute *)</span>;</span><br></pre></td></tr></table></figure><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>sysfs 目录结构和每个目录中的属性定义了内核与用户空间之间的 ABI。对于任何 ABI 来说，确保其稳定性和正确文档化是非常重要的。所有新的 sysfs 属性必须在 <code>Documentation/ABI</code> 中进行文档化。有关更多信息，请参阅 <code>Documentation/ABI/README</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Documentation</span><br><span class="line">~~~~~~~~~~~~~</span><br><span class="line"></span><br><span class="line">The sysfs directory structure and the attributes in each directory define an</span><br><span class="line">ABI between the kernel and user space. As for any ABI, it is important that</span><br><span class="line">this ABI is stable and properly documented. All new sysfs attributes must be</span><br><span class="line">documented in Documentation/ABI. See also Documentation/ABI/README for more</span><br><span class="line">information.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> sysfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux USB functionfs</title>
      <link href="/2024/09/22/Linux-USBfunctionfs/"/>
      <url>/2024/09/22/Linux-USBfunctionfs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>translate from <a href="https://www.kernel.org/doc/html/v6.1/usb/functionfs.html">https://www.kernel.org/doc/html/v6.1/usb/functionfs.html</a></p></blockquote><h1 id="FunctionFS-如何工作"><a href="#FunctionFS-如何工作" class="headerlink" title="FunctionFS 如何工作"></a>FunctionFS 如何工作</h1><p>从内核的角度来看，它只是一个具有一些独特行为的复合功能。只有在用户空间驱动程序通过写入描述符和字符串注册后，它才能被添加到 USB 配置中（用户空间程序必须提供与内核级复合功能在添加到配置中时提供的相同信息）。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">From kernel point of view it is just a composite function with some</span><br><span class="line">unique behaviour.  It may be added to an USB configuration only after</span><br><span class="line">the user space driver has registered by writing descriptors and</span><br><span class="line">strings (the user space program has to provide the same information</span><br><span class="line">that kernel level composite functions provide when they are added to</span><br><span class="line">the configuration).</span><br></pre></td></tr></table></figure><p>这特别意味着复合初始化函数可能不会在 init 部分（即可能不会使用 __init 标签）。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This in particular means that the composite initialisation functions</span><br><span class="line">may not be in init section (ie. may not use the __init tag).</span><br></pre></td></tr></table></figure><p>从用户空间的角度来看，它是一个文件系统，当挂载时会提供一个 “ep0” 文件。用户空间驱动程序需要向该文件写入描述符和字符串。它不需要担心端点、接口或字符串编号，而只需提供描述符，如同该功能是唯一的（端点和字符串编号从 1 开始，接口编号从 0 开始）。FunctionFS 根据需要更改它们，并处理在不同配置中编号不同的情况。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">From user space point of view it is a file system which when</span><br><span class="line">mounted provides an &quot;ep0&quot; file.  User space driver need to</span><br><span class="line">write descriptors and strings to that file.  It does not need</span><br><span class="line">to worry about endpoints, interfaces or strings numbers but</span><br><span class="line">simply provide descriptors such as if the function was the</span><br><span class="line">only one (endpoints and strings numbers starting from one and</span><br><span class="line">interface numbers starting from zero).  The FunctionFS changes</span><br><span class="line">them as needed also handling situation when numbers differ in</span><br><span class="line">different configurations.</span><br></pre></td></tr></table></figure><p>当描述符和字符串被写入后，“ep#”文件会出现（每个声明的端点对应一个），用于处理单个端点上的通信。同样，FunctionFS 负责实际编号和配置更改（这意味着 “ep1” 文件可能实际上映射到（例如）端点 3（当配置更改时可能映射到端点 2））。”ep0” 用于接收事件和处理设置请求。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">When descriptors and strings are written &quot;ep#&quot; files appear</span><br><span class="line">(one for each declared endpoint) which handle communication on</span><br><span class="line">a single endpoint.  Again, FunctionFS takes care of the real</span><br><span class="line">numbers and changing of the configuration (which means that</span><br><span class="line">&quot;ep1&quot; file may be really mapped to (say) endpoint 3 (and when</span><br><span class="line">configuration changes to (say) endpoint 2)).  &quot;ep0&quot; is used</span><br><span class="line">for receiving events and handling setup requests.</span><br></pre></td></tr></table></figure><p>当所有文件关闭时，该功能会自动禁用。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">When all files are closed the function disables itself.</span><br></pre></td></tr></table></figure><p>我还想提到的是，FunctionFS 的设计使其可以多次挂载，因此最终一个gadget可以使用多个 FunctionFS 功能。其理念是每个 FunctionFS 实例都由挂载时使用的设备名称标识。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">What I also want to mention is that the FunctionFS is designed in such</span><br><span class="line">a way that it is possible to mount it several times so in the end</span><br><span class="line">a gadget could use several FunctionFS functions. The idea is that</span><br><span class="line">each FunctionFS instance is identified by the device name used</span><br><span class="line">when mounting.</span><br></pre></td></tr></table></figure><p>可以想象一个gadget具有以太网、MTP 和 HID 接口，其中后两个是通过 FunctionFS 实现的。在用户空间层面，它看起来像这样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">One can imagine a gadget that has an Ethernet, MTP and HID interfaces</span><br><span class="line">where the last two are implemented via FunctionFS.  On user space</span><br><span class="line">level it would look like this::</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ insmod g_ffs.ko idVendor=&lt;ID&gt; iSerialNumber=&lt;string&gt; <span class="built_in">functions</span>=mtp,hid</span><br><span class="line">$ <span class="built_in">mkdir</span> /dev/ffs-mtp &amp;&amp; mount -t functionfs mtp /dev/ffs-mtp</span><br><span class="line">$ ( <span class="built_in">cd</span> /dev/ffs-mtp &amp;&amp; mtp-daemon ) &amp;</span><br><span class="line">$ <span class="built_in">mkdir</span> /dev/ffs-hid &amp;&amp; mount -t functionfs hid /dev/ffs-hid</span><br><span class="line">$ ( <span class="built_in">cd</span> /dev/ffs-hid &amp;&amp; hid-daemon ) &amp;</span><br></pre></td></tr></table></figure><p>在内核层面，gadget检查 ffs_data-&gt;dev_name 以确定它是为 MTP（“mtp”）还是 HID（“hid”）设计的 FunctionFS。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">On kernel level the gadget checks ffs_data-&gt;dev_name to identify</span><br><span class="line">whether it&#x27;s FunctionFS designed for MTP (&quot;mtp&quot;) or HID (&quot;hid&quot;).</span><br></pre></td></tr></table></figure><p>如果没有提供 “functions” 模块参数，驱动程序只接受一个具有任意名称的功能。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">If no &quot;functions&quot; module parameters is supplied, the driver accepts</span><br><span class="line">just one function with any name.</span><br></pre></td></tr></table></figure><p>当提供了 “functions” 模块参数时，只有列出的功能名称会被接受。特别地，如果 “functions” 参数的值只是一个单元素列表，那么行为类似于没有 “functions” 参数的情况；然而，仅接受具有指定名称的功能。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">When &quot;functions&quot; module parameter is supplied, only functions</span><br><span class="line">with listed names are accepted. In particular, if the &quot;functions&quot;</span><br><span class="line">parameter&#x27;s value is just a one-element list, then the behaviour</span><br><span class="line">is similar to when there is no &quot;functions&quot; at all; however,</span><br><span class="line">only a function with the specified name is accepted.</span><br></pre></td></tr></table></figure><p>只有在所有声明的功能文件系统都已挂载并且所有功能的 USB 描述符都已写入其 ep0 时，gadget才会被注册。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The gadget is registered only after all the declared function</span><br><span class="line">filesystems have been mounted and USB descriptors of all functions</span><br><span class="line">have been written to their ep0&#x27;s.</span><br></pre></td></tr></table></figure><p>相反，第一个 USB 功能关闭其端点后，gadget会被注销。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Conversely, the gadget is unregistered after the first USB function</span><br><span class="line">closes its endpoints.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> USB </tag>
            
            <tag> configfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux USB gadget_configfs</title>
      <link href="/2024/09/22/Linux-USBconfigfs/"/>
      <url>/2024/09/22/Linux-USBconfigfs/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-USB-gadget-通过-configfs-配置"><a href="#Linux-USB-gadget-通过-configfs-配置" class="headerlink" title="Linux USB gadget 通过 configfs 配置"></a>Linux USB gadget 通过 configfs 配置</h2><ul><li><input disabled="" type="checkbox"> 先阅读 <a href="Linux-configfs.md">Linux configfs</a>，再看此内容</li></ul><p>usb 只有在作为从设备时，才会用到 configfs 去配置功能。</p><p>更新日期：2013年4月25日</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>USB Linux Gadget 是一种设备，它具有一个 UDC（USB 设备控制器），并且可以连接到 USB 主机，通过添加功能扩展主机，如串行端口或大容量存储功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A USB Linux Gadget is a device which has a UDC (USB Device Controller)</span><br><span class="line">and can be connected to a USB Host to extend it with additional functions</span><br><span class="line">like a serial port or a mass storage capability.</span><br></pre></td></tr></table></figure><p>从主机的角度来看，<strong>一个 Gadget 是一组配置的集合</strong>，<strong>每个配置包含若干接口，而从 Gadget 的角度看，这些接口被称为功能（function），每个功能代表一个如串行连接或 SCSI 磁盘的设备</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A gadget is seen by its host as a set of configurations, each of which</span><br><span class="line">contains a number of interfaces which, from the gadget&#x27;s perspective,</span><br><span class="line">are known as functions, each function representing e.g. a serial</span><br><span class="line">connection or a SCSI disk.</span><br></pre></td></tr></table></figure><p>Linux 提供了许多功能供 Gadget 使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux provides a number of functions for gadgets to use.</span><br></pre></td></tr></table></figure><p><strong>创建一个 Gadget 意味着决定将有哪些配置，以及每个配置将提供哪些功能</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Creating a gadget means deciding what configurations there will be and which</span><br><span class="line">functions each configuration will provide.</span><br></pre></td></tr></table></figure><p>Configfs（请参见 <code>Documentation/filesystems/configfs.rst</code>）非常适合用于向内核传达上述决策。本文档讨论了如何实现这一目标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Configfs (please see `Documentation/filesystems/configfs.rst`) lends itself</span><br><span class="line">nicely for the purpose of telling the kernel about the above mentioned decision.</span><br><span class="line">This document is about how to do it.</span><br></pre></td></tr></table></figure><p>它还描述了 Gadget 中的 configfs 集成设计。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">It also describes how configfs integration into gadget is designed.</span><br></pre></td></tr></table></figure><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>为了使其工作，configfs 必须可用，因此 .config 中的 <code>CONFIGFS_FS</code> 必须为 ‘y’ 或 ‘m’。截至本文写作时，<code>USB_LIBCOMPOSITE</code> 选择了 <code>CONFIGFS_FS</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In order for this to work configfs must be available, so CONFIGFS_FS must be &#x27;y&#x27;</span><br><span class="line">or &#x27;m&#x27; in .config. As of this writing USB_LIBCOMPOSITE selects CONFIGFS_FS.</span><br></pre></td></tr></table></figure><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>（描述第一个通过 configfs 提供的功能的原始帖子可以在这里看到：<a href="http://www.spinics.net/lists/linux-usb/msg76388.html%EF%BC%89">http://www.spinics.net/lists/linux-usb/msg76388.html）</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(The original post describing the first function made available through configfs</span><br><span class="line">can be seen here: http://www.spinics.net/lists/linux-usb/msg76388.html)</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ modprobe libcomposite</span><br><span class="line">$ mount none <span class="variable">$CONFIGFS_HOME</span> -t configfs</span><br></pre></td></tr></table></figure><p>其中 CONFIGFS_HOME 是 configfs 的挂载点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where CONFIGFS_HOME is the mount point for configfs</span><br></pre></td></tr></table></figure><h3 id="1-创建-Gadgets"><a href="#1-创建-Gadgets" class="headerlink" title="1. 创建 Gadgets"></a>1. 创建 Gadgets</h3><p>为每个要创建的 Gadget 创建相应的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="variable">$CONFIGFS_HOME</span>/usb_gadget/&lt;gadget name&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For each gadget to be created its corresponding directory must be created:</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="variable">$CONFIGFS_HOME</span>/usb_gadget/g1</span><br></pre></td></tr></table></figure><p>进入对应的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> <span class="variable">$CONFIGFS_HOME</span>/usb_gadget/g1</span><br></pre></td></tr></table></figure><p>每个 Gadget 需要指定其供应商 ID（VID）和产品 ID（PID）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &lt;VID&gt; &gt; idVendor</span><br><span class="line">$ <span class="built_in">echo</span> &lt;PID&gt; &gt; idProduct</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Each gadget needs to have its vendor id &lt;VID&gt; and product id &lt;PID&gt; specified:</span><br></pre></td></tr></table></figure><p>一个 Gadget 还需要其序列号、制造商和产品字符串。为了存储它们，需要为每种语言创建一个字符串子目录，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A gadget also needs its serial number, manufacturer and product strings. In order</span><br><span class="line">to have a place to store them, a strings subdirectory must be created for each language,</span><br><span class="line">e.g.:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> strings/0x409</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/brookebasile/USB-langids/blob/master/USB%20Lang%20IDs%20-%20Language%20Identifiers.csv">usb language IDS</a> or <a href="http://www.baiheee.com/Documents/090518/090518112619/USB_LANGIDs.pdf">http://www.baiheee.com/Documents/090518/090518112619/USB_LANGIDs.pdf</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0x0404Chinese (Taiwan)</span><br><span class="line">0x0804Chinese (PRC)</span><br><span class="line">0x0c04Chinese (Hong Kong SAR, PRC)</span><br><span class="line">0x1004Chinese (Singapore)</span><br><span class="line">0x1404Chinese (Macau SAR)</span><br><span class="line">0x0409English (United States)</span><br><span class="line">0x0809English (United Kingdom)</span><br></pre></td></tr></table></figure></blockquote><p>然后可以指定字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Then the strings can be specified:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &lt;serial number&gt; &gt; strings/0x409/serialnumber</span><br><span class="line">$ <span class="built_in">echo</span> &lt;manufacturer&gt; &gt; strings/0x409/manufacturer</span><br><span class="line">$ <span class="built_in">echo</span> &lt;product&gt; &gt; strings/0x409/product</span><br></pre></td></tr></table></figure><h3 id="2-创建配置"><a href="#2-创建配置" class="headerlink" title="2. 创建配置"></a>2. 创建配置</h3><p>每个 Gadget 将包含若干配置，需要创建相应的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> configs/&lt;name&gt;.&lt;number&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Each gadget will consist of a number of configurations, their corresponding directories must be created:</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;name&gt;</code> 可以是文件系统中合法的任意字符串，<code>&lt;number&gt;</code> 是配置的编号，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> configs/c.1</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where &lt;name&gt; can be any string which is legal in a filesystem and the &lt;number&gt; is the configuration&#x27;s number, e.g.:</span><br></pre></td></tr></table></figure><p>每个配置也需要其字符串，因此需要为每种语言创建一个子目录，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> configs/c.1/strings/0x409</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Each configuration also needs its strings, so a subdirectory must be created for</span><br><span class="line">each language, e.g.:</span><br></pre></td></tr></table></figure><p>然后可以指定配置字符串：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &lt;configuration&gt; &gt; configs/c.1/strings/0x409/configuration</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Then the configuration string can be specified:</span><br></pre></td></tr></table></figure><p>还可以为配置设置一些属性，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 120 &gt; configs/c.1/MaxPower</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Some attributes can also be set for a configuration, e.g.:</span><br></pre></td></tr></table></figure><h3 id="3-创建功能"><a href="#3-创建功能" class="headerlink" title="3. 创建功能"></a>3. 创建功能</h3><p>Gadget 将提供一些功能，为每个功能创建相应的目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="built_in">functions</span>/&lt;name&gt;.&lt;instance name&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The gadget will provide some functions, for each function its corresponding</span><br><span class="line">directory must be created:</span><br></pre></td></tr></table></figure><p><strong>其中 <code>&lt;name&gt;</code> 对应于允许的功能名称之一</strong>，实例名称是文件系统中允许的任意字符串，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> <span class="built_in">functions</span>/ncm.usb0 <span class="comment"># usb_f_ncm.ko gets loaded with request_module()</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">where &lt;name&gt; corresponds to one of allowed function names and instance name is</span><br><span class="line">an arbitrary string allowed in a filesystem, e.g.:</span><br></pre></td></tr></table></figure><p>每个功能提供其特定的一组属性，具有只读或读写访问权限。在适用的情况下，需要适当写入它们。请参阅 <code>Documentation/ABI/*/configfs-usb-gadget*</code> 了解更多信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Each function provides its specific set of attributes, with either read-only or</span><br><span class="line">read-write access. Where applicable they need to be written to as appropriate.</span><br><span class="line">Please refer to Documentation/ABI/*/configfs-usb-gadget* for more information.</span><br></pre></td></tr></table></figure><blockquote><p>💥💥💥💥💥💥 <a href="https://elixir.bootlin.com/linux/v5.10.186/source/Documentation/ABI/testing">Documentation&#x2F;ABI&#x2F;*&#x2F;configfs-usb-gadget</a> <strong>这里有对每个文件的详细介绍</strong>。</p></blockquote><h3 id="4-将功能与配置关联"><a href="#4-将功能与配置关联" class="headerlink" title="4. 将功能与配置关联"></a>4. 将功能与配置关联</h3><p>此时创建了若干 Gadget，每个 Gadget 都指定了若干配置，并且有若干可用功能。剩下的就是指定哪个功能在哪个配置中可用（同一功能可以在多个配置中使用）。这可以通过创建符号链接来实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ln</span> -s <span class="built_in">functions</span>/&lt;name&gt;.&lt;instance name&gt; configs/&lt;name&gt;.&lt;number&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">At this moment a number of gadgets is created, each of which has a number of configurations specified and a number of functions available. What remains is specifying which function is available in which configuration (the same function can be used in multiple configurations). This is achieved with creating symbolic links:</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ln</span> -s <span class="built_in">functions</span>/ncm.usb0 configs/c.1</span><br></pre></td></tr></table></figure><h3 id="5-启用-Gadget"><a href="#5-启用-Gadget" class="headerlink" title="5. 启用 Gadget"></a>5. 启用 Gadget</h3><p>以上所有步骤的目的是将 Gadget 组成配置和功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">All the above steps serve the purpose of composing the gadget of configurations and functions.</span><br></pre></td></tr></table></figure><p>一个示例目录结构可能如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An example directory structure might look like this:</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">./strings</span><br><span class="line">./strings/0x409</span><br><span class="line">./strings/0x409/serialnumber</span><br><span class="line">./strings/0x409/product</span><br><span class="line">./strings/0x409/manufacturer</span><br><span class="line">./configs</span><br><span class="line">./configs/c.1</span><br><span class="line">./configs/c.1/ncm.usb0 -&gt; ../../../../usb_gadget/g1/functions/ncm.usb0</span><br><span class="line">./configs/c.1/strings</span><br><span class="line">./configs/c.1/strings/0x409</span><br><span class="line">./configs/c.1/strings/0x409/configuration</span><br><span class="line">./configs/c.1/bmAttributes</span><br><span class="line">./configs/c.1/MaxPower</span><br><span class="line">./functions</span><br><span class="line">./functions/ncm.usb0</span><br><span class="line">./functions/ncm.usb0/ifname</span><br><span class="line">./functions/ncm.usb0/qmult</span><br><span class="line">./functions/ncm.usb0/host_addr</span><br><span class="line">./functions/ncm.usb0/dev_addr</span><br><span class="line">./UDC</span><br><span class="line">./bcdUSB</span><br><span class="line">./bcdDevice</span><br><span class="line">./idProduct</span><br><span class="line">./idVendor</span><br><span class="line">./bMaxPacketSize0</span><br><span class="line">./bDeviceProtocol</span><br><span class="line">./bDeviceSubClass</span><br><span class="line">./bDeviceClass</span><br></pre></td></tr></table></figure><p>这样的 Gadget 必须最终启用，以便 USB 主机可以枚举它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Such a gadget must be finally enabled so that the USB host can enumerate it.</span><br></pre></td></tr></table></figure><p>为了启用 Gadget，必须将其绑定到 UDC（USB 设备控制器）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &lt;udc name&gt; &gt; UDC</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In order to enable the gadget it must be bound to a UDC (USB Device Controller):</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;udc name&gt;</code> 是在 <code>/sys/class/udc/*</code> 中找到的一个名称，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where &lt;udc name&gt; is one of those found in /sys/class/udc/* e.g.:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> s3c-hsotg &gt; UDC</span><br></pre></td></tr></table></figure><h3 id="6-禁用-Gadget"><a href="#6-禁用-Gadget" class="headerlink" title="6. 禁用 Gadget"></a>6. 禁用 Gadget</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; UDC</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;&quot; &gt; UDC</span><br></pre></td></tr></table></figure><h3 id="7-清理"><a href="#7-清理" class="headerlink" title="7. 清理"></a>7. 清理</h3><p>从配置中删除功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove functions from configurations:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> configs/&lt;config name&gt;.&lt;number&gt;/&lt;<span class="keyword">function</span>&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;config name&gt;.&lt;number&gt;</code> 指定配置，<code>&lt;function&gt;</code> 是要从配置中删除的功能的符号链接，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">where &lt;config name&gt;.&lt;number&gt; specify the configuration and &lt;function&gt; is a</span><br><span class="line">symlink to a function being removed from the configuration, e.g.:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> configs/c.1/ncm.usb0</span><br></pre></td></tr></table></figure><p>删除配置中的字符串目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove strings directories in configurations:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rmdir</span> configs/&lt;config name&gt;.&lt;number&gt;/strings/&lt;lang&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rmdir</span> configs/c.1/strings/0x409</span><br></pre></td></tr></table></figure><p>然后删除配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and remove the configurations:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rmdir</span> configs/&lt;config name&gt;.&lt;number&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rmdir</span> configs/c.1</span><br></pre></td></tr></table></figure><p>删除功能（功能模块不会被卸载）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove functions (function modules are not unloaded, though):</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rmdir</span> <span class="built_in">functions</span>/&lt;name&gt;.&lt;instance name&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rmdir</span> <span class="built_in">functions</span>/ncm.usb0</span><br></pre></td></tr></table></figure><p>删除 Gadget 中的字符串目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Remove strings directories in the gadget:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rmdir</span> strings/&lt;lang&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rmdir</span> strings/0x409</span><br></pre></td></tr></table></figure><p>最后删除 Gadget：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">and finally remove the gadget:</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ <span class="built_in">rmdir</span> &lt;gadget name&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rmdir</span> g1</span><br></pre></td></tr></table></figure><h2 id="实现设计"><a href="#实现设计" class="headerlink" title="实现设计"></a>实现设计</h2><blockquote><p><a href="Linux-configfs.md">linux configfs</a></p></blockquote><p>下面展示了 configfs 的工作原理。💥💥💥💥<strong>在 configfs 中，有项目<code>item</code>和组<code>group</code>，均表示为目录。项目和组的区别在于组可以包含其他组</strong>💥💥💥。下图仅显示了一个项目。项目和组都可以有属性，这些属性表示为文件。用户可以创建和删除目录，但不能删除文件，这些文件可以是只读或读写的，具体取决于它们表示的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Below the idea of how configfs works is presented. In configfs there are items and groups,</span><br><span class="line">both represented as directories. The difference between an item and a group is</span><br><span class="line">that a group can contain other groups. In the picture below only an item is shown.</span><br><span class="line">Both items and groups can have attributes, which are represented as files.</span><br><span class="line">The user can create and remove directories, but cannot remove files, which can</span><br><span class="line">be read-only or read-write, depending on what they represent.</span><br></pre></td></tr></table></figure><p>configfs 文件系统部分操作 config_items&#x2F;groups 和 configfs_attributes，它们是通用且对所有配置元素类型相同的。然而，它们嵌入在特定用途的更大结构中。下图中有一个 “cs” 包含一个 config_item，还有一个 “sa” 包含一个 configfs_attribute。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The filesystem part of configfs operates on config_items/groups and</span><br><span class="line">configfs_attributes which are generic and of the same type for all configured elements.</span><br><span class="line">However, they are embedded in usage-specific larger structures. In the picture</span><br><span class="line">below there is a &quot;cs&quot; which contains a config_item and an &quot;sa&quot;</span><br><span class="line">which contains a configfs_attribute.</span><br></pre></td></tr></table></figure><p>文件系统视图如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The filesystem view would be like this:</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./</span><br><span class="line">./cs        (directory)</span><br><span class="line">   |</span><br><span class="line">   +--sa    (file)</span><br><span class="line">   |</span><br><span class="line">   .</span><br><span class="line">   .</span><br><span class="line">   .</span><br></pre></td></tr></table></figure><p>每当用户读取&#x2F;写入 “sa” 文件时，会调用一个函数，该函数接收一个 struct config_item 和一个 struct configfs_attribute。在该函数中，使用已知的 container_of 技术检索 “cs” 和 “sa”，并调用适当的 sa 的函数（show 或 store），并传递 “cs” 和一个字符缓冲区。”show” 用于显示文件内容（将数据从 cs 复制到缓冲区），而 “store” 用于修改文件内容（将数据从缓冲区复制到 cs），但具体做什么取决于这两个函数的实现者。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Whenever a user reads/writes the &quot;sa&quot; file, a function is called which accepts</span><br><span class="line">a struct config_item and a struct configfs_attribute. In the said function the</span><br><span class="line">&quot;cs&quot; and &quot;sa&quot; are retrieved using the well known container_of technique and an</span><br><span class="line">appropriate sa&#x27;s function (show or store) is called and passed the &quot;cs&quot; and a</span><br><span class="line">character buffer. The &quot;show&quot; is for displaying the file&#x27;s contents (copy data</span><br><span class="line">from the cs to the buffer), while the &quot;store&quot; is for modifying the file&#x27;s</span><br><span class="line">contents (copy data from the buffer to the cs), but it is up to the implementer</span><br><span class="line">of the two functions to decide what they actually do.</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct configured_structure cs;</span><br><span class="line">typedef struct specific_attribute sa;</span><br><span class="line"></span><br><span class="line">                                       sa</span><br><span class="line">                       +----------------------------------+</span><br><span class="line">        cs             |  (*show)(cs *, buffer);          |</span><br><span class="line">+-----------------+    |  (*store)(cs *, buffer, length); |</span><br><span class="line">|                 |    |                                  |</span><br><span class="line">| +-------------+ |    |       +------------------+       |</span><br><span class="line">| | struct      |-|----|------&gt;|struct            |       |</span><br><span class="line">| | config_item | |    |       |configfs_attribute|       |</span><br><span class="line">| +-------------+ |    |       +------------------+       |</span><br><span class="line">|                 |    +----------------------------------+</span><br><span class="line">| data to be set  |                .</span><br><span class="line">|                 |                .</span><br><span class="line">+-----------------+                .</span><br></pre></td></tr></table></figure><p>文件名由配置项&#x2F;组设计者决定，而目录通常可以随意命名。一个组可以自动创建其默认子组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The file names are decided by the config item/group designer, while the directories</span><br><span class="line"> in general can be named at will. A group can have a number of its default</span><br><span class="line"> sub-groups created automatically.</span><br></pre></td></tr></table></figure><p>有关 configfs 的更多信息，请参见 <code>Documentation/filesystems/configfs.rst</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">For more information on configfs please see `Documentation/filesystems/configfs.rst`.</span><br></pre></td></tr></table></figure><p>上述概念在 USB gadgets 中的应用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The concepts described above translate to USB gadgets like this:</span><br></pre></td></tr></table></figure><ol><li>一个 Gadget 有其配置组，具有一些属性（如 idVendor、idProduct 等）和默认子组（configs、functions、strings）。写入这些属性会将信息存储在适当的位置。在 configs、functions 和 strings 子组中，用户可以创建它们的子组来表示给定语言的配置、功能和字符串组。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. A gadget has its config group, which has some attributes (idVendor, idProduct etc)</span><br><span class="line"> and default sub-groups (configs, functions, strings). Writing to the attributes</span><br><span class="line"> causes the information to be stored in appropriate locations. In the configs,</span><br><span class="line"> functions and strings sub-groups a user can create their sub-groups to represent</span><br><span class="line"> configurations, functions, and groups of strings in a given language.</span><br></pre></td></tr></table></figure><ol start="2"><li>用户创建配置和功能，在配置中创建指向功能的符号链接。当 Gadget 的 UDC 属性被写入时，这些信息将被使用，这意味着将 Gadget 绑定到 UDC。drivers&#x2F;usb&#x2F;gadget&#x2F;configfs.c 中的代码遍历所有配置，在每个配置中遍历所有功能并绑定它们。这样整个 Gadget 就被绑定了。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2. The user creates configurations and functions, in the configurations creates</span><br><span class="line">symbolic links to functions. This information is used when the gadget&#x27;s UDC</span><br><span class="line">attribute is written to, which means binding the gadget to the UDC. The code in</span><br><span class="line">drivers/usb/gadget/configfs.c iterates over all configurations, and in each</span><br><span class="line">configuration it iterates over all functions and binds them.</span><br><span class="line">This way the whole gadget is bound.</span><br></pre></td></tr></table></figure><ol start="3"><li>drivers&#x2F;usb&#x2F;gadget&#x2F;configfs.c 文件包含以下代码：</li></ol><ul><li>Gadget 的 config_group</li><li>Gadget 的默认组（configs、functions、strings）</li><li>将功能与配置关联（符号链接）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3. The file drivers/usb/gadget/configfs.c contains code for</span><br><span class="line"></span><br><span class="line">- gadget&#x27;s config_group</span><br><span class="line">- gadget&#x27;s default groups (configs, functions, strings)</span><br><span class="line">- associating functions with configurations (symlinks)</span><br></pre></td></tr></table></figure><ol start="4"><li>每个 USB 功能自然有其希望配置的视图，因此在 functions 实现文件 drivers&#x2F;usb&#x2F;gadget&#x2F;f_*.c 中定义了特定功能的 config_groups。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4. Each USB function naturally has its own view of what it wants configured,</span><br><span class="line">so config_groups for particular functions are defined in the functions</span><br><span class="line">implementation files drivers/usb/gadget/f_*.c.</span><br></pre></td></tr></table></figure><ol start="5"><li>功能代码的编写方式是使用 usb_get_function_instance()，该函数反过来调用 request_module。因此，只要 modprobe 工作，特定功能的模块就会自动加载。请注意，反之则不然：在 Gadget 被禁用和拆除后，模块仍然保持加载状态。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5. Function&#x27;s code is written in such a way that it uses usb_get_function_instance(),</span><br><span class="line">which, in turn, calls request_module. So, provided that modprobe works,</span><br><span class="line">modules for particular functions are loaded automatically. Please note that</span><br><span class="line">the converse is not true: after a gadget is disabled and torn down,</span><br><span class="line">the modules remain loaded.</span><br></pre></td></tr></table></figure><h2 id="useful-links"><a href="#useful-links" class="headerlink" title="useful links"></a>useful links</h2><p>一些开源仓库基于上面介绍的 usb configfs，USB Gadget API 等，搞了些 cool things.</p><blockquote><p>copy from <a href="https://www.reddit.com/r/linux/comments/1annx0u/a_comprehensive_list_of_all_configfs_functionfs/?rdt=34774">https://www.reddit.com/r/linux/comments/1annx0u/a_comprehensive_list_of_all_configfs_functionfs/?rdt=34774</a></p><p><strong>A comprehensive list of all ConfigFS, FunctionFS, USB Gadget API, etc. tools and libraries on Github(*)</strong></p><p>Ok, so I’m writing a comprehensive list for all libraries, tools, modules, and scripts for any linux distro or kernel that I can find on Github, so I can learn more about how to make use of it.</p><h3 id="What-is-this"><a href="#What-is-this" class="headerlink" title="What is this?"></a>What is this?</h3><p>For those who don’t know what any of the above APIs are, they are the underlying APIs that power things like the MTP protocol that is associated with your mobile electronics, such as smartphone and digital cameras. The Media Transfer Protocol (MTP) is the protocol that allows host devices to <em>pretend</em> to be peripheral storage devices to other hosts. This is what makes it possible for your cell phone or digital camera to show up as a storage device on your PC, even though they are technically small computers.</p><p>You can read more about these APIs from the kernel docs:</p><ul><li><a href="https://docs.kernel.org/driver-api/usb/gadget.html?highlight=gadgetfs">USB Gadget API for Linux — The Linux Kernel documentation</a></li></ul><h3 id="Why-is-this-cool"><a href="#Why-is-this-cool" class="headerlink" title="Why is this cool?"></a>Why is this cool?</h3><p>The really cool thing about these kernel APIs is that they can work at the USB protocol layer. Which means <em>any</em> USB device can be emulated by a linux machine any way you want. You are not limited to just the MTP protocol.</p><p>The reason I am exploring these tools is that I want to see exactly what kind of things I can do with this API. Something that has interested me about this API since I came across it was whether or not it could support hosting a <em>bootable</em> mass storage device. This could allow me to do something like providing Ventoy (or Medicat) over the Gadget API. I was thinking that I could build some kind of stack with this that would allow me to install an operating system dynamically on the host using live ISO, then once the OS has been installed provision it via Ansible over RNDIS without ever having to reboot the device doing the install. Basically, it would provide a method for a fully unattended bare metal install that could fit in your pocket.</p><h3 id="What’s-this-about-kernels-plural"><a href="#What’s-this-about-kernels-plural" class="headerlink" title="What’s this about kernels (plural)?"></a>What’s this about kernels (plural)?</h3><p>Note that earlier, in the first paragraph, I said any linux distro as well as any <em>kernel.</em> Since implementations of this API typically require USB OTG or USB Dual Role hardware, the kernel that is likely to have the most stable tools&#x2F;libraries is going to be the Android kernel. This is something to keep in mind when discussing these APIs.</p><h3 id="TL-DR-The-list"><a href="#TL-DR-The-list" class="headerlink" title="(TL;DR) The list"></a>(TL;DR) The list</h3><p>(*) - Most of these libraries are on Github, but it is worth-while to at least point out the Android Code Search</p><ul><li>(*) <a href="https://cs.android.com/">Android Code Search</a></li><li><a href="https://github.com/linux-usb-gadgets">linux-usb-gadgets</a> organization<ul><li>✨✨✨ <a href="https://github.com/linux-usb-gadgets/libusbgx">libusbgx</a><ul><li>Seemingly really well rounded C library for linux for encapsulating the ConfigFS API. It also includes some bash tools for automatically creating and monitoring USB Gadgets</li></ul></li><li><a href="https://github.com/linux-usb-gadgets/gt">gt (Gadget-tool)</a><ul><li>A command line tool for setting USB gadgets with ConfigFS</li></ul></li><li><a href="https://github.com/linux-usb-gadgets/ptp-gadget">ptp-gadget</a><ul><li>An implementation of the PTP protocol (the predecessor for MTP) for Linux</li></ul></li><li>(old org&#x2F;repo) <a href="https://github.com/libusbg/libusbg">libusbg&#x2F;libusbg</a><ul><li>the original version of libusbg</li></ul></li></ul></li><li><a href="https://github.com/litui/gadgeteer">litui&#x2F;gadgeteer</a><ul><li>A JSON daemon for controlling ConfigFS</li></ul></li><li><a href="https://github.com/luka177/mmc-to-usb">luka177&#x2F;mmc-to-usb</a><ul><li>Allows you to control an emmc storage device from another PC, including allowing you to partition it.</li></ul></li><li><a href="https://github.com/tylerwhall/configfs-regulator">tylerwhall&#x2F;configfs-regulator</a><ul><li>A ConfigFS-based Voltage Regulator Driver</li></ul></li><li><a href="https://github.com/kopasiak/simple_usb_chat">kopasiak&#x2F;simple_usb_chat</a><ul><li>A simple chat program over FunctionFS</li></ul></li><li><a href="https://github.com/jghubert/FunctionFSTester">jghubert&#x2F;FunctionFSTester</a><ul><li>A repository for testing FunctionFS features on both the remote host and peripheral device. Have been ignoring most of these kinds of repos, but added this one, since it included tests to be run on the remote host.</li></ul></li><li><a href="https://github.com/vladrobot/Raspberry-GadgetFS/tree/master">vladrobot&#x2F;Raspberry-GadgetFS</a><ul><li>A wrapper for GadgetFS tailored to the raspberry pi that provides HID spoofing as well as USB mass storage via Python</li></ul></li><li>PTP&#x2F;MTP protocol<ul><li>linux-usb-gadgets&#x2F;ptp-gadget (see above)</li><li>✨✨ <a href="https://github.com/viveris/uMTP-Responder">viveris&#x2F;uMTP-Responder</a><ul><li>An implementation of a MTP responder for Linux. README has a decent list of Single Board Computers with OTG&#x2F;Dual Role USB ports</li></ul></li></ul></li><li><em>Controller Emulators&#x2F;Adapters</em><ul><li><a href="https://github.com/Poohl/gadfetfs-Switch-Fightstick">Poohl&#x2F;gadfetfs-Switch-Fightstick</a><ul><li>Wii Remote Emulator&#x2F;Adapter for the Nintendo Switch</li></ul></li><li><a href="https://github.com/dogtopus/ffsds4">dogtopus&#x2F;ffsds4</a><ul><li>A PS4 Controller Emulator over FunctionFS</li></ul></li><li><a href="https://github.com/Frederic98/GadgetDeck">Frederic98&#x2F;GadgetDeck</a><ul><li>A controller emulator using a steam deck as a gadget device over ConfigFS</li></ul></li></ul></li><li><em>Android USB Tools</em><ul><li><a href="https://github.com/tejado/android-usb-gadget">tejado&#x2F;android-usb-gadget</a><ul><li>Rooted Android tool used to spoof what your phone appears as to your computer. Really good tool for visually showing you what the ConfigFS&#x2F;FunctionFS is capable of.</li></ul></li><li><a href="https://github.com/tejado/Authorizer">tejado&#x2F;Authorizer</a><ul><li>Secure Password Store that can autotype passwords over FunctionFS</li></ul></li></ul></li><li><em>Hacking, Sniffing, and Security:</em><ul><li><a href="https://github.com/threadexio/anducky">threadexio&#x2F;anducky</a><ul><li>An implementation of Hak5’s Rubber Ducky on Android</li></ul></li><li><a href="https://github.com/ehabhussein/AutoGadgetFS">ehabhussein&#x2F;AutoGadgetFS</a><ul><li>Very comprehensive USB security, sniffing, and analyzing tool that can be used to perform USB man-in-the-middle attacks built on ConfigFS</li></ul></li><li><a href="https://github.com/greatscottgadgets/Facedancer">greatscottgadgets&#x2F;Facedancer</a><ul><li>Another USB man-in-the-middle-ware built on GadgetFS</li><li><a href="https://github.com/usb-tools/USBProxy-legacy">usb-tools&#x2F;USBProxy-legacy</a> (The original)</li></ul></li><li><a href="https://github.com/Iskuri/Usb-Over-TCP">Iskuri&#x2F;Usb-Over-TCP</a><ul><li>A USB over TCP implementation built on GadgetFS</li></ul></li></ul></li><li><em>Simple HID Spoofing Scripts:</em><ul><li><a href="https://github.com/linkjumper/configfs">linkjumper&#x2F;configfs</a><ul><li>A simple shell script for creating a HID device via ConfigFS</li></ul></li><li><a href="https://github.com/qlyoung/keyboard-gadget">qlyoung&#x2F;keyboard-gadget</a><ul><li>Another simple shell script for creating a HID device via ConfigFS</li></ul></li><li><a href="https://github.com/karacanil/linux-mouse-gadget">karacanil&#x2F;linux-mouse-gadget</a><ul><li>A small mouse spoofer</li></ul></li></ul></li><li><em>Non-HID Spoofing Tools:</em><ul><li><a href="https://github.com/oandrew/ipod-gadget">oandrew&#x2F;ipod-gadget</a><ul><li>A tool to spoof your raspberry pi or beaglebone black as an iPod for streaming audio and use with iPod accessories.</li></ul></li><li><a href="https://github.com/du33169/usb-gadget-utils">du33169&#x2F;usb-gadget-utils</a><ul><li>A small, but comprehensive HID spoofing kit. Includes a toolkit for extracting and parsing HID data from real hardware for use with ConfigFS.</li></ul></li></ul></li><li><em>ConfigFS Device Tree Overlay Patches (not yet part of the linux kernel):</em><ul><li><a href="https://github.com/ikwzm/dtbocfg">ikwzm&#x2F;dtbocfg</a><ul><li>A custom implementation of a “ConfigFS overlay interface.” This is not part of the Linux Kernel, but independently developed “patch”</li></ul></li><li><a href="https://github.com/Xilinx/linux-xlnx">Xilinx&#x2F;linux-xlnx</a><ul><li>A similar solution, but as an actually patched kernel</li></ul></li><li><a href="https://github.com/digitalloggers/linux-custom-gpio-patches">digitalloggers&#x2F;linux-custom-gpio-patches</a><ul><li>A ConfigFS Device Tree Overlay patch specifically tailored to Raspberry Pi GPIO headers</li></ul></li></ul></li><li>✨✨ <em>Programming Libraries for ConfigFS&#x2F;FunctionFS:</em><ul><li>libusbg&#x2F;libusbgx (see above)<ul><li>ConfigFS for C</li></ul></li><li><a href="https://github.com/ueno/libusb-gadget">ueno&#x2F;libusb-gadget</a><ul><li>GadgetFS for C</li></ul></li><li><a href="https://github.com/xstevens/usbg.rs">xstevens&#x2F;usbg.rs</a><ul><li>ConfigFS for Rust</li></ul></li><li><a href="https://github.com/R030t1/linux-usb-functionfs-sys">R030t1&#x2F;linux-usb-functionfs-sys</a><ul><li>Crude FunctionFS for Rust</li></ul></li><li><a href="https://github.com/AlinaNova21/node-gadget">AlinaNova21&#x2F;node-gadget</a><ul><li>ConfigFS for Node.JS</li></ul></li><li><a href="https://github.com/mgalka/pygadget">mgalka&#x2F;pygadget</a><ul><li>ConfigFS for Python</li></ul></li><li><a href="https://github.com/vpelletier/python-functionfs">vpelletier&#x2F;python-functionfs</a><ul><li>FunctionFS for Python</li></ul></li><li><a href="https://github.com/google/go-configfs-tsm">google&#x2F;go-configfs-tsm</a><ul><li>ConfigFS (and other things) for Go - NOTE that this one is written by Google</li></ul></li></ul></li></ul><p>This list is mostly all inclusive:</p><ul><li>It contains the majority of repositories with noteworthy ConfigFS&#x2F;FunctionFS features.</li><li>Most of the ignored repositories were ones that either:<ul><li>had little documentation&#x2F;were definitively unmaintained</li><li>were just some playground or test repos for learning&#x2F;future development</li></ul></li></ul></blockquote><h2 id="gadget-configfs-源码分析"><a href="#gadget-configfs-源码分析" class="headerlink" title="gadget configfs 源码分析"></a>gadget configfs 源码分析</h2><blockquote><p><a href="https://elixir.bootlin.com/linux/v5.10.186/source/drivers/usb/gadget/configfs.c">https://elixir.bootlin.com/linux/v5.10.186/source/drivers/usb/gadget/configfs.c</a><br><a href="Linux-configfs#%E7%A4%BA%E4%BE%8B">Linux-configfs#示例)</a></p></blockquote><h3 id="顶层-subsystem"><a href="#顶层-subsystem" class="headerlink" title="顶层 subsystem"></a>顶层 subsystem</h3><p>初始化的时候注册了一个名为 <code>usb_gadget</code> 的 subsystem。所以，insmod 该模块之后，会得到 <code>/configfs/usb_gadget</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> <span class="title">gadget_subsys</span> =</span> &#123;</span><br><span class="line">.su_group = &#123;</span><br><span class="line">.cg_item = &#123;</span><br><span class="line">.ci_namebuf = <span class="string">&quot;usb_gadget&quot;</span>,</span><br><span class="line">.ci_type = &amp;gadgets_type,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">.su_mutex = __MUTEX_INITIALIZER(gadget_subsys.su_mutex),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">gadget_cfs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">config_group_init(&amp;gadget_subsys.su_group);</span><br><span class="line"></span><br><span class="line">ret = configfs_register_subsystem(&amp;gadget_subsys);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">module_init(gadget_cfs_init);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">gadget_cfs_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">configfs_unregister_subsystem(&amp;gadget_subsys);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(gadget_cfs_exit);</span><br></pre></td></tr></table></figure><p>该 <code>gadgets_type</code> 中没有 <code>.ct_attrs</code>，所以没有任何属性，即 <code>/configfs/usb_gadget</code> 目录为空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> <span class="title">gadgets_type</span> =</span> &#123;</span><br><span class="line">.ct_group_ops   = &amp;gadgets_ops,</span><br><span class="line">.ct_owner       = THIS_MODULE,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>gadgets_ops</code> 指定了 <code>.make_group</code>，所以 <code>mkdir</code> 会创建子项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static struct configfs_group_operations gadgets_ops = &#123;</span><br><span class="line">.make_group     = &amp;gadgets_make,</span><br><span class="line">.drop_item      = &amp;gadgets_drop,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比如 <code>mkdir cvitek</code> 会创建 <code>/configfs/usb_gadget/cvitek</code>，并同时为 cvitek 自动创建 <code>functions</code>, <code>configs</code>, <code>strings</code> 和 <code>os_desc</code> 4 个子项。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> config_group *<span class="title function_">gadgets_make</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> config_group *group,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gadget_info</span> *<span class="title">gi</span>;</span></span><br><span class="line"></span><br><span class="line">gi = kzalloc(<span class="keyword">sizeof</span>(*gi), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!gi)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 `/configfs/usb_gadget/cvitek`</span></span><br><span class="line">config_group_init_type_name(&amp;gi-&gt;group, name, &amp;gadget_root_type);</span><br><span class="line"></span><br><span class="line">config_group_init_type_name(&amp;gi-&gt;functions_group, <span class="string">&quot;functions&quot;</span>,</span><br><span class="line">&amp;functions_type);</span><br><span class="line">configfs_add_default_group(&amp;gi-&gt;functions_group, &amp;gi-&gt;group);</span><br><span class="line"></span><br><span class="line">config_group_init_type_name(&amp;gi-&gt;configs_group, <span class="string">&quot;configs&quot;</span>,</span><br><span class="line">&amp;config_desc_type);</span><br><span class="line">configfs_add_default_group(&amp;gi-&gt;configs_group, &amp;gi-&gt;group);</span><br><span class="line"></span><br><span class="line">config_group_init_type_name(&amp;gi-&gt;strings_group, <span class="string">&quot;strings&quot;</span>,</span><br><span class="line">&amp;gadget_strings_strings_type);</span><br><span class="line">configfs_add_default_group(&amp;gi-&gt;strings_group, &amp;gi-&gt;group);</span><br><span class="line"></span><br><span class="line">config_group_init_type_name(&amp;gi-&gt;os_desc_group, <span class="string">&quot;os_desc&quot;</span>,</span><br><span class="line">&amp;os_desc_type);</span><br><span class="line">configfs_add_default_group(&amp;gi-&gt;os_desc_group, &amp;gi-&gt;group);</span><br><span class="line"></span><br><span class="line">gi-&gt;composite.bind = configfs_do_nothing;</span><br><span class="line">gi-&gt;composite.unbind = configfs_do_nothing;</span><br><span class="line">gi-&gt;composite.suspend = <span class="literal">NULL</span>;</span><br><span class="line">gi-&gt;composite.resume = <span class="literal">NULL</span>;</span><br><span class="line">gi-&gt;composite.max_speed = USB_SPEED_SUPER;</span><br><span class="line"></span><br><span class="line">spin_lock_init(&amp;gi-&gt;spinlock);</span><br><span class="line">mutex_init(&amp;gi-&gt;lock);</span><br><span class="line">INIT_LIST_HEAD(&amp;gi-&gt;string_list);</span><br><span class="line">INIT_LIST_HEAD(&amp;gi-&gt;available_func);</span><br><span class="line"></span><br><span class="line">composite_init_dev(&amp;gi-&gt;cdev);</span><br><span class="line">gi-&gt;cdev.desc.bLength = USB_DT_DEVICE_SIZE;</span><br><span class="line">gi-&gt;cdev.desc.bDescriptorType = USB_DT_DEVICE;</span><br><span class="line">gi-&gt;cdev.desc.bcdDevice = cpu_to_le16(get_default_bcdDevice());</span><br><span class="line"></span><br><span class="line">gi-&gt;composite.gadget_driver = configfs_driver_template;</span><br><span class="line"></span><br><span class="line">gi-&gt;composite.gadget_driver.function = kstrdup(name, GFP_KERNEL);</span><br><span class="line">gi-&gt;composite.name = gi-&gt;composite.gadget_driver.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!gi-&gt;composite.gadget_driver.function)</span><br><span class="line"><span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;gi-&gt;group;</span><br><span class="line">err:</span><br><span class="line">kfree(gi);</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="gadget-root-type"><a href="#gadget-root-type" class="headerlink" title="gadget_root_type"></a>gadget_root_type</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> <span class="title">gadget_root_type</span> =</span> &#123;</span><br><span class="line">.ct_item_ops= &amp;gadget_root_item_ops,</span><br><span class="line">.ct_attrs= gadget_root_attrs,</span><br><span class="line">.ct_owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_item_operations</span> <span class="title">gadget_root_item_ops</span> =</span> &#123;</span><br><span class="line">.release                = gadget_info_attr_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>没有定义 <code>.make_item/.make_group</code>，所以无法在 <code>/configfs/usb_gadget/cvitek</code> 目录中通过 <code>mkdir</code> 创建子项。</p><p>它有 10 个可读写的属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CONFIGFS_ATTR(gadget_dev_desc_, bDeviceClass);</span><br><span class="line">CONFIGFS_ATTR(gadget_dev_desc_, bDeviceSubClass);</span><br><span class="line">CONFIGFS_ATTR(gadget_dev_desc_, bDeviceProtocol);</span><br><span class="line">CONFIGFS_ATTR(gadget_dev_desc_, bMaxPacketSize0);</span><br><span class="line">CONFIGFS_ATTR(gadget_dev_desc_, idVendor);</span><br><span class="line">CONFIGFS_ATTR(gadget_dev_desc_, idProduct);</span><br><span class="line">CONFIGFS_ATTR(gadget_dev_desc_, bcdDevice);</span><br><span class="line">CONFIGFS_ATTR(gadget_dev_desc_, bcdUSB);</span><br><span class="line">CONFIGFS_ATTR(gadget_dev_desc_, UDC);</span><br><span class="line">CONFIGFS_ATTR(gadget_dev_desc_, max_speed);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span> *<span class="title">gadget_root_attrs</span>[] =</span> &#123;</span><br><span class="line">&amp;gadget_dev_desc_attr_bDeviceClass,</span><br><span class="line">&amp;gadget_dev_desc_attr_bDeviceSubClass,</span><br><span class="line">&amp;gadget_dev_desc_attr_bDeviceProtocol,</span><br><span class="line">&amp;gadget_dev_desc_attr_bMaxPacketSize0,</span><br><span class="line">&amp;gadget_dev_desc_attr_idVendor,</span><br><span class="line">&amp;gadget_dev_desc_attr_idProduct,</span><br><span class="line">&amp;gadget_dev_desc_attr_bcdDevice,</span><br><span class="line">&amp;gadget_dev_desc_attr_bcdUSB,</span><br><span class="line">&amp;gadget_dev_desc_attr_UDC,</span><br><span class="line">&amp;gadget_dev_desc_attr_max_speed,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="functions-type"><a href="#functions-type" class="headerlink" title="functions_type"></a>functions_type</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> <span class="title">functions_type</span> =</span> &#123;</span><br><span class="line">.ct_group_ops   = &amp;functions_ops,</span><br><span class="line">.ct_owner       = THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_group_operations</span> <span class="title">functions_ops</span> =</span> &#123;</span><br><span class="line">.make_group     = &amp;function_make,</span><br><span class="line">.drop_item      = &amp;function_drop,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>💥💥💥💥在 configfs 中，有项目item和组group，均表示为目录。项目和组的区别在于组可以包含其他组💥💥💥</p></blockquote><p>没有属性，所以一开始 <code>/configfs/usb_gadget/cvitek/functions</code> 目录为空。但定义了 <code>make_group</code>，所以可以创建组。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="Linux-configfs.md">Linux-configfs.md</a></li><li><a href="Linux-USBmtp.md">Linux-USBmtp.md</a></li><li><a href="https://elixir.bootlin.com/linux/v5.10.186/source/Documentation/ABI/testing">https://elixir.bootlin.com/linux/v5.10.186/source/Documentation/ABI/testing</a></li><li><a href="https://elixir.bootlin.com/linux/v5.10.186/source/Documentation/ABI/testing/configfs-usb-gadget">https://elixir.bootlin.com/linux/v5.10.186/source/Documentation/ABI/testing/configfs-usb-gadget</a></li><li><a href="http://www.spinics.net/lists/linux-usb/msg76388.html">http://www.spinics.net/lists/linux-usb/msg76388.html</a></li><li><a href="https://www.kernel.org/doc/html/v6.1/usb/gadget-testing.html">https://www.kernel.org/doc/html/v6.1/usb/gadget-testing.html</a></li><li><a href="https://www.kernel.org/doc/html/v6.1/usb/raw-gadget.html">https://www.kernel.org/doc/html/v6.1/usb/raw-gadget.html</a></li><li><a href="https://www.kernel.org/doc/html/v6.1/usb/functionfs.html">https://www.kernel.org/doc/html/v6.1/usb/functionfs.html</a></li><li><a href="https://wowothink.com/6a85234b/">usb gadget configfs 原理</a></li><li><a href="https://wowothink.com/a64c6a27/">usb gadget configfs 验证</a></li><li><a href="https://wowothink.com/440dc3d9/">usb gadget configfs 翻译</a></li><li><a href="https://wowothink.com/ffcaead/">Android usb gadget类型</a></li><li><a href="https://wowothink.com/588ebc22/">ACM&amp;ECM&amp;NCM&amp;EEM&amp;RNDIS&amp;RmNet介绍</a></li><li><a href="https://wowothink.com/488cc6d0/">Linux USB Test Mode</a></li><li><a href="https://wowothink.com/69b1c932/">USB2.0理论传输速度和实际传输速度</a></li><li><a href="https://wowothink.com/68203a0/">Linux驱动中配置支持特定USB HUB</a></li><li><a href="https://wowothink.com/892013c5/">配置USB Host和USB Device full-speed工作</a></li><li><a href="https://wowothink.com/e0007988/">Linux测试U盘读写速度</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> USB </tag>
            
            <tag> configfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux configfs</title>
      <link href="/2024/09/22/Linux-configfs/"/>
      <url>/2024/09/22/Linux-configfs/</url>
      
        <content type="html"><![CDATA[<blockquote><p>translate from <a href="https://www.kernel.org/doc/Documentation/filesystems/configfs/configfs.txt">https://www.kernel.org/doc/Documentation/filesystems/configfs/configfs.txt</a></p></blockquote><hr><h2 id="configfs-用户空间驱动的内核对象配置"><a href="#configfs-用户空间驱动的内核对象配置" class="headerlink" title="configfs - 用户空间驱动的内核对象配置"></a>configfs - 用户空间驱动的内核对象配置</h2><p>乔尔·贝克尔 <a href="mailto:&#x6a;&#x6f;&#x65;&#108;&#x2e;&#x62;&#x65;&#x63;&#x6b;&#101;&#114;&#64;&#x6f;&#114;&#x61;&#x63;&#108;&#101;&#x2e;&#x63;&#111;&#109;">&#x6a;&#x6f;&#x65;&#108;&#x2e;&#x62;&#x65;&#x63;&#x6b;&#101;&#114;&#64;&#x6f;&#114;&#x61;&#x63;&#108;&#101;&#x2e;&#x63;&#111;&#109;</a></p><p>更新日期：2005年3月31日</p><p>版权所有 (c) 2005 Oracle Corporation,<br>乔尔·贝克尔 <a href="mailto:&#x6a;&#x6f;&#x65;&#x6c;&#46;&#x62;&#x65;&#x63;&#107;&#x65;&#114;&#x40;&#111;&#x72;&#x61;&#99;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;">&#x6a;&#x6f;&#x65;&#x6c;&#46;&#x62;&#x65;&#x63;&#107;&#x65;&#114;&#x40;&#111;&#x72;&#x61;&#99;&#108;&#101;&#x2e;&#99;&#x6f;&#x6d;</a></p><hr><h2 id="什么是-configfs？"><a href="#什么是-configfs？" class="headerlink" title="什么是 configfs？"></a>什么是 configfs？</h2><p><code>configfs</code> 是基于内存的文件系统，它提供与 <code>sysfs</code> 相反的功能。<code>sysfs</code> 提供的是内核对象的文件系统视图，而 <code>configfs</code> 则是内核对象或 <code>config_items</code> 的文件系统管理器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">configfs is a ram-based filesystem that provides the converse of</span><br><span class="line">sysfs&#x27;s functionality. Where sysfs is a filesystem-based view of</span><br><span class="line">kernel objects, configfs is a filesystem-based manager of kernel</span><br><span class="line">objects, or config_items.</span><br></pre></td></tr></table></figure><blockquote><p><strong>view VS manager</strong> 的区别。</p></blockquote><p>在 <code>sysfs</code> 中，当一个对象在内核中创建时（例如，发现一个设备），它会被注册到 <code>sysfs</code> 中。它的属性会出现在 <code>sysfs</code> 中，允许用户空间通过 <code>readdir(3)</code>&#x2F;<code>read(2)</code> 读取这些属性。某些属性也许可以通过 <code>write(2)</code> 进行修改。重要的是，内核控制着这些对象的生命周期，<code>sysfs</code> 仅仅是这些操作的一个窗口。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">With sysfs, an object is created in kernel (for example, when a device</span><br><span class="line">is discovered) and it is registered with sysfs. Its attributes then</span><br><span class="line">appear in sysfs, allowing userspace to read the attributes via</span><br><span class="line">readdir(3)/read(2). It may allow some attributes to be modified via</span><br><span class="line">write(2). The important point is that the object is created and</span><br><span class="line">destroyed in kernel, the kernel controls the lifecycle of the sysfs</span><br><span class="line">representation, and sysfs is merely a window on all this.</span><br></pre></td></tr></table></figure><p>而 <code>configfs</code> 的 <code>config_item</code> 是通过用户空间的显式操作创建的：使用 <code>mkdir(2)</code>。它通过 <code>rmdir(2)</code> 删除。属性在 <code>mkdir(2)</code> 操作时出现，可以通过 <code>read(2)</code> 和 <code>write(2)</code> 进行读取和修改。与 <code>sysfs</code> 类似，<code>readdir(3)</code> 可以查询项目和&#x2F;或属性的列表，<code>symlink(2)</code> 可以用于将项目分组。与 <code>sysfs</code> 不同的是，表示的<strong>生命周期完全由用户空间控制</strong>，内核模块必须对此作出响应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A configfs config_item is created via an explicit userspace operation:</span><br><span class="line">mkdir(2). It is destroyed via rmdir(2). The attributes appear at</span><br><span class="line">mkdir(2) time, and can be read or modified via read(2) and write(2).</span><br><span class="line">As with sysfs, readdir(3) queries the list of items and/or attributes.</span><br><span class="line">symlink(2) can be used to group items together. Unlike sysfs, the</span><br><span class="line">lifetime of the representation is completely driven by userspace. The</span><br><span class="line">kernel modules backing the items must respond to this.</span><br></pre></td></tr></table></figure><p><code>sysfs</code> 和 <code>configfs</code> 可以并且应该共存于同一系统上，它们互不替代。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Both sysfs and configfs can and should exist together on the same</span><br><span class="line">system. One is not a replacement for the other.</span><br></pre></td></tr></table></figure><hr><h2 id="使用-configfs"><a href="#使用-configfs" class="headerlink" title="使用 configfs"></a>使用 configfs</h2><p><code>configfs</code> 可以作为模块编译，也可以编译到内核中。可以通过以下方式访问它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t configfs none /config</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">configfs can be compiled as a module or into the kernel. You can access</span><br><span class="line">it by doing</span><br><span class="line"></span><br><span class="line">mount -t configfs none /config</span><br></pre></td></tr></table></figure><p>除非加载了客户端模块，否则 <code>configfs</code> 树是空的。这些模块会将它们的项目类型注册为 <code>configfs</code> 的子系统。一旦客户端子系统被加载，它会作为 <code>/config</code> 下的一个（或多个）子目录出现。和 <code>sysfs</code> 一样，<code>configfs</code> 树始终存在，无论是否挂载到 <code>/config</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The configfs tree will be empty unless client modules are also loaded.</span><br><span class="line">These are modules that register their item types with configfs as</span><br><span class="line">subsystems. Once a client subsystem is loaded, it will appear as a</span><br><span class="line">subdirectory (or more than one) under /config. Like sysfs, the</span><br><span class="line">configfs tree is always there, whether mounted on /config or not.</span><br></pre></td></tr></table></figure><blockquote><p>如果打开了某个子模块的 configfs 配置，在 mount configfs 之后，就能在对应的目录看到。比如 <code>CONFIG_USB_CONFIGFS=y</code> 开启之后，<code>/config/usb</code> 就会出现。</p></blockquote><p>一个项目可以通过 <code>mkdir(2)</code> 创建。项目的属性也会在此时出现。可以通过 <code>readdir(3)</code> 确定属性，<code>read(2)</code> 查询默认值，<code>write(2)</code> 存储新值。不要在一个属性文件中混合多个属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">An item is created via mkdir(2). The item&#x27;s attributes will also</span><br><span class="line">appear at this time. readdir(3) can determine what the attributes are,</span><br><span class="line">read(2) can query their default values, and write(2) can store new</span><br><span class="line">values. Don&#x27;t mix more than one attribute in one attribute file.</span><br></pre></td></tr></table></figure><blockquote><p>比如：<a href="./Linux-USBmtp.md#2-%E5%88%9B%E5%BB%BA%E5%A4%8D%E5%90%88%E8%AE%BE%E5%A4%87">Linux-USBmtp</a></p></blockquote><p><code>configfs</code> 属性有两种类型：</p><ol><li>正常属性，与 <code>sysfs</code> 属性类似，是小型 ASCII 文本文件，最大大小为一页（<code>PAGE_SIZE</code>，在 i386 上为 4096 字节）。每个文件中最好只包含一个值，并且遵循 <code>sysfs</code> 的相同注意事项。<code>configfs</code> 期望 <code>write(2)</code> 在一次操作中写入整个缓冲区。当写入正常的 <code>configfs</code> 属性时，<strong>用户空间进程应首先读取整个文件，修改他们想要更改的部分，然后写回整个缓冲区</strong>。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">There are two types of configfs attributes:</span><br><span class="line"></span><br><span class="line">* Normal attributes, which similar to sysfs attributes, are small ASCII text</span><br><span class="line">files, with a maximum size of one page (PAGE_SIZE, 4096 on i386). Preferably</span><br><span class="line">only one value per file should be used, and the same caveats from sysfs apply.</span><br><span class="line">Configfs expects write(2) to store the entire buffer at once. When writing to</span><br><span class="line">normal configfs attributes, userspace processes should first read the entire</span><br><span class="line">file, modify the portions they wish to change, and then write the entire</span><br><span class="line">buffer back.</span><br></pre></td></tr></table></figure><ol start="2"><li>二进制属性，与 <code>sysfs</code> 二进制属性类似，但语义上有一些细微变化。<code>PAGE_SIZE</code> 限制不适用，但整个二进制项必须适合单个内核 <code>vmalloc</code> 分配的缓冲区。来自用户空间的 <code>write(2)</code> 调用是缓冲的，属性的 <code>write_bin_attribute</code> 方法将在最终关闭时被调用，因此用户空间必须检查 <code>close(2)</code> 的返回码以验证操作是否成功完成。为了防止恶意用户导致内核内存不足，每个二进制属性都有最大缓冲区大小限制。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* Binary attributes, which are somewhat similar to sysfs binary attributes,</span><br><span class="line">but with a few slight changes to semantics. The PAGE_SIZE limitation does not</span><br><span class="line">apply, but the whole binary item must fit in single kernel vmalloc&#x27;ed buffer.</span><br><span class="line">The write(2) calls from user space are buffered, and the attributes&#x27;</span><br><span class="line">write_bin_attribute method will be invoked on the final close, therefore it is</span><br><span class="line">imperative for user-space to check the return code of close(2) in order to</span><br><span class="line">verify that the operation finished successfully.</span><br><span class="line">To avoid a malicious user OOMing the kernel, there&#x27;s a per-binary attribute</span><br><span class="line">maximum buffer value.</span><br></pre></td></tr></table></figure><p>当需要销毁一个项目时，使用 <code>rmdir(2)</code> 删除它。如果有其他项目通过 <code>symlink(2)</code> 链接到该项目，它是不能被删除的。链接可以通过 <code>unlink(2)</code> 删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">When an item needs to be destroyed, remove it with rmdir(2). An</span><br><span class="line">item cannot be destroyed if any other item has a link to it (via</span><br><span class="line">symlink(2)). Links can be removed via unlink(2).</span><br></pre></td></tr></table></figure><hr><h2 id="配置-FakeNBD-一个例子"><a href="#配置-FakeNBD-一个例子" class="headerlink" title="配置 FakeNBD: 一个例子"></a>配置 FakeNBD: 一个例子</h2><p>假设有一个网络块设备（NBD）驱动程序允许您访问远程块设备，称之为 FakeNBD。FakeNBD 使用 <code>configfs</code> 进行配置。显然，会有一个专门的程序供系统管理员使用来配置 FakeNBD，但该程序必须通过某种方式与驱动程序通信。这时 <code>configfs</code> 就派上用场了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Configuring FakeNBD: an Example]</span><br><span class="line"></span><br><span class="line">Imagine there&#x27;s a Network Block Device (NBD) driver that allows you to</span><br><span class="line">access remote block devices. Call it FakeNBD. FakeNBD uses configfs</span><br><span class="line">for its configuration. Obviously, there will be a nice program that</span><br><span class="line">sysadmins use to configure FakeNBD, but somehow that program has to tell</span><br><span class="line">the driver about it. Here&#x27;s where configfs comes in.</span><br></pre></td></tr></table></figure><p>当加载 FakeNBD 驱动程序时，它会注册到 <code>configfs</code>。使用 <code>readdir(3)</code> 可以看到这一点：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls /config</span></span><br><span class="line">fakenbd</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">When the FakeNBD driver is loaded, it registers itself with configfs.</span><br><span class="line">readdir(3) sees this just fine:</span><br><span class="line"></span><br><span class="line"># ls /config</span><br><span class="line">fakenbd</span><br></pre></td></tr></table></figure><p>可以使用 <code>mkdir(2)</code> 创建一个 fakenbd 连接。名称是任意的，但该工具可能会使用这个名称。也许它是一个 <code>uuid</code> 或磁盘名称：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir /config/fakenbd/disk1</span></span><br><span class="line"><span class="comment"># ls /config/fakenbd/disk1</span></span><br><span class="line">target device rw</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A fakenbd connection can be created with mkdir(2). The name is</span><br><span class="line">arbitrary, but likely the tool will make some use of the name. Perhaps</span><br><span class="line">it is a uuid or a disk name:</span><br><span class="line"></span><br><span class="line"># mkdir /config/fakenbd/disk1</span><br><span class="line"># ls /config/fakenbd/disk1</span><br><span class="line">target device rw</span><br></pre></td></tr></table></figure><p><code>target</code> 属性包含 FakeNBD 将连接的服务器的 IP 地址。<code>device</code> 属性是服务器上的设备。显然，<code>rw</code> 属性决定了连接是只读还是读写。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 10.0.0.1 &gt; /config/fakenbd/disk1/target</span></span><br><span class="line"><span class="comment"># echo /dev/sda1 &gt; /config/fakenbd/disk1/device</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /config/fakenbd/disk1/rw</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The target attribute contains the IP address of the server FakeNBD will</span><br><span class="line">connect to. The device attribute is the device on the server.</span><br><span class="line">Predictably, the rw attribute determines whether the connection is</span><br><span class="line">read-only or read-write.</span><br><span class="line"></span><br><span class="line"># echo 10.0.0.1 &gt; /config/fakenbd/disk1/target</span><br><span class="line"># echo /dev/sda1 &gt; /config/fakenbd/disk1/device</span><br><span class="line"># echo 1 &gt; /config/fakenbd/disk1/rw</span><br></pre></td></tr></table></figure><p>就是这样，仅此而已。现在，设备已配置好，并通过 shell 完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">That&#x27;s it. That&#x27;s all there is. Now the device is configured, via the</span><br><span class="line">shell no less.</span><br></pre></td></tr></table></figure><hr><h2 id="使用-configfs-编码"><a href="#使用-configfs-编码" class="headerlink" title="使用 configfs 编码"></a>使用 configfs 编码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Coding With configfs]</span><br></pre></td></tr></table></figure><p>在 <code>configfs</code> 中，每个对象都是一个 <code>config_item</code>。一个 <code>config_item</code> 反映了子系统中的一个对象。它具有与该对象的值匹配的属性。<code>configfs</code> 处理该对象及其属性的文件系统表示形式，允许子系统忽略除基本 <code>show/store</code> 交互以外的所有操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Every object in configfs is a config_item. A config_item reflects an</span><br><span class="line">object in the subsystem. It has attributes that match values on that</span><br><span class="line">object. configfs handles the filesystem representation of that object</span><br><span class="line">and its attributes, allowing the subsystem to ignore all but the</span><br><span class="line">basic show/store interaction.</span><br></pre></td></tr></table></figure><p>项目是在 <code>config_group</code> 中创建和销毁的。<code>group</code> 是一组具有相同属性和操作的项目。项目通过 <code>mkdir(2)</code> 创建，通过 <code>rmdir(2)</code> 移除，但 <code>configfs</code> 处理这些操作。<code>group</code> 有一组操作来执行这些任务。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Items are created and destroyed inside a config_group. A group is a</span><br><span class="line">collection of items that share the same attributes and operations.</span><br><span class="line">Items are created by mkdir(2) and removed by rmdir(2), but configfs</span><br><span class="line">handles that. The group has a set of operations to perform these tasks.</span><br></pre></td></tr></table></figure><p>子系统是客户端模块的顶层。在初始化期间，客户端模块将子系统注册到 <code>configfs</code>，子系统将作为 <code>configfs</code> 文件系统顶部的一个目录出现。子系统也是一个 <code>config_group</code>，并且可以执行 <code>config_group</code> 能做的所有操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A subsystem is the top level of a client module. During initialization,</span><br><span class="line">the client module registers the subsystem with configfs, the subsystem</span><br><span class="line">appears as a directory at the top of the configfs filesystem. A</span><br><span class="line">subsystem is also a config_group, and can do everything a config_group</span><br><span class="line">can.</span><br></pre></td></tr></table></figure><blockquote><p><code>USB CONFIGFS</code> 就是一个 <code>config_group/subsystem</code> 。</p></blockquote><hr><h3 id="struct-config-item"><a href="#struct-config-item" class="headerlink" title="struct config_item"></a><code>struct config_item</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_item</span> &#123;</span></span><br><span class="line"><span class="type">char</span>                    *ci_name;</span><br><span class="line"><span class="type">char</span>                    ci_namebuf[UOBJ_NAME_LEN];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kref</span>             <span class="title">ci_kref</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">ci_entry</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_item</span>      *<span class="title">ci_parent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_group</span>     *<span class="title">ci_group</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> *<span class="title">ci_type</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>           *<span class="title">ci_dentry</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">config_item_init</span><span class="params">(<span class="keyword">struct</span> config_item *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">config_item_init_type_name</span><span class="params">(<span class="keyword">struct</span> config_item *,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> config_item_type *type)</span>;</span><br><span class="line"><span class="keyword">struct</span> config_item *<span class="title function_">config_item_get</span><span class="params">(<span class="keyword">struct</span> config_item *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">config_item_put</span><span class="params">(<span class="keyword">struct</span> config_item *)</span>;</span><br></pre></td></tr></table></figure><p>一般来说，<code>struct config_item</code> 被嵌入到一个容器结构中，后者实际上表示子系统正在执行的操作。该结构中的 <code>config_item</code> 部分是对象与 <code>configfs</code> 交互的方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Generally, struct config_item is embedded in a container structure, a</span><br><span class="line">structure that actually represents what the subsystem is doing. The</span><br><span class="line">config_item portion of that structure is how the object interacts with</span><br><span class="line">configfs.</span><br></pre></td></tr></table></figure><p>无论是在源文件中静态定义还是由父 <code>config_group</code> 创建，都必须调用 <code>_init()</code> 函数之一对 <code>config_item</code> 进行初始化。这会初始化引用计数并设置相应的字段。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Whether statically defined in a source file or created by a parent</span><br><span class="line">config_group, a config_item must have one of the _init() functions</span><br><span class="line">called on it. This initializes the reference count and sets up the</span><br><span class="line">appropriate fields.</span><br></pre></td></tr></table></figure><hr><p>所有 <code>config_item</code> 的用户都应该通过 <code>config_item_get()</code> 获取其引用，并在使用完成后通过 <code>config_item_put()</code> 释放引用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">All users of a config_item should have a reference on it via</span><br><span class="line">config_item_get(), and drop the reference when they are done via</span><br><span class="line">config_item_put().</span><br></pre></td></tr></table></figure><p>仅仅有一个 <code>config_item</code>，它除了出现在 <code>configfs</code> 中以外，几乎不能做任何事情。通常子系统希望该项目显示和&#x2F;或存储属性，以及执行其他操作。为此，它需要一个类型。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">By itself, a config_item cannot do much more than appear in configfs.</span><br><span class="line">Usually a subsystem wants the item to display and/or store attributes,</span><br><span class="line">among other things. For that, it needs a type.</span><br></pre></td></tr></table></figure><hr><h3 id="struct-config-item-type"><a href="#struct-config-item-type" class="headerlink" title="struct config_item_type"></a><code>struct config_item_type</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_item_operations</span> &#123;</span></span><br><span class="line"><span class="type">void</span> (*release)(<span class="keyword">struct</span> config_item *);</span><br><span class="line"><span class="type">int</span> (*allow_link)(<span class="keyword">struct</span> config_item *src,</span><br><span class="line">  <span class="keyword">struct</span> config_item *target);</span><br><span class="line"><span class="type">void</span> (*drop_link)(<span class="keyword">struct</span> config_item *src,</span><br><span class="line"> <span class="keyword">struct</span> config_item *target);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span>                           *<span class="title">ct_owner</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_item_operations</span>         *<span class="title">ct_item_ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_group_operations</span>        *<span class="title">ct_group_ops</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span>               **<span class="title">ct_attrs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_bin_attribute</span>**<span class="title">ct_bin_attrs</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>config_item_type</code> 的最基本功能是定义可以对 <code>config_item</code> 执行的操作。所有动态分配的项目都需要提供 <code>ct_item_ops-&gt;release()</code> 方法。当 <code>config_item</code> 的引用计数降为零时，会调用此方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The most basic function of a config_item_type is to define what</span><br><span class="line">operations can be performed on a config_item. All items that have been</span><br><span class="line">allocated dynamically will need to provide the ct_item_ops-&gt;release()</span><br><span class="line">method. This method is called when the config_item&#x27;s reference count</span><br><span class="line">reaches zero.</span><br></pre></td></tr></table></figure><hr><h3 id="struct-configfs-attribute"><a href="#struct-configfs-attribute" class="headerlink" title="struct configfs_attribute"></a><code>struct configfs_attribute</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span> &#123;</span></span><br><span class="line"><span class="type">char</span>                    *ca_name;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module</span>           *<span class="title">ca_owner</span>;</span></span><br><span class="line"><span class="type">umode_t</span>                  ca_mode;</span><br><span class="line"><span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> config_item *, <span class="type">char</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> config_item *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当 <code>config_item</code> 希望某个属性作为文件出现在其 <code>configfs</code> 目录中时，它必须定义一个描述该属性的 <code>configfs_attribute</code>。然后它将该属性添加到 <code>config_item_type-&gt;ct_attrs</code> 的以 NULL 结尾的数组中。当项目出现在 <code>configfs</code> 中时，属性文件将以 <code>configfs_attribute-&gt;ca_name</code> 文件名出现。<code>configfs_attribute-&gt;ca_mode</code> 指定文件权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">When a config_item wants an attribute to appear as a file in the item&#x27;s</span><br><span class="line">configfs directory, it must define a configfs_attribute describing it.</span><br><span class="line">It then adds the attribute to the NULL-terminated array</span><br><span class="line">config_item_type-&gt;ct_attrs. When the item appears in configfs, the</span><br><span class="line">attribute file will appear with the configfs_attribute-&gt;ca_name</span><br><span class="line">filename. configfs_attribute-&gt;ca_mode specifies the file permissions.</span><br></pre></td></tr></table></figure><p>如果属性是可读的并且提供了 <code>-&gt;show</code> 方法，则每当用户空间请求读取该属性时，该方法将被调用。如果属性是可写的并且提供了 <code>-&gt;store</code> 方法，则每当用户空间请求写入该属性时，该方法将被调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">If an attribute is readable and provides a -&gt;show method, that method will</span><br><span class="line">be called whenever userspace asks for a read(2) on the attribute. If an</span><br><span class="line">attribute is writable and provides a -&gt;store method, that method will be</span><br><span class="line">be called whenever userspace asks for a write(2) on the attribute.</span><br></pre></td></tr></table></figure><hr><h3 id="struct-configfs-bin-attribute"><a href="#struct-configfs-bin-attribute" class="headerlink" title="struct configfs_bin_attribute"></a><code>struct configfs_bin_attribute</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_bin_attribute</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span><span class="title">cb_attr</span>;</span></span><br><span class="line"><span class="type">void</span>*cb_private;</span><br><span class="line"><span class="type">size_t</span>cb_max_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当需要一个二进制 blob 作为文件内容出现在项目的 <code>configfs</code> 目录中时，可以使用 <code>configfs_bin_attribute</code>。要实现这一点，将二进制属性添加到 <code>config_item_type-&gt;ct_bin_attrs</code> 的以 NULL 结尾的数组中，当项目出现在 <code>configfs</code> 中时，属性文件将以 <code>configfs_bin_attribute-&gt;cb_attr.ca_name</code> 文件名出现。<code>configfs_bin_attribute-&gt;cb_attr.ca_mode</code> 指定文件权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The binary attribute is used when the one needs to use a binary blob to</span><br><span class="line">appear as the contents of a file in the item&#x27;s configfs directory.</span><br><span class="line">To do so, add the binary attribute to the NULL-terminated array</span><br><span class="line">config_item_type-&gt;ct_bin_attrs, and the item appears in configfs, the</span><br><span class="line">attribute file will appear with the configfs_bin_attribute-&gt;cb_attr.ca_name</span><br><span class="line">filename. configfs_bin_attribute-&gt;cb_attr.ca_mode specifies the file</span><br><span class="line">permissions.</span><br></pre></td></tr></table></figure><p><code>cb_private</code> 成员是为驱动程序使用而提供的，而 <code>cb_max_size</code> 成员指定用于该二进制属性的最大 <code>vmalloc</code> 缓冲区大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The cb_private member is provided for use by the driver, while the</span><br><span class="line">cb_max_size member specifies the maximum amount of vmalloc buffer</span><br><span class="line">to be used.</span><br></pre></td></tr></table></figure><p>如果二进制属性是可读的，并且 <code>config_item</code> 提供了 <code>ct_item_ops-&gt;read_bin_attribute()</code> 方法，那么每当用户空间请求读取该属性时，将调用该方法。对于 <code>write(2)</code> 也是如此。读&#x2F;写操作是缓冲的，因此只会进行一次读&#x2F;写；属性本身不需要关心这一点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If binary attribute is readable and the config_item provides a</span><br><span class="line">ct_item_ops-&gt;read_bin_attribute() method, that method will be called</span><br><span class="line">whenever userspace asks for a read(2) on the attribute. The converse</span><br><span class="line">will happen for write(2). The reads/writes are buffered, so only a</span><br><span class="line">single read/write will occur; the attributes need not concern itself</span><br><span class="line">with it.</span><br></pre></td></tr></table></figure><hr><h3 id="struct-config-group"><a href="#struct-config-group" class="headerlink" title="struct config_group"></a><code>struct config_group</code></h3><p><code>config_item</code> 不能独立存在。创建 <code>config_item</code> 的唯一方法是通过在 <code>config_group</code> 上使用 <code>mkdir(2)</code>，这将触发子项的创建。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_group</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_item</span><span class="title">cg_item</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">cg_children</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> *<span class="title">cg_subsys</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">default_groups</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span><span class="title">group_entry</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">config_group_init</span><span class="params">(<span class="keyword">struct</span> config_group *group)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">config_group_init_type_name</span><span class="params">(<span class="keyword">struct</span> config_group *group,</span></span><br><span class="line"><span class="params"> <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params"> <span class="keyword">struct</span> config_item_type *type)</span>;</span><br></pre></td></tr></table></figure><p><code>config_group</code> 结构包含一个 <code>config_item</code>。适当配置该项意味着 <code>group</code> 可以作为自己的项目发挥作用。不过，它可以做更多：它可以创建子项目或子组。这是通过在组的 <code>config_item_type</code> 上指定的组操作来实现的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The config_group structure contains a config_item. Properly configuring</span><br><span class="line">that item means that a group can behave as an item in its own right.</span><br><span class="line">However, it can do more: it can create child items or groups. This is</span><br><span class="line">accomplished via the group operations specified on the group&#x27;s</span><br><span class="line">config_item_type.</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_group_operations</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_item</span> *(*<span class="title">make_item</span>)(<span class="keyword">struct</span> <span class="title">config_group</span> *<span class="title">group</span>,</span></span><br><span class="line"><span class="class"> <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>);</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_group</span> *(*<span class="title">make_group</span>)(<span class="keyword">struct</span> <span class="title">config_group</span> *<span class="title">group</span>,</span></span><br><span class="line"><span class="class">   <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>);</span></span><br><span class="line"><span class="type">int</span> (*commit_item)(<span class="keyword">struct</span> config_item *item);</span><br><span class="line"><span class="type">void</span> (*disconnect_notify)(<span class="keyword">struct</span> config_group *group,</span><br><span class="line">  <span class="keyword">struct</span> config_item *item);</span><br><span class="line"><span class="type">void</span> (*drop_item)(<span class="keyword">struct</span> config_group *group,</span><br><span class="line">  <span class="keyword">struct</span> config_item *item);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p>如果组提供了 <code>ct_group_ops-&gt;make_item()</code> 方法，则通过 <code>mkdir(2)</code> 在组的目录中调用该方法创建子项。子系统分配一个新的 <code>config_item</code>（或更可能是其容器结构），对其进行初始化并返回给 <code>configfs</code>。然后 <code>configfs</code> 将填充文件系统树以反映新项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A group creates child items by providing the</span><br><span class="line">ct_group_ops-&gt;make_item() method. If provided, this method is called from mkdir(2) in the group&#x27;s directory. The subsystem allocates a new</span><br><span class="line">config_item (or more likely, its container structure), initializes it,</span><br><span class="line">and returns it to configfs. Configfs will then populate the filesystem</span><br><span class="line">tree to reflect the new item.</span><br></pre></td></tr></table></figure><p>如果子系统希望子项本身也是一个组，则子系统会提供 <code>ct_group_ops-&gt;make_group()</code> 方法。其他所有行为相同，使用组的 <code>_init()</code> 函数对该组进行初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If the subsystem wants the child to be a group itself, the subsystem</span><br><span class="line">provides ct_group_ops-&gt;make_group(). Everything else behaves the same,</span><br><span class="line">using the group _init() functions on the group.</span><br></pre></td></tr></table></figure><p>最后，当用户空间在该项或组上调用 <code>rmdir(2)</code> 时，<code>ct_group_ops-&gt;drop_item()</code> 方法将被调用。由于 <code>config_group</code> 也是一个 <code>config_item</code>，因此不需要单独的 <code>drop_group()</code> 方法。子系统必须在项目分配时初始化的引用上调用 <code>config_item_put()</code>。如果子系统没有任何工作要做，则可以省略 <code>ct_group_ops-&gt;drop_item()</code> 方法，<code>configfs</code> 将代表子系统在该项上调用 <code>config_item_put()</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Finally, when userspace calls rmdir(2) on the item or group,</span><br><span class="line">ct_group_ops-&gt;drop_item() is called. As a config_group is also a</span><br><span class="line">config_item, it is not necessary for a separate drop_group() method.</span><br><span class="line">The subsystem must config_item_put() the reference that was initialized</span><br><span class="line">upon item allocation. If a subsystem has no work to do, it may omit</span><br><span class="line">the ct_group_ops-&gt;drop_item() method, and configfs will call</span><br><span class="line">config_item_put() on the item on behalf of the subsystem.</span><br></pre></td></tr></table></figure><p>重要提示：<code>drop_item()</code> 是 <code>void</code> 函数，因此不能返回失败。当调用 <code>rmdir(2)</code> 时，<code>configfs</code> 将从文件系统树中删除该项（假设没有子项保持它忙碌）。子系统负责对此做出响应。如果子系统在其他线程中引用了该项，则内存是安全的。该项实际上可能需要一些时间才能从子系统的使用中消失。但它已经从 <code>configfs</code> 中删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IMPORTANT: drop_item() is void, and as such cannot fail. When rmdir(2)</span><br><span class="line">is called, configfs WILL remove the item from the filesystem tree</span><br><span class="line">(assuming that it has no children to keep it busy). The subsystem is</span><br><span class="line">responsible for responding to this. If the subsystem has references to</span><br><span class="line">the item in other threads, the memory is safe. It may take some time</span><br><span class="line">for the item to actually disappear from the subsystem&#x27;s usage. But it</span><br><span class="line">is gone from configfs.</span><br></pre></td></tr></table></figure><p>当调用 <code>drop_item()</code> 时，项的链接已经被拆除。它不再拥有其父项的引用，并且在项目层次结构中没有位置。如果客户端需要在这种拆除发生之前进行一些清理操作，子系统可以实现 <code>ct_group_ops-&gt;disconnect_notify()</code> 方法。该方法在 <code>configfs</code> 从文件系统视图中删除该项后，但在从其父组中删除之前调用。与 <code>drop_item()</code> 一样，<code>disconnect_notify()</code> 是 <code>void</code> 函数，不能返回失败。客户端子系统不应在这里删除任何引用，因为它们仍然必须在 <code>drop_item()</code> 中执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">When drop_item() is called, the item&#x27;s linkage has already been torn</span><br><span class="line">down. It no longer has a reference on its parent and has no place in</span><br><span class="line">the item hierarchy. If a client needs to do some cleanup before this</span><br><span class="line">teardown happens, the subsystem can implement the</span><br><span class="line">ct_group_ops-&gt;disconnect_notify() method. The method is called after</span><br><span class="line">configfs has removed the item from the filesystem view but before the</span><br><span class="line">item is removed from its parent group. Like drop_item(),</span><br><span class="line">disconnect_notify() is void and cannot fail. Client subsystems should</span><br><span class="line">not drop any references here, as they still must do it in drop_item().</span><br></pre></td></tr></table></figure><p>如果 <code>config_group</code> 仍有子项，则无法将其删除。这在 <code>configfs</code> 的 <code>rmdir(2)</code> 代码中实现。不会调用 <code>-&gt;drop_item()</code>，因为该项尚未被删除。<code>rmdir(2)</code> 将失败，因为目录不为空。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A config_group cannot be removed while it still has child items. This</span><br><span class="line">is implemented in the configfs rmdir(2) code. -&gt;drop_item() will not be</span><br><span class="line">called, as the item has not been dropped. rmdir(2) will fail, as the</span><br><span class="line">directory is not empty.</span><br></pre></td></tr></table></figure><hr><h3 id="struct-configfs-subsystem"><a href="#struct-configfs-subsystem" class="headerlink" title="struct configfs_subsystem"></a><code>struct configfs_subsystem</code></h3><p>🔥🔥 <strong>子系统必须在模块初始化期间注册自身。这会告诉 <code>configfs</code> 将子系统显示在文件树中</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_group</span><span class="title">su_group</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span><span class="title">su_mutex</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">configfs_register_subsystem</span><span class="params">(<span class="keyword">struct</span> configfs_subsystem *subsys)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">configfs_unregister_subsystem</span><span class="params">(<span class="keyword">struct</span> configfs_subsystem *subsys)</span>;</span><br></pre></td></tr></table></figure><p>一个子系统由一个顶层 <code>config_group</code> 和一个互斥锁组成。该组是创建子 <code>config_items</code> 的位置。对于子系统来说，这个组通常是静态定义的。在调用 <code>configfs_register_subsystem()</code> 之前，子系统必须通过常规的组初始化函数初始化该组，并且还必须初始化互斥锁。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A subsystem consists of a toplevel config_group and a mutex.</span><br><span class="line">The group is where child config_items are created. For a subsystem,</span><br><span class="line">this group is usually defined statically. Before calling</span><br><span class="line">configfs_register_subsystem(), the subsystem must have initialized the</span><br><span class="line">group via the usual group _init() functions, and it must also have</span><br><span class="line">initialized the mutex.</span><br></pre></td></tr></table></figure><p>当注册调用返回时，子系统变为活动状态，并通过 <code>configfs</code> 可见。此时，可以调用 <code>mkdir(2)</code>，子系统必须准备好处理它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">When the register call returns, the subsystem is live, and it</span><br><span class="line">will be visible via configfs. At that point, mkdir(2) can be called and</span><br><span class="line">the subsystem must be ready for it.</span><br></pre></td></tr></table></figure><hr><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这些基本概念的最佳示例是 <code>samples/configfs/configfs_sample.c</code> 中的 <code>simple_children</code> 子系统&#x2F;组和 <code>simple_child</code> 项。它展示了一个显示和存储属性的简单对象，以及一个创建和销毁这些子项的简单组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[An Example]</span><br><span class="line"></span><br><span class="line">The best example of these basic concepts is the simple_children</span><br><span class="line">subsystem/group and the simple_child item in</span><br><span class="line">samples/configfs/configfs_sample.c. It shows a trivial object displaying</span><br><span class="line">and storing an attribute, and a simple group creating and destroying</span><br><span class="line">these children.</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://elixir.bootlin.com/linux/v5.10.186/source/samples/configfs/configfs_sample.c">https://elixir.bootlin.com/linux/v5.10.186/source/samples/configfs/configfs_sample.c</a><br>可以试试编译，加一些日志看看。</p><p>这里起来时，将 configfs 挂载到了 &#x2F;tmp&#x2F;usb 目录。不好，有歧义🌚。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@milkv-duo]~# ls</span><br><span class="line">configfs_sample.ko</span><br><span class="line">[root@milkv-duo]~# ls /tmp/usb</span><br><span class="line">usb_gadget</span><br><span class="line">[root@milkv-duo]~# insmod configfs_sample.ko</span><br><span class="line">[root@milkv-duo]~# ls /tmp/usb</span><br><span class="line">01-childless  02-simple-children  03-group-children  usb_gadget</span><br><span class="line">[root@milkv-duo]~# cd /tmp/usb/</span><br><span class="line">[root@milkv-duo]/tmp/usb# tree 0*</span><br><span class="line">01-childless</span><br><span class="line">├── description</span><br><span class="line">├── showme</span><br><span class="line">└── storeme</span><br><span class="line">02-simple-children</span><br><span class="line">└── description</span><br><span class="line">03-group-children</span><br><span class="line">└── description</span><br><span class="line"></span><br><span class="line">0 directories, 5 files</span><br></pre></td></tr></table></figure></blockquote><h3 id="00-init"><a href="#00-init" class="headerlink" title="00-init"></a>00-init</h3><p>我们现在已经完成了子系统的定义。为了方便起见，这里列出了所有的子系统。这使得初始化函数可以轻松注册它们。大多数模块只包含一个子系统，并且只会直接调用 <code>register_subsystem</code> 进行注册。</p><blockquote><p>如前面 <a href="#struct-configfs_subsystem"><code>struct configfs_subsystem</code></a> 的描述，通过调用</p><ul><li><code>config_group_init(&amp;subsys-&gt;su_group);</code></li><li><code>mutex_init(&amp;subsys-&gt;su_mutex);</code></li><li><code>configfs_register_subsystem(subsys);</code></li></ul><p>来完成configfs 子系统的注册。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We&#x27;re now done with our subsystem definitions.</span></span><br><span class="line"><span class="comment"> * For convenience in this module, here&#x27;s a list of them all.  It</span></span><br><span class="line"><span class="comment"> * allows the init function to easily register them.  Most modules</span></span><br><span class="line"><span class="comment"> * will only have one subsystem, and will only call register_subsystem</span></span><br><span class="line"><span class="comment"> * on it directly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> *<span class="title">example_subsys</span>[] =</span> &#123;</span><br><span class="line">&amp;childless_subsys.subsys,</span><br><span class="line">&amp;simple_children_subsys,</span><br><span class="line">&amp;group_children_subsys,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">configfs_example_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> *<span class="title">subsys</span>;</span></span><br><span class="line"><span class="type">int</span> ret, i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; example_subsys[i]; i++) &#123;</span><br><span class="line">subsys = example_subsys[i];</span><br><span class="line"></span><br><span class="line">config_group_init(&amp;subsys-&gt;su_group);</span><br><span class="line">mutex_init(&amp;subsys-&gt;su_mutex);</span><br><span class="line">ret = configfs_register_subsystem(subsys);</span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">pr_err(<span class="string">&quot;Error %d while registering subsystem %s\n&quot;</span>,</span><br><span class="line">       ret, subsys-&gt;su_group.cg_item.ci_namebuf);</span><br><span class="line"><span class="keyword">goto</span> out_unregister;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line"><span class="keyword">for</span> (i--; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">configfs_unregister_subsystem(example_subsys[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">configfs_example_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; example_subsys[i]; i++)</span><br><span class="line">configfs_unregister_subsystem(example_subsys[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(configfs_example_init);</span><br><span class="line">module_exit(configfs_example_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h3 id="01-childless"><a href="#01-childless" class="headerlink" title="01-childless"></a>01-childless</h3><p>这个第一个例子是一个没有子项的子系统。它不能创建任何 <code>config_items</code>，只包含属性。</p><p>请注意，我们将 <code>configfs_subsystem</code> 封装在一个容器中。如果子系统本身没有直接的属性，这并不是必须的。可以参考下一个例子，02-simple-children，来了解这种子系统。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 01-childless</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This first example is a childless subsystem.  It cannot create</span></span><br><span class="line"><span class="comment"> * any config_items.  It just has attributes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that we are enclosing the configfs_subsystem inside a container.</span></span><br><span class="line"><span class="comment"> * This is not necessary if a subsystem has no attributes directly</span></span><br><span class="line"><span class="comment"> * on the subsystem.  See the next example, 02-simple-children, for</span></span><br><span class="line"><span class="comment"> * such a subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">childless</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> <span class="title">subsys</span>;</span></span><br><span class="line"><span class="type">int</span> showme;</span><br><span class="line"><span class="type">int</span> storeme;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> childless *<span class="title function_">to_childless</span><span class="params">(<span class="keyword">struct</span> config_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> container_of(to_configfs_subsystem(to_config_group(item)),</span><br><span class="line">    <span class="keyword">struct</span> childless, subsys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">childless_showme_show</span><span class="params">(<span class="keyword">struct</span> config_item *item, <span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">childless</span> *<span class="title">childless</span> =</span> to_childless(item);</span><br><span class="line"><span class="type">ssize_t</span> pos;</span><br><span class="line"></span><br><span class="line">pos = <span class="built_in">sprintf</span>(page, <span class="string">&quot;%d\n&quot;</span>, childless-&gt;showme);</span><br><span class="line">childless-&gt;showme++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">childless_storeme_show</span><span class="params">(<span class="keyword">struct</span> config_item *item, <span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sprintf</span>(page, <span class="string">&quot;%d\n&quot;</span>, to_childless(item)-&gt;storeme);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">childless_storeme_store</span><span class="params">(<span class="keyword">struct</span> config_item *item,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *page, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">childless</span> *<span class="title">childless</span> =</span> to_childless(item);</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = kstrtoint(page, <span class="number">10</span>, &amp;childless-&gt;storeme);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">childless_description_show</span><span class="params">(<span class="keyword">struct</span> config_item *item, <span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sprintf</span>(page,</span><br><span class="line"><span class="string">&quot;[01-childless]\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;The childless subsystem is the simplest possible subsystem in\n&quot;</span></span><br><span class="line"><span class="string">&quot;configfs.  It does not support the creation of child config_items.\n&quot;</span></span><br><span class="line"><span class="string">&quot;It only has a few attributes.  In fact, it isn&#x27;t much different\n&quot;</span></span><br><span class="line"><span class="string">&quot;than a directory in /proc.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* https://elixir.bootlin.com/linux/v5.10.186/source/include/linux/configfs.h#L134</span></span><br><span class="line"><span class="comment">#define CONFIGFS_ATTR(_pfx, _name)\</span></span><br><span class="line"><span class="comment">static struct configfs_attribute _pfx##attr_##_name = &#123;\</span></span><br><span class="line"><span class="comment">.ca_name= __stringify(_name),\</span></span><br><span class="line"><span class="comment">.ca_mode= S_IRUGO | S_IWUSR,\</span></span><br><span class="line"><span class="comment">.ca_owner= THIS_MODULE,\</span></span><br><span class="line"><span class="comment">.show= _pfx##_name##_show,\</span></span><br><span class="line"><span class="comment">.store= _pfx##_name##_store,\</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define CONFIGFS_ATTR_RO(_pfx, _name)\</span></span><br><span class="line"><span class="comment">static struct configfs_attribute _pfx##attr_##_name = &#123;\</span></span><br><span class="line"><span class="comment">.ca_name= __stringify(_name),\</span></span><br><span class="line"><span class="comment">.ca_mode= S_IRUGO,\</span></span><br><span class="line"><span class="comment">.ca_owner= THIS_MODULE,\</span></span><br><span class="line"><span class="comment">.show= _pfx##_name##_show,\</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define CONFIGFS_ATTR_WO(_pfx, _name)\</span></span><br><span class="line"><span class="comment">static struct configfs_attribute _pfx##attr_##_name = &#123;\</span></span><br><span class="line"><span class="comment">.ca_name= __stringify(_name),\</span></span><br><span class="line"><span class="comment">.ca_mode= S_IWUSR,\</span></span><br><span class="line"><span class="comment">.ca_owner= THIS_MODULE,\</span></span><br><span class="line"><span class="comment">.store= _pfx##_name##_store,\</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当项目出现在 configfs 中时，属性文件将以 configfs_attribute-&gt;ca_name 文件名出现。</span></span><br><span class="line"><span class="comment">// configfs_attribute-&gt;ca_mode 指定文件权限。</span></span><br><span class="line"><span class="comment">// ✨✨✨ 注意这里宏中，指定了 .show/.store 对应的处理函数。</span></span><br><span class="line">CONFIGFS_ATTR_RO(childless_, showme);</span><br><span class="line">CONFIGFS_ATTR(childless_, storeme);</span><br><span class="line">CONFIGFS_ATTR_RO(childless_, description);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[root@milkv-duo]/tmp/usb/01-childless# ls -lh</span></span><br><span class="line"><span class="comment">total 0</span></span><br><span class="line"><span class="comment">-r--r--r-- 1 root root 4.0K Jan  1 05:15 description</span></span><br><span class="line"><span class="comment">-r--r--r-- 1 root root 4.0K Jan  1 05:15 showme</span></span><br><span class="line"><span class="comment">-rw-r--r-- 1 root root 4.0K Jan  1 05:15 storeme</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 config_item 希望某个属性作为文件出现在其 configfs 目录中时，</span></span><br><span class="line"><span class="comment">// 它必须定义一个描述该属性的 configfs_attribute。然后它将该属性添加到</span></span><br><span class="line"><span class="comment">// config_item_type-&gt;ct_attrs 的以 NULL 结尾的数组中。</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span> *<span class="title">childless_attrs</span>[] =</span> &#123;</span><br><span class="line">&amp;childless_attr_showme,</span><br><span class="line">&amp;childless_attr_storeme,</span><br><span class="line">&amp;childless_attr_description,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> <span class="title">childless_type</span> =</span> &#123;</span><br><span class="line">.ct_attrs= childless_attrs,</span><br><span class="line">.ct_owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">childless</span> <span class="title">childless_subsys</span> =</span> &#123;</span><br><span class="line">.subsys = &#123;</span><br><span class="line">.su_group = &#123;</span><br><span class="line">.cg_item = &#123;</span><br><span class="line">.ci_namebuf = <span class="string">&quot;01-childless&quot;</span>,</span><br><span class="line"><span class="comment">// config_item_type 的最基本功能是定义可以对 config_item 执行的操作</span></span><br><span class="line">.ci_type = &amp;childless_type,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>倒着看代码，注意配合看前面的介绍。属性基本只有 <code>show/store</code> 两种操作，对应读写，可通过 <code>echo/cat</code> 测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@milkv-duo]/tmp/usb<span class="comment"># ls</span></span><br><span class="line">01-childless  02-simple-children  03-group-children  usb_gadget</span><br><span class="line">[root@milkv-duo]/tmp/usb<span class="comment"># cd 01-childless/</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># ls -lh</span></span><br><span class="line">total 0</span><br><span class="line">-r--r--r-- 1 root root 4.0K Jan  1 05:15 description</span><br><span class="line">-r--r--r-- 1 root root 4.0K Jan  1 05:15 showme</span><br><span class="line">-rw-r--r-- 1 root root 4.0K Jan  1 05:15 storeme</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">0</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">1</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">2</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">3</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">4</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat storeme</span></span><br><span class="line">0</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat storeme</span></span><br><span class="line">0</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat description</span></span><br><span class="line">[01-childless]</span><br><span class="line"></span><br><span class="line">The childless subsystem is the simplest possible subsystem <span class="keyword">in</span></span><br><span class="line">configfs.  It does not support the creation of child config_items.</span><br><span class="line">It only has a few attributes.  In fact, it isn<span class="string">&#x27;t much different</span></span><br><span class="line"><span class="string">than a directory in /proc.</span></span><br><span class="line"><span class="string">[root@milkv-duo]/tmp/usb/01-childless# echo 0 &gt; showme</span></span><br><span class="line"><span class="string">-sh: can&#x27;</span>t create showme: Permission denied</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">5</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># echo 3 &gt; storeme</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat storeme</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure></blockquote><hr><h3 id="02-simple-children"><a href="#02-simple-children" class="headerlink" title="02-simple-children"></a>02-simple-children</h3><p>这个例子仅包含一个简单的、带有单一属性的子项。注意，这里没有额外的属性结构，因为子项的属性一开始就是已知的。此外，子系统没有容器，因为它自身没有任何属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 02-simple-children</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This example merely has a simple one-attribute child.  Note that</span></span><br><span class="line"><span class="comment"> * there is no extra attribute structure, as the child&#x27;s attribute is</span></span><br><span class="line"><span class="comment"> * known from the get-go.  Also, there is no container for the</span></span><br><span class="line"><span class="comment"> * subsystem, as it has no attributes of its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simple_child</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_item</span> <span class="title">item</span>;</span></span><br><span class="line"><span class="type">int</span> storeme;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> simple_child *<span class="title function_">to_simple_child</span><span class="params">(<span class="keyword">struct</span> config_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> container_of(item, <span class="keyword">struct</span> simple_child, item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">simple_child_storeme_show</span><span class="params">(<span class="keyword">struct</span> config_item *item, <span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sprintf</span>(page, <span class="string">&quot;%d\n&quot;</span>, to_simple_child(item)-&gt;storeme);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">simple_child_storeme_store</span><span class="params">(<span class="keyword">struct</span> config_item *item,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *page, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simple_child</span> *<span class="title">simple_child</span> =</span> to_simple_child(item);</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = kstrtoint(page, <span class="number">10</span>, &amp;simple_child-&gt;storeme);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONFIGFS_ATTR(simple_child_, storeme);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span> *<span class="title">simple_child_attrs</span>[] =</span> &#123;</span><br><span class="line">&amp;simple_child_attr_storeme,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">simple_child_release</span><span class="params">(<span class="keyword">struct</span> config_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">kfree(to_simple_child(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_item_operations</span> <span class="title">simple_child_item_ops</span> =</span> &#123;</span><br><span class="line">.release= simple_child_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> <span class="title">simple_child_type</span> =</span> &#123;</span><br><span class="line">.ct_item_ops= &amp;simple_child_item_ops,</span><br><span class="line">.ct_attrs= simple_child_attrs,</span><br><span class="line">.ct_owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simple_children</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_group</span> <span class="title">group</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> simple_children *<span class="title function_">to_simple_children</span><span class="params">(<span class="keyword">struct</span> config_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> container_of(to_config_group(item),</span><br><span class="line">    <span class="keyword">struct</span> simple_children, group);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> config_item *<span class="title function_">simple_children_make_item</span><span class="params">(<span class="keyword">struct</span> config_group *group,</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simple_child</span> *<span class="title">simple_child</span>;</span></span><br><span class="line"></span><br><span class="line">simple_child = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> simple_child), GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!simple_child)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">config_item_init_type_name(&amp;simple_child-&gt;item, name,</span><br><span class="line">   &amp;simple_child_type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;simple_child-&gt;item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">simple_children_description_show</span><span class="params">(<span class="keyword">struct</span> config_item *item,</span></span><br><span class="line"><span class="params"><span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sprintf</span>(page,</span><br><span class="line"><span class="string">&quot;[02-simple-children]\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;This subsystem allows the creation of child config_items.  These\n&quot;</span></span><br><span class="line"><span class="string">&quot;items have only one attribute that is readable and writeable.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONFIGFS_ATTR_RO(simple_children_, description);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span> *<span class="title">simple_children_attrs</span>[] =</span> &#123;</span><br><span class="line">&amp;simple_children_attr_description,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">simple_children_release</span><span class="params">(<span class="keyword">struct</span> config_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">kfree(to_simple_children(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_item_operations</span> <span class="title">simple_children_item_ops</span> =</span> &#123;</span><br><span class="line">.release= simple_children_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note that, since no extra work is required on -&gt;drop_item(),</span></span><br><span class="line"><span class="comment"> * no -&gt;drop_item() is provided.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果组提供了 ct_group_ops-&gt;make_item() 方法，则通过 mkdir(2) 在组的目录中调用该方法创建子项。</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_group_operations</span> <span class="title">simple_children_group_ops</span> =</span> &#123;</span><br><span class="line">.make_item= simple_children_make_item,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> <span class="title">simple_children_type</span> =</span> &#123;</span><br><span class="line">.ct_item_ops= &amp;simple_children_item_ops,</span><br><span class="line">.ct_group_ops= &amp;simple_children_group_ops,</span><br><span class="line">.ct_attrs= simple_children_attrs,</span><br><span class="line">.ct_owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> <span class="title">simple_children_subsys</span> =</span> &#123;</span><br><span class="line">.su_group = &#123;</span><br><span class="line">.cg_item = &#123;</span><br><span class="line">.ci_namebuf = <span class="string">&quot;02-simple-children&quot;</span>,</span><br><span class="line">.ci_type = &amp;simple_children_type,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><a href="#struct-config_group">config_group 结构包含一个 config_item。适当配置该项意味着 group 可以作为自己的项目发挥作用。不过，它可以做更多：它可以创建子项目或子组。这是通过在组的 config_item_type 上指定的组操作来实现的。</a></p><p>这个例子，可以通过 mkdir 创建子项，子项有一个可读写的 storeme 属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># cat description</span></span><br><span class="line">[02-simple-children]</span><br><span class="line"></span><br><span class="line">This subsystem allows the creation of child config_items.  These</span><br><span class="line">items have only one attribute that is readable and writeable.</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># mkdir test01</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># tree .</span></span><br><span class="line">.</span><br><span class="line">├── description</span><br><span class="line">└── test01</span><br><span class="line">    └── storeme</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># echo xxx &gt; test01/storeme</span></span><br><span class="line">sh: write error: Invalid argument</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># echo 30 &gt; test01/storeme</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># cat test01/storeme</span></span><br><span class="line">30</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># mkdir test02</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># mkdir test03</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># tree .</span></span><br><span class="line">.</span><br><span class="line">├── description</span><br><span class="line">├── test01</span><br><span class="line">│   └── storeme</span><br><span class="line">├── test02</span><br><span class="line">│   └── storeme</span><br><span class="line">└── test03</span><br><span class="line">    └── storeme</span><br><span class="line"></span><br><span class="line">3 directories, 4 files</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># cat test02/storeme</span></span><br><span class="line">0</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># rmdir test03</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># ls</span></span><br><span class="line">description  test01  test02</span><br></pre></td></tr></table></figure></blockquote><h3 id="03-group-children"><a href="#03-group-children" class="headerlink" title="03-group-children"></a>03-group-children</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 03-group-children</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This example reuses the simple_children group from above.  However,</span></span><br><span class="line"><span class="comment"> * the simple_children group is not the subsystem itself, it is a</span></span><br><span class="line"><span class="comment"> * child of the subsystem.  Creation of a group in the subsystem creates</span></span><br><span class="line"><span class="comment"> * a new simple_children group.  That group can then have simple_child</span></span><br><span class="line"><span class="comment"> * children of its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> config_group *<span class="title function_">group_children_make_group</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="keyword">struct</span> config_group *group, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simple_children</span> *<span class="title">simple_children</span>;</span></span><br><span class="line"></span><br><span class="line">simple_children = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> simple_children),</span><br><span class="line">  GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!simple_children)</span><br><span class="line"><span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">config_group_init_type_name(&amp;simple_children-&gt;group, name,</span><br><span class="line">    &amp;simple_children_type);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &amp;simple_children-&gt;group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">group_children_description_show</span><span class="params">(<span class="keyword">struct</span> config_item *item,</span></span><br><span class="line"><span class="params"><span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">sprintf</span>(page,</span><br><span class="line"><span class="string">&quot;[03-group-children]\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;This subsystem allows the creation of child config_groups.  These\n&quot;</span></span><br><span class="line"><span class="string">&quot;groups are like the subsystem simple-children.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONFIGFS_ATTR_RO(group_children_, description);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span> *<span class="title">group_children_attrs</span>[] =</span> &#123;</span><br><span class="line">&amp;group_children_attr_description,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note that, since no extra work is required on -&gt;drop_item(),</span></span><br><span class="line"><span class="comment"> * no -&gt;drop_item() is provided.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_group_operations</span> <span class="title">group_children_group_ops</span> =</span> &#123;</span><br><span class="line">.make_group= group_children_make_group,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> <span class="title">group_children_type</span> =</span> &#123;</span><br><span class="line">.ct_group_ops= &amp;group_children_group_ops,</span><br><span class="line">.ct_attrs= group_children_attrs,</span><br><span class="line">.ct_owner= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> <span class="title">group_children_subsys</span> =</span> &#123;</span><br><span class="line">.su_group = &#123;</span><br><span class="line">.cg_item = &#123;</span><br><span class="line">.ci_namebuf = <span class="string">&quot;03-group-children&quot;</span>,</span><br><span class="line">.ci_type = &amp;group_children_type,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><a href="#sturct-config_group">如果子系统希望子项本身也是一个组，则子系统会提供 <code>ct_group_ops-&gt;make_group()</code> 方法。</a></p><p>这个例子中，可以通过 mkdir 去创建 group。</p><blockquote><p>❓❓一个问题：如果 <code>ct_group_ops</code> 中同时指定了 <code>make_group</code> 和 <code>make_item</code> ，那么调用 <code>mkdir</code> 时是执行哪一个呢？可以从源码中找答案：<a href="https://elixir.bootlin.com/linux/v5.10.186/source/fs/configfs">https://elixir.bootlin.com/linux/v5.10.186/source/fs/configfs</a>  <code>configfs</code> 的实现看起来有点简单，代码量并不大。</p><p><a href="https://elixir.bootlin.com/linux/v5.10.186/source/fs/configfs/dir.c#L1353">https://elixir.bootlin.com/linux/v5.10.186/source/fs/configfs/dir.c#L1353</a> 在 configfs_mkdir() 中，<code>make_group</code> 优先调用。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># cat description</span></span><br><span class="line">[03-group-children]</span><br><span class="line"></span><br><span class="line">This subsystem allows the creation of child config_groups.  These</span><br><span class="line"><span class="built_in">groups</span> are like the subsystem simple-children.</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># mkdir grp1</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># tree .</span></span><br><span class="line">.</span><br><span class="line">├── description</span><br><span class="line">└── grp1</span><br><span class="line">    └── description</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># cat grp1/description</span></span><br><span class="line">[02-simple-children]</span><br><span class="line"></span><br><span class="line">This subsystem allows the creation of child config_items.  These</span><br><span class="line">items have only one attribute that is readable and writeable.</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># mkdir grp1/item1</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># mkdir grp1/item2</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># tree .</span></span><br><span class="line">.</span><br><span class="line">├── description</span><br><span class="line">└── grp1</span><br><span class="line">    ├── description</span><br><span class="line">    ├── item1</span><br><span class="line">    │   └── storeme</span><br><span class="line">    └── item2</span><br><span class="line">        └── storeme</span><br><span class="line"></span><br><span class="line">3 directories, 4 files</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># rmdir grp1</span></span><br><span class="line"><span class="built_in">rmdir</span>: failed to remove <span class="string">&#x27;grp1&#x27;</span>: Directory not empty</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># cd grp1/</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children/grp1<span class="comment"># rmdir item1</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children/grp1<span class="comment"># rmdir item2</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children/grp1<span class="comment"># cd ..</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># rmdir grp1</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># ls</span></span><br><span class="line">description</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment">#</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="层次结构导航和子系统互斥锁"><a href="#层次结构导航和子系统互斥锁" class="headerlink" title="层次结构导航和子系统互斥锁"></a>层次结构导航和子系统互斥锁</h2><p><code>configfs</code> 提供了一个额外的好处。由于 <code>config_groups</code> 和 <code>config_items</code> 出现在文件系统中，因此它们被排列成层次结构。子系统<strong>永远</strong>不应触及文件系统部分，但子系统可能对该层次结构感兴趣。为此，层次结构通过 <code>config_group-&gt;cg_children</code> 和 <code>config_item-&gt;ci_parent</code> 结构成员进行镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Hierarchy Navigation and the Subsystem Mutex]</span><br><span class="line"></span><br><span class="line">There is an extra bonus that configfs provides. The config_groups and</span><br><span class="line">config_items are arranged in a hierarchy due to the fact that they</span><br><span class="line">appear in a filesystem. A subsystem is NEVER to touch the filesystem</span><br><span class="line">parts, but the subsystem might be interested in this hierarchy. For</span><br><span class="line">this reason, the hierarchy is mirrored via the config_group-&gt;cg_children</span><br><span class="line">and config_item-&gt;ci_parent structure members.</span><br></pre></td></tr></table></figure><p>子系统可以在保护子系统互斥锁的情况下导航 <code>cg_children</code> 列表和 <code>ci_parent</code> 指针，以查看由子系统创建的树。这可能会与 <code>configfs</code> 对层次结构的管理产生竞争，因此 <code>configfs</code> 使用子系统互斥锁来保护修改。每当子系统想要导航层次结构时，必须在子系统互斥锁的保护下进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A subsystem can navigate the cg_children list and the ci_parent pointer</span><br><span class="line">to see the tree created by the subsystem. This can race with configfs&#x27;</span><br><span class="line">management of the hierarchy, so configfs uses the subsystem mutex to</span><br><span class="line">protect modifications. Whenever a subsystem wants to navigate the</span><br><span class="line">hierarchy, it must do so under the protection of the subsystem</span><br><span class="line">mutex.</span><br></pre></td></tr></table></figure><p>只要新分配的项尚未链接到层次结构中，子系统将无法获取互斥锁。同样，只要正在删除的项尚未从层次结构中解除链接，它将无法获取互斥锁。这意味着只要该项在 <code>configfs</code> 中，其 <code>ci_parent</code> 指针就永远不会为 NULL，并且该项在其父项的 <code>cg_children</code> 列表中存在的时间也是</p><p>相同的。这使子系统在持有互斥锁时可以信任 <code>ci_parent</code> 和 <code>cg_children</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A subsystem will be prevented from acquiring the mutex while a newly</span><br><span class="line">allocated item has not been linked into this hierarchy. Similarly, it</span><br><span class="line">will not be able to acquire the mutex while a dropping item has not</span><br><span class="line">yet been unlinked. This means that an item&#x27;s ci_parent pointer will</span><br><span class="line">never be NULL while the item is in configfs, and that an item will only</span><br><span class="line">be in its parent&#x27;s cg_children list for the same duration. This allows</span><br><span class="line">a subsystem to trust ci_parent and cg_children while they hold the</span><br><span class="line">mutex.</span><br></pre></td></tr></table></figure><hr><h2 id="通过-symlink-2-实现项的聚合"><a href="#通过-symlink-2-实现项的聚合" class="headerlink" title="通过 symlink(2) 实现项的聚合"></a>通过 <code>symlink(2)</code> 实现项的聚合</h2><p><code>configfs</code> 通过 <code>group-&gt;item</code> 的父&#x2F;子关系提供了一个简单的分组。然而，在更大的环境中，通常需要超出父&#x2F;子连接的聚合。这可以通过 <code>symlink(2)</code> 实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Item Aggregation Via symlink(2)]</span><br><span class="line"></span><br><span class="line">configfs provides a simple group via the group-&gt;item parent/child</span><br><span class="line">relationship. Often, however, a larger environment requires aggregation</span><br><span class="line">outside of the parent/child connection. This is implemented via</span><br><span class="line">symlink(2).</span><br></pre></td></tr></table></figure><p><code>config_item</code> 可以提供 <code>ct_item_ops-&gt;allow_link()</code> 和 <code>ct_item_ops-&gt;drop_link()</code> 方法。如果存在 <code>-&gt;allow_link()</code> 方法，可以将 <code>symlink(2)</code> 调用配置项作为链接的源。链接只允许在 <code>configfs</code> 的 <code>config_items</code> 之间进行。任何在 <code>configfs</code> 文件系统之外的 <code>symlink(2)</code> 尝试都将被拒绝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A config_item may provide the ct_item_ops-&gt;allow_link() and</span><br><span class="line">ct_item_ops-&gt;drop_link() methods. If the -&gt;allow_link() method exists,</span><br><span class="line">symlink(2) may be called with the config_item as the source of the link.</span><br><span class="line">These links are only allowed between configfs config_items. Any</span><br><span class="line">symlink(2) attempt outside the configfs filesystem will be denied.</span><br></pre></td></tr></table></figure><p>当调用 <code>symlink(2)</code> 时，源 <code>config_item</code> 的 <code>-&gt;allow_link()</code> 方法将与自身和目标项一起调用。如果源项允许链接到目标项，它将返回 0。源项可能希望拒绝链接，如果它只希望链接到某一类对象（例如，只能链接到自己的子系统中的对象）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">When symlink(2) is called, the source config_item&#x27;s -&gt;allow_link()</span><br><span class="line">method is called with itself and a target item. If the source item</span><br><span class="line">allows linking to target item, it returns 0. A source item may wish to</span><br><span class="line">reject a link if it only wants links to a certain type of object (say,</span><br><span class="line">in its own subsystem).</span><br></pre></td></tr></table></figure><p>当在符号链接上调用 <code>unlink(2)</code> 时，源项将通过 <code>-&gt;drop_link()</code> 方法收到通知。与 <code>-&gt;drop_item()</code> 方法一样，这是一个 <code>void</code> 函数，不能返回失败。子系统负责对更改作出响应。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">When unlink(2) is called on the symbolic link, the source item is</span><br><span class="line">notified via the -&gt;drop_link() method. Like the -&gt;drop_item() method,</span><br><span class="line">this is a void function and cannot return failure. The subsystem is</span><br><span class="line">responsible for responding to the change.</span><br></pre></td></tr></table></figure><p>只要链接到其他项，或其他项链接到它，就无法移除 <code>config_item</code>。<code>configfs</code> 不允许出现悬空的符号链接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A config_item cannot be removed while it links to any other item, nor</span><br><span class="line">can it be removed while an item links to it. Dangling symlinks are not</span><br><span class="line">allowed in configfs.</span><br></pre></td></tr></table></figure><hr><h2 id="自动创建的子组"><a href="#自动创建的子组" class="headerlink" title="自动创建的子组"></a>自动创建的子组</h2><p>一个新的 <code>config_group</code> 可能希望拥有两种类型的子 <code>config_items</code>。虽然这可以通过 <code>-&gt;make_item()</code> 方法中的“魔法名称”实现，但通过一种用户空间可以看到这种分歧的方法更加明确。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Automatically Created Subgroups]</span><br><span class="line"></span><br><span class="line">A new config_group may want to have two types of child config_items.</span><br><span class="line">While this could be codified by magic names in -&gt;make_item(), it is much</span><br><span class="line">more explicit to have a method whereby userspace sees this divergence.</span><br></pre></td></tr></table></figure><p>与其拥有一个行为不同的项，不如让 <code>configfs</code> 提供一种方法，即在创建父组时，自动在父组中创建一个或多个子组。因此，<code>mkdir(&quot;parent&quot;)</code> 结果是 <code>&quot;parent&quot;</code>，<code>&quot;parent/subgroup1&quot;</code>，依次到 <code>&quot;parent/subgroupN&quot;</code>。类型 1 的项现在可以在 <code>&quot;parent/subgroup1&quot;</code> 中创建，类型 N 的项可以在 <code>&quot;parent/subgroupN&quot;</code> 中创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rather than have a group where some items behave differently than</span><br><span class="line">others, configfs provides a method whereby one or many subgroups are</span><br><span class="line">automatically created inside the parent at its creation. Thus,</span><br><span class="line">mkdir(&quot;parent&quot;) results in &quot;parent&quot;, &quot;parent/subgroup1&quot;, up through</span><br><span class="line">&quot;parent/subgroupN&quot;. Items of type 1 can now be created in</span><br><span class="line">&quot;parent/subgroup1&quot;, and items of type N can be created in</span><br><span class="line">&quot;parent/subgroupN&quot;.</span><br></pre></td></tr></table></figure><p>这些自动子组（或默认组）不会排除父组的其他子项。如果存在 <code>ct_group_ops-&gt;make_group()</code> 方法，可以直接在父组中创建其他子组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">These automatic subgroups, or default groups, do not preclude other</span><br><span class="line">children of the parent group. If ct_group_ops-&gt;make_group() exists,</span><br><span class="line">other child groups can be created on the parent group directly.</span><br></pre></td></tr></table></figure><p><code>configfs</code> 子系统通过使用 <code>configfs_add_default_group()</code> 函数将它们添加到父 <code>config_group</code> 结构中来指定默认组。每个添加的组将在父组创建时同时填充到 <code>configfs</code> 树中。类似地，它们将在父组移除时一起被删除。没有额外的通知。当 <code>-&gt;drop_item()</code> 方法通知子系统父组正在消失时，这也意味着与该父组关联的每个默认组子项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A configfs subsystem specifies default groups by adding them using the</span><br><span class="line">configfs_add_default_group() function to the parent config_group</span><br><span class="line">structure. Each added group is populated in the configfs tree at the same</span><br><span class="line">time as the parent group. Similarly, they are removed at the same time</span><br><span class="line">as the parent. No extra notification is provided. When a -&gt;drop_item()</span><br><span class="line">method call notifies the subsystem the parent group is going away, it</span><br><span class="line">also means every default group child associated with that parent group.</span><br></pre></td></tr></table></figure><p>因此，默认组不能直接通过 <code>rmdir(2)</code> 删除。在父组上执行 <code>rmdir(2)</code> 时，它们也不会被视为子项。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">As a consequence of this, default groups cannot be removed directly via</span><br><span class="line">rmdir(2). They also are not considered when rmdir(2) on the parent</span><br><span class="line">group is checking for children.</span><br></pre></td></tr></table></figure><hr><h2 id="依赖子系统"><a href="#依赖子系统" class="headerlink" title="依赖子系统"></a>依赖子系统</h2><p>有时其他驱动程序依赖于特定的 <code>configfs</code> 项。例如，<code>ocfs2</code> 挂载依赖于心跳区域项。如果该区域项通过 <code>rmdir(2)</code> 被移除，<code>ocfs2</code> 挂载必须 <code>BUG</code> 或切换到只读模式。这并不理想。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Dependent Subsystems]</span><br><span class="line"></span><br><span class="line">Sometimes other drivers depend on particular configfs items. For</span><br><span class="line">example, ocfs2 mounts depend on a heartbeat region item. If that</span><br><span class="line">region item is removed with rmdir(2), the ocfs2 mount must BUG or go</span><br><span class="line">readonly. Not happy.</span><br></pre></td></tr></table></figure><p><code>configfs</code> 提供了两个额外的 API 调用：<code>configfs_depend_item()</code> 和 <code>configfs_undepend_item()</code>。客户端驱动程序可以调用 <code>configfs_depend_item()</code> 来告知 <code>configfs</code> 它依赖某个现有项。之后，<code>configfs</code> 将在 <code>rmdir(2)</code> 调用时返回 <code>-EBUSY</code> 错误。当该项不再被依赖时，客户端驱动程序调用 <code>configfs_undepend_item()</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configfs provides two additional API calls: configfs_depend_item() and</span><br><span class="line">configfs_undepend_item(). A client driver can call</span><br><span class="line">configfs_depend_item() on an existing item to tell configfs that it is</span><br><span class="line">depended on. configfs will then return -EBUSY from rmdir(2) for that</span><br><span class="line">item. When the item is no longer depended on, the client driver calls</span><br><span class="line">configfs_undepend_item() on it.</span><br></pre></td></tr></table></figure><p>这些 API 不能在任何 <code>configfs</code> 回调中调用，因为它们会产生冲突。它们可能会阻塞和分配内存。客户端驱动程序可能不应自行调用它们，而应该提供供外部子系统调用的 API。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">These API cannot be called underneath any configfs callbacks, as</span><br><span class="line">they will conflict. They can block and allocate. A client driver</span><br><span class="line">probably shouldn&#x27;t calling them of its own gumption. Rather it should</span><br><span class="line">be providing an API that external subsystems call.</span><br></pre></td></tr></table></figure><p>这个过程如何工作？想象一下 <code>ocfs2</code> 的挂载过程。当它挂载时，它请求一个心跳区域项。这是通过调用心跳代码来实现的。在心跳代码中，查找区域项。在这里，心跳代码调用 <code>configfs_depend_item()</code>。如果调用成功，心跳知道该区域是安全的，可以分配给 <code>ocfs2</code>。如果失败，则表示该区域正在被拆除，心跳代码可以优雅地返回一个错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">How does this work? Imagine the ocfs2 mount process. When it mounts,</span><br><span class="line">it asks for a heartbeat region item. This is done via a call into the</span><br><span class="line">heartbeat code. Inside the heartbeat code, the region item is looked</span><br><span class="line">up. Here, the heartbeat code calls configfs_depend_item(). If it</span><br><span class="line">succeeds, then heartbeat knows the region is safe to give to ocfs2.</span><br><span class="line">If it fails, it was being torn down anyway, and</span><br><span class="line"></span><br><span class="line"> heartbeat can gracefully</span><br><span class="line">pass up an error.</span><br></pre></td></tr></table></figure><hr><h2 id="可提交项"><a href="#可提交项" class="headerlink" title="可提交项"></a>可提交项</h2><p>注意：可提交项当前未实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Committable Items]</span><br><span class="line"></span><br><span class="line">NOTE: Committable items are currently unimplemented.</span><br></pre></td></tr></table></figure><p>某些 <code>config_items</code> 无法拥有有效的初始状态。也就是说，无法为项目的属性指定默认值，以使项目能够执行其工作。用户空间必须配置一个或多个属性，之后子系统才能启动该项目所代表的实体。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Some config_items cannot have a valid initial state. That is, no</span><br><span class="line">default values can be specified for the item&#x27;s attributes such that the</span><br><span class="line">item can do its work. Userspace must configure one or more attributes,</span><br><span class="line">after which the subsystem can start whatever entity this item</span><br><span class="line">represents.</span><br></pre></td></tr></table></figure><p>考虑上面的 FakeNBD 设备。没有目标地址和目标设备，子系统无法知道要导入哪个块设备。简单示例假设子系统仅在所有属性都配置完成后连接。这确实可以工作，但现在每个属性存储都必须检查属性是否已初始化。一旦满足条件，每个属性存储都必须触发连接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Consider the FakeNBD device from above. Without a target address *and*</span><br><span class="line">a target device, the subsystem has no idea what block device to import.</span><br><span class="line">The simple example assumes that the subsystem merely waits until all the</span><br><span class="line">appropriate attributes are configured, and then connects. This will,</span><br><span class="line">indeed, work, but now every attribute store must check if the attributes</span><br><span class="line">are initialized. Every attribute store must fire off the connection if</span><br><span class="line">that condition is met.</span><br></pre></td></tr></table></figure><p>更好的方式是使用一个明确的操作通知子系统 <code>config_item</code> 已准备好。更重要的是，明确的操作可以让子系统提供反馈，说明属性是否以合理的方式进行了初始化。<code>configfs</code> 通过可提交项提供了此功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Far better would be an explicit action notifying the subsystem that the</span><br><span class="line">config_item is ready to go. More importantly, an explicit action allows</span><br><span class="line">the subsystem to provide feedback as to whether the attributes are</span><br><span class="line">initialized in a way that makes sense. configfs provides this as</span><br><span class="line">committable items.</span><br></pre></td></tr></table></figure><p><code>configfs</code> 仍然仅使用正常的文件系统操作。通过 <code>rename(2)</code> 提交一个项。该项从可以修改的目录移动到不能修改的目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configfs still uses only normal filesystem operations. An item is</span><br><span class="line">committed via rename(2). The item is moved from a directory where it</span><br><span class="line">can be modified to a directory where it cannot.</span><br></pre></td></tr></table></figure><p>任何提供 <code>ct_group_ops-&gt;commit_item()</code> 方法的组都拥有可提交的项。当该组出现在 <code>configfs</code> 中时，不能直接在组中使用 <code>mkdir(2)</code>。相反，该组将有两个子目录：“live”和“pending”。<code>live</code> 目录不支持 <code>mkdir(2)</code> 或 <code>rmdir(2)</code>。它只允许 <code>rename(2)</code>。<code>pending</code> 目录允许 <code>mkdir(2)</code> 和 <code>rmdir(2)</code>。一个项在 <code>pending</code> 目录中创建。其属性可以随意修改。用户空间通过将项重命名到 <code>live</code> 目录来提交该项。这时，子系统收到 <code>-&gt;commit_item()</code> 回调。如果所有必需属性都已填写，方法返回 0，项被移动到 <code>live</code> 目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Any group that provides the ct_group_ops-&gt;commit_item() method has</span><br><span class="line">committable items. When this group appears in configfs, mkdir(2) will</span><br><span class="line">not work directly in the group. Instead, the group will have two</span><br><span class="line">subdirectories: &quot;live&quot; and &quot;pending&quot;. The &quot;live&quot; directory does not</span><br><span class="line">support mkdir(2) or rmdir(2) either. It only allows rename(2). The</span><br><span class="line">&quot;pending&quot; directory does allow mkdir(2) and rmdir(2). An item is</span><br><span class="line">created in the &quot;pending&quot; directory. Its attributes can be modified at</span><br><span class="line">will. Userspace commits the item by renaming it into the &quot;live&quot;</span><br><span class="line">directory. At this point, the subsystem receives the -&gt;commit_item()</span><br><span class="line">callback. If all required attributes are filled to satisfaction, the</span><br><span class="line">method returns zero and the item is moved to the &quot;live&quot; directory.</span><br></pre></td></tr></table></figure><p>由于在 <code>live</code> 目录中无法使用 <code>rmdir(2)</code>，必须关闭或“取消提交”该项。同样，这可以通过 <code>rename(2)</code> 完成，这次是从 <code>live</code> 目录重命名回 <code>pending</code> 目录。子系统通过 <code>ct_group_ops-&gt;uncommit_object()</code> 方法收到通知。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">As rmdir(2) does not work in the &quot;live&quot; directory, an item must be</span><br><span class="line">shutdown, or &quot;uncommitted&quot;. Again, this is done via rename(2), this</span><br><span class="line">time from the &quot;live&quot; directory back to the &quot;pending&quot; one. The subsystem</span><br><span class="line">is notified by the ct_group_ops-&gt;uncommit_object() method.</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> configfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux USB mtp</title>
      <link href="/2024/09/17/Linux-USBmtp/"/>
      <url>/2024/09/17/Linux-USBmtp/</url>
      
        <content type="html"><![CDATA[<h2 id="USB-mtp-介绍"><a href="#USB-mtp-介绍" class="headerlink" title="USB mtp 介绍"></a>USB mtp 介绍</h2><p><a href="https://en.wikipedia.org/wiki/Media_Transfer_Protocol">https://en.wikipedia.org/wiki/Media_Transfer_Protocol</a></p><blockquote><p>from wiki:<br>MTP是一种高水平的文件传输协议，与通用串行总线大容量存储等通用存储协议相反。这意味着MTP客户端（计算机）看不到构成文件系统的数据结构的字节块数组，而是用文件和文件夹来表示MTP设备。这使得MTP设备可以参与高水平的操作（如更新其元信息索引），同时将文件系统的完整性掌握在自己手中。特别是，掉线传输（例如过早拔掉USB电缆）不会损坏设备文件系统。[6]MTP的非通用性会影响计算机操作系统如何向其他程序和用户呈现MTP设备。<br>根据其规范，MTP的</p><ul><li>主要目的是促进具有瞬态连接的媒体设备之间的通信。[5]</li><li>第二个目的是启用对连接设备的命令和控制。[5]电池供电的移动设备可以通过MTP报告其电池电量水平。[6]</li></ul><p>该协议最初是为跨USB使用而实现的，但扩展为跨TCP&#x2F;IP和蓝牙使用。Windows Vista支持TCP&#x2F;IP上的MTP。带有Windows Vista平台更新的Windows 7和Windows Vista也支持蓝牙上的MTP。[7]连接到MTP设备的主机称为MTP启动器，而设备本身是MTP响应器。[8]</p></blockquote><p>还是 wiki 介绍得更好，其他的随便看看</p><p><a href="https://www.cnblogs.com/skywang12345/p/3474206.html">https://www.cnblogs.com/skywang12345/p/3474206.html</a></p><blockquote><p><a href="https://wowothink.com/ffcaead/">https://wowothink.com/ffcaead/</a></p><p>1、UMS：USB mass storage，USB大容量存储，也被称为UMS，USB MSC。在旧版Android手机上会将其暴露给计算机，有如下几种缺点：</p><ul><li>USB mass storage是flash driver，外部hd，SD卡和其他USB存储设备使用的标准协议。驱动器使其自身完全对计算机可见，就像它是内部驱动器一样；</li><li><strong>这种方式存在问题。无论什么设备访问存储，都需要对其进行独占访问。</strong>将存储连接到计算机时，它与设备上运行的Android操作系统断开连接。存储在SD卡或USB存储器上的任何文件或应用程序在连接到计算机时都将不可用，此时是计算机独占；</li><li>由于必须可以从Windows设备访问文件系统，因此必须使用FAT文件系统对其进行格式化。 微软不仅拥有对FAT施加的专利，而且FAT也是一个较旧的，较慢的文件系统，没有现代许可系统。</li></ul><p>2、MTP：Media Transfer Protocol，媒体传输协议，主要用于传输媒体文件，当Android使用该协议，将其连接到电脑上，会显示一个媒体设备。该协议与USB mass storage的工作方式非常不同。</p><ul><li>MTP不会将Android设备的原始文件系统暴露给Windows，而是在文件级别运行；</li><li>Android设备不会将其整个存储设备暴露给Windows。 相反，当将设备连接到计算机时，计算机将查询设备，并且设备会响应其提供的文件和目录列表。</li><li>Android可以选择它呈现出来的文件，并隐藏系统文件，以便其他人无法查看或修改它们。 如果尝试删除或编辑无法修改的文件，设备将拒绝该请求，将会看到错误消息。</li><li><strong>计算机不需要对存储设备进行独占访问，因此无需连接存储，断开连接或为不同类型的数据分别设置分区</strong>。Android也可以使用它想要的ext4或任何其他文件系统，但Windows不必了解该文件系统。</li><li>在实践中，MTP的功能很像USB mass storage。 例如，MTP设备显示在Windows资源管理器中，因此您可以浏览和传输文件。</li></ul></blockquote><h2 id="libmtp-库"><a href="#libmtp-库" class="headerlink" title="libmtp 库"></a>libmtp 库</h2><p><a href="https://github.com/libmtp/libmtp">https://github.com/libmtp/libmtp</a></p><h2 id="Initiator-and-Responder"><a href="#Initiator-and-Responder" class="headerlink" title="Initiator and Responder"></a>Initiator and Responder</h2><p>libmtp implements an MTP initiator, which means it initiate<br>MTP sessions with devices. The devices responding are known<br>as MTP responders. libmtp runs on something with a USB host<br>controller interface, using libusb to access the host<br>controller.</p><p>If you’re more interested in the MTP responders, gadgets like<br>MP3 players, mobile phones etc, look into:</p><ul><li>MeeGo:s Buteo Sync:<br><a href="https://github.com/nemomobile/buteo-mtp">https://github.com/nemomobile/buteo-mtp</a><br><a href="https://wiki.merproject.org/wiki/Buteo/MTP">https://wiki.merproject.org/wiki/Buteo/MTP</a></li><li>Android has an MTP responder implementation:<br><a href="https://android.googlesource.com/platform/frameworks/base/+/master/media/jni/">https://android.googlesource.com/platform/frameworks/base/+/master/media/jni/</a></li><li>Ubuntu&#x2F;Ricardo Salveti has mtp-server and libmtp-server going:<br><a href="https://code.launchpad.net/~phablet-team/mtp/trunk">https://code.launchpad.net/~phablet-team/mtp/trunk</a><br><a href="https://bazaar.launchpad.net/~phablet-team/mtp/trunk/files">https://bazaar.launchpad.net/~phablet-team/mtp/trunk/files</a></li></ul><p>明显，libmtp 是主机端用的库，</p><h2 id="umtprd"><a href="#umtprd" class="headerlink" title="umtprd"></a>umtprd</h2><p>buildroot 编译 umtprd 工具，类似于 adbd 的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mtp tools</span><br><span class="line">BR2_PACKAGE_UMTPRD=y</span><br></pre></td></tr></table></figure><h3 id="configfs-配置-mtp-流程"><a href="#configfs-配置-mtp-流程" class="headerlink" title="configfs 配置 mtp 流程"></a>configfs 配置 mtp 流程</h3><h4 id="0-切换为-device-模式"><a href="#0-切换为-device-模式" class="headerlink" title="0. 切换为 device 模式"></a>0. 切换为 device 模式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> device &gt;/proc/cviusb/otg_role</span><br></pre></td></tr></table></figure><blockquote><p>参考 <a href="https://wowothink.com/6a85234b/">https://wowothink.com/6a85234b/</a></p></blockquote><h4 id="1-挂载-configfs"><a href="#1-挂载-configfs" class="headerlink" title="1. 挂载 configfs"></a>1. 挂载 configfs</h4><p>注册了一个名为usb_gadget的configfs子系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /tmp/usb</span><br><span class="line">mount none /tmp/usb -t configfs</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;[root@sg200x]~# tree /tmp/usb/</span><br><span class="line">&gt;/tmp/usb/</span><br><span class="line">&gt;└── usb_gadget</span><br><span class="line"></span><br><span class="line">&gt;1 directory, 0 files</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-创建复合设备"><a href="#2-创建复合设备" class="headerlink" title="2. 创建复合设备"></a>2. 创建复合设备</h4><p><code>mkdir usb_gadget/cvitek</code> 创建名为 cvitek 的usb复合设备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /tmp/usb/usb_gadget/cvitek</span><br></pre></td></tr></table></figure><p>在 cvitek 目录下会创建很多属性，</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@sg200x]/tmp/usb/usb_gadget# tree .</span><br><span class="line">.</span><br><span class="line">└── cvitek</span><br><span class="line">    ├── UDC</span><br><span class="line">    ├── bDeviceClass</span><br><span class="line">    ├── bDeviceProtocol</span><br><span class="line">    ├── bDeviceSubClass</span><br><span class="line">    ├── bMaxPacketSize0</span><br><span class="line">    ├── bcdDevice</span><br><span class="line">    ├── bcdUSB</span><br><span class="line">    ├── configs</span><br><span class="line">    ├── functions</span><br><span class="line">    ├── idProduct</span><br><span class="line">    ├── idVendor</span><br><span class="line">    ├── max_speed</span><br><span class="line">    ├── os_desc</span><br><span class="line">    │   ├── b_vendor_code</span><br><span class="line">    │   ├── qw_sign</span><br><span class="line">    │   └── use</span><br><span class="line">    └── strings</span><br><span class="line"></span><br><span class="line">5 directories, 13 files</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-1-配置PID和VID"><a href="#2-1-配置PID和VID" class="headerlink" title="2.1 配置PID和VID"></a>2.1 配置PID和VID</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0x3346 &gt;/tmp/usb/usb_gadget/cvitek/idVendor</span><br><span class="line"><span class="built_in">echo</span> 0x1003 &gt;/tmp/usb/usb_gadget/cvitek/idProduct</span><br></pre></td></tr></table></figure><h4 id="2-2-创建并配置-strings-子目录"><a href="#2-2-创建并配置-strings-子目录" class="headerlink" title="2.2 创建并配置 strings 子目录"></a>2.2 创建并配置 strings 子目录</h4><p>配置 strings 首先必须设置<code>language</code>，这里设置为<code>0x0409</code>表示使用的是<code>en-us</code>语言。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Set the product information string</span><br><span class="line">mkdir /tmp/usb/usb_gadget/cvitek/strings/0x409</span><br><span class="line">echo &quot;Cvitek&quot; &gt;/tmp/usb/usb_gadget/cvitek/strings/0x409/manufacturer</span><br><span class="line">echo &quot;USB Com Port&quot; &gt;/tmp/usb/usb_gadget/cvitek/strings/0x409/product</span><br><span class="line">echo &quot;0123456789&quot; &gt;/tmp/usb/usb_gadget/cvitek/strings/0x409/serialnumber</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;[root@sg200x]/tmp/usb/usb_gadget# tree .</span><br><span class="line">&gt;.</span><br><span class="line">&gt;└── cvitek</span><br><span class="line">   ├── UDC</span><br><span class="line">   ├── bDeviceClass</span><br><span class="line">   ├── bDeviceProtocol</span><br><span class="line">   ├── bDeviceSubClass</span><br><span class="line">   ├── bMaxPacketSize0</span><br><span class="line">   ├── bcdDevice</span><br><span class="line">   ├── bcdUSB</span><br><span class="line">   ├── configs</span><br><span class="line">   ├── functions</span><br><span class="line">   ├── idProduct</span><br><span class="line">   ├── idVendor</span><br><span class="line">   ├── max_speed</span><br><span class="line">   ├── os_desc</span><br><span class="line">   │   ├── b_vendor_code</span><br><span class="line">   │   ├── qw_sign</span><br><span class="line">   │   └── use</span><br><span class="line">   └── strings</span><br><span class="line">       └── 0x409</span><br><span class="line">           ├── manufacturer</span><br><span class="line">           ├── product</span><br><span class="line">           └── serialnumber</span><br><span class="line"></span><br><span class="line">&gt;6 directories, 16 files</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-3-创建configuration和字符串"><a href="#2-3-创建configuration和字符串" class="headerlink" title="2.3 创建configuration和字符串"></a>2.3 创建configuration和字符串</h4><p>创建配置 <code>c.1</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /tmp/usb/usb_gadget/cvitek/configs/c.1</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">[root@sg200x]/tmp/usb/usb_gadget# tree .</span><br><span class="line">.</span><br><span class="line">└── cvitek</span><br><span class="line">    ├── UDC</span><br><span class="line">    ├── bDeviceClass</span><br><span class="line">    ├── bDeviceProtocol</span><br><span class="line">    ├── bDeviceSubClass</span><br><span class="line">    ├── bMaxPacketSize0</span><br><span class="line">    ├── bcdDevice</span><br><span class="line">    ├── bcdUSB</span><br><span class="line">    ├── configs</span><br><span class="line">    │   └── c.1</span><br><span class="line">    │       ├── MaxPower</span><br><span class="line">    │       ├── bmAttributes</span><br><span class="line">    │       └── strings</span><br><span class="line">    ├── functions</span><br><span class="line">    ├── idProduct</span><br><span class="line">    ├── idVendor</span><br><span class="line">    ├── max_speed</span><br><span class="line">    ├── os_desc</span><br><span class="line">    │   ├── b_vendor_code</span><br><span class="line">    │   ├── qw_sign</span><br><span class="line">    │   └── use</span><br><span class="line">    └── strings</span><br><span class="line">        └── 0x409</span><br><span class="line">            ├── manufacturer</span><br><span class="line">            ├── product</span><br><span class="line">            └── serialnumber</span><br><span class="line"></span><br><span class="line">8 directories, 18 files</span><br></pre></td></tr></table></figure></blockquote><p>设置配置名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /tmp/usb/usb_gadget/cvitek/configs/c.1/strings/0x409</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;config1&quot;</span> &gt;/tmp/usb/usb_gadget/cvitek/configs/c.1/strings/0x409/configuration</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@sg200x]/tmp/usb/usb_gadget# tree .</span><br><span class="line">.</span><br><span class="line">└── cvitek</span><br><span class="line">    ├── UDC</span><br><span class="line">    ├── bDeviceClass</span><br><span class="line">    ├── bDeviceProtocol</span><br><span class="line">    ├── bDeviceSubClass</span><br><span class="line">    ├── bMaxPacketSize0</span><br><span class="line">    ├── bcdDevice</span><br><span class="line">    ├── bcdUSB</span><br><span class="line">    ├── configs</span><br><span class="line">    │   └── c.1</span><br><span class="line">    │       ├── MaxPower</span><br><span class="line">    │       ├── bmAttributes</span><br><span class="line">    │       └── strings</span><br><span class="line">    │           └── 0x409</span><br><span class="line">    │               └── configuration</span><br><span class="line">    ├── functions</span><br><span class="line">    ├── idProduct</span><br><span class="line">    ├── idVendor</span><br><span class="line">    ├── max_speed</span><br><span class="line">    ├── os_desc</span><br><span class="line">    │   ├── b_vendor_code</span><br><span class="line">    │   ├── qw_sign</span><br><span class="line">    │   └── use</span><br><span class="line">    └── strings</span><br><span class="line">        └── 0x409</span><br><span class="line">            ├── manufacturer</span><br><span class="line">            ├── product</span><br><span class="line">            └── serialnumber</span><br><span class="line"></span><br><span class="line">9 directories, 19 files</span><br></pre></td></tr></table></figure></blockquote><p>Set the MaxPower of USB descriptor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 120 &gt;/tmp/usb/usb_gadget/cvitek/configs/c.1/MaxPower</span><br></pre></td></tr></table></figure><h4 id="3-创建functions"><a href="#3-创建functions" class="headerlink" title="3. 创建functions"></a>3. 创建functions</h4><p><strong>一个USB复合设备会有多个功能，每个功能由function来表示，所谓的function就是USB设备支持的功能</strong>。当执行<code>mkdir functions/mass_storage.0</code>的时候，会调用<code>function_make()</code>函数，调用<code>usb_get_function_instance()</code>函数传入<code>mass_storage</code>字段，将会从现有的function list中找到与之匹配的function。现有的function list是由<code>drivers/usb/gadget/function/f_xxx.c</code>中进行添加的，这就将<code>f_xxx.c</code>联系起来了。</p><h4 id="3-1-创建-mtp-functions"><a href="#3-1-创建-mtp-functions" class="headerlink" title="3.1 创建 mtp functions"></a>3.1 创建 mtp functions</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /tmp/usb/usb_gadget/cvitek/functions/mtp.usb0</span><br></pre></td></tr></table></figure><p>内核还没开启相应配置的，就会报错。<code>USB_CONFIGFS_F_MTP=y</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@sg200x]/tmp/usb/usb_gadget<span class="comment"># mkdir /tmp/usb/usb_gadget/cvitek/functions/mtp</span></span><br><span class="line">.usb0</span><br><span class="line"><span class="built_in">mkdir</span>: can<span class="string">&#x27;t create directory &#x27;</span>/tmp/usb/usb_gadget/cvitek/functions/mtp.usb0<span class="string">&#x27;: No such file or directory</span></span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@sg200x]/tmp/usb/usb_gadget# tree .</span><br><span class="line">.</span><br><span class="line">└── cvitek</span><br><span class="line">    ├── UDC</span><br><span class="line">    ├── bDeviceClass</span><br><span class="line">    ├── bDeviceProtocol</span><br><span class="line">    ├── bDeviceSubClass</span><br><span class="line">    ├── bMaxPacketSize0</span><br><span class="line">    ├── bcdDevice</span><br><span class="line">    ├── bcdUSB</span><br><span class="line">    ├── configs</span><br><span class="line">    │   └── c.1</span><br><span class="line">    │       ├── MaxPower</span><br><span class="line">    │       ├── bmAttributes</span><br><span class="line">    │       └── strings</span><br><span class="line">    │           └── 0x409</span><br><span class="line">    │               └── configuration</span><br><span class="line">    ├── functions</span><br><span class="line">    │   └── mtp.usb0</span><br><span class="line">    ├── idProduct</span><br><span class="line">    ├── idVendor</span><br><span class="line">    ├── max_speed</span><br><span class="line">    ├── os_desc</span><br><span class="line">    │   ├── b_vendor_code</span><br><span class="line">    │   ├── qw_sign</span><br><span class="line">    │   └── use</span><br><span class="line">    └── strings</span><br><span class="line">        └── 0x409</span><br><span class="line">            ├── manufacturer</span><br><span class="line">            ├── product</span><br><span class="line">            └── serialnumber</span><br><span class="line"></span><br><span class="line">10 directories, 19 files</span><br></pre></td></tr></table></figure></blockquote><h4 id="4-将func和config关联起来"><a href="#4-将func和config关联起来" class="headerlink" title="4. 将func和config关联起来"></a>4. 将func和config关联起来</h4><p>执行<code>ln -s usb_gadget/cvitek/functions/mtp.usb0 usb_gadget/cvitek/configs/c.1</code>命令将新添加的<code>mtp</code>的<code>functions</code>添加到<code>configuration</code>对应的function list中，表示当前usb复合设备中新增了一个function。这时候调用的是<code>config_usb_cfg_link()</code>函数。至此，<code>functions</code>和<code>configuration</code>关联起来了。接下来要将<code>configuration</code>与特定的UDC设备连接起来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /tmp/usb/usb_gadget/cvitek/functions/mtp.usb0 /tmp/usb/usb_gadget/cvitek/configs/c.1</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[root@sg200x]/tmp/usb/usb_gadget# tree .</span><br><span class="line">.</span><br><span class="line">└── cvitek</span><br><span class="line">    ├── UDC</span><br><span class="line">    ├── bDeviceClass</span><br><span class="line">    ├── bDeviceProtocol</span><br><span class="line">    ├── bDeviceSubClass</span><br><span class="line">    ├── bMaxPacketSize0</span><br><span class="line">    ├── bcdDevice</span><br><span class="line">    ├── bcdUSB</span><br><span class="line">    ├── configs</span><br><span class="line">    │   └── c.1</span><br><span class="line">    │       ├── MaxPower</span><br><span class="line">    │       ├── bmAttributes</span><br><span class="line">    │       ├── mtp.usb0 -&gt; ../../../../usb_gadget/cvitek/functions/mtp.usb0</span><br><span class="line">    │       └── strings</span><br><span class="line">    │           └── 0x409</span><br><span class="line">    │               └── configuration</span><br><span class="line">    ├── functions</span><br><span class="line">    │   └── mtp.usb0</span><br><span class="line">    ├── idProduct</span><br><span class="line">    ├── idVendor</span><br><span class="line">    ├── max_speed</span><br><span class="line">    ├── os_desc</span><br><span class="line">    │   ├── b_vendor_code</span><br><span class="line">    │   ├── qw_sign</span><br><span class="line">    │   └── use</span><br><span class="line">    └── strings</span><br><span class="line">        └── 0x409</span><br><span class="line">            ├── manufacturer</span><br><span class="line">            ├── product</span><br><span class="line">            └── serialnumber</span><br><span class="line"></span><br><span class="line">11 directories, 19 files</span><br></pre></td></tr></table></figure></blockquote><hr><h4 id="5-绑定到UDC，使能gadget"><a href="#5-绑定到UDC，使能gadget" class="headerlink" title="5. 绑定到UDC，使能gadget"></a>5. 绑定到UDC，使能gadget</h4><p>执行<code>echo xxx &gt; usb_gadget/g1/UDC</code>命令，就会调用<code>gadget_dev_desc_UDC_store()</code>函数，这里面调用<code>usb composite framework</code>中的<code>usb_gadget_probe_driver()</code>函数将gadget driver与USB Controller Driver绑定，这里的<code>Gadget Driver</code>就是与我们创建的usb复合设备对应的驱动，接下来就会走一系列的<code>bind</code>流程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Start the gadget driver</span></span><br><span class="line">CVI_UDC=$(<span class="built_in">ls</span> /sys/class/udc/ | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;CVI_UDC&#125;</span> &gt;/tmp/usb/usb_gadget/cvitek/UDC</span><br></pre></td></tr></table></figure><h4 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"># 0. 切换为 device 模式</span><br><span class="line">echo device &gt;/proc/cviusb/otg_role</span><br><span class="line"># 1. 挂载 configfs</span><br><span class="line">mkdir -p /tmp/usb</span><br><span class="line">mount none /tmp/usb -t configfs</span><br><span class="line"># 2. 创建复合设备</span><br><span class="line">mkdir -p /tmp/usb/usb_gadget/cvitek</span><br><span class="line"># 2.1 配置PID和VID</span><br><span class="line">echo 0x3346 &gt;/tmp/usb/usb_gadget/cvitek/idVendor</span><br><span class="line">echo 0x1003 &gt;/tmp/usb/usb_gadget/cvitek/idProduct</span><br><span class="line"># 2.2 创建并配置 strings 子目录</span><br><span class="line">mkdir /tmp/usb/usb_gadget/cvitek/strings/0x409</span><br><span class="line">echo &quot;Cvitek&quot; &gt;/tmp/usb/usb_gadget/cvitek/strings/0x409/manufacturer</span><br><span class="line">echo &quot;USB Com Port&quot; &gt;/tmp/usb/usb_gadget/cvitek/strings/0x409/product</span><br><span class="line">echo &quot;0123456789&quot; &gt;/tmp/usb/usb_gadget/cvitek/strings/0x409/serialnumber</span><br><span class="line"># 2.3 创建configuration和字符串</span><br><span class="line">mkdir /tmp/usb/usb_gadget/cvitek/configs/c.1</span><br><span class="line">mkdir /tmp/usb/usb_gadget/cvitek/configs/c.1/strings/0x409</span><br><span class="line">echo &quot;config1&quot; &gt;/tmp/usb/usb_gadget/cvitek/configs/c.1/strings/0x409/configuration</span><br><span class="line"></span><br><span class="line">echo 120 &gt;/tmp/usb/usb_gadget/cvitek/configs/c.1/MaxPower</span><br><span class="line"># 3. 创建functions</span><br><span class="line">mkdir /tmp/usb/usb_gadget/cvitek/functions/mtp.usb0</span><br><span class="line"># 4. 将func和config关联起来</span><br><span class="line">ln -s /tmp/usb/usb_gadget/cvitek/functions/mtp.usb0 /tmp/usb/usb_gadget/cvitek/configs/c.1</span><br><span class="line"></span><br><span class="line">##########</span><br><span class="line">mkdir /dev/ffs-umtp</span><br><span class="line">mount -t functionfs mtp /dev/ffs-umtp</span><br><span class="line"># Start the umtprd service</span><br><span class="line">umtprd &amp;</span><br><span class="line"></span><br><span class="line"># 5. 绑定到UDC，使能gadget</span><br><span class="line">CVI_UDC=$(ls /sys/class/udc/ | awk &#x27;&#123;print $1&#125;&#x27;)</span><br><span class="line">echo $&#123;CVI_UDC&#125; &gt;/tmp/usb/usb_gadget/cvitek/UDC</span><br></pre></td></tr></table></figure><h3 id="umptrd-源码"><a href="#umptrd-源码" class="headerlink" title="umptrd 源码"></a>umptrd 源码</h3><p><a href="https://github.com/viveris/uMTP-Responder/tree/master/conf">https://github.com/viveris/uMTP-Responder/tree/master/conf</a></p><p>官方提供了一个配置脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># FunctionFS uMTPrd startup example/test script</span></span><br><span class="line"><span class="comment"># Must be launched from a writable/temporary folder.</span></span><br><span class="line"></span><br><span class="line">modprobe libcomposite</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> cfg</span><br><span class="line">mount none cfg -t configfs</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> cfg/usb_gadget/g1</span><br><span class="line"><span class="built_in">cd</span> cfg/usb_gadget/g1</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> configs/c.1</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> <span class="built_in">functions</span>/ffs.mtp</span><br><span class="line"><span class="comment"># Uncomment / Change the follow line to enable another usb gadget function</span></span><br><span class="line"><span class="comment">#mkdir functions/acm.usb0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> strings/0x409</span><br><span class="line"><span class="built_in">mkdir</span> configs/c.1/strings/0x409</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 0x0100 &gt; idProduct</span><br><span class="line"><span class="built_in">echo</span> 0x1D6B &gt; idVendor</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;01234567&quot;</span> &gt; strings/0x409/serialnumber</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Viveris Technologies&quot;</span> &gt; strings/0x409/manufacturer</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;The Viveris Product !&quot;</span> &gt; strings/0x409/product</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Conf 1&quot;</span> &gt; configs/c.1/strings/0x409/configuration</span><br><span class="line"><span class="built_in">echo</span> 120 &gt; configs/c.1/MaxPower</span><br><span class="line"></span><br><span class="line"><span class="built_in">ln</span> -s <span class="built_in">functions</span>/ffs.mtp configs/c.1</span><br><span class="line"><span class="comment"># Uncomment / Change the follow line to enable another usb gadget function</span></span><br><span class="line"><span class="comment">#ln -s functions/acm.usb0 configs/c.1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> /dev/ffs-umtp</span><br><span class="line">mount -t functionfs mtp /dev/ffs-umtp</span><br><span class="line"><span class="comment"># Start the umtprd service</span></span><br><span class="line">umtprd &amp;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ../../..</span><br><span class="line"></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># enable the usb functions</span></span><br><span class="line"><span class="built_in">ls</span> /sys/class/udc/ &gt; cfg/usb_gadget/g1/UDC</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount -t functionfs mtp /dev/ffs-umtp</span><br><span class="line">mount: mounting mtp on /dev/ffs-umtp failed: No such device</span><br></pre></td></tr></table></figure><p><code>CONFIG_USB_FUNCTIONFS=y</code> 可解决上面的问题。</p>]]></content>
      
      
      <categories>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> USB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cvitek-busybox init/reboot/poweroff</title>
      <link href="/2024/09/11/Cvitek-reboot/"/>
      <url>/2024/09/11/Cvitek-reboot/</url>
      
        <content type="html"><![CDATA[<h2 id="reboot-x2F-poweroff"><a href="#reboot-x2F-poweroff" class="headerlink" title="reboot&#x2F;poweroff"></a>reboot&#x2F;poweroff</h2><p><code>boards/default/dts/cv181x/cv181x_base.dtsi</code> 中定义了 <code>restart-controller</code> 设备。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">restart:</span> <span class="title class_">restart-controller</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">compatible</span> <span class="operator">=</span> <span class="string">&quot;cvitek,restart&quot;</span><span class="punctuation">;</span></span><br><span class="line"><span class="attr">reg</span> <span class="operator">=</span> <span class="params">&lt;<span class="number">0x0</span> <span class="number">0x05025000</span> <span class="number">0x0</span> <span class="number">0x2000</span>&gt;</span><span class="punctuation">;</span></span><br><span class="line"><span class="punctuation">&#125;;</span></span><br></pre></td></tr></table></figure><p><code>drivers/power/reset/cvi-reboot.c</code> 中实现了对应的一个平台驱动：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">of_device_id</span> <span class="title">cvi_reboot_of_match</span>[] =</span> &#123;</span><br><span class="line">&#123; .compatible = <span class="string">&quot;cvitek,restart&quot;</span> &#125;,</span><br><span class="line">&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">cvi_reboot_driver</span> =</span> &#123;</span><br><span class="line">.probe = cvi_reboot_probe,</span><br><span class="line">.driver = &#123;</span><br><span class="line">.name = <span class="string">&quot;cvi-reboot&quot;</span>,</span><br><span class="line">.of_match_table = cvi_reboot_of_match,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>主要看下 <code>cvi_reboot_probe</code>，它做的事情很简单，注册 <code>restart</code> 以及 <code>poweroff</code> 的回调处理函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">cvi_restart_nb</span> =</span> &#123;</span><br><span class="line">.notifier_call = cvi_restart_handler,</span><br><span class="line">.priority = <span class="number">128</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cvi_reboot_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device_node</span> *<span class="title">np</span> =</span> pdev-&gt;dev.of_node;</span><br><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据设备树信息调用 ioremap 映射基址 0x05025000, size 0x2000</span></span><br><span class="line">base = of_iomap(np, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (!base) &#123;</span><br><span class="line">WARN(<span class="number">1</span>, <span class="string">&quot;failed to map base address&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 restart 的回调函数</span></span><br><span class="line">err = register_restart_handler(&amp;cvi_restart_nb);</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">dev_err(&amp;pdev-&gt;dev, <span class="string">&quot;cannot register restart handler (err=%d)\n&quot;</span>,</span><br><span class="line">err);</span><br><span class="line">iounmap(base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 poweroff 的回调函数</span></span><br><span class="line">pm_power_off = &amp;cvi_do_pwroff;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="reboot-调用链"><a href="#reboot-调用链" class="headerlink" title="reboot 调用链"></a>reboot 调用链</h2><p>上面只是在了 kernel 中注册了一个 reboot 指令的一个回调函数，但 reboot 的完整流程:</p><blockquote><p><a href="https://blog.csdn.net/davion_zhang/article/details/52233043">https://blog.csdn.net/davion_zhang/article/details/52233043</a></p></blockquote><p><img src="/../images/Cvitek-reboot/Center.jpeg" alt="reboot"></p><p>普通的reboot是通过busybox为入口，进入halt_main函数，然后给init进程发送SIGTERM信号，init进程接收到信号后给其他进程发送终止信号，最后调用C库函数reboot，reboot通过系统调用sys_reboot进入内核，内核将整个系统重启。<strong>其中在shell中执行reboot –f则通过halt_main直接调用C函数reboot，不经过init进程</strong>。</p><h3 id="reboot-应用层实现"><a href="#reboot-应用层实现" class="headerlink" title="reboot 应用层实现"></a>reboot 应用层实现</h3><p>reboot 本身也只是 busybox 实现的。所以看 busybox 的源码就好。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@milkv-duo]~<span class="comment"># whereis reboot</span></span><br><span class="line">reboot: /sbin/reboot</span><br><span class="line">[root@milkv-duo]~<span class="comment"># cd /sbin/</span></span><br><span class="line">[root@milkv-duo]/sbin<span class="comment"># ll reboot</span></span><br><span class="line">lrwxrwxrwx 1 root root 14 Aug  1  2024 reboot -&gt; ../bin/busybox*</span><br></pre></td></tr></table></figure><p><strong>✨✨✨✨✨✨✨ 实际上，reboot、poweroff、CTRL-ALT-DEL 等都是由INIT 进程去处理的，init 进程中配置了 信号-信号处理函数，reboot、poweroff、CTRL-ALT-DEL 本质上都是给init 进程发送信号，从而让 init 进去去执行相应的动作。<br>USR1&#x2F;TERM&#x2F;USR2&#x2F;INT: run halt&#x2F;reboot&#x2F;poweroff&#x2F;Ctrl-Alt-Del script。所以，你可以通过 <code>kill -s SIGTERM 1</code> 实现reboot操作，其余类似。所以，得熟悉  <a href="./Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7.md">信号</a>✨✨✨✨✨✨✨✨✨✨</strong></p><p>基于上面的结论，再来看代码。在 <code>init/init.c halt.c</code> 中，reboot 的具体实现是这样的：</p><p>首先，有个全局变量 G 。数据结构如下所示，主要包含一个action list代表初始化过程会执行的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">globals</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">init_action</span> *<span class="title">init_action_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !ENABLE_FEATURE_INIT_SYSLOG</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *log_console;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">sigset_t</span> delayed_sigset;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">zero_ts</span>;</span></span><br><span class="line">&#125; FIX_ALIASING;</span><br></pre></td></tr></table></figure><p>init进程本身是通过信号传递消息，进而处理对应的动作。这里主要先通过 <a href="./Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7.md">sigprocmask</a> 把一些影响系统启动的信号进行阻塞。防止干扰前期初始化过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">init_main</span><span class="params">(<span class="type">int</span> argc UNUSED_PARAM, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line"></span><br><span class="line">INIT_G();</span><br><span class="line"><span class="comment">/* Some users send poweroff signals to init VERY early.</span></span><br><span class="line"><span class="comment"> * To handle this, mask signals early.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">sigaddset(&amp;G.delayed_sigset, SIGINT);  <span class="comment">/* Ctrl-Alt-Del */</span></span><br><span class="line">sigaddset(&amp;G.delayed_sigset, SIGQUIT); <span class="comment">/* re-exec another init */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SIGPWR</span></span><br><span class="line">sigaddset(&amp;G.delayed_sigset, SIGPWR);  <span class="comment">/* halt */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">sigaddset(&amp;G.delayed_sigset, SIGUSR1); <span class="comment">/* halt */</span></span><br><span class="line">sigaddset(&amp;G.delayed_sigset, SIGTERM); <span class="comment">/* reboot */</span></span><br><span class="line">sigaddset(&amp;G.delayed_sigset, SIGUSR2); <span class="comment">/* poweroff */</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_FEATURE_USE_INITTAB</span></span><br><span class="line">sigaddset(&amp;G.delayed_sigset, SIGHUP);  <span class="comment">/* reread /etc/inittab */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">sigaddset(&amp;G.delayed_sigset, SIGCHLD); <span class="comment">/* make sigtimedwait() exit on SIGCHLD */</span></span><br><span class="line">sigprocmask(SIG_BLOCK, &amp;G.delayed_sigset, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>如果参数带了-q就直接给 进程1 （init）发送 SIGHUP 信号.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (argv[<span class="number">1</span>] &amp;&amp; <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-q&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> kill(<span class="number">1</span>, SIGHUP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>init进程的进程号必须是1.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !DEBUG_INIT</span></span><br><span class="line"><span class="comment">/* Expect to be invoked as init with PID=1 or be invoked as linuxrc */</span></span><br><span class="line"><span class="keyword">if</span> (getpid() != <span class="number">1</span></span><br><span class="line"> &amp;&amp; (!ENABLE_LINUXRC || applet_name[<span class="number">0</span>] != <span class="string">&#x27;l&#x27;</span>) <span class="comment">/* not linuxrc? */</span></span><br><span class="line">) &#123;</span><br><span class="line">bb_simple_error_msg_and_die(<span class="string">&quot;must be run as PID 1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> RB_DISABLE_CAD</span></span><br><span class="line"><span class="comment">/* Turn off rebooting via CTL-ALT-DEL - we get a</span></span><br><span class="line"><span class="comment"> * SIGINT on CAD so we can shut things down gracefully... */</span></span><br><span class="line">reboot(RB_DISABLE_CAD); <span class="comment">/* misnomer */</span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>设置环境变量，如果有参数的话，设置 RUNLEVEL</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Make sure environs is set to something sane */</span></span><br><span class="line">putenv((<span class="type">char</span> *) <span class="string">&quot;HOME=/&quot;</span>);</span><br><span class="line">putenv((<span class="type">char</span> *) bb_PATH_root_path);</span><br><span class="line">putenv((<span class="type">char</span> *) <span class="string">&quot;SHELL=/bin/sh&quot;</span>);</span><br><span class="line">putenv((<span class="type">char</span> *) <span class="string">&quot;USER=root&quot;</span>); <span class="comment">/* needed? why? */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argv[<span class="number">1</span>])</span><br><span class="line">xsetenv(<span class="string">&quot;RUNLEVEL&quot;</span>, argv[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@milkv-duo]/sbin<span class="comment"># printenv</span></span><br><span class="line">USER=root</span><br><span class="line">HOSTNAME=milkv-duo</span><br><span class="line">SHLVL=1</span><br><span class="line">LD_LIBRARY_PATH=/mnt/system/lib:/mnt/system/usr/lib</span><br><span class="line">HOME=/root</span><br><span class="line">OLDPWD=/root</span><br><span class="line">TERMINFO=/usr/share/terminfo</span><br><span class="line">PAGER=/bin/more</span><br><span class="line">PS1=[\u@\h]\w\$</span><br><span class="line">LOGNAME=root</span><br><span class="line">TERM=vt100</span><br><span class="line">PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:/mnt/system/usr/bin:/mnt/system/usr/sbin</span><br><span class="line">SHELL=/bin/sh</span><br><span class="line">PWD=/sbin</span><br><span class="line">EDITOR=/bin/vi</span><br></pre></td></tr></table></figure><p>非单用户模式下，读取 &#x2F;etc&#x2F;inittab。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Check if we are supposed to be in single user mode */</span></span><br><span class="line"><span class="keyword">if</span> (argv[<span class="number">1</span>]</span><br><span class="line"> &amp;&amp; (<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;single&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;-s&quot;</span>) == <span class="number">0</span> || LONE_CHAR(argv[<span class="number">1</span>], <span class="string">&#x27;1&#x27;</span>))</span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">/* ??? shouldn&#x27;t we set RUNLEVEL=&quot;b&quot; here? */</span></span><br><span class="line"><span class="comment">/* Start a shell on console */</span></span><br><span class="line">new_init_action(RESPAWN, bb_default_login_shell, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/* Not in single user mode - see what inittab says */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* NOTE that if CONFIG_FEATURE_USE_INITTAB is NOT defined,</span></span><br><span class="line"><span class="comment"> * then parse_inittab() simply adds in some default</span></span><br><span class="line"><span class="comment"> * actions (i.e., INIT_SCRIPT and a pair</span></span><br><span class="line"><span class="comment"> * of &quot;askfirst&quot; shells) */</span></span><br><span class="line">parse_inittab();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://elixir.bootlin.com/busybox/1.36.1/source/init/init.c#L1248">https://elixir.bootlin.com/busybox/1.36.1/source/init/init.c#L1248</a><br>即使没有 &#x2F;etc&#x2F;inittab 文件，也有默认配置。<br>这个文件非常重要💥💥，这是只关注 action 和 process<br>Valid actions include: <strong>sysinit, respawn, askfirst, wait, once, restart, ctrlaltdel, and shutdown</strong>.\n”</p><p><strong>Run only-once actions:</strong></p><ul><li>sysinit: ‘sysinit’ is the first item run on boot. init waits until all sysinit actions are completed before continuing.</li><li>wait: then all ‘wait’ actions are run. wait’ actions, like ‘sysinit’ actions, cause init to wait until the specified task completes.</li><li>once: ‘once’ actions are asynchronous, therefore, init does not wait for them to complete.</li><li>restart: ‘restart’ is the action taken to restart the init process. By default this should simply run &#x2F;sbin&#x2F;init, but can be a script which runs pivot_root or it can do all sorts of other interesting things.</li><li>ctrlaltdel: run when the system detects that someone on the system console has pressed the CTRL-ALT-DEL key combination. Typically one wants to run ‘reboot’ at this point to cause the system to reboot.</li><li>shutdown: Finally the ‘shutdown’ action specifies the actions to taken when init is told to reboot. Unmounting filesystems and disabling swap is a very good here.</li></ul><p><strong>Run repeatedly actions</strong>:</p><ul><li>respawn: ‘respawn’ actions are run after the ‘once’ actions. When a process started with a ‘respawn’ action exits, init automatically restarts it. Unlike sysvinit, BusyBox init does not stop processes from respawning out of control. emmm 就是 ctrl+d 时又重新有登陆吗？</li><li>askfirst: The ‘askfirst’ actions acts just like respawn, except that before running the specified process it displays the line &quot;Please press Enter to activate this console.&quot; and then waits for the user to press enter before starting the specified process.</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//usage:&quot;BusyBox init works just fine without an inittab. If no inittab is found,\n&quot;</span><br><span class="line">//usage:&quot;it has the following default behavior:\n&quot;</span><br><span class="line">//usage:&quot;\n&quot;</span><br><span class="line">//usage:&quot;::sysinit:/etc/init.d/rcS\n&quot;</span><br><span class="line">//usage:&quot;::askfirst:/bin/sh\n&quot;</span><br><span class="line">//usage:&quot;::ctrlaltdel:/sbin/reboot\n&quot;</span><br><span class="line">//usage:&quot;::shutdown:/sbin/swapoff -a\n&quot;</span><br><span class="line">//usage:&quot;::shutdown:/bin/umount -a -r\n&quot;</span><br><span class="line">//usage:&quot;::restart:/sbin/init\n&quot;</span><br><span class="line">//usage:&quot;tty2::askfirst:/bin/sh\n&quot;</span><br><span class="line">//usage:&quot;tty3::askfirst:/bin/sh\n&quot;</span><br><span class="line">//usage:&quot;tty4::askfirst:/bin/sh\n&quot;</span><br><span class="line">//usage:&quot;\n&quot;</span><br><span class="line">//usage:&quot;If you choose to use an /etc/inittab file, the inittab entry format is as follows:\n&quot;</span><br><span class="line">//usage:&quot;\n&quot;</span><br><span class="line">//usage:&quot;&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;\n&quot;</span><br></pre></td></tr></table></figure><p>demo in ramdisk&#x2F;rootfs&#x2F;common_musl_riscv64&#x2F;etc&#x2F;inittab</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># Format for each entry: &lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br><span class="line">#</span><br><span class="line"># id        == tty to run on, or empty for /dev/console</span><br><span class="line"># runlevels == ignored</span><br><span class="line"># action    == one of sysinit, respawn, askfirst, wait, and once</span><br><span class="line"># process   == program to run</span><br><span class="line"></span><br><span class="line"># Startup the system</span><br><span class="line">::sysinit:/sbin/mdev -s</span><br><span class="line">::sysinit:/bin/mkdir -p /dev/pts</span><br><span class="line">::sysinit:/bin/mkdir -p /dev/shm</span><br><span class="line">::sysinit:/bin/mount -a</span><br><span class="line">null::sysinit:/bin/hostname -F /etc/hostname</span><br><span class="line"></span><br><span class="line"># now run any rc scripts</span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"></span><br><span class="line"># now run any post scripts</span><br><span class="line">::sysinit:/etc/init.d/rcP</span><br><span class="line"></span><br><span class="line"># Put a getty on the serial port</span><br><span class="line">console::respawn:/sbin/getty -L  console 115200 vt100 -n -l /usr/local/bin/autologin</span><br><span class="line"></span><br><span class="line"># Stuff to do for the 3-finger salute</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line"></span><br><span class="line"># Stuff to do before rebooting</span><br><span class="line">::shutdown:/etc/init.d/rcK</span><br><span class="line">::shutdown:/sbin/swapoff -a</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br></pre></td></tr></table></figure><p>顺序执行 &#x2F;etc&#x2F;inittab 中的事情。All actions are run in the order they appear in &#x2F;etc&#x2F;inittab.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now run everything that needs to be run */</span></span><br><span class="line"><span class="comment">/* First run the sysinit command */</span></span><br><span class="line">run_actions(SYSINIT);</span><br><span class="line">check_delayed_sigs(&amp;G.zero_ts);</span><br><span class="line"><span class="comment">/* Next run anything that wants to block */</span></span><br><span class="line">run_actions(WAIT);</span><br><span class="line">check_delayed_sigs(&amp;G.zero_ts);</span><br><span class="line"><span class="comment">/* Next run anything to be run only once */</span></span><br><span class="line">run_actions(ONCE);</span><br></pre></td></tr></table></figure><p>可以看到 <code>SYSINIT | WAIT | CTRLALTDEL | SHUTDOWN</code> 4 种类型的任务都是阻塞的，等一个命令执行完才会继续执行下一个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Run all commands of a particular type */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_actions</span><span class="params">(<span class="type">int</span> action_type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">init_action</span> *<span class="title">a</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (a = G.init_action_list; a; a = a-&gt;next) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(a-&gt;action_type &amp; action_type))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a-&gt;action_type &amp; (SYSINIT | WAIT | ONCE | CTRLALTDEL | SHUTDOWN)) &#123;</span><br><span class="line"><span class="type">pid_t</span> pid = run(a);</span><br><span class="line"><span class="keyword">if</span> (a-&gt;action_type &amp; (SYSINIT | WAIT | CTRLALTDEL | SHUTDOWN))</span><br><span class="line">waitfor(pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a-&gt;action_type &amp; (RESPAWN | ASKFIRST)) &#123;</span><br><span class="line"><span class="comment">/* Only run stuff with pid == 0. If pid != 0,</span></span><br><span class="line"><span class="comment"> * it is already running</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (a-&gt;pid == <span class="number">0</span>)</span><br><span class="line">a-&gt;pid = run(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 init 进程主要是通过信号来处理消息，init 进程本身并不会退出，而是阻塞休眠。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Now run the looping stuff for the rest of forever */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* (Re)run the respawn/askfirst stuff */</span></span><br><span class="line">run_actions(RESPAWN | ASKFIRST);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for any signal (typically it&#x27;s SIGCHLD) */</span></span><br><span class="line">⛔⛔⛔⛔ 就这里是阻塞，直到有信号到来。</span><br><span class="line">check_delayed_sigs(<span class="literal">NULL</span>); <span class="comment">/* NULL timespec makes it wait */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for any child process(es) to exit */</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="type">pid_t</span> wpid;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">init_action</span> *<span class="title">a</span>;</span></span><br><span class="line"></span><br><span class="line">wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG);</span><br><span class="line"><span class="keyword">if</span> (wpid &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">a = mark_terminated(wpid);</span><br><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">message(L_LOG, <span class="string">&quot;process &#x27;%s&#x27; (pid %u) exited. &quot;</span></span><br><span class="line"><span class="string">&quot;Scheduling for restart.&quot;</span>,</span><br><span class="line">a-&gt;command, (<span class="type">unsigned</span>)wpid);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Don&#x27;t consume all CPU time - sleep a bit */</span></span><br><span class="line">sleep1();</span><br><span class="line">&#125; <span class="comment">/* while (1) */</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">check_delayed_sigs</span><span class="params">(<span class="keyword">struct</span> timespec *ts)</span></span><br><span class="line">&#123;</span><br><span class="line">⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔ 就这里是阻塞，直到有信号到来。</span><br><span class="line"><span class="type">int</span> sig = sigtimedwait(&amp;G.delayed_sigset, <span class="comment">/* siginfo_t */</span> <span class="literal">NULL</span>, ts);</span><br><span class="line"><span class="keyword">if</span> (sig &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The signal &quot;sig&quot; was caught */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ENABLE_FEATURE_USE_INITTAB</span></span><br><span class="line"><span class="keyword">if</span> (sig == SIGHUP)</span><br><span class="line">reload_inittab();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">不同信号，不同处理。</span><br><span class="line"><span class="keyword">if</span> (sig == SIGINT)</span><br><span class="line">run_actions(CTRLALTDEL);</span><br><span class="line"><span class="keyword">if</span> (sig == SIGQUIT) &#123;</span><br><span class="line">exec_restart_action();</span><br><span class="line"><span class="comment">/* returns only if no restart action defined */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; sig) &amp; (<span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SIGPWR</span></span><br><span class="line">    | (<span class="number">1</span> &lt;&lt; SIGPWR)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    | (<span class="number">1</span> &lt;&lt; SIGUSR1)</span><br><span class="line">    | (<span class="number">1</span> &lt;&lt; SIGUSR2)</span><br><span class="line">    | (<span class="number">1</span> &lt;&lt; SIGTERM)</span><br><span class="line">)) &#123;</span><br><span class="line"><span class="comment">/* reboot, poweroff, or halt */</span></span><br><span class="line">halt_reboot_pwoff(sig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* if (sig == SIGCHLD) do nothing */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">halt_reboot_pwoff</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *m;</span><br><span class="line"><span class="type">unsigned</span> rb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We may call run() and it unmasks signals,</span></span><br><span class="line"><span class="comment"> * including the one masked inside this signal handler.</span></span><br><span class="line"><span class="comment"> * Testcase which would start multiple reboot scripts:</span></span><br><span class="line"><span class="comment"> *  while true; do reboot; done</span></span><br><span class="line"><span class="comment"> * Preventing it:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">reset_sighandlers_and_unblock_sigs();</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://elixir.bootlin.com/busybox/1.36.1/source/init/init.c#L758</span></span><br><span class="line">    <span class="comment">// run_actions(SHUTDOWN); 这里运行 inittab 中定义的 shutdown  📢📢📢📢📢📢📢📢📢📢📢📢📢</span></span><br><span class="line"><span class="comment">// kill(-1, SIGTERM);</span></span><br><span class="line">    <span class="comment">// kill(-1, SIGKILL);</span></span><br><span class="line">    <span class="comment">// 延时后再次发送SIGKILL信号，这里说明一下为什么要发送SIGKILL信号，一般的SIGINT和SIGTERM信号都可以屏蔽或转作他用，SIGKILL信号是不可被屏蔽的，</span></span><br><span class="line">run_shutdown_and_kill_processes();</span><br><span class="line"></span><br><span class="line">m = <span class="string">&quot;halt&quot;</span>;</span><br><span class="line">rb = RB_HALT_SYSTEM;</span><br><span class="line"><span class="keyword">if</span> (sig == SIGTERM) &#123;</span><br><span class="line">m = <span class="string">&quot;reboot&quot;</span>;</span><br><span class="line">rb = RB_AUTOBOOT;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sig == SIGUSR2) &#123;</span><br><span class="line">m = <span class="string">&quot;poweroff&quot;</span>;</span><br><span class="line">rb = RB_POWER_OFF;</span><br><span class="line">&#125;</span><br><span class="line">message(L_CONSOLE, <span class="string">&quot;Requesting system %s&quot;</span>, m);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">pause_and_low_level_reboot(rb); <span class="comment">// reboot(magic);</span></span><br><span class="line"><span class="comment">/* not reached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="库函数-musl-clib"><a href="#库函数-musl-clib" class="headerlink" title="库函数 musl clib"></a>库函数 musl clib</h3><p><a href="https://elixir.bootlin.com/musl/v1.2.5/source/src/linux/reboot.c#L4">https://elixir.bootlin.com/musl/v1.2.5/source/src/linux/reboot.c#L4</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">type:</span><br><span class="line"><span class="comment">/* Perform a hard reset now.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_AUTOBOOT0x01234567</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Halt the system.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_HALT_SYSTEM0xcdef0123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable reboot using Ctrl-Alt-Delete keystroke.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_ENABLE_CAD0x89abcdef</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Disable reboot using Ctrl-Alt-Delete keystroke.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_DISABLE_CAD0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Stop system and switch power off if possible.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_POWER_OFF0x4321fedc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Suspend system using software suspend.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_SW_SUSPEND0xd000fce2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reboot system into new kernel.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RB_KEXEC0x45584543</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">reboot</span><span class="params">(<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> syscall(SYS_reboot, <span class="number">0xfee1dead</span>, <span class="number">672274793</span>, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel/reboot.c https://elixir.bootlin.com/linux/v5.10.186/source/kernel/reboot.c#L310</span></span><br><span class="line">SYSCALL_DEFINE4(reboot, <span class="type">int</span>, magic1, <span class="type">int</span>, magic2, <span class="type">unsigned</span> <span class="type">int</span>, cmd,</span><br><span class="line"><span class="type">void</span> __user *, arg)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* Instead of trying to make the power_off code look like</span></span><br><span class="line"><span class="comment"> * halt when pm_power_off is not set do it the easy way.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> ((cmd == LINUX_REBOOT_CMD_POWER_OFF) &amp;&amp; !pm_power_off)</span><br><span class="line">cmd = LINUX_REBOOT_CMD_HALT;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;system_transition_mutex);</span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line"><span class="keyword">case</span> LINUX_REBOOT_CMD_RESTART: <span class="comment">// restart</span></span><br><span class="line">kernel_restart(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> LINUX_REBOOT_CMD_HALT:</span><br><span class="line">kernel_halt();</span><br><span class="line">do_exit(<span class="number">0</span>);</span><br><span class="line">panic(<span class="string">&quot;cannot halt&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> LINUX_REBOOT_CMD_POWER_OFF:</span><br><span class="line">kernel_power_off();</span><br><span class="line">do_exit(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> LINUX_REBOOT_CMD_RESTART2: <span class="comment">// 这个带 buffer ?</span></span><br><span class="line">ret = strncpy_from_user(&amp;buffer[<span class="number">0</span>], arg, <span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">ret = -EFAULT;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">kernel_restart(buffer);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kernel_restart_prepare</span><span class="params">(<span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">blocking_notifier_call_chain(&amp;reboot_notifier_list, SYS_RESTART, cmd);</span><br><span class="line">system_state = SYSTEM_RESTART;</span><br><span class="line">usermodehelper_disable();</span><br><span class="line">device_shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * syscore_shutdown - Execute all the registered system core shutdown callbacks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">syscore_shutdown</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">syscore_ops</span> *<span class="title">ops</span>;</span></span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;syscore_ops_lock);</span><br><span class="line"></span><br><span class="line">list_for_each_entry_reverse(ops, &amp;syscore_ops_list, node)</span><br><span class="line"><span class="keyword">if</span> (ops-&gt;shutdown) &#123;</span><br><span class="line"><span class="keyword">if</span> (initcall_debug)</span><br><span class="line">pr_info(<span class="string">&quot;PM: Calling %pS\n&quot;</span>, ops-&gt;shutdown);</span><br><span class="line">ops-&gt;shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutex_unlock(&amp;syscore_ops_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">kernel_restart</span><span class="params">(<span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">kernel_restart_prepare(cmd);</span><br><span class="line">migrate_to_reboot_cpu();</span><br><span class="line">syscore_shutdown();</span><br><span class="line"><span class="keyword">if</span> (!cmd)</span><br><span class="line">pr_emerg(<span class="string">&quot;Restarting system\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">pr_emerg(<span class="string">&quot;Restarting system with command &#x27;%s&#x27;\n&quot;</span>, cmd);</span><br><span class="line">kmsg_dump(KMSG_DUMP_SHUTDOWN);</span><br><span class="line">machine_restart(cmd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// arch/riscv/kernel/reset.c</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">machine_restart</span><span class="params">(<span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">do_kernel_restart(cmd);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *do_kernel_restart - Execute kernel restart handler call chain</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Calls functions registered with register_restart_handler.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Expected to be called from machine_restart as last step of the restart</span></span><br><span class="line"><span class="comment"> *sequence.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *Restarts the system immediately if a restart handler function has been</span></span><br><span class="line"><span class="comment"> *registered. Otherwise does nothing.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">do_kernel_restart</span><span class="params">(<span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 这里就会调用到</span></span><br><span class="line">atomic_notifier_call_chain(&amp;restart_handler_list, reboot_mode, cmd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就会调用到 <a href="#reboot/poweroff">reboot&#x2F;poweroff</a> 中注册的处理函数了.</p><p>看 datasheet . <a href="https://github.com/sophgo/sophgo-doc/releases/tag/sg2002-trm-v1.01">https://github.com/sophgo/sophgo-doc/releases/tag/sg2002-trm-v1.01</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reg = &lt;0x0 0x05025000 0x0 0x2000&gt;;</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">cvi_restart_handler</span><span class="params">(<span class="keyword">struct</span> notifier_block *this,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">long</span> mode, <span class="type">void</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span> __iomem *REG_RTC_CTRL_BASE = base;</span><br><span class="line"><span class="type">void</span> __iomem *REG_RTC_BASE = base + <span class="number">0x1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Enable power suspend wakeup source mask */</span></span><br><span class="line"><span class="comment">// rtcsys_clkdiv 0x03c</span></span><br><span class="line">writel(<span class="number">0x1</span>, REG_RTC_BASE + <span class="number">0x3C</span>); <span class="comment">// 1 = select prdata from 32K domain</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rtc_ctrl_unlockkey 0x004</span></span><br><span class="line">writel(<span class="number">0xAB18</span>, REG_RTC_CTRL_BASE + RTC_CTRL0_UNLOCKKEY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个datasheet 上没有 0x0cc</span></span><br><span class="line">writel(<span class="number">0x1</span>, REG_RTC_BASE + RTC_EN_WARM_RST_REQ);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (readl(REG_RTC_BASE + RTC_EN_WARM_RST_REQ) != <span class="number">0x01</span>)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (readl(REG_RTC_BASE + RSM_STATE) != ST_ON)</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">writel(<span class="number">0xFFFF0800</span> | (<span class="number">0x1</span> &lt;&lt; <span class="number">4</span>), REG_RTC_CTRL_BASE + RTC_CTRL0);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> NOTIFY_DONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算了，不管了，这里看起来就是最后的一步了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cvitek </tag>
            
            <tag> reboot </tag>
            
            <tag> poweroff </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux USB 驱动框架</title>
      <link href="/2024/09/01/Linux-USB%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/"/>
      <url>/2024/09/01/Linux-USB%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<p>depends on:</p><ul><li><input disabled="" type="checkbox"> bus 通用知识</li><li><input disabled="" type="checkbox"> uevent 机制</li><li><input disabled="" type="checkbox"> 字符设备</li></ul><h2 id="USB-驱动框架"><a href="#USB-驱动框架" class="headerlink" title="USB 驱动框架"></a>USB 驱动框架</h2><p>很典型的Linux 驱动框架，分</p><ul><li>核心层：完成通用功能。</li><li>设备驱动层 PDD（实现特定功能，比如 UVC， UAC， HID 这些类型的设备驱动）</li><li>控制器驱动 HCD（配置寄存器去操作硬件USB IP，完成数据收发）类似与网络中的数据链路层，只负责数据收发。</li></ul><p><img src="/../images/Linux-USB%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20240901105545261.png" alt="image-20240901105545261"></p><blockquote><p>image from paper <USBIP a transparent device sharing technolog over ip network></p><p>这段 USB Driver Architecture 讲得很好。</p><p>USB (Universal Serial Bus) 17) is one of the sophisticated peripheral interfaces based on the recent hardware progress. In the USB 2.0 speciﬁcation announced in April 2000, a host computer controls various USB devices with 3 transfer speeds (1.5 Mbps, 12.0 Mbps, and 480 Mbps) and 4 transfer types (Control, Bulk, Interrupt, and Isochronous). These transfers are serialized and controlled by a dedicated hardware function which is named USB Host Controller. Figure 1 shows the USB device driver model in most operating systems. A <strong>USB Host Controller Driver</strong> (USB HCD) exists in the lowest layer of the device driver stack and abstracts the I&#x2F;O interface of a host controller into a common API for USB device drivers. <strong>A USB PerDevice Drivers (USB PDD)</strong> is respon-sible for the control of each USB device. The key design of the USB driver stack is that a USB Host Controller and its USB HCD provide USB PDDs with abstracted data input&#x2F;output for I&#x2F;O buﬀers. Although a USB device and its USB PDD use the buﬀer to transfer some control data and corresponding reply data, <strong>the USB HCD do not distinguish between control and reply</strong>.</p><p>In USB device drivers, a <strong>USB Request Block (URB)</strong> presents USB I&#x2F;O in a controller-independent form, which includes information about I&#x2F;O;</p><ul><li><strong>I&#x2F;O buﬀer</strong></li><li>I&#x2F;O direction (Input&#x2F;Output)</li><li>I&#x2F;O speed (1.5 Mbps&#x2F;12 Mbps&#x2F;480 Mbps)</li><li>I&#x2F;O type (Control&#x2F;Bulk&#x2F;Interrupt&#x2F;Isochronous)</li><li>I&#x2F;O destination address</li><li><strong>completion handler</strong></li></ul><p>An application or a device driver controls a USB device as follows:</p><ol><li><strong>A USB PDD converts I&#x2F;O requests from another driver into URBs and submits these URBs to a USB HCD.</strong></li><li>The USB HCD transfers data as de-scribed by the URB.</li><li>After I&#x2F;O of the URB is completed, the completion handler of the URB is called in an interrupt context.</li><li>The USB PDD notiﬁes the upper driver of the requested I&#x2F;O completion.</li></ol><p>A USB device and its USB PDD use 4 diﬀer- ent transfer types depending on characteristics of the device. <strong>Control and Bulk transfer types are asynchronously scheduled into the rest of the bandwidth after the periodical transfers</strong>. Control transfer is the most fundamental one for enumeration and initialization of devices. In 480 Mbps mode, <strong>20% of the bandwidth is reserved for Control transfer</strong>. Bulk transfer is used for the requests without any temporal re-striction, such as storage device I&#x2F;O, which is the fastest transfer when the bus is available. <strong>Isochronous and Interrupt transfer types are pe-riodically scheduled</strong>. Isochronous transfer can move control data at a constant bit rate, which is useful to read image data from a USB cam-era or to write sound data to a USB speaker. <strong>Interrupt transfer conﬁrms the maximum delay of the requested I&#x2F;O</strong>. This is used for USB mice and keyboards, which move a small amount of data sporadically.</p><p>note: UVC 出流的时候发现最大3个设备总带宽44MB 没问题，但48MB 会提示资源不足。总共 480Mbps -&gt; 60MB -&gt; *80% -&gt; 48MB. 理论上 48M刚好够，不过其他HUB 之类的设备可能也会占一点就导致不够了。</p></blockquote><h3 id="代码阅读流程"><a href="#代码阅读流程" class="headerlink" title="代码阅读流程"></a>代码阅读流程</h3><ol><li><p><strong>确定核心代码</strong>（通过 .config + MAKEFILE + KCONFIG）</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> build/sg2002_wevb_riscv64_sd/.config | grep USB | grep <span class="string">&quot;=&quot;</span></span><br><span class="line">CONFIG_USB_OHCI_LITTLE_ENDIAN=y <span class="comment"># 大小端，一般都是小端</span></span><br><span class="line">CONFIG_USB_SUPPORT=y <span class="comment"># usb/phy 也是 USB 驱动的总开关</span></span><br><span class="line">CONFIG_USB_ARCH_HAS_HCD=y <span class="comment"># HOST CONTROLLER，肯定得默认Y</span></span><br><span class="line">CONFIG_USB_COMMON=y <span class="comment"># usb/common/usb-common.o</span></span><br><span class="line"></span><br><span class="line">CONFIG_USB_DEFAULT_PERSIST=y <span class="comment"># USB电源会话持久性</span></span><br><span class="line">CONFIG_USB_AUTOSUSPEND_DELAY=2 <span class="comment"># 默认自动休眠时间（2S）</span></span><br><span class="line">CONFIG_USB_ROLE_SWITCH=y <span class="comment"># 支持角色 host/device 切换 += usb/roles/roles.o</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########## HOST ##########</span></span><br><span class="line">CONFIG_USB=y <span class="comment"># += usb/core usb/storage/ usb/misc/  Support for Host-side USB</span></span><br><span class="line"><span class="comment"># 作为 HOST 时用。要作为device，应该看 USB Gadget。EHCI HCD 代表USB2.0。USB1.1是 UHCI，OHCI</span></span><br><span class="line"><span class="comment"># Say Y here if your computer has a host-side USB port and you want to use USB devices.  You then need to say Y to at least one of the Host Controller Driver (HCD) options below.  Choose a USB 1.1 controller, such as &quot;UHCI HCD support&quot; or &quot;OHCI HCD support&quot;, and &quot;EHCI HCD (USB 2.0) support&quot; except for older systems that do not have USB 2.0 support.  It doesn&#x27;t normally hurt to select them all if you are not certain.</span></span><br><span class="line"><span class="comment"># If your system has a device-side USB port, used in the peripheral side of the USB protocol, see the &quot;USB Gadget&quot; framework instead.</span></span><br><span class="line"><span class="comment">#### controller driver ####</span></span><br><span class="line">CONFIG_USB_DWC2=y           <span class="comment"># usb/dwc2/dwc2.o USB HCD 驱动</span></span><br><span class="line">CONFIG_USB_DWC2_DUAL_ROLE=y <span class="comment"># 支持两种角色的工作模式（host/device）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">########## DEVICE ##########</span></span><br><span class="line">CONFIG_USB_GADGET=y         <span class="comment"># += 作为USBdevice用。usb/gadget udc/ function/ legacy/ udc/udc-core.o</span></span><br><span class="line">CONFIG_USB_GADGET_VBUS_DRAW=2 <span class="comment"># Maximum VBUS Power usage (2-500 mA)</span></span><br><span class="line">CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2 <span class="comment"># Number of storage pipeline buffers</span></span><br><span class="line">CONFIG_USB_LIBCOMPOSITE=y   <span class="comment"># += usb/gadget/libcomposite.o  复合设备驱动</span></span><br><span class="line">CONFIG_USB_F_ACM=y          <span class="comment"># += usb/gadget/function/usb_f_acm.o</span></span><br><span class="line">CONFIG_USB_U_SERIAL=y       <span class="comment"># += usb/gadget/function/u_serial.o</span></span><br><span class="line">CONFIG_USB_U_ETHER=y        <span class="comment"># += usb/gadget/function/u_ether.o</span></span><br><span class="line">CONFIG_USB_U_AUDIO=y        <span class="comment"># += usb/gadget/function/u_audio.o</span></span><br><span class="line">CONFIG_USB_F_SERIAL=y       <span class="comment"># += usb/gadget/function/usb_f_serial.o</span></span><br><span class="line">CONFIG_USB_F_ECM=y          <span class="comment"># += usb/gadget/function/f_ecm.o</span></span><br><span class="line">CONFIG_USB_F_EEM=y          <span class="comment"># += usb/gadget/function/f_eem.o</span></span><br><span class="line">CONFIG_USB_F_RNDIS=y        <span class="comment"># += usb/gadget/function/usb_f_rndis.o</span></span><br><span class="line">CONFIG_USB_F_MASS_STORAGE=y <span class="comment"># += usb/gadget/function/usb_f_mass_storage.o</span></span><br><span class="line">CONFIG_USB_F_FS=y           <span class="comment"># += usb/gadget/function/usb_f_fs.o</span></span><br><span class="line">CONFIG_USB_F_UAC1=y         <span class="comment"># += usb/gadget/function/usb_f_uac1.o</span></span><br><span class="line">CONFIG_USB_F_UVC=y          <span class="comment"># += usb/gadget/function/usb_f_uvc.o</span></span><br><span class="line">CONFIG_USB_CONFIGFS=y       <span class="comment"># 支持通过configfs对功能进行配置 USB Gadget functions configurable through configfs</span></span><br><span class="line">CONFIG_USB_CONFIGFS_SERIAL=y <span class="comment"># Generic serial bulk in/out</span></span><br><span class="line">CONFIG_USB_CONFIGFS_ACM=y   <span class="comment"># Abstract Control Model (CDC ACM)</span></span><br><span class="line">CONFIG_USB_CONFIGFS_ECM=y   <span class="comment"># Ethernet Control Model (CDC ECM)</span></span><br><span class="line">CONFIG_USB_CONFIGFS_RNDIS=y <span class="comment"># RNDIS</span></span><br><span class="line">CONFIG_USB_CONFIGFS_EEM=y   <span class="comment"># Ethernet Emulation Model (EEM)</span></span><br><span class="line">CONFIG_USB_CONFIGFS_MASS_STORAGE=y <span class="comment"># Mass Storage</span></span><br><span class="line">CONFIG_USB_CONFIGFS_F_FS=y  <span class="comment"># Function filesystem (FunctionFS)</span></span><br><span class="line"><span class="comment"># The Function Filesystem (FunctionFS) lets one create USB composite functions in user space in the same way GadgetFS lets one create USB gadgets in user space.</span></span><br><span class="line">CONFIG_USB_CONFIGFS_F_UAC1=y <span class="comment"># Audio Class 1.0</span></span><br><span class="line">CONFIG_USB_CONFIGFS_F_UVC=y <span class="comment"># USB Webcam function</span></span><br><span class="line">CONFIG_USB_HID=y            <span class="comment"># hid/usbhid/usbhid.o 并非所有的PDD驱动实现都放在 usb 目录下</span></span><br></pre></td></tr></table></figure><p> 再查找配置对应的代码。vscode 中搜索，仅搜索 Makefile, Kconfig 。<strong>注意搜索技巧</strong>。<br> <img src="/../images/Linux-USB%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6/image-20240901121143789.png" alt="image-20240901121143789"></p></li></ol><h3 id="core-目录"><a href="#core-目录" class="headerlink" title="core 目录"></a>core 目录</h3><blockquote><p><a href="https://www.cnblogs.com/wen123456/p/14281890.html">https://www.cnblogs.com/wen123456/p/14281890.html</a></p></blockquote><p>首先，可以通过 Makefile <strong>确定我们需要关注那些 .c 文件</strong>。比如，我们启用了 CONFIG_USB  CONFIG_OF。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usbcore-y := usb.o hub.o hcd.o urb.o message.o driver.o</span><br><span class="line">usbcore-y += config.o file.o buffer.o sysfs.o endpoint.o</span><br><span class="line">usbcore-y += devio.o notify.o generic.o quirks.o devices.o</span><br><span class="line">usbcore-y += phy.o port.o</span><br><span class="line">usbcore-<span class="variable">$(CONFIG_OF)</span>+= of.o</span><br><span class="line">obj-<span class="variable">$(CONFIG_USB)</span>+= usbcore.o</span><br></pre></td></tr></table></figure><p>确定当前目录下会编译多少个模块 <code>ko</code>：</p><ol><li><p>通过在当前路径搜索 <code>module_init/subsys_initcall</code> 等模块初始化函数。</p></li><li><p>通过 Kconfig 文件中 <code>tristate</code>  的个数。只有为 tristate 才能编译为 ko 形式加载。int 的一般都只是以宏判断的形式嵌入在代码中，不过这个非绝对。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">config USB_LEDS_TRIGGER_USBPORT</span><br><span class="line">tristate &quot;USB port LED trigger&quot;</span><br><span class="line">depends on USB &amp;&amp; LEDS_TRIGGERS</span><br><span class="line">help</span><br><span class="line">  This driver allows LEDs to be controlled by USB events. Enabling this</span><br><span class="line">  trigger allows specifying list of USB ports that should turn on LED</span><br><span class="line">  when some USB device gets connected.</span><br><span class="line"></span><br><span class="line">config USB_AUTOSUSPEND_DELAY</span><br><span class="line">int &quot;Default autosuspend delay&quot;</span><br><span class="line">depends on USB</span><br><span class="line">default 2</span><br><span class="line">help</span><br><span class="line">  The default autosuspend delay in seconds.  Can be overridden</span><br><span class="line">  with the usbcore.autosuspend command line or module parameter.</span><br><span class="line"></span><br><span class="line">  The default value Linux has always had is 2 seconds.  Change</span><br><span class="line">  this value if you want a different delay and cannot modify</span><br><span class="line">  the command line or module parameter.</span><br></pre></td></tr></table></figure></li></ol><p>总之目前确认了 core 目录下可以编译出两个 ko 文件。<code>usbcore.ko</code> 以及 <code>ledtrig-usbport.ko</code>.</p><p>确定模块之后，就可以从 module 的init 函数去追代码。过程中自然会看到他调用其他 c 文件的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Init</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">usb_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"><span class="keyword">if</span> (usb_disabled()) &#123;</span><br><span class="line">pr_info(<span class="string">&quot;%s: USB support disabled\n&quot;</span>, usbcore_name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">usb_init_pool_max(); <span class="comment">// USB 驱动中会分配dma内存池，确定内存中内存块的最小的大小，与 ARCH_KMALLOC_MINALIGN 有关。</span></span><br><span class="line"></span><br><span class="line">usb_debugfs_init(); <span class="comment">// debugfs 中增加文件，方便调试</span></span><br><span class="line"></span><br><span class="line">usb_acpi_register(); <span class="comment">// 没配置，暂时不管</span></span><br><span class="line">retval = bus_register(&amp;usb_bus_type); <span class="comment">// USB 总线注册</span></span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> bus_register_failed;</span><br><span class="line">retval = bus_register_notifier(&amp;usb_bus_type, &amp;usb_bus_nb); <span class="comment">// 注册内核通知链，用于设备和接口注册的通知</span></span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> bus_notifier_failed;</span><br><span class="line">retval = usb_major_init(); <span class="comment">// 申请 major number。</span></span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> major_init_failed;</span><br><span class="line">retval = usb_register(&amp;usbfs_driver); <span class="comment">// 注册接口驱动 usbfs</span></span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> driver_register_failed;</span><br><span class="line">retval = usb_devio_init(); <span class="comment">// 初始化字符设备</span></span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> usb_devio_init_failed;</span><br><span class="line">retval = usb_hub_init(); <span class="comment">// 注册接口驱动 hub</span></span><br><span class="line"><span class="keyword">if</span> (retval)</span><br><span class="line"><span class="keyword">goto</span> hub_init_failed;</span><br><span class="line">retval = usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);</span><br><span class="line"><span class="keyword">if</span> (!retval)</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面都是些异常情况的清理过程。</span></span><br><span class="line">usb_hub_cleanup();</span><br><span class="line">hub_init_failed:</span><br><span class="line">usb_devio_cleanup();</span><br><span class="line">usb_devio_init_failed:</span><br><span class="line">usb_deregister(&amp;usbfs_driver);</span><br><span class="line">driver_register_failed:</span><br><span class="line">usb_major_cleanup();</span><br><span class="line">major_init_failed:</span><br><span class="line">bus_unregister_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);</span><br><span class="line">bus_notifier_failed:</span><br><span class="line">bus_unregister(&amp;usb_bus_type);</span><br><span class="line">bus_register_failed:</span><br><span class="line">usb_acpi_unregister();</span><br><span class="line">usb_debugfs_cleanup();</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="usb-debugfs-init"><a href="#usb-debugfs-init" class="headerlink" title="usb_debugfs_init"></a>usb_debugfs_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">usb_debugfs_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 在debugfs 中创建一个 devices 文件。提供了两个 fops：read &amp; llseek</span></span><br><span class="line">usb_devices_root = debugfs_create_file(<span class="string">&quot;devices&quot;</span>, <span class="number">0444</span>, usb_debug_root,</span><br><span class="line">       <span class="literal">NULL</span>, &amp;usbfs_devices_fops);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// core/devices.c</span></span><br><span class="line"><span class="comment">// read 方法会遍历总线，然后dump每一个设备的信息。</span></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">usb_device_read</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">       <span class="type">size_t</span> nbytes, <span class="type">loff_t</span> *ppos)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_bus</span> *<span class="title">bus</span>;</span></span><br><span class="line"><span class="type">ssize_t</span> ret, total_written = <span class="number">0</span>;</span><br><span class="line"><span class="type">loff_t</span> skip_bytes = *ppos;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (*ppos &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -EINVAL;</span><br><span class="line"><span class="keyword">if</span> (nbytes &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">mutex_lock(&amp;usb_bus_idr_lock);</span><br><span class="line"><span class="comment">/* print devices for all busses */</span></span><br><span class="line">idr_for_each_entry(&amp;usb_bus_idr, bus, id) &#123;</span><br><span class="line"><span class="comment">/* recurse through all children of the root hub */</span></span><br><span class="line"><span class="keyword">if</span> (!bus_to_hcd(bus)-&gt;rh_registered)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">usb_lock_device(bus-&gt;root_hub);</span><br><span class="line"><span class="comment">// 这里 dump 方法将设备信息写入到 buf 中，传递给 user-space</span></span><br><span class="line">ret = usb_device_dump(&amp;buf, &amp;nbytes, &amp;skip_bytes, ppos,</span><br><span class="line">      bus-&gt;root_hub, bus, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">usb_unlock_device(bus-&gt;root_hub);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">mutex_unlock(&amp;usb_bus_idr_lock);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">total_written += ret;</span><br><span class="line">&#125;</span><br><span class="line">mutex_unlock(&amp;usb_bus_idr_lock);</span><br><span class="line"><span class="keyword">return</span> total_written;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">usbfs_devices_fops</span> =</span> &#123;</span><br><span class="line">.llseek =no_seek_end_llseek,</span><br><span class="line">.read =usb_device_read,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// common/common.c</span></span><br><span class="line"><span class="comment">// common 已经是另一个 module 里面的代码了，所以usbcore.ko加载之前必须先加载这个 common.ko</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">usb_debug_root</span>;</span></span><br><span class="line">EXPORT_SYMBOL_GPL(usb_debug_root);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">usb_common_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// debugfs 中创建一个 usb 目录</span></span><br><span class="line">usb_debug_root = debugfs_create_dir(<span class="string">&quot;usb&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">ledtrig_usb_init();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bus-register"><a href="#bus-register" class="headerlink" title="bus_register"></a>bus_register</h4><p>总线嘛：<strong>一边设备，一边驱动，完成设备和驱动的匹配过程</strong>。</p><p>无论是有设备注册、还是驱动加载，总线都调用 <code>match</code> 方法去匹配。</p><p><code>uevent</code> 方法，会在设备注册时调用，可以给应用层上报信息，通知有设备插入之类的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">retval = bus_register(&amp;usb_bus_type);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bus_type</span> <span class="title">usb_bus_type</span> =</span> &#123;</span><br><span class="line">.name =<span class="string">&quot;usb&quot;</span>,</span><br><span class="line">.match =usb_device_match,</span><br><span class="line">.uevent =usb_uevent,</span><br><span class="line">.need_parent_lock =<span class="literal">true</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设备与驱动的匹配实现，后面再细看吧。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">usb_device_match</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> device_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* devices and interfaces are handled separately */</span></span><br><span class="line"><span class="keyword">if</span> (is_usb_device(dev)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">udev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device_driver</span> *<span class="title">udrv</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* interface drivers never match devices */</span></span><br><span class="line"><span class="keyword">if</span> (!is_usb_device_driver(drv))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">udev = to_usb_device(dev);</span><br><span class="line">udrv = to_usb_device_driver(drv);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If the device driver under consideration does not have a</span></span><br><span class="line"><span class="comment"> * id_table or a match function, then let the driver&#x27;s probe</span></span><br><span class="line"><span class="comment"> * function decide.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (!udrv-&gt;id_table &amp;&amp; !udrv-&gt;match)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> usb_driver_applicable(udev, udrv);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_usb_interface(dev)) &#123;</span><br><span class="line"><span class="keyword">struct</span> usb_interface *intf;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> *<span class="title">usb_drv</span>;</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> *<span class="title">id</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* device drivers never match interfaces */</span></span><br><span class="line"><span class="keyword">if</span> (is_usb_device_driver(drv))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">intf = to_usb_interface(dev);</span><br><span class="line">usb_drv = to_usb_driver(drv);</span><br><span class="line"></span><br><span class="line">id = usb_match_id(intf, usb_drv-&gt;id_table);</span><br><span class="line"><span class="keyword">if</span> (id)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">id = usb_match_dynamic_id(intf, usb_drv);</span><br><span class="line"><span class="keyword">if</span> (id)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 uevent 机制上报设备信息。</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">usb_uevent</span><span class="params">(<span class="keyword">struct</span> device *dev, <span class="keyword">struct</span> kobj_uevent_env *env)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">usb_dev</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (is_usb_device(dev)) &#123;</span><br><span class="line">usb_dev = to_usb_device(dev);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (is_usb_interface(dev)) &#123;</span><br><span class="line"><span class="keyword">struct</span> usb_interface *intf = to_usb_interface(dev);</span><br><span class="line"></span><br><span class="line">usb_dev = interface_to_usbdev(intf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usb_dev-&gt;devnum &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/* driver is often null here; dev_dbg() would oops */</span></span><br><span class="line">pr_debug(<span class="string">&quot;usb %s: already deleted?\n&quot;</span>, dev_name(dev));</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!usb_dev-&gt;bus) &#123;</span><br><span class="line">pr_debug(<span class="string">&quot;usb %s: bus removed?\n&quot;</span>, dev_name(dev));</span><br><span class="line"><span class="keyword">return</span> -ENODEV;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* per-device configurations are common */</span></span><br><span class="line"><span class="keyword">if</span> (add_uevent_var(env, <span class="string">&quot;PRODUCT=%x/%x/%x&quot;</span>,</span><br><span class="line">   le16_to_cpu(usb_dev-&gt;descriptor.idVendor),</span><br><span class="line">   le16_to_cpu(usb_dev-&gt;descriptor.idProduct),</span><br><span class="line">   le16_to_cpu(usb_dev-&gt;descriptor.bcdDevice)))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* class-based driver binding models */</span></span><br><span class="line"><span class="keyword">if</span> (add_uevent_var(env, <span class="string">&quot;TYPE=%d/%d/%d&quot;</span>,</span><br><span class="line">   usb_dev-&gt;descriptor.bDeviceClass,</span><br><span class="line">   usb_dev-&gt;descriptor.bDeviceSubClass,</span><br><span class="line">   usb_dev-&gt;descriptor.bDeviceProtocol))</span><br><span class="line"><span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/downey-blog/p/10507703.html">https://www.cnblogs.com/downey-blog/p/10507703.html</a></p><blockquote><ul><li><code>name</code>: 该bus的名字，这个名字是这个bus在sysfs文件系统中的体现，对应&#x2F;sys&#x2F;bus&#x2F;$name.</li><li><code>dev_name</code>: 这个dev_name并不对应bus的名称，而是对应bus所包含的struct device的名字，即对应dev_root。</li><li><code>dev_root</code>：bus对应的device结构，每个设备都需要对应一个相应的struct device.</li><li><code>match</code>:bus的device链表和driver链表进行匹配的实际执行回调函数，每当有device或者driver添加到bus中时，调用match函数，为device(driver)寻找匹配的driver(device)。</li><li><code>uevent</code>: bus时间回调函数，当属于这个bus的设备发生添加、删除、修改等行为时，都将出发uvent事件。</li><li><code>probe</code>: 当device和driver经由match匹配成功时，将会调用总线的probe函数实现具体driver的初始化。事实上每个driver也会提供相应的probe函数，先调用总线的probe函数，在总线probe函数中调用driver的probe函数。</li><li><code>remove</code>: 移除挂载在设备上的driver，bus上的driver部分也会提供remove函数，在执行移除时，先调用driver的remove，然后再调用bus的remove以清除资源。</li></ul></blockquote><h4 id="bus-register-notifier"><a href="#bus-register-notifier" class="headerlink" title="bus_register_notifier"></a>bus_register_notifier</h4><p>通知链，用于设备&#x2F;接口的添加、删除的通知。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">retval = bus_register_notifier(&amp;usb_bus_type, &amp;usb_bus_nb);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">notifier_block</span> <span class="title">usb_bus_nb</span> =</span> &#123;</span><br><span class="line">.notifier_call = usb_bus_notify,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Notifications of device and interface registration</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">usb_bus_notify</span><span class="params">(<span class="keyword">struct</span> notifier_block *nb, <span class="type">unsigned</span> <span class="type">long</span> action,</span></span><br><span class="line"><span class="params"><span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> =</span> data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (action) &#123;</span><br><span class="line"><span class="keyword">case</span> BUS_NOTIFY_ADD_DEVICE:</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;type == &amp;usb_device_type)</span><br><span class="line">(<span class="type">void</span>) usb_create_sysfs_dev_files(to_usb_device(dev));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;type == &amp;usb_if_device_type)</span><br><span class="line">usb_create_sysfs_intf_files(to_usb_interface(dev));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> BUS_NOTIFY_DEL_DEVICE:</span><br><span class="line"><span class="keyword">if</span> (dev-&gt;type == &amp;usb_device_type)</span><br><span class="line">usb_remove_sysfs_dev_files(to_usb_device(dev));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dev-&gt;type == &amp;usb_if_device_type)</span><br><span class="line">usb_remove_sysfs_intf_files(to_usb_interface(dev));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="usb-register"><a href="#usb-register" class="headerlink" title="usb_register"></a>usb_register</h4><p>注册 usbfs 驱动，这是一个<strong>接口驱动</strong>。🧠奇怪，这个驱动不需要指定匹配方式吗？哦哦应该是只通过名字来匹配哦。</p><p>将 usbfs 驱动提交到设备模型，添加到USB总线的驱动链表里。</p><p>设备驱动<code>struct usb_device_driver</code>和接口驱动<code>struct usb_driver</code>分别用了不同的数据结构表示。此外还有一个 <code>struct usb_class_driver</code> 用于表示设备类驱动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">retval = usb_register(&amp;usbfs_driver);</span><br><span class="line"><span class="comment">// devio.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">usbfs_driver</span> =</span> &#123;</span><br><span class="line">.name =<span class="string">&quot;usbfs&quot;</span>,</span><br><span class="line">.probe =driver_probe,</span><br><span class="line">.disconnect =driver_disconnect,</span><br><span class="line">.suspend =driver_suspend,</span><br><span class="line">.resume =driver_resume,</span><br><span class="line">.supports_autosuspend = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* use a define to avoid include chaining to get THIS_MODULE &amp; friends */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> usb_register(driver) \</span></span><br><span class="line"><span class="meta">usb_register_driver(driver, THIS_MODULE, KBUILD_MODNAME)</span></span><br></pre></td></tr></table></figure><p>和下面的 <code>usb_register_device_driver</code> 注册设备驱动区分。</p><h4 id="usb-devio-init"><a href="#usb-devio-init" class="headerlink" title="usb_devio_init"></a>usb_devio_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">usb_devio_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请 USB_DEVICE_MAX 个设备号，所有的usb相关的文件节点都是用的这个 MAJOR 设备号</span></span><br><span class="line"><span class="comment">// #define USB_DEVICE_DEV MKDEV(USB_DEVICE_MAJOR, 0)</span></span><br><span class="line"><span class="comment">// #define USB_MAXBUS 64</span></span><br><span class="line"><span class="comment">// #define USB_DEVICE_MAX (USB_MAXBUS * 128)</span></span><br><span class="line">retval = register_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX,</span><br><span class="line"><span class="string">&quot;usb_device&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (retval) &#123;</span><br><span class="line">printk(KERN_ERR <span class="string">&quot;Unable to register minors for usb_device\n&quot;</span>);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将字符设备与文件操作关联</span></span><br><span class="line">cdev_init(&amp;usb_device_cdev, &amp;usbdev_file_operations);</span><br><span class="line"><span class="comment">// 将字符设备添加到内核设备链表</span></span><br><span class="line">retval = cdev_add(&amp;usb_device_cdev, USB_DEVICE_DEV, USB_DEVICE_MAX);</span><br><span class="line"><span class="keyword">if</span> (retval) &#123;</span><br><span class="line">printk(KERN_ERR <span class="string">&quot;Unable to get usb_device major %d\n&quot;</span>,</span><br><span class="line">       USB_DEVICE_MAJOR);</span><br><span class="line"><span class="keyword">goto</span> error_cdev;</span><br><span class="line">&#125;</span><br><span class="line">usb_register_notify(&amp;usbdev_nb);</span><br><span class="line">out:</span><br><span class="line"><span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">error_cdev:</span><br><span class="line">unregister_chrdev_region(USB_DEVICE_DEV, USB_DEVICE_MAX);</span><br><span class="line"><span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="usb-hub-init"><a href="#usb-hub-init" class="headerlink" title="usb_hub_init"></a>usb_hub_init</h4><p>注册 hub 接口驱动。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_driver</span> <span class="title">hub_driver</span> =</span> &#123;</span><br><span class="line">.name =<span class="string">&quot;hub&quot;</span>,</span><br><span class="line">.probe =hub_probe,</span><br><span class="line">.disconnect =hub_disconnect,</span><br><span class="line">.suspend =hub_suspend,</span><br><span class="line">.resume =hub_resume,</span><br><span class="line">.reset_resume =hub_reset_resume,</span><br><span class="line">.pre_reset =hub_pre_reset,</span><br><span class="line">.post_reset =hub_post_reset,</span><br><span class="line">.unlocked_ioctl = hub_ioctl,</span><br><span class="line">.id_table =hub_id_table,</span><br><span class="line">.supports_autosuspend =<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">usb_hub_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 注册 hub 接口驱动</span></span><br><span class="line"><span class="keyword">if</span> (usb_register(&amp;hub_driver) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">printk(KERN_ERR <span class="string">&quot;%s: can&#x27;t register hub driver\n&quot;</span>,</span><br><span class="line">usbcore_name);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The workqueue needs to be freezable to avoid interfering with</span></span><br><span class="line"><span class="comment"> * USB-PERSIST port handover. Otherwise it might see that a full-speed</span></span><br><span class="line"><span class="comment"> * device was gone before the EHCI controller had handed its port</span></span><br><span class="line"><span class="comment"> * over to the companion full-speed controller.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 创建一个 workqueue to process hub events</span></span><br><span class="line">hub_wq = alloc_workqueue(<span class="string">&quot;usb_hub_wq&quot;</span>, WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hub_wq)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fall through if kernel_thread failed */</span></span><br><span class="line">usb_deregister(&amp;hub_driver);</span><br><span class="line">pr_err(<span class="string">&quot;%s: can&#x27;t allocate workqueue for usb hub\n&quot;</span>, usbcore_name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="usb-register-device-driver"><a href="#usb-register-device-driver" class="headerlink" title="usb_register_device_driver"></a>usb_register_device_driver</h4><blockquote><p><a href="https://blog.csdn.net/qq_41483419/article/details/129158142">https://blog.csdn.net/qq_41483419/article/details/129158142</a></p><p> <strong>只要是usb设备，都会跟usb_generic_driver匹配上</strong>。</p><p>usb_generic_driver中的generic_probe函数，这个函数是一个usb设备的第一个匹配的driver。Generic通用，只要是个usb设备就得先跟他来一段，usb设备驱动界的老大。他的probe干啥了呢？很简单！找个合适的配置，配置一下。从此usb设备就进入配置的时代了。(前期的工作谁做的呢，到这都已经设置完地址了，当然是hub了，hub发现设备后，会进行前期的枚举过程，获得配置，最终调用device_add将该usb设备添加到总线上。这个过程可以专门来一大段，是hub的主要工作，所以需要把hub单独作为一个家族来对待，人家可是走在第一线的默默无闻的工作者，默默的将设备枚举完成后，将这个设备添加到usb总线上，多伟大)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">usb_register_device_driver(&amp;usb_generic_driver, THIS_MODULE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// generic.c</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device_driver</span> <span class="title">usb_generic_driver</span> =</span> &#123;</span><br><span class="line">.name =<span class="string">&quot;usb&quot;</span>,</span><br><span class="line">.match = usb_generic_driver_match,</span><br><span class="line">.probe = usb_generic_driver_probe,</span><br><span class="line">.disconnect = usb_generic_driver_disconnect,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>CONFIG_PM</span></span><br><span class="line">.suspend = usb_generic_driver_suspend,</span><br><span class="line">.resume = usb_generic_driver_resume,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">.supports_autosuspend = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>usb_device_driver结构体是usb_driver的简化版本,这里注册的是usb设备(非接口)驱动。</p><p>usb总线的match方法对usb设备和usb接口做了区分处理,针对usb设备,直接match的,(分析match时候再细化)</p><p>然后调用usb设备驱动的probe方法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">usb_probe_device</span><span class="params">(<span class="keyword">struct</span> device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_driver</span> *<span class="title">udriver</span> =</span> to_usb_device_driver(dev-&gt;driver);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">udev</span> =</span> to_usb_device(dev);</span><br><span class="line">    <span class="type">int</span> error = <span class="number">0</span>;</span><br><span class="line">    dev_dbg(dev, <span class="string">&quot;%s\n&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">if</span> (!udriver-&gt;supports_autosuspend)  <span class="comment">//条件成立</span></span><br><span class="line">        error = usb_autoresume_device(udev);</span><br><span class="line">    <span class="keyword">if</span> (!error)</span><br><span class="line">        error = udriver-&gt;probe(udev);    <span class="comment">//调用usb_device_driver的probe方法</span></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着调用usb_generic_driver的probe方法</p><p>对应到root hub,流程会转入到generic_probe().代码如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">generic_probe</span><span class="params">(<span class="keyword">struct</span> usb_device *udev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* Choose and set the configuration.  This registers the interfaces</span></span><br><span class="line"><span class="comment">     * with the driver core and lets interface drivers bind to them.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (udev-&gt;authorized == <span class="number">0</span>) <span class="comment">//至于udev-&gt;authorized,在root hub的初始化中,是会将其初始化为1的.后面的逻辑就更简单了.为root hub 选择一个配置然后再设定这个配置.</span></span><br><span class="line">        dev_err(&amp;udev-&gt;dev, <span class="string">&quot;Device is not authorized for usage\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        c = usb_choose_configuration(udev); <span class="comment">//Usb2.0 spec上规定,对于hub设备,只能有一个config,一个interface,一个endpoint.实际上,在这里,对hub的选择约束不大,反正就一个配置,不管怎么样,选择和设定都是这个配置.</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            err = usb_set_configuration(udev, c);</span><br><span class="line">            <span class="keyword">if</span> (err &amp;&amp; err != -ENODEV) &#123;</span><br><span class="line">                dev_err(&amp;udev-&gt;dev, <span class="string">&quot;can&#x27;t set config #%d, error %d\n&quot;</span>,</span><br><span class="line">                    c, err);</span><br><span class="line">                <span class="comment">/* This need not be fatal.  The user can try to</span></span><br><span class="line"><span class="comment">                 * set other configurations. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* USB device state == configured ... usable */</span></span><br><span class="line">    usb_notify_add_device(udev);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>USB CORE 模块初始化过程：</p><ul><li>注册 usb 总线</li><li>注册 usbfs 接口驱动</li><li>注册 hub 接口驱动</li><li>注册 usb generic 设备驱动</li></ul><blockquote><p><a href="https://blog.csdn.net/vitalma/article/details/136300790">https://blog.csdn.net/vitalma/article/details/136300790</a></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">usb_debugfs_init;</span><br><span class="line">---&gt; /sys/kernel/debug/usb/devices; dump USB设备信息</span><br><span class="line">bus_register; 总线节点</span><br><span class="line">---&gt; /sys/bus/usb;</span><br><span class="line">---&gt; /sys/bus/usb/drivers 目录</span><br><span class="line">---&gt; /sys/bus/usb/devices 目录</span><br><span class="line">---&gt; /sys/bus/usb/drivers_probe</span><br><span class="line">---&gt; /sys/bus/usb/drivers_autoprobe</span><br><span class="line">---&gt; /sys/bus/usb/uevent</span><br><span class="line">usb_register;</span><br><span class="line">---&gt; /sys/bus/usb/drivers/usbfs 目录</span><br><span class="line">usb_hub_init;</span><br><span class="line">---&gt; /sys/bus/usb/drivers/hub 目录</span><br><span class="line">usb_register_device_driver:</span><br><span class="line">---&gt; /sys/bus/usb/drivers/usb 目录</span><br></pre></td></tr></table></figure><p>简单看下其他文件实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">usbcore-y := usb.o hub.o hcd.o urb.o message.o driver.o</span><br><span class="line">usbcore-y += config.o file.o buffer.o sysfs.o endpoint.o</span><br><span class="line">usbcore-y += devio.o notify.o generic.o quirks.o devices.o</span><br><span class="line">usbcore-y += phy.o port.o</span><br><span class="line">usbcore-$(CONFIG_OF)+= of.o</span><br><span class="line">obj-$(CONFIG_USB)+= usbcore.o</span><br><span class="line">buffer.c: DMA mempool，提供一些 HCD 会用到的API</span><br><span class="line">config.c: 低速全速高速超速的最大包大小、解析endpoint/interface/configuration描述符。</span><br><span class="line">devices.c: 就一个作用 dump 所有设备信息。见 [debugfs/usb/devices]</span><br><span class="line">devio.c: usbfs 驱动，实现了usb字符设备的文件操作，read/write/ioctl 等</span><br><span class="line">driver.c: 提供了驱动注册相关的API</span><br><span class="line">endpoint.c: 创建、删除endpoint</span><br><span class="line">file.c: 在 /dev 目录下创建设备，设备名是对于的driver名+miner设备号。</span><br><span class="line">generic.c: generic 设备驱动实现。</span><br><span class="line">hcd.c: HCD ....</span><br><span class="line">hub.c: HUB 接口驱动，这个文件也有很多内容，好像设备枚举阶段都是它完成。</span><br><span class="line">message.c: 这玩意怎么也很多内容</span><br><span class="line">port.c: hub的端口相关</span><br><span class="line">sysfs.c: /sys/bus/usb 相关吧</span><br><span class="line">urb.c: USB Request Block.</span><br></pre></td></tr></table></figure><p>TODO：</p><ul><li><p><input disabled="" type="checkbox"> 确定这三个驱动的作用。</p></li><li><p><input disabled="" type="checkbox"> 接口驱动和设备驱动的关系。</p></li><li><p><a href="https://www.cnblogs.com/zyly/p/16255617.html">https://www.cnblogs.com/zyly/p/16255617.html</a></p></li><li><p><strong><a href="https://blog.csdn.net/jun_8018/article/details/116096984">Linux USB驱动分析(一)</a></strong></p></li><li><p><strong><a href="https://blog.csdn.net/jun_8018/article/details/116137244">Linux USB驱动分析(二)</a></strong></p></li><li><p><strong><a href="https://blog.csdn.net/jun_8018/article/details/116211644">Linux USB驱动分析(三)</a></strong></p></li><li><p><strong><a href="https://zhuanlan.zhihu.com/p/61079354">Linux USB总线驱动框架分析</a></strong></p></li><li><p><strong><a href="https://blog.csdn.net/qq_30736309/article/details/79583098">USB主机控制器驱动——OHCI分析</a></strong></p></li><li><p><strong><a href="https://blog.csdn.net/jixianghao/article/details/45336873">二、usb子系统初始化</a></strong></p></li><li><p><strong><a href="https://blog.csdn.net/fengyuwuzu0519/article/details/104259648">【linux驱动】USB子系统分析</a></strong></p></li></ul><h4 id="debugfs-x2F-usb-x2F-devices"><a href="#debugfs-x2F-usb-x2F-devices" class="headerlink" title="debugfs&#x2F;usb&#x2F;devices"></a>debugfs&#x2F;usb&#x2F;devices</h4><p>dump USB设备信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">root@h:usb<span class="meta"># cat /sys/kernel/debug/usb/devices</span></span><br><span class="line"></span><br><span class="line">T:  Bus=<span class="number">01</span> Lev=<span class="number">00</span> Prnt=<span class="number">00</span> Port=<span class="number">00</span> Cnt=<span class="number">00</span> Dev#=  <span class="number">1</span> Spd=<span class="number">480</span>  MxCh=<span class="number">16</span></span><br><span class="line">B:  Alloc=  <span class="number">0</span>/<span class="number">800</span> us ( <span class="number">0</span>%), #Int=  <span class="number">0</span>, #Iso=  <span class="number">0</span></span><br><span class="line">D:  Ver= <span class="number">2.00</span> Cls=<span class="number">09</span>(hub  ) Sub=<span class="number">00</span> Prot=<span class="number">01</span> MxPS=<span class="number">64</span> #Cfgs=  <span class="number">1</span></span><br><span class="line">P:  Vendor=<span class="number">1</span>d6b ProdID=<span class="number">0002</span> Rev= <span class="number">6.08</span></span><br><span class="line">S:  Manufacturer=Linux <span class="number">6.8</span><span class="number">.0</span><span class="number">-41</span>-generic xhci-hcd</span><br><span class="line">S:  Product=xHCI Host Controller</span><br><span class="line">S:  SerialNumber=<span class="number">0000</span>:<span class="number">00</span>:<span class="number">14.0</span></span><br><span class="line">C:* #Ifs= <span class="number">1</span> Cfg#= <span class="number">1</span> Atr=e0 MxPwr=  <span class="number">0</span>mA</span><br><span class="line">I:* If#= <span class="number">0</span> Alt= <span class="number">0</span> #EPs= <span class="number">1</span> Cls=<span class="number">09</span>(hub  ) Sub=<span class="number">00</span> Prot=<span class="number">00</span> Driver=hub</span><br><span class="line">E:  Ad=<span class="number">81</span>(I) Atr=<span class="number">03</span>(Int.) MxPS=   <span class="number">4</span> Ivl=<span class="number">256</span>ms</span><br><span class="line"></span><br><span class="line">T:  Bus=<span class="number">01</span> Lev=<span class="number">01</span> Prnt=<span class="number">01</span> Port=<span class="number">01</span> Cnt=<span class="number">01</span> Dev#=  <span class="number">2</span> Spd=<span class="number">12</span>   MxCh= <span class="number">0</span></span><br><span class="line">D:  Ver= <span class="number">2.00</span> Cls=<span class="number">00</span>(&gt;ifc ) Sub=<span class="number">00</span> Prot=<span class="number">00</span> MxPS=<span class="number">64</span> #Cfgs=  <span class="number">1</span></span><br><span class="line">P:  Vendor=<span class="number">0b0</span>5 ProdID=<span class="number">19</span>af Rev= <span class="number">1.00</span></span><br><span class="line">S:  Manufacturer=AsusTek Computer Inc.</span><br><span class="line">S:  Product=AURA LED Controller</span><br><span class="line">S:  SerialNumber=<span class="number">9876543210</span></span><br><span class="line">C:* #Ifs= <span class="number">2</span> Cfg#= <span class="number">1</span> Atr=a0 MxPwr= <span class="number">16</span>mA</span><br><span class="line">I:* If#= <span class="number">0</span> Alt= <span class="number">0</span> #EPs= <span class="number">0</span> Cls=ff(vend.) Sub=ff Prot=ff Driver=(none)</span><br><span class="line">I:* If#= <span class="number">2</span> Alt= <span class="number">0</span> #EPs= <span class="number">1</span> Cls=<span class="number">03</span>(HID  ) Sub=<span class="number">00</span> Prot=<span class="number">00</span> Driver=usbhid</span><br><span class="line">E:  Ad=<span class="number">82</span>(I) Atr=<span class="number">03</span>(Int.) MxPS=  <span class="number">32</span> Ivl=<span class="number">4</span>ms</span><br><span class="line"></span><br><span class="line">T:  Bus=<span class="number">01</span> Lev=<span class="number">01</span> Prnt=<span class="number">01</span> Port=<span class="number">08</span> Cnt=<span class="number">02</span> Dev#=  <span class="number">3</span> Spd=<span class="number">480</span>  MxCh= <span class="number">4</span></span><br><span class="line">D:  Ver= <span class="number">2.00</span> Cls=<span class="number">09</span>(hub  ) Sub=<span class="number">00</span> Prot=<span class="number">01</span> MxPS=<span class="number">64</span> #Cfgs=  <span class="number">1</span></span><br><span class="line">P:  Vendor=<span class="number">05e3</span> ProdID=<span class="number">0608</span> Rev=<span class="number">60.90</span></span><br><span class="line">S:  Product=USB2<span class="number">.0</span> Hub</span><br><span class="line">C:* #Ifs= <span class="number">1</span> Cfg#= <span class="number">1</span> Atr=e0 MxPwr=<span class="number">100</span>mA</span><br><span class="line">I:* If#= <span class="number">0</span> Alt= <span class="number">0</span> #EPs= <span class="number">1</span> Cls=<span class="number">09</span>(hub  ) Sub=<span class="number">00</span> Prot=<span class="number">00</span> Driver=hub</span><br><span class="line">E:  Ad=<span class="number">81</span>(I) Atr=<span class="number">03</span>(Int.) MxPS=   <span class="number">1</span> Ivl=<span class="number">256</span>ms</span><br><span class="line"></span><br><span class="line">T:  Bus=<span class="number">01</span> Lev=<span class="number">02</span> Prnt=<span class="number">03</span> Port=<span class="number">00</span> Cnt=<span class="number">01</span> Dev#=  <span class="number">5</span> Spd=<span class="number">12</span>   MxCh= <span class="number">0</span></span><br><span class="line">D:  Ver= <span class="number">2.00</span> Cls=e0(wlcon) Sub=<span class="number">01</span> Prot=<span class="number">01</span> MxPS=<span class="number">64</span> #Cfgs=  <span class="number">1</span></span><br><span class="line">P:  Vendor=<span class="number">0</span>a12 ProdID=<span class="number">0001</span> Rev=<span class="number">88.91</span></span><br><span class="line">C:* #Ifs= <span class="number">2</span> Cfg#= <span class="number">1</span> Atr=c0 MxPwr=  <span class="number">0</span>mA</span><br><span class="line">I:* If#= <span class="number">0</span> Alt= <span class="number">0</span> #EPs= <span class="number">3</span> Cls=e0(wlcon) Sub=<span class="number">01</span> Prot=<span class="number">01</span> Driver=btusb</span><br><span class="line">E:  Ad=<span class="number">81</span>(I) Atr=<span class="number">03</span>(Int.) MxPS=  <span class="number">16</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">E:  Ad=<span class="number">02</span>(O) Atr=<span class="number">02</span>(Bulk) MxPS=  <span class="number">64</span> Ivl=<span class="number">0</span>ms</span><br><span class="line">E:  Ad=<span class="number">82</span>(I) Atr=<span class="number">02</span>(Bulk) MxPS=  <span class="number">64</span> Ivl=<span class="number">0</span>ms</span><br><span class="line">I:* If#= <span class="number">1</span> Alt= <span class="number">0</span> #EPs= <span class="number">2</span> Cls=e0(wlcon) Sub=<span class="number">01</span> Prot=<span class="number">01</span> Driver=btusb</span><br><span class="line">E:  Ad=<span class="number">03</span>(O) Atr=<span class="number">01</span>(Isoc) MxPS=   <span class="number">0</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">E:  Ad=<span class="number">83</span>(I) Atr=<span class="number">01</span>(Isoc) MxPS=   <span class="number">0</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">I:  If#= <span class="number">1</span> Alt= <span class="number">1</span> #EPs= <span class="number">2</span> Cls=e0(wlcon) Sub=<span class="number">01</span> Prot=<span class="number">01</span> Driver=btusb</span><br><span class="line">E:  Ad=<span class="number">03</span>(O) Atr=<span class="number">01</span>(Isoc) MxPS=   <span class="number">9</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">E:  Ad=<span class="number">83</span>(I) Atr=<span class="number">01</span>(Isoc) MxPS=   <span class="number">9</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">I:  If#= <span class="number">1</span> Alt= <span class="number">2</span> #EPs= <span class="number">2</span> Cls=e0(wlcon) Sub=<span class="number">01</span> Prot=<span class="number">01</span> Driver=btusb</span><br><span class="line">E:  Ad=<span class="number">03</span>(O) Atr=<span class="number">01</span>(Isoc) MxPS=  <span class="number">17</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">E:  Ad=<span class="number">83</span>(I) Atr=<span class="number">01</span>(Isoc) MxPS=  <span class="number">17</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">I:  If#= <span class="number">1</span> Alt= <span class="number">3</span> #EPs= <span class="number">2</span> Cls=e0(wlcon) Sub=<span class="number">01</span> Prot=<span class="number">01</span> Driver=btusb</span><br><span class="line">E:  Ad=<span class="number">03</span>(O) Atr=<span class="number">01</span>(Isoc) MxPS=  <span class="number">25</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">E:  Ad=<span class="number">83</span>(I) Atr=<span class="number">01</span>(Isoc) MxPS=  <span class="number">25</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">I:  If#= <span class="number">1</span> Alt= <span class="number">4</span> #EPs= <span class="number">2</span> Cls=e0(wlcon) Sub=<span class="number">01</span> Prot=<span class="number">01</span> Driver=btusb</span><br><span class="line">E:  Ad=<span class="number">03</span>(O) Atr=<span class="number">01</span>(Isoc) MxPS=  <span class="number">33</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">E:  Ad=<span class="number">83</span>(I) Atr=<span class="number">01</span>(Isoc) MxPS=  <span class="number">33</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">I:  If#= <span class="number">1</span> Alt= <span class="number">5</span> #EPs= <span class="number">2</span> Cls=e0(wlcon) Sub=<span class="number">01</span> Prot=<span class="number">01</span> Driver=btusb</span><br><span class="line">E:  Ad=<span class="number">03</span>(O) Atr=<span class="number">01</span>(Isoc) MxPS=  <span class="number">49</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">E:  Ad=<span class="number">83</span>(I) Atr=<span class="number">01</span>(Isoc) MxPS=  <span class="number">49</span> Ivl=<span class="number">1</span>ms</span><br><span class="line"></span><br><span class="line">T:  Bus=<span class="number">01</span> Lev=<span class="number">02</span> Prnt=<span class="number">03</span> Port=<span class="number">01</span> Cnt=<span class="number">02</span> Dev#=  <span class="number">7</span> Spd=<span class="number">480</span>  MxCh= <span class="number">0</span></span><br><span class="line">D:  Ver= <span class="number">2.00</span> Cls=<span class="number">00</span>(&gt;ifc ) Sub=<span class="number">00</span> Prot=<span class="number">00</span> MxPS=<span class="number">64</span> #Cfgs=  <span class="number">1</span></span><br><span class="line">P:  Vendor=<span class="number">14</span>cd ProdID=<span class="number">1212</span> Rev= <span class="number">1.00</span></span><br><span class="line">S:  Manufacturer=Generic</span><br><span class="line">S:  Product=Mass Storage Device</span><br><span class="line">S:  SerialNumber=<span class="number">121220160204</span></span><br><span class="line">C:* #Ifs= <span class="number">1</span> Cfg#= <span class="number">1</span> Atr=<span class="number">80</span> MxPwr=<span class="number">100</span>mA</span><br><span class="line">I:* If#= <span class="number">0</span> Alt= <span class="number">0</span> #EPs= <span class="number">2</span> Cls=<span class="number">08</span>(stor.) Sub=<span class="number">06</span> Prot=<span class="number">50</span> Driver=usb-storage</span><br><span class="line">E:  Ad=<span class="number">81</span>(I) Atr=<span class="number">02</span>(Bulk) MxPS= <span class="number">512</span> Ivl=<span class="number">0</span>ms</span><br><span class="line">E:  Ad=<span class="number">02</span>(O) Atr=<span class="number">02</span>(Bulk) MxPS= <span class="number">512</span> Ivl=<span class="number">0</span>ms</span><br><span class="line"></span><br><span class="line">T:  Bus=<span class="number">01</span> Lev=<span class="number">02</span> Prnt=<span class="number">03</span> Port=<span class="number">02</span> Cnt=<span class="number">03</span> Dev#= <span class="number">14</span> Spd=<span class="number">480</span>  MxCh= <span class="number">0</span></span><br><span class="line">D:  Ver= <span class="number">2.00</span> Cls=<span class="number">00</span>(&gt;ifc ) Sub=<span class="number">00</span> Prot=<span class="number">00</span> MxPS=<span class="number">64</span> #Cfgs=  <span class="number">1</span></span><br><span class="line">P:  Vendor=<span class="number">3346</span> ProdID=<span class="number">1009</span> Rev= <span class="number">5.10</span></span><br><span class="line">S:  Manufacturer=Cvitek</span><br><span class="line">S:  Product=RNDIS</span><br><span class="line">S:  SerialNumber=<span class="number">0123456789</span></span><br><span class="line">C:* #Ifs= <span class="number">2</span> Cfg#= <span class="number">1</span> Atr=<span class="number">80</span> MxPwr=<span class="number">120</span>mA</span><br><span class="line">A:  FirstIf#= <span class="number">0</span> IfCount= <span class="number">2</span> Cls=<span class="number">02</span>(comm.) Sub=<span class="number">06</span> Prot=<span class="number">00</span></span><br><span class="line">I:* If#= <span class="number">0</span> Alt= <span class="number">0</span> #EPs= <span class="number">1</span> Cls=<span class="number">02</span>(comm.) Sub=<span class="number">02</span> Prot=ff Driver=rndis_host</span><br><span class="line">E:  Ad=<span class="number">82</span>(I) Atr=<span class="number">03</span>(Int.) MxPS=   <span class="number">8</span> Ivl=<span class="number">32</span>ms</span><br><span class="line">I:* If#= <span class="number">1</span> Alt= <span class="number">0</span> #EPs= <span class="number">2</span> Cls=<span class="number">0</span>a(data ) Sub=<span class="number">00</span> Prot=<span class="number">00</span> Driver=rndis_host</span><br><span class="line">E:  Ad=<span class="number">81</span>(I) Atr=<span class="number">02</span>(Bulk) MxPS= <span class="number">512</span> Ivl=<span class="number">0</span>ms</span><br><span class="line">E:  Ad=<span class="number">01</span>(O) Atr=<span class="number">02</span>(Bulk) MxPS= <span class="number">512</span> Ivl=<span class="number">0</span>ms</span><br><span class="line"></span><br><span class="line">T:  Bus=<span class="number">01</span> Lev=<span class="number">01</span> Prnt=<span class="number">01</span> Port=<span class="number">09</span> Cnt=<span class="number">03</span> Dev#=  <span class="number">4</span> Spd=<span class="number">12</span>   MxCh= <span class="number">0</span></span><br><span class="line">D:  Ver= <span class="number">2.00</span> Cls=<span class="number">00</span>(&gt;ifc ) Sub=<span class="number">00</span> Prot=<span class="number">00</span> MxPS= <span class="number">8</span> #Cfgs=  <span class="number">1</span></span><br><span class="line">P:  Vendor=<span class="number">320f</span> ProdID=<span class="number">5088</span> Rev= <span class="number">1.04</span></span><br><span class="line">S:  Manufacturer=Telink</span><br><span class="line">S:  Product=Wireless Gaming Keyboard</span><br><span class="line">C:* #Ifs= <span class="number">2</span> Cfg#= <span class="number">1</span> Atr=a0 MxPwr=<span class="number">200</span>mA</span><br><span class="line">I:* If#= <span class="number">0</span> Alt= <span class="number">0</span> #EPs= <span class="number">1</span> Cls=<span class="number">03</span>(HID  ) Sub=<span class="number">01</span> Prot=<span class="number">01</span> Driver=usbhid</span><br><span class="line">E:  Ad=<span class="number">81</span>(I) Atr=<span class="number">03</span>(Int.) MxPS=   <span class="number">8</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">I:* If#= <span class="number">1</span> Alt= <span class="number">0</span> #EPs= <span class="number">2</span> Cls=<span class="number">03</span>(HID  ) Sub=<span class="number">01</span> Prot=<span class="number">01</span> Driver=usbhid</span><br><span class="line">E:  Ad=<span class="number">82</span>(I) Atr=<span class="number">03</span>(Int.) MxPS=  <span class="number">64</span> Ivl=<span class="number">1</span>ms</span><br><span class="line">E:  Ad=<span class="number">05</span>(O) Atr=<span class="number">03</span>(Int.) MxPS=  <span class="number">64</span> Ivl=<span class="number">1</span>ms</span><br><span class="line"></span><br><span class="line">T:  Bus=<span class="number">01</span> Lev=<span class="number">01</span> Prnt=<span class="number">01</span> Port=<span class="number">12</span> Cnt=<span class="number">04</span> Dev#=  <span class="number">8</span> Spd=<span class="number">480</span>  MxCh= <span class="number">4</span></span><br><span class="line">D:  Ver= <span class="number">2.00</span> Cls=<span class="number">09</span>(hub  ) Sub=<span class="number">00</span> Prot=<span class="number">01</span> MxPS=<span class="number">64</span> #Cfgs=  <span class="number">1</span></span><br><span class="line">P:  Vendor=<span class="number">058f</span> ProdID=<span class="number">6254</span> Rev= <span class="number">1.00</span></span><br><span class="line">C:* #Ifs= <span class="number">1</span> Cfg#= <span class="number">1</span> Atr=e0 MxPwr=<span class="number">100</span>mA</span><br><span class="line">I:* If#= <span class="number">0</span> Alt= <span class="number">0</span> #EPs= <span class="number">1</span> Cls=<span class="number">09</span>(hub  ) Sub=<span class="number">00</span> Prot=<span class="number">00</span> Driver=hub</span><br><span class="line">E:  Ad=<span class="number">81</span>(I) Atr=<span class="number">03</span>(Int.) MxPS=   <span class="number">1</span> Ivl=<span class="number">256</span>ms</span><br><span class="line"></span><br><span class="line">T:  Bus=<span class="number">01</span> Lev=<span class="number">02</span> Prnt=<span class="number">08</span> Port=<span class="number">00</span> Cnt=<span class="number">01</span> Dev#=  <span class="number">9</span> Spd=<span class="number">12</span>   MxCh= <span class="number">0</span></span><br><span class="line">D:  Ver= <span class="number">1.10</span> Cls=<span class="number">00</span>(&gt;ifc ) Sub=<span class="number">00</span> Prot=<span class="number">00</span> MxPS= <span class="number">8</span> #Cfgs=  <span class="number">1</span></span><br><span class="line">P:  Vendor=<span class="number">046</span>d ProdID=c542 Rev= <span class="number">3.03</span></span><br><span class="line">S:  Manufacturer=Logitech</span><br><span class="line">S:  Product=Wireless Receiver</span><br><span class="line">C:* #Ifs= <span class="number">1</span> Cfg#= <span class="number">1</span> Atr=a0 MxPwr= <span class="number">50</span>mA</span><br><span class="line">I:* If#= <span class="number">0</span> Alt= <span class="number">0</span> #EPs= <span class="number">1</span> Cls=<span class="number">03</span>(HID  ) Sub=<span class="number">01</span> Prot=<span class="number">02</span> Driver=usbhid</span><br><span class="line">E:  Ad=<span class="number">82</span>(I) Atr=<span class="number">03</span>(Int.) MxPS=   <span class="number">8</span> Ivl=<span class="number">4</span>ms</span><br><span class="line"></span><br><span class="line">T:  Bus=<span class="number">02</span> Lev=<span class="number">00</span> Prnt=<span class="number">00</span> Port=<span class="number">00</span> Cnt=<span class="number">00</span> Dev#=  <span class="number">1</span> Spd=<span class="number">10000</span> MxCh= <span class="number">9</span></span><br><span class="line">B:  Alloc=  <span class="number">0</span>/<span class="number">800</span> us ( <span class="number">0</span>%), #Int=  <span class="number">0</span>, #Iso=  <span class="number">0</span></span><br><span class="line">D:  Ver= <span class="number">3.10</span> Cls=<span class="number">09</span>(hub  ) Sub=<span class="number">00</span> Prot=<span class="number">03</span> MxPS= <span class="number">9</span> #Cfgs=  <span class="number">1</span></span><br><span class="line">P:  Vendor=<span class="number">1</span>d6b ProdID=<span class="number">0003</span> Rev= <span class="number">6.08</span></span><br><span class="line">S:  Manufacturer=Linux <span class="number">6.8</span><span class="number">.0</span><span class="number">-41</span>-generic xhci-hcd</span><br><span class="line">S:  Product=xHCI Host Controller</span><br><span class="line">S:  SerialNumber=<span class="number">0000</span>:<span class="number">00</span>:<span class="number">14.0</span></span><br><span class="line">C:* #Ifs= <span class="number">1</span> Cfg#= <span class="number">1</span> Atr=e0 MxPwr=  <span class="number">0</span>mA</span><br><span class="line">I:* If#= <span class="number">0</span> Alt= <span class="number">0</span> #EPs= <span class="number">1</span> Cls=<span class="number">09</span>(hub  ) Sub=<span class="number">00</span> Prot=<span class="number">00</span> Driver=hub</span><br><span class="line">E:  Ad=<span class="number">81</span>(I) Atr=<span class="number">03</span>(Int.) MxPS=   <span class="number">4</span> Ivl=<span class="number">256</span>ms</span><br></pre></td></tr></table></figure><p>前面字段的意思：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usb/core/devices.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> format_topo[] =</span><br><span class="line"><span class="comment">/* T:  Bus=dd Lev=dd Prnt=dd Port=dd Cnt=dd Dev#=ddd Spd=dddd MxCh=dd */</span></span><br><span class="line"><span class="string">&quot;\nT:  Bus=%2.2d Lev=%2.2d Prnt=%2.2d Port=%2.2d Cnt=%2.2d Dev#=%3d Spd=%-4s MxCh=%2d\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> format_string_manufacturer[] =</span><br><span class="line"><span class="comment">/* S:  Manufacturer=xxxx */</span></span><br><span class="line">  <span class="string">&quot;S:  Manufacturer=%.100s\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> format_string_product[] =</span><br><span class="line"><span class="comment">/* S:  Product=xxxx */</span></span><br><span class="line">  <span class="string">&quot;S:  Product=%.100s\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ALLOW_SERIAL_NUMBER</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> format_string_serialnumber[] =</span><br><span class="line"><span class="comment">/* S:  SerialNumber=xxxx */</span></span><br><span class="line">  <span class="string">&quot;S:  SerialNumber=%.100s\n&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> format_bandwidth[] =</span><br><span class="line"><span class="comment">/* B:  Alloc=ddd/ddd us (xx%), #Int=ddd, #Iso=ddd */</span></span><br><span class="line">  <span class="string">&quot;B:  Alloc=%3d/%3d us (%2d%%), #Int=%3d, #Iso=%3d\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> format_device1[] =</span><br><span class="line"><span class="comment">/* D:  Ver=xx.xx Cls=xx(sssss) Sub=xx Prot=xx MxPS=dd #Cfgs=dd */</span></span><br><span class="line">  <span class="string">&quot;D:  Ver=%2x.%02x Cls=%02x(%-5s) Sub=%02x Prot=%02x MxPS=%2d #Cfgs=%3d\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> format_device2[] =</span><br><span class="line"><span class="comment">/* P:  Vendor=xxxx ProdID=xxxx Rev=xx.xx */</span></span><br><span class="line">  <span class="string">&quot;P:  Vendor=%04x ProdID=%04x Rev=%2x.%02x\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> format_config[] =</span><br><span class="line"><span class="comment">/* C:  #Ifs=dd Cfg#=dd Atr=xx MPwr=dddmA */</span></span><br><span class="line">  <span class="string">&quot;C:%c #Ifs=%2d Cfg#=%2d Atr=%02x MxPwr=%3dmA\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> format_iad[] =</span><br><span class="line"><span class="comment">/* A:  FirstIf#=dd IfCount=dd Cls=xx(sssss) Sub=xx Prot=xx */</span></span><br><span class="line">  <span class="string">&quot;A:  FirstIf#=%2d IfCount=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> format_iface[] =</span><br><span class="line"><span class="comment">/* I:  If#=dd Alt=dd #EPs=dd Cls=xx(sssss) Sub=xx Prot=xx Driver=xxxx*/</span></span><br><span class="line">  <span class="string">&quot;I:%c If#=%2d Alt=%2d #EPs=%2d Cls=%02x(%-5s) Sub=%02x Prot=%02x Driver=%s\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> format_endpt[] =</span><br><span class="line"><span class="comment">/* E:  Ad=xx(s) Atr=xx(ssss) MxPS=dddd Ivl=D?s */</span></span><br><span class="line">  <span class="string">&quot;E:  Ad=%02x(%c) Atr=%02x(%-4s) MxPS=%4d Ivl=%d%cs\n&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="file-c"><a href="#file-c" class="headerlink" title="file.c"></a>file.c</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">root@h:usb<span class="comment"># dmesg | tail -n 20</span></span><br><span class="line">[45807.088223] usb 1-9.4: New USB device found, idVendor=0403, idProduct=6001, bcdDevice= 6.00</span><br><span class="line">[45807.088238] usb 1-9.4: New USB device strings: Mfr=1, Product=2, SerialNumber=3</span><br><span class="line">[45807.088244] usb 1-9.4: Product: FT232R USB UART</span><br><span class="line">[45807.088248] usb 1-9.4: Manufacturer: FTDI</span><br><span class="line">[45807.088252] usb 1-9.4: SerialNumber: A50285BI</span><br><span class="line">[45807.096989] ftdi_sio 1-9.4:1.0: FTDI USB Serial Device converter detected</span><br><span class="line">[45807.097079] usb 1-9.4: Detected FT232R</span><br><span class="line">[45807.097821] usb 1-9.4: FTDI USB Serial Device converter now attached to ttyUSB0</span><br><span class="line">[45956.898368] usb 1-12: new full-speed USB device number 16 using xhci_hcd</span><br><span class="line">[45957.039833] usb 1-12: New USB device found, idVendor=320f, idProduct=5055, bcdDevice= 1.04</span><br><span class="line">[45957.039852] usb 1-12: New USB device strings: Mfr=1, Product=2, SerialNumber=0</span><br><span class="line">[45957.039859] usb 1-12: Product: VGN N75 PRO</span><br><span class="line">[45957.039864] usb 1-12: Manufacturer: Telink</span><br><span class="line">[45957.049757] input: Telink VGN N75 PRO  as /devices/pci0000:00/0000:00:14.0/usb1/1-12/1-12:1.0/0003:320F:5055.0007/input/input33</span><br><span class="line">[45957.102483] hid-generic 0003:320F:5055.0007: input,hidraw3: USB HID v1.11 Keyboard [Telink VGN N75 PRO ] on usb-0000:00:14.0-12/input0</span><br><span class="line">[45957.118181] input: Telink VGN N75 PRO  Keyboard as /devices/pci0000:00/0000:00:14.0/usb1/1-12/1-12:1.1/0003:320F:5055.0008/input/input34</span><br><span class="line">[45957.169742] input: Telink VGN N75 PRO  as /devices/pci0000:00/0000:00:14.0/usb1/1-12/1-12:1.1/0003:320F:5055.0008/input/input35</span><br><span class="line">[45957.169984] input: Telink VGN N75 PRO  as /devices/pci0000:00/0000:00:14.0/usb1/1-12/1-12:1.1/0003:320F:5055.0008/input/input36</span><br><span class="line">[45957.170313] input: Telink VGN N75 PRO  Mouse as /devices/pci0000:00/0000:00:14.0/usb1/1-12/1-12:1.1/0003:320F:5055.0008/input/input37</span><br><span class="line">[45957.170779] hid-generic 0003:320F:5055.0008: input,hiddev2,hidraw4: USB HID v1.11 Keyboard [Telink VGN N75 PRO ] on usb-0000:00:14.0-12/input1</span><br><span class="line">root@h:usb<span class="comment"># ls</span></span><br><span class="line">hiddev0  hiddev1  hiddev2</span><br><span class="line">root@h:usb<span class="comment"># ls -lh</span></span><br><span class="line">total 0</span><br><span class="line">crw------- 1 root root 180, 0  9月  1 09:12 hiddev0</span><br><span class="line">crw------- 1 root root 180, 1  9月  1 09:12 hiddev1</span><br><span class="line">crw------- 1 root root 180, 2  9月  1 21:58 hiddev2</span><br><span class="line">root@h:usb<span class="comment">#</span></span><br></pre></td></tr></table></figure><h3 id="usbfs-接口驱动"><a href="#usbfs-接口驱动" class="headerlink" title="usbfs 接口驱动"></a>usbfs 接口驱动</h3><h3 id="hub-接口驱动"><a href="#hub-接口驱动" class="headerlink" title="hub 接口驱动"></a>hub 接口驱动</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/61079354">https://zhuanlan.zhihu.com/p/61079354</a></p></blockquote><p><img src="https://pica.zhimg.com/80/v2-6257ed39e775173bc62759393ddbb21c_720w.webp"></p><p>硬件主机控制器Host Controller之上运行的是HCD，是对主机控制器硬件的一个抽象，实现核心层与控制器之间的对话接口，USB HCD包含多种USB接口规范：</p><p>（1）UHCI：Intel提供，通用主机控制接口，USB1.0&#x2F;1.1；</p><p>（2）OHCI：微软提供，开放主机控制接口，USB1.0&#x2F;1.1；</p><p>（3）EHCI：增强主机控制接口，USB2.0；</p><p>2.4 USB Device Driver</p><p>USB设备驱动框架如下图所示：</p><p><img src="https://picx.zhimg.com/80/v2-e2d44ba87579ca5f775dc2d79fd48143_720w.webp"></p><p>USB设备是由一些配置(configuration)、接口（interface）和端点(endpoint)组成，，即一个USB设备可以含有一个或多个配置，在每个配置中可含有一个或多个接口，在每个接口中可含有若干个端点。一个USB设备驱动可能包含多个子驱动。一个USB设备子驱动程序对应一个USB接口，而非整个USB设备。</p><p>USB设备使用各种描述符来说明其设备架构，包括设备描述符、配置描述符、接口描述符、端点描述符、字符串描述符。后面单独讨论USB设备描述符。</p><p>USB传输的对象为端点(endpoint)，每一个端点都有传输类型，传输方向，除了端点0外，每一个端点只支持一个方向的数据传输，端点0用于控制传输，既能输出也能输入。输入(IN)、输出(OUT) “都是” 基于USB主机的立场说的。比如鼠标的数据是从鼠标传到PC机, 对应的端点称为”输入端点”。</p><p>通过以上分析，USB设备驱动模型可以概括为如下图。</p><p><img src="https://pic4.zhimg.com/80/v2-d3eab094e80102ae1ad79ed7fc477c2b_720w.webp"></p><p>主要包含三个部分：USB控制器驱动，USB核心，USB设备驱动。如上图khubd是USB守护进程，当USB设备插入的时候，守护进程监测到，USB主机控制器就会产生一个hub_irq中断，控制器调用hub的探测函数，来解析设备信息。</p><h3 id="hub-c-源码分析"><a href="#hub-c-源码分析" class="headerlink" title="hub.c 源码分析"></a>hub.c 源码分析</h3><p>hub.c 文件内容很多，但hub.h 中对外的接口还好。数据结构主要就一个 <code>usb_hub, usb_port</code>。</p><p>hub 参数太多了，且一开始不方便理解。先从 usb_port 开始</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_hub</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_port</span>**<span class="title">ports</span>;</span> <span class="comment">/* array of usb_port pointers */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * struct usb port - kernel&#x27;s representation of a usb port</span></span><br><span class="line"><span class="comment"> * @child: usb device attached to the port</span></span><br><span class="line"><span class="comment"> * @dev: generic device interface</span></span><br><span class="line"><span class="comment"> * @port_owner: port&#x27;s owner</span></span><br><span class="line"><span class="comment"> * @peer: related usb2 and usb3 ports (share the same connector)</span></span><br><span class="line"><span class="comment"> * @req: default pm qos request for hubs without port power control</span></span><br><span class="line"><span class="comment"> * @connect_type: port&#x27;s connect type</span></span><br><span class="line"><span class="comment"> * @location: opaque representation of platform connector location</span></span><br><span class="line"><span class="comment"> * @status_lock: synchronize port_event() vs usb_port_&#123;suspend|resume&#125;</span></span><br><span class="line"><span class="comment"> * @portnum: port index num based one</span></span><br><span class="line"><span class="comment"> * @is_superspeed cache super-speed status</span></span><br><span class="line"><span class="comment"> * @usb3_lpm_u1_permit: whether USB3 U1 LPM is permitted.</span></span><br><span class="line"><span class="comment"> * @usb3_lpm_u2_permit: whether USB3 U2 LPM is permitted.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_port</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_device</span> *<span class="title">child</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">dev</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_dev_state</span> *<span class="title">port_owner</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">usb_port</span> *<span class="title">peer</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dev_pm_qos_request</span> *<span class="title">req</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">usb_port_connect_type</span> <span class="title">connect_type</span>;</span></span><br><span class="line"><span class="type">usb_port_location_t</span> location;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">status_lock</span>;</span></span><br><span class="line">u32 over_current_count;</span><br><span class="line">u8 portnum;</span><br><span class="line">u32 quirks;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> is_superspeed:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> usb3_lpm_u1_permit:<span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> usb3_lpm_u2_permit:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> USB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scripts-管理多个 git 仓库</title>
      <link href="/2024/08/11/Scripts-git_tools/"/>
      <url>/2024/08/11/Scripts-git_tools/</url>
      
        <content type="html"><![CDATA[<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ANSI颜色码</span></span><br><span class="line">RED=<span class="string">&#x27;\033[0;31m&#x27;</span></span><br><span class="line">GREEN=<span class="string">&#x27;\033[0;32m&#x27;</span></span><br><span class="line">YELLOW=<span class="string">&#x27;\033[0;33m&#x27;</span></span><br><span class="line">BLUE=<span class="string">&#x27;\033[0;34m&#x27;</span></span><br><span class="line">NC=<span class="string">&#x27;\033[0m&#x27;</span> <span class="comment"># 恢复默认颜色</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define special characters</span></span><br><span class="line">OK_STATUS=$<span class="string">&#x27;\u2714&#x27;</span>   <span class="comment"># ✅</span></span><br><span class="line">FAIL_STATUS=$<span class="string">&#x27;\u274C&#x27;</span> <span class="comment"># ❌</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存当前目录</span></span><br><span class="line">current_dir=$(<span class="built_in">pwd</span>)</span><br><span class="line">command_to_execute=<span class="string">&quot;\$1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># git log</span></span><br><span class="line"><span class="keyword">function</span> git_log &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前分支名称</span></span><br><span class="line">current_branch=$(git rev-parse --abbrev-ref HEAD)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取默认远程仓库名称</span></span><br><span class="line">remote=$(git for-each-ref --format=<span class="string">&#x27;%(upstream:short)&#x27;</span> <span class="string">&quot;<span class="subst">$(git symbolic-ref -q HEAD)</span>&quot;</span>)</span><br><span class="line">remote_name=<span class="variable">$&#123;remote%%/*&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否存在默认远程仓库</span></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$remote</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;YELLOW&#125;</span>当前分支没有追踪远程分支。<span class="variable">$&#123;NO_COLOR&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment"># 检查本地是否有未推送的提交</span></span><br><span class="line">local_commits=$(git <span class="built_in">log</span> <span class="variable">$&#123;remote&#125;</span>..HEAD --oneline)</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$local_commits</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;YELLOW&#125;</span>存在未同步到远程仓库的提交 (<span class="variable">$&#123;FAIL_STATUS&#125;</span>):<span class="variable">$&#123;NO_COLOR&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$local_commits</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>当前分支已经全部同步到远程仓库 (<span class="variable">$&#123;OK_STATUS&#125;</span> ).<span class="variable">$&#123;NO_COLOR&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查远程是否有未拉取的提交</span></span><br><span class="line">git fetch <span class="variable">$&#123;remote_name&#125;</span> &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">remote_commits=$(git <span class="built_in">log</span> HEAD..<span class="variable">$&#123;remote&#125;</span> --oneline)</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="variable">$remote_commits</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;YELLOW&#125;</span>远程仓库存在未拉取的提交 (<span class="variable">$&#123;FAIL_STATUS&#125;</span>):<span class="variable">$&#123;NO_COLOR&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$remote_commits</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;GREEN&#125;</span>远程仓库的提交已经全部拉取到本地 (<span class="variable">$&#123;OK_STATUS&#125;</span> ).<span class="variable">$&#123;NO_COLOR&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># git status function</span></span><br><span class="line"><span class="keyword">function</span> git_status &#123;</span><br><span class="line">git status</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;&quot;</span></span><br><span class="line">git_log</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;BLUE&#125;</span>==========================================================================<span class="variable">$&#123;NO_COLOR&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历当前目录下的所有子目录</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> */ ; <span class="keyword">do</span></span><br><span class="line"><span class="comment"># 进入子目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$dir</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查子目录中是否存在.git目录</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;.git&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;BLUE&#125;</span>Executing &#x27;<span class="variable">$1</span>&#x27;, Current directory: <span class="subst">$(pwd)</span><span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"><span class="comment"># 执行传递进来的命令</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="variable">$command_to_execute</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;<span class="variable">$&#123;YELLOW&#125;</span><span class="variable">$dir</span> is not a git repository<span class="variable">$&#123;NC&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回初始目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$current_dir</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Operation completed for all repositories.&quot;</span></span><br></pre></td></tr></table></figure><p>将上面的脚本添加到 <code>bin</code> 目录下，或者增加 <code>PATH</code> 环境变量，以便任意位置都可以执行。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>以上脚本命名为 gits，用法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gits <span class="string">&quot;git_status&quot;</span> <span class="comment"># 遍历每个子目录，如果是 git 仓库，执行 git status</span></span><br><span class="line">                  <span class="comment"># 并检查是否有未同步到远程仓库的提交，或者未拉取到本地仓库的提交</span></span><br><span class="line"></span><br><span class="line">gits <span class="string">&quot;git xxx&quot;</span> <span class="comment"># 遍历每个子目录，如果是 git 仓库，执行 git xxx</span></span><br><span class="line">               <span class="comment"># 例如 gits &quot;git fetch&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Alios USB camera 常见需求处理</title>
      <link href="/2024/06/04/Cvitek-usbcamera%E9%9C%80%E6%B1%82/"/>
      <url>/2024/06/04/Cvitek-usbcamera%E9%9C%80%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h2><h3 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h3><p>每个组件都有一个 <code>.yaml</code> 配置文件，主要关注：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">def_config:</span> <span class="comment"># 组件的可配置项</span></span><br><span class="line">  <span class="attr">CONFIG_XXX:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>def_config</code> 下的配置都会以宏定义的形式来影响代码。就相当于在编译时多了 <code>-DCONFIG_XXX=1</code> 这样。</p><h3 id="Solution-配置"><a href="#Solution-配置" class="headerlink" title="Solution 配置"></a>Solution 配置</h3><p>Solution 也有一个 <code>yaml</code> 的配置文件，也包含 <code>depends</code>、<code>def_config</code> 等配置项，这里单独来讲主要是想强调 <code>def_config</code> 这个配置，Solution 下的配置文件中，可以修改任意组件的 <code>def_config</code> 。也就是说，每个组件下的配置文件中，<code>def_config</code> 下配置相当于是<em>默认配置</em>。如果 Solution 下的配置项与组件的下配置不一致，以 Solution 的为准。</p><p><strong>❗❗强调：Solution 下的配置会对所有组件生效，所以在定义配置的时候，注意配置名是否与其他组件重复了（可以重复，但要确认这是你期望的）。</strong></p><h2 id="用户常用改动"><a href="#用户常用改动" class="headerlink" title="用户常用改动"></a>用户常用改动</h2><ul><li><p><input checked="" disabled="" type="checkbox"> 板卡内存大小</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_DRAM_CFG:</span> <span class="string">&quot;128m&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><input checked="" disabled="" type="checkbox"> 配置 UVC 数量。有的客户是单目，有的客户是双目。</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_USBD_UVC_NUM:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p><input checked="" disabled="" type="checkbox"> 修改 PID, VID。（设备描述符里面）</p></li><li><p><input checked="" disabled="" type="checkbox"> 修改设备名称（视频控制接口描述符里面。双目场景一般一个rgb摄像头 + 一个红外摄像头，需要分别设置名字以区分）。</p></li><li><p><input checked="" disabled="" type="checkbox"> 修改序列号。（设备描述符里面）</p></li><li><p><input checked="" disabled="" type="checkbox"> 修改 PRODUCT ID（设备描述符里面）</p></li><li><p><input checked="" disabled="" type="checkbox"> 视频码率控制。（MJPEG&#x2F;H264 H265）</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_UVC_MJPEG_BITRATE:</span> <span class="number">20480</span>          <span class="comment"># UVC 推流时，设置视频编码器 MJPEG 的码率，单位 kbps</span></span><br><span class="line"><span class="attr">CONFIG_UVC_H264_H265_BITRATE:</span> <span class="number">4096</span>       <span class="comment"># UVC 推流时，设置视频编码器 H264/H265 的码率，单位 kbps</span></span><br></pre></td></tr></table></figure></li><li><p><input disabled="" type="checkbox"> 灯光亮度控制。（通过 PWM 调控）</p></li><li><p><input checked="" disabled="" type="checkbox"> 分辨率。（不同客户需要支持的分辨率不一样）</p></li><li><p><input checked="" disabled="" type="checkbox"> 支持高分辨率（vpss 仅一个通道支持2880x1620)</p></li><li><p><input checked="" disabled="" type="checkbox"> <a href="#USBcamera%E9%80%9A%E7%94%A8%E5%8A%9F%E8%83%BD">USB camera 通用功能（亮度、色调、饱和度等调整）</a></p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_UVC_COMM_FUNC:</span> <span class="number">0</span>                  <span class="comment"># USB camera 使能亮度、色调、对比度等调整功能</span></span><br></pre></td></tr></table></figure></li><li><p><input checked="" disabled="" type="checkbox"> <a href="#%E4%BF%9D%E6%8C%81%E8%BE%93%E5%87%BA%E9%95%BF%E5%AE%BD%E6%AF%94">设置裁剪以保证任意格式输出不会变形</a></p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_UVC_CROP_BEFORE_SCALE:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="板卡内存大小"><a href="#板卡内存大小" class="headerlink" title="板卡内存大小"></a>板卡内存大小</h3><p>1811c，1810c 等内存大小不一样，需要更具客户使用的具体芯片来调整。</p><p><strong>配置选项</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_DRAM_CFG:</span> <span class="string">&quot;128m&quot;</span></span><br></pre></td></tr></table></figure><p><strong>默认配置</strong>：<code>64m</code></p><p><strong>用户（特定项目）配置位置</strong>：<code>solutions/usb_cam/customization/&#123;项目xxx&#125;/package.xxx.yaml</code></p><h3 id="UVC-数量"><a href="#UVC-数量" class="headerlink" title="UVC 数量"></a>UVC 数量</h3><p><strong>配置选项</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_USBD_UVC_NUM:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>默认配置</strong>：<code>1</code></p><p><strong>组件配置位置（默认配置）</strong>：<code>components/cvi_platform/package.yaml</code></p><p><strong>用户（特定项目）配置位置</strong>：<code>solutions/usb_cam/customization/&#123;项目xxx&#125;/package.xxx.yaml</code></p><h3 id="PID-x2F-VID-修改"><a href="#PID-x2F-VID-修改" class="headerlink" title="PID&#x2F;VID 修改"></a>PID&#x2F;VID 修改</h3><p>暂未定义宏。直接修改对应文件。</p><p><strong>配置位置</strong>：<code>components/cvi_platform/protocol/usb_devices/usbd_composite/src/usbd_comp.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CVITEK_VENDOR_ID        0x3346    <span class="comment">/* cvitek vendor id */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVITEK_PRODUCT_ID       0x0001    <span class="comment">/* Webcam A/V gadget */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CVITEK_DEVICE_BCD       0x0001    <span class="comment">/* 0.01 */</span></span></span><br><span class="line"></span><br><span class="line"># 修改上述宏，在设备描述符中使用</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_descriptor</span> <span class="title">comp_device_descriptor</span> =</span> &#123;</span><br><span class="line">    .bLength            = USB_DT_DEVICE_SIZE,</span><br><span class="line">    .bDescriptorType    = USB_DT_DEVICE,</span><br><span class="line">    .bcdUSB             = USB_2_0,</span><br><span class="line">    .bDeviceClass       = USB_CLASS_MISC,</span><br><span class="line">    .bDeviceSubClass    = <span class="number">0x02</span>,</span><br><span class="line">    .bDeviceProtocol    = <span class="number">0x01</span>,</span><br><span class="line">    .bMaxPacketSize0    = <span class="number">0x40</span>,</span><br><span class="line">    .idVendor           = cpu_to_le16(CVITEK_VENDOR_ID),   # VID</span><br><span class="line">    .idProduct          = cpu_to_le16(CVITEK_PRODUCT_ID),  # PID</span><br><span class="line">    .bcdDevice          = cpu_to_le16(CVITEK_DEVICE_BCD),</span><br><span class="line">    .iManufacturer      = USB_STRING_MFC_INDEX,</span><br><span class="line">    .iProduct           = USB_STRING_PRODUCT_INDEX,</span><br><span class="line">    .iSerialNumber      = USB_STRING_SERIAL_INDEX,</span><br><span class="line">    .bNumConfigurations = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="修改序列号"><a href="#修改序列号" class="headerlink" title="修改序列号"></a>修改序列号</h3><p>序列号<code>iSerialNumber</code>是在设备描述中指定的（指定字符串描述符的ID）。要修改的话只需修改对应的字符串描述符。</p><p><strong>配置位置</strong>：<code>components/cvi_platform/protocol/usb_devices/usbd_composite/src/usbd_comp.c</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static const struct usb_descriptor_header * const comp_string_descriptors[] = &#123;</span><br><span class="line">    (struct usb_descriptor_header *) &amp;comp_string_descriptor_zero,</span><br><span class="line">    (struct usb_descriptor_header *) &amp;comp_string_descriptor_manufacturer,</span><br><span class="line">    (struct usb_descriptor_header *) &amp;dev_string_descriptor_product,</span><br><span class="line">    (struct usb_descriptor_header *) &amp;comp_string_descriptor_serial, // 序列号字符串描述符</span><br><span class="line">    (struct usb_descriptor_header *) &amp;comp_string_descriptor_zero,</span><br><span class="line">    (struct usb_descriptor_header *) &amp;uac_string_descriptor_audio,</span><br><span class="line">    (struct usb_descriptor_header *) &amp;uvc_string_descriptor_camera1_name,</span><br><span class="line">    (struct usb_descriptor_header *) &amp;uvc_string_descriptor_camera2_name,</span><br><span class="line">    (struct usb_descriptor_header *) &amp;uvc_string_descriptor_camera3_name,</span><br><span class="line">    NULL,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 修改 `comp_string_descriptor_serial` 即可。</span><br><span class="line">// 由于 USB 协议规定序列号是 unicode 编码，所以要用 `cpu_to_le16` 转换。</span><br><span class="line">// 并注意字符串的长度和声明的一致。</span><br><span class="line">DECLARE_UVC_STRING_DESCRIPTOR(10);</span><br><span class="line">static const struct UVC_STRING_DESCRIPTOR(10) comp_string_descriptor_serial = &#123;</span><br><span class="line">    .bLength            = UVC_STRING_DESCRIPTOR_SIZE(10),</span><br><span class="line">    .bDescriptorType    = USB_DESCRIPTOR_TYPE_STRING,</span><br><span class="line">    .wData              = &#123;</span><br><span class="line">        cpu_to_le16(&#x27;2&#x27;),</span><br><span class="line">        cpu_to_le16(&#x27;0&#x27;),</span><br><span class="line">        cpu_to_le16(&#x27;2&#x27;),</span><br><span class="line">        cpu_to_le16(&#x27;4&#x27;),</span><br><span class="line">        cpu_to_le16(&#x27;0&#x27;),</span><br><span class="line">        cpu_to_le16(&#x27;1&#x27;),</span><br><span class="line">        cpu_to_le16(&#x27;1&#x27;),</span><br><span class="line">        cpu_to_le16(&#x27;9&#x27;),</span><br><span class="line">        cpu_to_le16(&#x27;0&#x27;),</span><br><span class="line">        cpu_to_le16(&#x27;0&#x27;),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="动态修改序列号✨"><a href="#动态修改序列号✨" class="headerlink" title="动态修改序列号✨"></a>动态修改序列号✨</h3><p>基本都会用到。</p><h3 id="修改-PRODUCT-ID"><a href="#修改-PRODUCT-ID" class="headerlink" title="修改 PRODUCT ID"></a>修改 PRODUCT ID</h3><p><code>product ID</code> 也是在设备描述中指定的<code>iProduct</code>（指定字符串描述符的ID）。要修改的话只需修改对应的字符串描述符。</p><p><strong>配置位置</strong>：<code>components/cvi_platform/protocol/usb_devices/usbd_composite/src/usbd_comp.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title function_">UVC_STRING_DESCRIPTOR</span><span class="params">(<span class="number">10</span>)</span> dev_string_descriptor_product = &#123;</span><br><span class="line">    .bLength            = UVC_STRING_DESCRIPTOR_SIZE(<span class="number">10</span>),</span><br><span class="line">    .bDescriptorType    = USB_DESCRIPTOR_TYPE_STRING,</span><br><span class="line">    .wData              = &#123;</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;C&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;V&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;I&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;T&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;E&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;K&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;-&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;D&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;E&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;V&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="设备名称修改"><a href="#设备名称修改" class="headerlink" title="设备名称修改"></a>设备名称修改</h3><p>设备名称也是通过字符串描述符传递。视频控制接口描述符中的 <code>iInterface</code> 指定了名称对应的字符串描述符的下标。</p><p><strong>配置位置</strong>：<code>components/cvi_platform/protocol/usb_devices/usbd_composite/src/usbd_comp.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_descriptor_header</span> * <span class="title">const</span> <span class="title">comp_string_descriptors</span>[] =</span> &#123;</span><br><span class="line">    (<span class="keyword">struct</span> usb_descriptor_header *) &amp;comp_string_descriptor_zero,</span><br><span class="line">    (<span class="keyword">struct</span> usb_descriptor_header *) &amp;comp_string_descriptor_manufacturer,</span><br><span class="line">    (<span class="keyword">struct</span> usb_descriptor_header *) &amp;dev_string_descriptor_product,</span><br><span class="line">    (<span class="keyword">struct</span> usb_descriptor_header *) &amp;comp_string_descriptor_serial,</span><br><span class="line">    (<span class="keyword">struct</span> usb_descriptor_header *) &amp;comp_string_descriptor_zero,</span><br><span class="line">    (<span class="keyword">struct</span> usb_descriptor_header *) &amp;uac_string_descriptor_audio,</span><br><span class="line">    (<span class="keyword">struct</span> usb_descriptor_header *) &amp;uvc_string_descriptor_camera1_name, <span class="comment">// 3个设备名称描述符</span></span><br><span class="line">    (<span class="keyword">struct</span> usb_descriptor_header *) &amp;uvc_string_descriptor_camera2_name,</span><br><span class="line">    (<span class="keyword">struct</span> usb_descriptor_header *) &amp;uvc_string_descriptor_camera3_name,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UVC Camera max name length is 32  */</span></span><br><span class="line">DECLARE_UVC_STRING_DESCRIPTOR(<span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">struct</span> <span class="title function_">UVC_STRING_DESCRIPTOR</span><span class="params">(<span class="number">32</span>)</span> uvc_string_descriptor_camera1_name = &#123;</span><br><span class="line">    .bLength            = UVC_STRING_DESCRIPTOR_SIZE(<span class="number">14</span>), <span class="comment">// name length is 14</span></span><br><span class="line">    .bDescriptorType    = USB_DESCRIPTOR_TYPE_STRING,</span><br><span class="line">    .wData              = &#123;</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;C&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;V&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;I&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;T&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;E&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;K&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27; &#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;C&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;A&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;M&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;E&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;R&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;A&#x27;</span>),</span><br><span class="line">        cpu_to_le16(<span class="string">&#x27;1&#x27;</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>目前最大支持三个摄像头，所以这里预留了三个设备描述符。如需修改名称，修改对应的描述符即可。</p><p>❗❗<strong>注意</strong>：修改之后，Windows 需要在设备管理器中卸载设备，再插上设备才能看的修改后的名字。(Windows自身有缓存)</p><h3 id="视频码率控制"><a href="#视频码率控制" class="headerlink" title="视频码率控制"></a>视频码率控制</h3><p>目前 <code>H264/H265</code> 都是吃配置 <code>CONFIG_UVC_H264_H265_BITRATE</code>。</p><p><code>MJPEG</code> 格式的码率则是通过 <code>CONFIG_UVC_MJPEG_BITRATE</code> 配置。</p><p><strong>配置选项</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_UVC_MJPEG_BITRATE:</span> <span class="number">20480</span>          <span class="comment"># UVC 推流时，设置视频编码器 MJPEG 的码率，单位 kbps</span></span><br><span class="line"><span class="attr">CONFIG_UVC_H264_H265_BITRATE:</span> <span class="number">4096</span>       <span class="comment"># UVC 推流时，设置视频编码器 H264/H265 的码率，单位 kbps</span></span><br></pre></td></tr></table></figure><p><strong>组件配置位置（默认配置）</strong>：<code>components/cvi_platform/package.yaml</code></p><p><strong>用户（特定项目）配置位置</strong>：<code>solutions/usb_cam/customization/&#123;项目xxx&#125;/package.xxx.yaml</code></p><h3 id="视频格式设置"><a href="#视频格式设置" class="headerlink" title="视频格式设置"></a>视频格式设置</h3><p>目前支持 <code>YUY2</code>，<code>H264</code>，<code>H265</code>，<code>MJPEG</code> 4 种格式出流。其中 H264, H265 有一个 DISABLE 配置选项，因为这两种编解码方式需要一个固件，H264 的固件大小约为253k，h265 约为 147k，某些场景下flash 大小不够需要严格控制固件大小，就可以考虑disable h264&#x2F;h265。</p><p>不过目前release 版本中，codec 是以.a 静态库的形式提供的，默认是使能了的。所以该配置意义不大。</p><p><strong>配置选项</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_DISABLE_VENC_H264:</span> <span class="number">0</span>              <span class="comment"># 是否禁用 H264 编码</span></span><br><span class="line"><span class="attr">CONFIG_DISABLE_VENC_H265:</span> <span class="number">0</span>              <span class="comment"># 是否禁用 H265 编码</span></span><br></pre></td></tr></table></figure><p><strong>用户（特定项目）配置位置</strong>：<code>solutions/usb_cam/customization/&#123;项目xxx&#125;/package.xxx.yaml</code></p><h3 id="分辨率设置"><a href="#分辨率设置" class="headerlink" title="分辨率设置"></a>分辨率设置</h3><p>可为不同视频格式配置多种不同的分辨率，直接修改对于的描述数组。</p><p><strong>配置位置</strong>：<code>components/cvi_platform/protocol/usb_devices/usbd_class/usbd_uvc/src/usbd_uvc.c</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static struct uvc_frame_info_st yuy2_frame_info[] = &#123;</span><br><span class="line">    &#123;1, 800, 600, 15, 0&#125;,</span><br><span class="line">    &#123;2, 640, 360, 15, 0&#125;,</span><br><span class="line">    &#123;3, 400, 300, 15, 0&#125;,</span><br><span class="line">    &#123;5, 480, 320, 15, 0&#125;,</span><br><span class="line">    &#123;6, 480, 360, 15, 0&#125;,</span><br><span class="line">    &#123;7, 1280, 720, 15, 0&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct uvc_frame_info_st mjpeg_frame_info[] = &#123;</span><br><span class="line">&#123;1, 240, 320, 30, 0&#125;,</span><br><span class="line">&#123;2, 320, 240, 30, 0&#125;,</span><br><span class="line">&#123;3, 480, 320, 30, 0&#125;,</span><br><span class="line">&#123;4, 640, 480, 30, 0&#125;,</span><br><span class="line">&#123;5, 656, 468, 30, 0&#125;,</span><br><span class="line">&#123;6, 720, 480, 30, 0&#125;,</span><br><span class="line">&#123;7, 800, 480, 30, 0&#125;,</span><br><span class="line">&#123;8, 864, 480, 30, 0&#125;,</span><br><span class="line">&#123;9, 800, 600, 30, 0&#125;,</span><br><span class="line">&#123;10, 1280, 720, 30, 0&#125;,</span><br><span class="line">&#123;11, 1920, 1080, 30, 0&#125;,</span><br><span class="line">&#123;12, 1600, 1200, 30, 0&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static struct uvc_frame_info_st h264_frame_info[] = &#123;</span><br><span class="line">    &#123;1, 800, 600, 30, 0&#125;,</span><br><span class="line">    &#123;2, 1280, 720, 30, 0&#125;,</span><br><span class="line">    &#123;3, 640, 480, 30, 0&#125;,</span><br><span class="line">    &#123;4, 400, 300, 30, 0&#125;,</span><br><span class="line">    &#123;5, 1920, 1080, 30, 0&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>格式为：<code>&#123;序号，宽，高，帧率，是否旋转&#125;</code>。</p><h3 id="支持高分辨率"><a href="#支持高分辨率" class="headerlink" title="支持高分辨率"></a>支持高分辨率</h3><p>视频流处理过程中，会用到一些中间变量来存放图像数据，目前该变量的大小是预先确定的，即 <code>DEFAULT_FRAME_SIZE</code>。默认分配的大小是1920x1080x1.5。</p><p>在大多数情况下，MJEPG&#x2F;H264&#x2F;H265 等需要存放的都是编码后的数据，即使是 2560x1440 经过编码后也完全能存放下，但我们还支持未压缩的 YUY2 格式，若需要输出 1920x1080 的 YUY2 格式，则上述空间就不够用了。需要设置为 1920x1080x2，另外，处理过程中还需要再原始图像数据的基础上，每1012字节加上12字节的header，所以还需额外分配 些空间。目前建议设置  1920x1120x2</p><p><strong>配置位置</strong>：<code>components/cvi_platform/protocol/usb_devices/usbd_class/usbd_uvc/src/usbd_uvc.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH  (unsigned int)(1920)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEIGHT (unsigned int)(1080)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAM_FPS        (30)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERVAL       (unsigned long)(10000000 / CAM_FPS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FRAME_SIZE (unsigned long)(WIDTH * HEIGHT * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_FRAME_SIZE (unsigned long)(WIDTH * HEIGHT * 3 / 2)</span></span><br></pre></td></tr></table></figure><p>修改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH  (unsigned int)(1920)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEIGHT (unsigned int)(1120)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAM_FPS        (30)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTERVAL       (unsigned long)(10000000 / CAM_FPS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FRAME_SIZE (unsigned long)(WIDTH * HEIGHT * 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_FRAME_SIZE (unsigned long)(WIDTH * HEIGHT * 2)</span></span><br></pre></td></tr></table></figure><h3 id="支持-2880x1440-等高分辨率"><a href="#支持-2880x1440-等高分辨率" class="headerlink" title="支持 2880x1440 等高分辨率"></a>支持 2880x1440 等高分辨率</h3><p>参考 《Cvitek Debug SOP》</p><p>这个问题是由vpss各scaler硬件性能差异导致的，这种情况下需要使用最强的scaler-1进行所需图像处理。具体的，对于single mode，需要设置vpss chn的chn号为1，<strong>对于dual mode，需要设置 grp 属性中的u8VpssDev为1且设置vpss chn的chn号为0</strong>。</p><p><strong>推荐解决办法：即使单个设备也使用dual mode</strong>。</p><p>备选方案：使用 single mode 并设置通道为1的话，目前还会启用通道0，会占用额外的VB，也可以合入这笔代码 <a href="https://gerrit-ai.sophgo.vip:8443/#/c/114453/%EF%BC%8C%E4%B8%8D%E5%90%AF%E7%94%A8chn0%E3%80%82%E8%BF%99%E6%A0%B7%E8%BF%98%E9%9C%80%E4%BF%AE%E6%94%B9uvc">https://gerrit-ai.sophgo.vip:8443/#/c/114453/，不启用chn0。这样还需修改uvc</a> 使用的通道号为1.  VPSS 和venc的绑定关系在：<code>components/cvi_platform/protocol/usb_devices/usbd_class/usbd_uvc/src/usbd_uvc.c</code> 中<code>uvc</code>这个全局变量下配置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static struct uvc_device_info uvc[USBD_UVC_MAX_NUM] = &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    // .ep = 0x81,</span><br><span class="line">    .format_info = uvc_format_info,</span><br><span class="line">    .formats = ARRAY_SIZE(uvc_format_info),</span><br><span class="line">    .video = &#123;0, 0, 1&#125;, // &#123;venc chn, vpss grp, vpss chn&#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="USBcamera通用功能"><a href="#USBcamera通用功能" class="headerlink" title="USBcamera通用功能"></a>USBcamera通用功能</h3><blockquote><p>其他项目也会用到 usbcamera，但并不需要调整色调等功能，所以目前 SDK 默认并未启用这些功能。</p><p>如需启用，需要通过配置 <code>CONFIG_UVC_COMM_FUNC:1</code>，则将目前支持的功能都启用。</p></blockquote><p><strong>配置选项</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_UVC_COMM_FUNC:</span> <span class="number">0</span>                  <span class="comment"># USB camera 使能亮度、色调、对比度等调整功能</span></span><br></pre></td></tr></table></figure><p><strong>默认配置</strong>：<code>0</code> 未启用。</p><p><strong>组件配置位置（默认配置）</strong>：<code>components/cvi_platform/package.yaml</code></p><p><strong>用户（特定项目）配置位置</strong>：<code>solutions/usb_cam/customization/&#123;项目xxx&#125;/package.xxx.yaml</code></p><p><strong>注意</strong>：由于有多目 sensor 的场景，在特定摄像头下进行配置的时候，会区分设备的。设备需要与对应的 VPSS GRP, VI_PIPE 绑定，必须满足以下关系：</p><p>SENSOR0 -&gt; VI_PIPE0 -&gt; GRP0</p><p>SENSOR1 -&gt; VI_PIPE1 -&gt; GRP1</p><p>否则设置无法生效。</p><p><strong>VI 绑定 VPSS</strong> 是在 <code>solutions/usb_cam/customization/&#123;xxx&#125;/param/custom_vpssparam.c</code> 中，Group 配置中有如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.bBindMode = CVI_TRUE,</span><br><span class="line">.astChn[<span class="number">0</span>] = &#123;</span><br><span class="line">    .enModId = CVI_ID_VI,</span><br><span class="line">    .s32DevId = <span class="number">0</span>,</span><br><span class="line">    .s32ChnId = <span class="number">1</span>,  <span class="comment">// VI CHN ID</span></span><br><span class="line">&#125;,</span><br><span class="line">.astChn[<span class="number">1</span>] = &#123;</span><br><span class="line">    .enModId = CVI_ID_VPSS,</span><br><span class="line">    .s32DevId = <span class="number">1</span>,  <span class="comment">// group ID</span></span><br><span class="line">    .s32ChnId = <span class="number">0</span>,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>目前支持的功能有：</p><ul><li><input disabled="" type="checkbox"> PROCESSING UNIT<ul><li><input checked="" disabled="" type="checkbox"> 亮度</li><li><input checked="" disabled="" type="checkbox"> 对比度</li><li><input checked="" disabled="" type="checkbox"> 色调</li><li><input checked="" disabled="" type="checkbox"> 饱和度</li><li><input checked="" disabled="" type="checkbox"> 锐度</li></ul></li><li><input disabled="" type="checkbox"> INPUT TERMINAL(CAMERA TERMINAL)<ul><li><input checked="" disabled="" type="checkbox"> PANTILE上下左右移动(绝对)</li></ul></li><li><input disabled="" type="checkbox"> EXTENSION UNIT<ul><li><input checked="" disabled="" type="checkbox"> REBOOT（发送 reboot 会重启，无插拔烧录时用）</li></ul></li></ul><h3 id="保持输出长宽比"><a href="#保持输出长宽比" class="headerlink" title="保持输出长宽比"></a>保持输出长宽比</h3><p>当sensor的输入图像为 16:9 时，若输出的分辨率为 4:3 ，会看到输出的图像明显发生畸变 &#x2F; 或者说有黑边（<strong>取决于 vpss 通道的 ASPECT_RATIO_S 参数设置</strong>）。可以使能该配置 <code>CONFIG_UVC_CROP_BEFORE_SCALE:1</code>，在进行缩放前先进行裁剪，使裁剪后的大小与输出的长宽比一致，并且尽可能提供更大的视野。这样经过缩放就不会发生畸变。</p><p><strong>配置选项</strong>：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_UVC_CROP_BEFORE_SCALE:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>默认配置</strong>：<code>1</code></p><p><strong>组件配置位置（默认配置）</strong>：<code>components/cvi_platform/package.yaml</code></p><p><strong>用户（特定项目）配置位置</strong>：<code>solutions/usb_cam/customization/&#123;项目xxx&#125;/package.xxx.yaml</code></p><h3 id="保持输出长宽比2–是否插黑边"><a href="#保持输出长宽比2–是否插黑边" class="headerlink" title="保持输出长宽比2–是否插黑边"></a>保持输出长宽比2–是否插黑边</h3><p>VPSS 在缩放处理时，可以指定参数是否保存长宽比。</p><p>如 1280x720的屏幕，如果输出的画面是 800x400，</p><ul><li>AUTO 保持比例的话就会拉伸为960x720，左右两边就会有黑边。</li><li>NONE 不进行处理，原始大小输出。（画面可能会变形，比如16:9的输入，输出为4:3时）</li><li>MANUAL 手动指定显示的位置，以及显示画面的宽、高。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ASPECT_RATIO_S</span> &#123;</span></span><br><span class="line">    ASPECT_RATIO_E enMode;      <span class="comment">// 是否固定长宽比：NONE, AUTO, MANUAL</span></span><br><span class="line">    CVI_BOOL bEnableBgColor;    <span class="comment">// 是否要让画面以外以背景色覆盖。</span></span><br><span class="line">    CVI_U32 u32BgColor;         <span class="comment">// 填充背景颜色，RGB 888，可通过宏 RGB_8BIT(0, 0, 0xFF) 来指定。bit[7:0]為 B，bit[15:8]為 G，bit[23:16]為 R</span></span><br><span class="line">    RECT_S stVideoRect;         <span class="comment">// 在手动模式时才生效，这个 RECT</span></span><br><span class="line">&#125; ASPECT_RATIO_S;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">ASPECT_RATIO_E</span> &#123;</span></span><br><span class="line">    ASPECT_RATIO_NONE = <span class="number">0</span>,      <span class="comment">// 无动作，满屏</span></span><br><span class="line">    ASPECT_RATIO_AUTO,          <span class="comment">// 视频保持比例，自动计算视频区域</span></span><br><span class="line">    ASPECT_RATIO_MANUAL,        <span class="comment">// 手动决定视频区域</span></span><br><span class="line">    ASPECT_RATIO_MAX</span><br><span class="line">&#125; ASPECT_RATIO_E;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RECT_S</span> &#123;</span></span><br><span class="line">    CVI_S32 s32X;</span><br><span class="line">    CVI_S32 s32Y;</span><br><span class="line">    CVI_U32 u32Width;</span><br><span class="line">    CVI_U32 u32Height;</span><br><span class="line">&#125; RECT_S;</span><br></pre></td></tr></table></figure><p><strong>用户（特定项目）配置位置</strong>：<code>solutions/usb_cam/customization/&#123;项目xxx&#125;/param/custom_vpssparam.c</code> 为每个 vpss 通道单独配置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PARAM_CLASSDEFINE(PARAM_VPSS_CHN_CFG_S, CHNCFG, GRP0, CHN) [] =</span><br><span class="line">&#123;</span><br><span class="line">   &#123;.u8Rotation = ROTATION_0,</span><br><span class="line">    .stVpssChnAttr = &#123;</span><br><span class="line">            .u32Width = <span class="number">2880</span>,</span><br><span class="line">            .u32Height = <span class="number">1620</span>,</span><br><span class="line">            .enVideoFormat = VIDEO_FORMAT_LINEAR,</span><br><span class="line">            .enPixelFormat = PIXEL_FORMAT_NV21,</span><br><span class="line">            .stFrameRate.s32SrcFrameRate = <span class="number">-1</span>,</span><br><span class="line">            .stFrameRate.s32DstFrameRate = <span class="number">-1</span>,</span><br><span class="line">            .bFlip = CVI_FALSE,</span><br><span class="line">            .bMirror = CVI_FALSE,</span><br><span class="line">            .u32Depth = <span class="number">0</span>,</span><br><span class="line">            .stAspectRatio.enMode = ASPECT_RATIO_AUTO, <span class="comment">// 保持比例，会有黑边，未配置的话就是拉伸</span></span><br><span class="line">            .stAspectRatio.bEnableBgColor = CVI_TRUE,</span><br><span class="line">            .stAspectRatio.u32BgColor    = COLOR_RGB_BLACK,</span><br><span class="line">            .stNormalize.bEnable = CVI_FALSE,</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure><h3 id="启用-pqtool-支持"><a href="#启用-pqtool-支持" class="headerlink" title="启用 pqtool 支持"></a>启用 pqtool 支持</h3><p>❗❗<strong>注意编译时要指定正确的 <code>CHIP_ARCH</code> ，否则会导致 pqtool 工具使用时报错</strong>。通过 <code>export CHIP_ARCH=cv181x; make usb_cam PROJECTS=&quot;XXXX&quot;</code>  编译。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CONFIG_PQTOOL_SUPPORT:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">CONFIG_USBD_CDC_RNDIS:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">CONFIG_USBD_UVC:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">CONFIG_USB_DWC2_DMA_ENABLE:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">CONFIG_APP_RTSP_SUPPORT:</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>启用 pqtool_support 以及 rndis 网络才能让pc端工具连上。使用 UVC 出流效果比 rtsp 更好。<br>DMA 与 rndis 不兼容，所以要关闭。不过目前不开 DMA 会有概率屏闪，所以仅推荐在调试时关闭DMA。<br>RTSP 与 UVC 不兼容，所以要关闭。</p><p><strong>目前 RNDIS  有概率出错，发现连不上的话在设备管理器中，禁用 rndis 对应的设备再启用。</strong></p><p>板端默认的 IP 地址是 <code>192.168.11.10</code>，PC端对应的 rndis 网卡的 IP 也需要手动设置到相同网段，才能使用 Pqtool 工具进行连接。</p><h3 id="快启说明"><a href="#快启说明" class="headerlink" title="快启说明"></a>快启说明</h3><p>为了能使用USB烧录，在rom阶段会等待1s检测usb连接，还有uart烧录的引脚被占用，也会等待1s。</p><ul><li><p>快启1：通过写 efuse 跳过 rom 阶段的烧录检测。</p><ul><li>配置：<code>CONFIG_ENABLE_FASTBOOT=1</code>，启用后，app_main 中会调用 <code>CVI_EFUSE_EnableFastBoot</code> 去烧写 efuse 使能快启。</li><li>收益：1s整或2s整。</li></ul></li><li><p>快启2：boot0 阶段通过拉高 SPI 的速率加速从flash load固件的过程。来提升启动速度。</p><ul><li>配置：<code>CONFIG_QUICK_STARTUP_SUPPORT</code>。启用后 boot0 中会拉高 spi 的时钟。</li><li>收益：看yoc.bin，或者是否需要从flash加载模型吧，收益不大，可能就几十ms。</li></ul></li></ul><h3 id="AE-快速收敛"><a href="#AE-快速收敛" class="headerlink" title="AE 快速收敛"></a>AE 快速收敛</h3><p>若 sensor 的自动曝光调整较慢，在刚打开sensor时，可能会看到明显的画面亮度调整的过程。可以调整pq参数，调大自动曝光的调整速率。</p><h3 id="摄像头开启关闭时进行额外处理"><a href="#摄像头开启关闭时进行额外处理" class="headerlink" title="摄像头开启关闭时进行额外处理"></a>摄像头开启关闭时进行额外处理</h3><p>目前是为每个摄像头建立了一个处理线程，完成 UVC 推流。该线程中每一次调用<code>vedio_streaming_send</code>发送一帧，通过检查stream_on的变化情况，确定当前的状态。stream_on 由 0-&gt;1 时表示打开了设备。反之关闭摄像头。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">send_to_uvc</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int64_t</span> dev_index = (<span class="type">int64_t</span>)arg;</span><br><span class="line"><span class="type">bool</span> last_stream_on = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> cur_stream_on = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (av_session_init_flag) &#123;</span><br><span class="line">cur_stream_on = uvc[dev_index].streaming_on;</span><br><span class="line"><span class="keyword">if</span> (cur_stream_on != last_stream_on) &#123;</span><br><span class="line">last_stream_on = cur_stream_on;</span><br><span class="line"><span class="keyword">if</span> (last_stream_on) &#123; <span class="comment">// 开始推流</span></span><br><span class="line"><span class="comment">// led gpio up, restart sensor, etc.</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 停止推流</span></span><br><span class="line"><span class="comment">// led gpio down, standby sensor, etc.</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(cur_stream_on) &#123;</span><br><span class="line">vedio_streaming_send(&amp;uvc[dev_index], dev_index);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">aos_msleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="灯光控制"><a href="#灯光控制" class="headerlink" title="灯光控制"></a>灯光控制</h4><p>推流时开灯，停止推流时关灯。简单的开关可直接在上面的流程中实现，有些场景可考虑使用UVC 处理单元中的 backlight， 通过pwm去控制灯光。</p><h4 id="standby-sensor-降低功耗"><a href="#standby-sensor-降低功耗" class="headerlink" title="standby sensor 降低功耗"></a>standby sensor 降低功耗</h4><p>在不出流的时候（待机状态），将 sensor standby，以降低整机功耗。standby 一般有两中方式：</p><ul><li>软件standby：通过I2C发送指令，让sensor进入standby模式（仍会有较低的功耗，以确保能接受I2C的唤醒指令）</li><li>硬件standby：拉低sensor的powerdown引脚，进行standby。功耗比软件更低。</li></ul><h3 id="超频"><a href="#超频" class="headerlink" title="超频"></a>超频</h3><p>clkstat 命令可以看时钟。</p><h3 id="带宽控制"><a href="#带宽控制" class="headerlink" title="带宽控制"></a>带宽控制</h3><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化计数器</span></span><br><span class="line"><span class="variable">$counter</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="variable">$true</span>) &#123;</span><br><span class="line">    <span class="comment"># 增加计数器</span></span><br><span class="line">    <span class="variable">$counter</span>++</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 输出当前次数</span></span><br><span class="line">    <span class="built_in">Write-Output</span> <span class="string">&quot;当前次数: <span class="variable">$counter</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动名为 &#x27;xxx.exe&#x27; 的程序</span></span><br><span class="line">    <span class="variable">$process</span> = <span class="built_in">Start-Process</span> <span class="string">&quot;C:\Program Files (x86)\Noël Danjou\AMCap\amcap.exe&quot;</span> <span class="literal">-PassThru</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待3秒</span></span><br><span class="line">    <span class="built_in">Start-Sleep</span> <span class="literal">-Seconds</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 杀死进程</span></span><br><span class="line">    <span class="built_in">Stop-Process</span> <span class="literal">-Id</span> <span class="variable">$process</span>.Id <span class="literal">-Force</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 等待1秒</span></span><br><span class="line">    <span class="built_in">Start-Sleep</span> <span class="literal">-Seconds</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Cvitek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cvitek </tag>
            
            <tag> Alios </tag>
            
            <tag> USB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVC 扩展单元</title>
      <link href="/2024/05/15/USB-UVC_extension/"/>
      <url>/2024/05/15/USB-UVC_extension/</url>
      
        <content type="html"><![CDATA[<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ul><li><p><input checked="" disabled="" type="checkbox"> UVC 扩展单元的作用是啥？</p><blockquote><p>《UVC 1.5 Class specification》 的 <code>2.7, 3.7.2</code> 中介绍了 UVC 的控制接口包含：输入终端、输出终端、相机终端、选择器单元、处理单元、编码单元、扩展单元。前几个都是类标准中有指定应该实现什么功能的，扩展单元就是专门给厂商实现自定义的一些功能。</p><p>比如我们这里客户需要能给设备发送重启指令。</p></blockquote></li><li><p><input checked="" disabled="" type="checkbox"> 和 UVC 的关系是啥？</p><blockquote><p>UVC 扩展单元是 UVC 的一个可选的小功能。</p></blockquote></li><li><p><input checked="" disabled="" type="checkbox"> 如何实现与测试？</p><blockquote><p>测试可使用：</p><ul><li><code>Bus Hound</code>，可给设备发送任意命令。分免费版和付费版，我们这里只用来发指令，免费版就够用了。官方网址：<a href="https://www.perisoft.net/bushound/index.htm">https://www.perisoft.net/bushound/index.htm</a></li><li><a href="https://www.usbzh.com/article/detail-761.html">UVCXU摄像头扩展单元调试工具UVCXU-USB中文网官方版</a>，需要加QQ群下载。</li><li><code>wireshark</code> 抓包分析。</li></ul><blockquote><p><code>BusHound</code> 是直接转到驱动去发的，没有通过 <code>windows</code> 视频类驱动，而UVCXU调试工具时调用了  <code>windows</code> 视频类驱动，就会受到 windows 的一些限制。见：<a href="https://www.usbzh.com/article/detail-538.html">https://www.usbzh.com/article/detail-538.html</a></p></blockquote></blockquote></li></ul><h2 id="UVC-扩展单元描述符"><a href="#UVC-扩展单元描述符" class="headerlink" title="UVC 扩展单元描述符"></a>UVC 扩展单元描述符</h2><p>扩展单元描述符允许硬件设计者定义任意一组控制接口，使类驱动程序可以在设备与供应商提供的主机软件之间进行通讯控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UINT8 bLength;</span><br><span class="line">UINT8 bDescriptorType;</span><br><span class="line">UINT8 bDescriptorSubtype;</span><br><span class="line">UINT8 bUnitID;</span><br><span class="line">UINT8 guidExtensionCode[<span class="number">16</span>];</span><br><span class="line">UINT8 bNumControls;</span><br><span class="line">UINT8 bNrInPins;</span><br><span class="line">UINT8 baSourceID[bNrInPins];</span><br><span class="line">UINT8 bControlSize;</span><br><span class="line">UINT8 bmControls[bControlSize];</span><br><span class="line">UINT8 iExtension;</span><br></pre></td></tr></table></figure><hr><ul><li><code>bLength</code>：描述符的长度，<code>24+p(bNrInPins)+n(bControlSize)</code>，就是标记描述符这个结构体的大小。</li></ul><hr><ul><li><p><code>bDescriptorType</code>：描述符类型，<code>CS_INTERFACE</code>，值为 <code>0x24</code>。</p></li><li><p><code>bDescriptorSubtype</code>：描述符子类型。 <code>VC_EXTENSION_UNIT</code>，值为 <code>0x06</code>。</p><blockquote><p>这两个值都是按照标准来的，指定描述符的类型，必须按照标准填固定值。</p></blockquote></li></ul><hr><ul><li><p><code>bUnitID</code>：唯一标识描述符。同一视频功能内的任何其他单元或终端不得具有相同的功能 <code>ID</code>。非零值。</p><blockquote><p>上面提到的输入终端、输出终端、相机终端、选择器单元、处理单元、编码单元、扩展单元，每个终端 <code>terminal</code> 或者单元 <code>unit</code> 都会有一个唯一的标识符，<code>bTerminalID</code> 或者 <code>bUnitID</code>，收到数据时会依据这个值，交给对应的模块处理。</p></blockquote></li></ul><hr><ul><li><p><code>guidExtensionCode</code>：供应商扩展单元编码</p><blockquote><p>这个值似乎没啥用处，应该只是填表示供应商的信息。</p></blockquote></li></ul><hr><ul><li><p><code>bNumControls</code>：该扩展单元的控制数量。这个控制是指控制请求，对应扩展单元的<a href="https://www.usbzh.com/article/detail-172.html">特定类请求</a>的选择子的数量。</p></li><li><p><code>bControlSize</code>：<code>bmControls</code> 的大小。</p></li><li><p><code>bmControls[bControlSize]</code>：扩商指定自定义支持的 <code>bControlSize * 8</code> 个控制。</p><blockquote><p>首先，<code>bmControls</code> 是个位图，每一位代表一个功能。可以看<a href="https://elixir.bootlin.com/linux/v5.10/source/include/uapi/linux/usb/video.h#L88">看 <code>linux</code> 内核中的定义</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A.9.4. Camera Terminal Control Selectors */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVC_CT_CONTROL_UNDEFINED0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVC_CT_SCANNING_MODE_CONTROL0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVC_CT_AE_MODE_CONTROL0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVC_CT_AE_PRIORITY_CONTROL0x03</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVC_CT_EXPOSURE_TIME_ABSOLUTE_CONTROL0x04</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVC_CT_EXPOSURE_TIME_RELATIVE_CONTROL0x05</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVC_CT_FOCUS_ABSOLUTE_CONTROL0x06</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UVC_CT_FOCUS_RELATIVE_CONTROL0x07</span></span><br></pre></td></tr></table></figure><p>这些宏的值就是选择子。选择子与 <code>bmControls</code> 这个数组的对应关系如下。</p><table><thead><tr><th>BIT</th><th>选择子</th></tr></thead><tbody><tr><td>BIT0</td><td>1</td></tr><tr><td>BIT1</td><td>2</td></tr><tr><td>BIT2</td><td>3</td></tr><tr><td>…</td><td>…</td></tr><tr><td>BIT31</td><td>32</td></tr></tbody></table><p><code>bmControls[bControlSize]</code> 的值中，对应 <code>bit</code> 为1，就表示支持该功能。比如我只支持<code>UVC_CT_SCANNING_MODE_CONTROL</code> 这一个功能，那么</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bNumControls = <span class="number">1</span>;</span><br><span class="line">bControlSize = <span class="number">1</span>;</span><br><span class="line">bmControls[<span class="number">0</span>] = cpu_to_le16(<span class="number">0x1</span>);</span><br></pre></td></tr></table></figure><p><code>bNumControls</code> 就是 <code>bmControls</code> 中1的个数。不过 <code>host/PC</code> 端驱动不一定会用这个值，windows 好像就直接自己判断的 <code>bmControls</code> 中1的个数。</p><p>在上面的 Camera Terminal Control Selectors 的定义中，每一位对应的功能都是 UVC 标准中制定的。而扩展描述符就是留给厂商自由发挥的。</p><p><strong>选择子</strong>：<strong>就是对应功能的 ID</strong>。给设备发消息时需要指定选择子。</p></blockquote></li></ul><hr><ul><li><p><code>bNrInPins</code>：输入管脚数 p</p></li><li><p><code>baSourceID</code>：各个输入管脚连接的实体或端点ID(从第一个到最后一个)</p><blockquote><p>不知道这两个有啥用。</p></blockquote></li></ul><hr><ul><li><p><code>iExtension</code>：扩展单元的<a href="https://www.usbzh.com/article/detail-53.html">字符串描述符</a>索引。用来提供一些额外的信息，用不着写0就行。</p><blockquote><p>为了提供比较友好的设备标识，USB规范中定义了字符串描述符，即使用人类的自然语言来描述设备的功能，生产厂家，生产序列号等。这里的自然语言可以为英文，也可以为中文，也可以为其它的自然语言。</p><p>为了解决字符串的跨国性，USB字符串使用UNICODE编码。</p></blockquote></li></ul><p>描述符配置对了，基本就成功了一大半。</p><h2 id="Unit-and-Terminal-Control-Requests"><a href="#Unit-and-Terminal-Control-Requests" class="headerlink" title="Unit and Terminal Control Requests"></a>Unit and Terminal Control Requests</h2><p>大概猜测了下，这些请求是把每个 <code>control_selector</code> 当成一个数值属性来看，比如以灯光亮度来理解。</p><ul><li><p><code>GET_LEN</code>: 表示 <code>SET_CUR</code> 时传输的数据长度（字节）。比如亮度的范围在 0~255 以类的话，一个字节就可以表示。而范围如果超过 255，那一个字节显然不够用。<strong>注意：标准中要求 <code>GET_LEN</code> 的返回值为2字节的</strong>。</p></li><li><p><code>GET_INFO</code>: 用于获取设备支持的特定请求。一般就使能 <code>D0, D1</code> 就行，返回的值各 <code>bit</code> 代表的含义见下表：</p><table><thead><tr><th>位</th><th>描述</th><th>位状态</th></tr></thead><tbody><tr><td>D0</td><td>1&#x3D;Supports GET value requests</td><td>Capability</td></tr><tr><td>D1</td><td>1&#x3D;Supports SET value requests</td><td>Capability</td></tr><tr><td>D2</td><td>1&#x3D;Disabled due to automatic mode(under device control)</td><td>State</td></tr><tr><td>D3</td><td>1&#x3D;Autoupdate Control</td><td>Capability</td></tr><tr><td>D4</td><td>1&#x3D;Asynchronous Control</td><td>Capability</td></tr><tr><td>D5</td><td>1&#x3D;Disabled due to incompatibility with Commit state.</td><td>State</td></tr><tr><td>D7..D6</td><td>保留，置为0</td><td>—</td></tr></tbody></table><p>如果<a href="https://www.usbzh.com/article/detail-82.html">编码单元</a>控制的实现使得设备可以启动该控件的最小和&#x2F;或最大设置属性的更改，那么该设备应该能够发送控制更改中断来通知主机新的 <code>GET_MIN</code> 和&#x2F;或 <code>GET_MAX</code> 设置，因此必须设置 <code>D3</code>（自动更新控制）。</p></li></ul><hr><ul><li><p><code>GET_MIN</code>: 支持的亮度最小值。比如 0</p></li><li><p><code>GET_MAX</code>: 支持的亮度最大值。比如 100</p></li><li><p><code>GET_RES(resolution)</code>: 获取调整的精度。比如 10，这样的话，调用 <code>SET_CUR</code> 时，就只能设置 10 的整数倍。</p><p>  这三个值存在关联的，标准中似乎有要求 <code>min/res</code>，<code>max/res</code>，<code>cur/res</code> 都是整数，不能是小数。<strong>如果属性是字符串的话，那这里 <code>RES</code> 就得设置为</strong><code>1</code>。</p></li></ul><hr><ul><li><code>GET_DEF(default)</code>: 默认值，设备枚举完成之后，会立马调用该请求获取默认值。</li><li><code>SET_CUR</code>: 设置亮度为特定值。</li><li><code>GET_CUR</code>: 获取当前的亮度值。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>]]></content>
      
      
      <categories>
          
          <category> USB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> USB </tag>
            
            <tag> UVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CLANG FORMAT 格式化代码</title>
      <link href="/2024/01/15/VSCODE-clang-format/"/>
      <url>/2024/01/15/VSCODE-clang-format/</url>
      
        <content type="html"><![CDATA[<h2 id="VSCODE-CLANG-FORMAT-格式化"><a href="#VSCODE-CLANG-FORMAT-格式化" class="headerlink" title="VSCODE CLANG FORMAT 格式化"></a>VSCODE CLANG FORMAT 格式化</h2><ol><li>获取 linux 的 clang-format.txt <a href="https://github.com/torvalds/linux/blob/master/.clang-format">https://github.com/torvalds/linux/blob/master/.clang-format</a></li><li>放到项目的根目录，并命名为 <code>.clang-format</code></li><li>vscode 准备 c&#x2F;c++ 插件，</li><li>在VSCode中安装的多个插件均支持使用clang-format来对代码执行格式化，此时按照上述文章中的方法完成配置后，代码格式化并没有生效。后来无意中发现，需要在VSCode的配置文件中增加如下配置，从多个插件中选择默认启用的格式化工具。 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;[cpp]&quot;: &#123;</span><br><span class="line">&quot;editor.defaultFormatter&quot;: &quot;ms-vscode.cpptools&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>Documentation&#x2F;process&#x2F;clang-format.rst</li><li><a href="https://clang.llvm.org/docs/ClangFormat.html">https://clang.llvm.org/docs/ClangFormat.html</a></li><li><a href="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">https://clang.llvm.org/docs/ClangFormatStyleOptions.html</a></li></ul><h2 id="可能需要修改的地方"><a href="#可能需要修改的地方" class="headerlink" title="可能需要修改的地方"></a>可能需要修改的地方</h2><ol><li><p>声明对齐；</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AlignConsecutiveDeclarations: false</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ats_attr</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> bucket_size;</span><br><span class="line"><span class="type">uint64_t</span> rate;</span><br><span class="line"><span class="type">uint64_t</span> bucket_empty;</span><br><span class="line"><span class="type">uint64_t</span> empty_to_full;</span><br><span class="line"><span class="type">uint64_t</span> eligility;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> *b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// AlignConsecutiveDeclarations: true</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ats_attr</span> &#123;</span></span><br><span class="line"><span class="type">uint64_t</span> bucket_size;</span><br><span class="line"><span class="type">uint64_t</span> rate;</span><br><span class="line"><span class="type">uint64_t</span> bucket_empty;</span><br><span class="line"><span class="type">uint64_t</span> empty_to_full;</span><br><span class="line"><span class="type">uint64_t</span> eligility;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span>*b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 不过这样也会导致如下的难看的情况：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ats_attr</span> <span class="title">attr</span>;</span></span><br><span class="line"><span class="type">int</span>offset = offsetof(<span class="keyword">struct</span> ats_attr, bucket_size);</span><br></pre></td></tr></table></figure></li><li><p>注释对齐；</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AlignTrailingComments: true</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_NONE 0  <span class="comment">// 无日志输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_ERROR 1 <span class="comment">// 错误日志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_WARN 2  <span class="comment">// 警告日志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_INFO 3  <span class="comment">// 信息日志</span></span></span><br><span class="line"><span class="comment">// AlignTrailingComments: false</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_NONE 0 <span class="comment">// 无日志输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_ERROR 1 <span class="comment">// 错误日志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_WARN 2 <span class="comment">// 警告日志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_INFO 3 <span class="comment">// 信息日志</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义对齐</span></span><br><span class="line">AlignConsecutiveMacros: <span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>代码之间的最大空行；</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MaxEmptyLinesToKeep: 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW <span class="string">&quot;\e[1;33m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE <span class="string">&quot;\e[0;34m&quot;</span></span></span><br><span class="line"><span class="comment">// MaxEmptyLinesToKeep: 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW <span class="string">&quot;\e[1;33m&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE <span class="string">&quot;\e[0;34m&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p>as named;</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AllowShortLoopsOnASingleLine: true</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) xxx;</span><br><span class="line"><span class="comment">// AllowShortLoopsOnASingleLine: false</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">xxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AllowShortIfStatementsOnASingleLine: true</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) xxx;</span><br><span class="line"><span class="comment">// AllowShortIfStatementsOnASingleLine: false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="number">1</span>)</span><br><span class="line">xxx;</span><br></pre></td></tr></table></figure></li></ol><h2 id="其他配置含义"><a href="#其他配置含义" class="headerlink" title="其他配置含义"></a>其他配置含义</h2><blockquote><p><a href="https://www.cnblogs.com/oloroso/p/14699855.html">https://www.cnblogs.com/oloroso/p/14699855.html</a></p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># https://clang.llvm.org/docs/ClangFormatStyleOptions.html</span></span><br><span class="line"><span class="comment"># https://www.bbsmax.com/A/VGzlMjexJb/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语言: None, Cpp, Java, JavaScript, ObjC, Proto, TableGen, TextProto</span></span><br><span class="line">Language: Cpp</span><br><span class="line"></span><br><span class="line">BasedOnStyle: LLVM</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问说明符(public、private等)的偏移</span></span><br><span class="line">AccessModifierOffset: -4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左括号(左圆括号、左尖括号、左方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在左括号后换行)</span></span><br><span class="line">AlignAfterOpenBracket: Align</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续赋值时，对齐所有等号</span></span><br><span class="line">AlignConsecutiveAssignments: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续声明时，对齐所有声明的变量名</span></span><br><span class="line">AlignConsecutiveDeclarations: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对齐连续位域字段的风格</span></span><br><span class="line"><span class="comment"># AlignConsecutiveBitFields: AcrossEmptyLinesAndComments</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对齐连续宏定义的风格</span></span><br><span class="line"><span class="comment"># AlignConsecutiveMacros: Consecutive #clang-format 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于在使用反斜杠换行中对齐反斜杠的选项</span></span><br><span class="line">AlignEscapedNewlines: Left</span><br><span class="line"></span><br><span class="line"><span class="comment"># 水平对齐二元和三元表达式的操作数</span></span><br><span class="line">AlignOperands: Align</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对齐连续的尾随的注释</span></span><br><span class="line">AlignTrailingComments: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果函数调用或带括号的初始化列表不适合全部在一行时</span></span><br><span class="line"><span class="comment"># 允许将所有参数放到下一行，即使BinPackArguments为false</span></span><br><span class="line">AllowAllArgumentsOnNextLine: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许构造函数的初始化参数放在下一行</span></span><br><span class="line">AllowAllConstructorInitializersOnNextLine: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许函数声明的所有参数在放在下一行</span></span><br><span class="line">AllowAllParametersOfDeclarationOnNextLine: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的块放在同一行(Always 总是将短块合并成一行，Empty 只合并空块)</span></span><br><span class="line">AllowShortBlocksOnASingleLine: Empty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的case标签放在同一行</span></span><br><span class="line">AllowShortCaseLabelsOnASingleLine: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的函数放在同一行: None, InlineOnly(定义在类中), Empty(空函数), Inline(定义在类中，空函数), All</span></span><br><span class="line">AllowShortFunctionsOnASingleLine: Inline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的if语句保持在同一行</span></span><br><span class="line">AllowShortIfStatementsOnASingleLine: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许短的循环保持在同一行</span></span><br><span class="line">AllowShortLoopsOnASingleLine: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总是在定义返回类型后换行(deprecated)</span></span><br><span class="line">AlwaysBreakAfterDefinitionReturnType: None</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总是在返回类型后换行: None, All, TopLevel(顶级函数，不包括在类中的函数),</span></span><br><span class="line"><span class="comment">#   AllDefinitions(所有的定义，不包括声明), TopLevelDefinitions(所有的顶级函数的定义)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数声明返回类型后是否换行(None 自动，All全部，TopLevel...)</span></span><br><span class="line">AlwaysBreakAfterReturnType: None</span><br><span class="line"></span><br><span class="line"><span class="comment"># 总是在多行string字面量前换行</span></span><br><span class="line">AlwaysBreakBeforeMultilineStrings: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 总是在template声明后换行</span></span><br><span class="line">AlwaysBreakTemplateDeclarations: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># false表示函数实参要么都在同一行，要么都各自一行</span></span><br><span class="line">BinPackArguments: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># false表示所有形参要么都在同一行，要么都各自一行</span></span><br><span class="line">BinPackParameters: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大括号换行，只有当 BreakBeforeBraces 设置为Custom时才有效</span></span><br><span class="line">BraceWrapping:</span><br><span class="line"><span class="comment"># case 语句后面</span></span><br><span class="line">AfterCaseLabel: <span class="literal">true</span></span><br><span class="line"><span class="comment"># class定义后面</span></span><br><span class="line">AfterClass: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 控制语句后面</span></span><br><span class="line">AfterControlStatement: Never</span><br><span class="line"><span class="comment"># enum定义后面</span></span><br><span class="line">AfterEnum: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 函数定义后面</span></span><br><span class="line">AfterFunction: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 命名空间定义后面</span></span><br><span class="line">AfterNamespace: <span class="literal">false</span></span><br><span class="line"><span class="comment"># ObjC定义后面</span></span><br><span class="line">AfterObjCDeclaration: <span class="literal">false</span></span><br><span class="line"><span class="comment"># struct定义后面</span></span><br><span class="line">AfterStruct: <span class="literal">true</span></span><br><span class="line"><span class="comment"># union定义后面</span></span><br><span class="line">AfterUnion: <span class="literal">true</span></span><br><span class="line"><span class="comment"># extern 导出块后面</span></span><br><span class="line">AfterExternBlock: <span class="literal">false</span></span><br><span class="line"><span class="comment"># catch之前</span></span><br><span class="line">BeforeCatch: <span class="literal">true</span></span><br><span class="line"><span class="comment"># else之前</span></span><br><span class="line">BeforeElse: <span class="literal">true</span></span><br><span class="line"><span class="comment"># 缩进大括号(整个大括号框起来的部分都缩进)</span></span><br><span class="line">IndentBraces: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 空函数的大括号是否可以在一行</span></span><br><span class="line">SplitEmptyFunction: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 空记录体(struct/class/union)的大括号是否可以在一行</span></span><br><span class="line">SplitEmptyRecord: <span class="literal">false</span></span><br><span class="line"><span class="comment"># 空名字空间的大括号是否可以在一行</span></span><br><span class="line">SplitEmptyNamespace: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在二元运算符前换行: None(在操作符后换行), NonAssignment(在非赋值的操作符前换行), All(在操作符前换行)</span></span><br><span class="line">BreakBeforeBinaryOperators: None</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在大括号前换行: Attach(始终将大括号附加到周围的上下文), Linux(除函数、命名空间和类定义，与Attach类似),</span></span><br><span class="line"><span class="comment">#   Mozilla(除枚举、函数、记录定义，与Attach类似), Stroustrup(除函数定义、catch、else，与Attach类似),</span></span><br><span class="line"><span class="comment">#   Allman(总是在大括号前换行), GNU(总是在大括号前换行，并对于控制语句的大括号增加额外的缩进), WebKit(在函数前换行), Custom</span></span><br><span class="line"><span class="comment">#   注：这里认为语句块也属于函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 大括号的换行规则</span></span><br><span class="line">BreakBeforeBraces: Custom</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三元运算操作符换行位置（?和: 在新行还是尾部）</span></span><br><span class="line">BreakBeforeTernaryOperators: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在构造函数的初始化列表的逗号前换行</span></span><br><span class="line">BreakConstructorInitializersBeforeComma: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要使用的构造函数初始化式样式</span></span><br><span class="line">BreakConstructorInitializers: BeforeComma</span><br><span class="line"></span><br><span class="line"><span class="comment"># 每行字符的限制，0表示没有限制</span></span><br><span class="line">ColumnLimit: 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 描述具有特殊意义的注释的正则表达式，它不应该被分割为多行或以其它方式改变</span></span><br><span class="line"><span class="comment"># CommentPragmas: &#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果为true，则连续的名称空间声明将在同一行上。如果为false，则在新行上声明每个名称空间。</span></span><br><span class="line">CompactNamespaces: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造函数的初始化列表要么都在同一行，要么都各自一行</span></span><br><span class="line">ConstructorInitializerAllOnOneLineOrOnePerLine: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造函数的初始化列表的缩进宽度</span></span><br><span class="line">ConstructorInitializerIndentWidth:  4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 延续的行的缩进宽度</span></span><br><span class="line">ContinuationIndentWidth: 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除C++11的列表初始化的大括号&#123;后和&#125;前的空格</span></span><br><span class="line">Cpp11BracedListStyle: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 继承最常用的指针和引用的对齐方式</span></span><br><span class="line">DerivePointerAlignment: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭格式化</span></span><br><span class="line">DisableFormat: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动检测函数的调用和定义是否被格式为每行一个参数(Experimental)</span></span><br><span class="line">ExperimentalAutoDetectBinPacking: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果为true，则clang格式会为短名称空间添加缺少的名称空间结尾注释，并修复无效的现有名称结束注释</span></span><br><span class="line">FixNamespaceComments: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要被解读为foreach循环而不是函数调用的宏</span></span><br><span class="line">ForEachMacros:  [ foreach, Q_FOREACH, BOOST_FOREACH ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对#include进行排序，匹配了某正则表达式的#include拥有对应的优先级，匹配不到的则默认优先级为INT_MAX(优先级越小排序越靠前)，</span></span><br><span class="line"><span class="comment">#   可以定义负数优先级从而保证某些#include永远在最前面</span></span><br><span class="line">IncludeCategories:</span><br><span class="line">- Regex:  <span class="string">&#x27;^&quot;(llvm|llvm-c|clang|clang-c)/&#x27;</span></span><br><span class="line">Priority:   2</span><br><span class="line">- Regex:  <span class="string">&#x27;^(&lt;|&quot;(gtest|isl|json)/)&#x27;</span></span><br><span class="line">Priority:   3</span><br><span class="line">- Regex:  <span class="string">&#x27;.*&#x27;</span></span><br><span class="line">Priority:   1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩进case标签</span></span><br><span class="line">IndentCaseLabels: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要使用的预处理器指令缩进样式</span></span><br><span class="line">IndentPPDirectives: AfterHash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缩进宽度</span></span><br><span class="line">IndentWidth: 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 函数返回类型换行时，缩进函数声明或函数定义的函数名</span></span><br><span class="line">IndentWrappedFunctionNames: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留在块开始处的空行</span></span><br><span class="line">KeepEmptyLinesAtTheStartOfBlocks: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始一个块的宏的正则表达式</span></span><br><span class="line">MacroBlockBegin: <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 结束一个块的宏的正则表达式</span></span><br><span class="line">MacroBlockEnd: <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续空行的最大数量</span></span><br><span class="line">MaxEmptyLinesToKeep: 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命名空间的缩进: None, Inner(缩进嵌套的命名空间中的内容), All</span></span><br><span class="line"><span class="comment"># NamespaceIndentation: Inner</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用ObjC块时缩进宽度</span></span><br><span class="line">ObjCBlockIndentWidth: 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在ObjC的@property后添加一个空格</span></span><br><span class="line">ObjCSpaceAfterProperty: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在ObjC的protocol列表前添加一个空格</span></span><br><span class="line">ObjCSpaceBeforeProtocolList: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在call(后对函数调用换行的penalty</span></span><br><span class="line">PenaltyBreakBeforeFirstCallParameter: 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个注释中引入换行的penalty</span></span><br><span class="line">PenaltyBreakComment: 300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次在&lt;&lt;前换行的penalty</span></span><br><span class="line">PenaltyBreakFirstLessLess:  120</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个字符串字面量中引入换行的penalty</span></span><br><span class="line">PenaltyBreakString: 1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于每个在行字符数限制之外的字符的penalty</span></span><br><span class="line">PenaltyExcessCharacter: 1000000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对每一个空格缩进字符的penalty(相对于前导的非空格列计算)</span></span><br><span class="line"><span class="comment"># PenaltyIndentedWhitespace: 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将函数的返回类型放到它自己的行的penalty</span></span><br><span class="line">PenaltyReturnTypeOnItsOwnLine: 120</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指针和引用的对齐: Left, Right, Middle</span></span><br><span class="line">PointerAlignment: Left</span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许重新排版注释</span></span><br><span class="line">ReflowComments: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许排序#include</span></span><br><span class="line">SortIncludes: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 允许排序 using 声明顺序</span></span><br><span class="line">SortUsingDeclarations: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在C风格类型转换后添加空格</span></span><br><span class="line">SpaceAfterCStyleCast: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在逻辑非操作符(!)之后插入一个空格</span></span><br><span class="line">SpaceAfterLogicalNot: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 template 关键字后插入一个空格</span></span><br><span class="line">SpaceAfterTemplateKeyword: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义在什么情况下在指针限定符之前或之后放置空格</span></span><br><span class="line"><span class="comment"># SpaceAroundPointerQualifiers: Before</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在赋值运算符之前添加空格</span></span><br><span class="line">SpaceBeforeAssignmentOperators: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 左圆括号之前添加一个空格: Never, ControlStatements, Always</span></span><br><span class="line">SpaceBeforeParens: ControlStatements</span><br><span class="line"></span><br><span class="line"><span class="comment"># 空格将在基于范围的for循环冒号之前被删除</span></span><br><span class="line">SpaceBeforeRangeBasedForLoopColon: <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [ 前是否添加空格（数组名和[之间，Lambdas不会受到影响）</span></span><br><span class="line"><span class="comment"># 连续多个 [ 只考虑第一个（嵌套数组，多维数组）</span></span><br><span class="line">SpaceBeforeSquareBrackets: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在空的圆括号中添加空格</span></span><br><span class="line">SpaceInEmptyParentheses: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在尾随的评论前添加的空格数(只适用于//)</span></span><br><span class="line">SpacesBeforeTrailingComments: 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在尖括号的&lt;后和&gt;前添加空格</span></span><br><span class="line">SpacesInAngles: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在容器(ObjC和JavaScript的数组和字典等)字面量中添加空格</span></span><br><span class="line">SpacesInContainerLiterals:  <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在C风格类型转换的括号中添加空格</span></span><br><span class="line">SpacesInCStyleCastParentheses: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果为true，将在If/for/switch/while条件括号前后插入空格。</span></span><br><span class="line">SpacesInConditionalStatement: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在圆括号的(后和)前添加空格</span></span><br><span class="line">SpacesInParentheses: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在方括号的[后和]前添加空格，lamda表达式和未指明大小的数组的声明不受影响</span></span><br><span class="line">SpacesInSquareBrackets: <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标准: Cpp03, Cpp11, Auto</span></span><br><span class="line">Standard: Cpp11</span><br><span class="line"></span><br><span class="line"><span class="comment"># tab宽度</span></span><br><span class="line">TabWidth: 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用tab字符: Never, ForIndentation, ForContinuationAndIndentation, Always</span></span><br><span class="line">UseTab: Never</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Clang </tag>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buildroot 打包 rootfs</title>
      <link href="/2023/11/16/Cvitek-buildroot/"/>
      <url>/2023/11/16/Cvitek-buildroot/</url>
      
        <content type="html"><![CDATA[<h2 id="Cvitek-buildroot-打包-rootfs-流程介绍"><a href="#Cvitek-buildroot-打包-rootfs-流程介绍" class="headerlink" title="Cvitek buildroot 打包 rootfs 流程介绍"></a>Cvitek buildroot 打包 rootfs 流程介绍</h2><blockquote><p>基于 <a href="https://github.com/sophgo/cvi_mmf_sdk/tree/v4.1.0">https://github.com/sophgo/cvi_mmf_sdk&#x2F;tree&#x2F;v4.1.0</a> 的实现。</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在 <a href="https://github.com/sophgo/cvi_mmf_sdk">cvi_mmf_sdk</a> 中，支持两种生成 rootfs 的方式：</p><ul><li>基于 ramdisk 目录下的文件系统。</li><li>基于 buildroot 打包生成文件系统。</li></ul><p>前者仅保留了常用的一些工具，因此生成的文件系统较小，不过新增工具比较麻烦。后者方便用户自己控制需要打包哪些工具。</p><p><strong>默认使用第一种方式来生成文件系统</strong>，可通过在板子的配置文件中加上 <code>CONFIG_BUILDROOT_FS=y</code> （如 <a href="https://github.com/sophgo/cvi_mmf_sdk/blob/v4.1.0/build/boards/cv181x/cv1812cp_sophpi_duo_sd/cv1812cp_sophpi_duo_sd_defconfig#L30">cv1812cp_sophpi_duo_sd_defconfig#L30</a> 中的例子），以启用 <code>buildroot</code> 来生成文件系统。</p><h2 id="rootfs-打包流程说明"><a href="#rootfs-打包流程说明" class="headerlink" title="rootfs 打包流程说明"></a>rootfs 打包流程说明</h2><p>在 <code>source cvisetup.sh</code> 之后，就可以使用 <code>pack_rootfs</code> 命令来打包文件系统了。它本质上是定义在 <a href="https://github.com/sophgo/cvi_mmf_sdk/blob/v4.1.0/build/common_functions.sh#L107">common_functions.sh</a> 中的一个 shell 函数，在设置必要的环境变量后，通过 <code>make rootfs</code> 完成打包的相关处理。主要有3个步骤：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">rootfs-prepare:</span></span><br><span class="line"><span class="comment"># 这里将所需要的打包文件都复制到 $(OUTPUT_DIR)/rootfs 这个目录中</span></span><br><span class="line"></span><br><span class="line"><span class="section">rootfs-pack:rootfs-prepare</span></span><br><span class="line"><span class="section">rootfs-pack:</span></span><br><span class="line"><span class="comment"># 完成一些清理工作，去掉无用的文件或者 strip ko文件等</span></span><br><span class="line"><span class="comment"># 制作文件系统</span></span><br><span class="line"></span><br><span class="line"><span class="section">rootfs:rootfs-pack</span></span><br><span class="line"><span class="section">rootfs:</span></span><br><span class="line"><span class="comment"># 文件系统在 rootfs-pack 中已制作完成，</span></span><br><span class="line"><span class="comment"># 这里仅对该文件再进行封装一个指定的 Header，烧录到 flash 时会检查该 Header。</span></span><br><span class="line"><span class="comment"># 若无Header，或Header信息不正确，就会跳过该文件的烧录。Header本身并不会烧录到 flash。</span></span><br><span class="line"><span class="comment"># 如果是 SD 卡启动的方式，则不需要封装。</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(STORAGE_TYPE)</span>, sd)</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> raw2cimg ,rootfs.<span class="variable">$(STORAGE_TYPE)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>上面是基于 <code>ramdisk</code> 目录制作文件系统的流程，基于 <code>buildroot</code> 的流程也是类似的：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">br-rootfs-prepare:</span></span><br><span class="line"><span class="comment"># 将必要的文件复制到 buildroot 目录下的 overlay 中，</span></span><br><span class="line"><span class="comment"># buildroot 制作文件系统时会将该目录下的文件也包含进去。</span></span><br><span class="line"></span><br><span class="line"><span class="section">br-rootfs-pack:</span></span><br><span class="line"><span class="comment"># 制作 ext4 的文件系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 Makefile 中，会检查 CONFIG_BUILDROOT_FS 配置是否启用</span></span><br><span class="line"><span class="comment"># 若启用了，则通过 br-rootfs-pack 调用 buildroot 来制作文件系统。</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_BUILDROOT_FS)</span>,y)</span><br><span class="line"><span class="section">rootfs:br-rootfs-prepare</span></span><br><span class="line"><span class="section">rootfs:br-rootfs-pack</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="section">rootfs:rootfs-pack</span></span><br><span class="line"><span class="section">rootfs:</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> print_target)</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(STORAGE_TYPE)</span>, sd)</span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> raw2cimg ,rootfs.<span class="variable">$(STORAGE_TYPE)</span>)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>有了基本流程的概念后，下面展开分析基于 <code>buildroot</code> 制作文件系统的流程。</p><h3 id="br-rootfs-prepare"><a href="#br-rootfs-prepare" class="headerlink" title="br-rootfs-prepare"></a>br-rootfs-prepare</h3><p><code>br-rootfs-prepare</code> 的主要工作是将需要打包到文件系统中的文件复制到指定的目录下，以便 buildroot 在制作文件系统时，能将这些文件一同打包。一般这些文件包括：</p><ul><li><code>build_kernel</code> 得到的 <code>.ko</code> 文件；</li><li><code>build_middleware</code> 得到的动态库文件；</li><li>存放在 <code>middlleware</code> 中以 <code>ko</code> 或 <code>so</code> 形式发布的一些模块，如：<a href="https://github.com/sophgo/cvi_mmf_sdk/tree/v4.1.0/middleware/v2/cv180x/ko">middleware&#x2F;v2&#x2F;cv180x&#x2F;ko</a>。</li></ul><p>在 <code>cvisetup.sh</code> 中将需要的路径导出为环境变量，主要有：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># buildroot 仓库所在路径</span></span><br><span class="line"><span class="built_in">export</span> BR_DIR=<span class="string">&quot;<span class="variable">$TOP_DIR</span>&quot;</span>/buildroot-2021.05</span><br><span class="line"></span><br><span class="line"><span class="comment"># overlay 路径，用于存储需要打包到文件系统中的文件</span></span><br><span class="line"><span class="built_in">export</span> BR_OVERLAY_DIR=<span class="variable">$&#123;BR_DIR&#125;</span>/board/cvitek/<span class="variable">$&#123;CHIP_ARCH&#125;</span>/overlay</span><br><span class="line"></span><br><span class="line"><span class="comment"># buildroot 的配置文件名称，即：</span></span><br><span class="line"><span class="comment"># cvitek_CV180X_musl_riscv64_defconfig  cvitek_CV181X_musl_riscv64_defconfig</span></span><br><span class="line"><span class="built_in">export</span> BR_BOARD=cvitek_<span class="variable">$&#123;CHIP_ARCH&#125;</span>_<span class="variable">$&#123;SDK_VER&#125;</span></span><br><span class="line"><span class="built_in">export</span> BR_DEFCONFIG=<span class="variable">$&#123;BR_BOARD&#125;</span>_defconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># buildroot 生成的文件系统的保存路径</span></span><br><span class="line"><span class="built_in">export</span> BR_ROOTFS_DIR=<span class="string">&quot;<span class="variable">$OUTPUT_DIR</span>&quot;</span>/tmp-rootfs</span><br></pre></td></tr></table></figure><p>上述环境变量定义了文件复制的目标位置，在 <code>br-rootfs-prepare</code> 只进行复制即可！</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">br-rootfs-prepare:</span></span><br><span class="line"><span class="comment"># 复制 ko 以及相关 lib 到 buildroot 相关路径</span></span><br><span class="line">$&#123;Q&#125;mkdir -p <span class="variable">$(BR_OVERLAY_DIR)</span>/mnt/system</span><br><span class="line">$&#123;Q&#125;cp -arf $&#123;SYSTEM_OUT_DIR&#125;/* <span class="variable">$(BR_OVERLAY_DIR)</span>/mnt/system/</span><br><span class="line"><span class="comment"># 对 ko 以及相关动态库 进行 strip，以缩小文件系统大小</span></span><br><span class="line">$&#123;Q&#125;find <span class="variable">$(BR_OVERLAY_DIR)</span> -name <span class="string">&quot;*.ko&quot;</span> -type f -printf &#x27;striping %p\n&#x27; -exec <span class="variable">$(CROSS_COMPILE_KERNEL)</span>strip --strip-unneeded &#123;&#125; \;</span><br><span class="line">$&#123;Q&#125;find <span class="variable">$(BR_OVERLAY_DIR)</span> -name <span class="string">&quot;*.so*&quot;</span> -type f -printf &#x27;striping %p\n&#x27; -exec <span class="variable">$(CROSS_COMPILE_KERNEL)</span>strip --strip-all &#123;&#125; \;</span><br><span class="line">$&#123;Q&#125;find <span class="variable">$(BR_OVERLAY_DIR)</span> -executable -type f ! -name <span class="string">&quot;*.sh&quot;</span> ! -path <span class="string">&quot;*etc*&quot;</span> ! -path <span class="string">&quot;*.ko&quot;</span> -printf &#x27;striping %p\n&#x27; -exec <span class="variable">$(CROSS_COMPILE_SDK)</span>strip --strip-all &#123;&#125; 2&gt;/dev/null \;</span><br></pre></td></tr></table></figure><h3 id="br-rootfs-pack"><a href="#br-rootfs-pack" class="headerlink" title="br-rootfs-pack"></a>br-rootfs-pack</h3><p><code>br-rootfs-pack</code> 的主要工作是指定 buildroot 的配置文件，完成 buildroot 的编译工作，以得到需要的文件系统。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">br-rootfs-pack:export TARGET_OUTPUT_DIR=<span class="variable">$(BR_DIR)</span>/output/<span class="variable">$(BR_BOARD)</span></span></span><br><span class="line"><span class="section">br-rootfs-pack:</span></span><br><span class="line"><span class="comment"># 指定配置文件 和 编译工具链路径</span></span><br><span class="line">$&#123;Q&#125;<span class="variable">$(MAKE)</span> -C <span class="variable">$(BR_DIR)</span> <span class="variable">$(BR_DEFCONFIG)</span> BR2_TOOLCHAIN_EXTERNAL_PATH=<span class="variable">$(CROSS_COMPILE_PATH)</span></span><br><span class="line"><span class="comment"># 编译得到文件系统，位于 $(TARGET_OUTPUT_DIR)/images/rootfs.ext4</span></span><br><span class="line">$&#123;Q&#125;<span class="variable">$(MAKE)</span> -j$&#123;NPROC&#125; -C <span class="variable">$(BR_DIR)</span></span><br><span class="line"><span class="comment"># $&#123;Q&#125;rm -rf $(BR_ROOTFS_DIR)/*</span></span><br><span class="line"><span class="comment"># 将文件系统从 buildroot 路径，复制到 SDK 统一的输出路径 $(OUTPUT_DIR)</span></span><br><span class="line"> $&#123;Q&#125;cp <span class="variable">$(TARGET_OUTPUT_DIR)</span>/images/rootfs.ext4 <span class="variable">$(OUTPUT_DIR)</span>/rawimages/rootfs_ext4.<span class="variable">$(STORAGE_TYPE)</span></span><br><span class="line"> <span class="comment"># 封装 Header，这是烧录到 flash 的必要步骤</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> raw2cimg ,rootfs_ext4.<span class="variable">$(STORAGE_TYPE)</span>)</span></span><br></pre></td></tr></table></figure><p>至此，就得到了 buildroot 编译的文件系统，不过需要注意的是：<strong>该文件系统中仅包含了 <code>ko</code> 和 动态库，ramdisk 中的一些开机自动运行的脚本并未包含进文件系统中，因此没有自动加载 ko 等流程</strong></p><h2 id="buildroot-配置文件说明"><a href="#buildroot-配置文件说明" class="headerlink" title="buildroot 配置文件说明"></a>buildroot 配置文件说明</h2><p>目前 <code>buildroot/configs</code> 目录下提供了 <code>cv180x, cv181x</code> 的基础配置文件，用户可在该配置文件的基础上进行修改，部分参数与上面介绍的编译流程或编译工具链有关，不可随意更改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 工具链相关的配置。</span></span><br><span class="line">BR2_TOOLCHAIN_*</span><br><span class="line">BR2_TOOLCHAIN_EXTERNAL_PREFIX=<span class="string">&quot;riscv64-unknown-linux-musl&quot;</span></span><br><span class="line">BR2_TARGET_LDFLAGS=<span class="string">&quot;-mcpu=c906fdv -march=rv64imafdcv0p7xthead -mcmodel=medany -mabi=lp64d&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. overlay 路径</span></span><br><span class="line">BR2_ROOTFS_OVERLAY=<span class="string">&quot;board/cvitek/CV181X/overlay&quot;</span></span><br></pre></td></tr></table></figure><h3 id="网络问题"><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 国内镜像</span></span><br><span class="line">BR2_BACKUP_SITE=<span class="string">&quot;http://sources.buildroot.net&quot;</span></span><br><span class="line">BR2_KERNEL_MIRROR=<span class="string">&quot;https://mirrors.aliyun.com/linux-kernel&quot;</span></span><br><span class="line">BR2_GNU_MIRROR=<span class="string">&quot;https://mirrors.aliyun.com/gnu&quot;</span></span><br><span class="line">BR2_LUAROCKS_MIRROR=<span class="string">&quot;https://luarocks.cn&quot;</span></span><br><span class="line">BR2_CPAN_MIRROR=<span class="string">&quot;https://mirrors.aliyun.com/CPAN&quot;</span></span><br></pre></td></tr></table></figure><p>有些仓库设置上面的代理也没用😑，就需要<strong>手动下载后，放到 <code>buildroot-2021.05/dl</code> 对应模块的文件夹下</strong>。</p><h3 id="打包-public-工具问题"><a href="#打包-public-工具问题" class="headerlink" title="打包 public 工具问题"></a>打包 public 工具问题</h3><p>在使用 ramdisk 方式打包文件系统时，有从好几个地方复制文件。一般来说，既然选择用 buildroot 了，一些三方工具都直接用 buildroot 编译的就好，不需要拷贝。<strong>不过像 S11defer_init 这个文件，又必须从 ramdisk 拷贝。</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从 ramdisk/rootfs/public 下拷贝选中的工具</span></span><br><span class="line"><span class="keyword">define</span> TARGET_PACKAGE_INSTALL_CMD</span><br><span class="line">@echo &#x27;TARGET PACKAGE OUTPUT DIR=<span class="variable">$(OUTPUT_DIR)</span>/rootfs&#x27;;\</span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> t,<span class="variable">$(TARGET_PACKAGES)</span>,\</span></span><br><span class="line"><span class="variable">$&#123;Q&#125;cd <span class="variable">$(TOP_DIR)</span>/ramdisk/rootfs/public/<span class="variable">$(t)</span>/<span class="variable">$(packages_arch)</span>/ &amp;&amp; \</span></span><br><span class="line"><span class="variable">$&#123;Q&#125;find . \( ! -type d ! -name &quot;*.a&quot; ! -path &quot;*include*&quot; ! -name &quot;.gitkeep&quot; \)</span> \</span><br><span class="line">-printf &#x27;Copy Package file <span class="variable">$(TOP_DIR)</span>/ramdisk/rootfs/public/<span class="variable">$(t)</span>/<span class="variable">$(packages_arch)</span>/%p\n&#x27; \</span><br><span class="line">-exec cp -a --remove-destination --parents &#x27;&#123;&#125;&#x27; <span class="variable">$(OUTPUT_DIR)</span>/rootfs/ \; ; )</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="section">rootfs-prepare:<span class="variable">$(OUTPUT_DIR)</span>/rootfs</span></span><br><span class="line"><span class="comment"># Copy rootfs</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(CONFIG_FASTBOOT)</span>,y)</span><br><span class="line">$&#123;Q&#125;cp -a --remove-destination <span class="variable">$(RAMDISK_PATH)</span>/rootfs/<span class="variable">$(ROOTFS_BASE)</span>_shrink/* <span class="variable">$(OUTPUT_DIR)</span>/rootfs</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">$&#123;Q&#125;cp -a --remove-destination <span class="variable">$(RAMDISK_PATH)</span>/rootfs/<span class="variable">$(ROOTFS_BASE)</span>/* <span class="variable">$(OUTPUT_DIR)</span>/rootfs</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy arch overlay rootfs</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="string">&quot;$(wildcard <span class="variable">$(SDK_VER_FOLDER_PATH)</span>)&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">$&#123;Q&#125;cp -r <span class="variable">$(SDK_VER_FOLDER_PATH)</span>/* <span class="variable">$(OUTPUT_DIR)</span>/rootfs</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy chip overlay rootfs</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="string">&quot;$(wildcard <span class="variable">$(CHIP_FOLDER_PATH)</span>)&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">$&#123;Q&#125;cp -r <span class="variable">$(CHIP_FOLDER_PATH)</span>/* <span class="variable">$(OUTPUT_DIR)</span>/rootfs</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy project overlay rootfs</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="string">&quot;$(wildcard <span class="variable">$(CUST_FOLDER_PATH)</span>)&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">$&#123;Q&#125;cp -r <span class="variable">$(CUST_FOLDER_PATH)</span>/* <span class="variable">$(OUTPUT_DIR)</span>/rootfs</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打包 menuconfig 中配置的一些三方工具。比如 ntp/dropbear/python3 等</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> TARGET_PACKAGE_INSTALL_CMD)</span></span><br><span class="line"><span class="comment"># 设置其他</span></span><br><span class="line">$&#123;Q&#125;$&#123;BUILD_PATH&#125;/boards/default/rootfs_script/prepare_rootfs.sh <span class="variable">$(OUTPUT_DIR)</span>/rootfs</span><br><span class="line"><span class="comment"># Generate S10_automount</span></span><br><span class="line">$&#123;Q&#125;python3 <span class="variable">$(COMMON_TOOLS_PATH)</span>/image_tool/create_automount.py <span class="variable">$(FLASH_PARTITION_XML)</span> <span class="variable">$(OUTPUT_DIR)</span>/rootfs/etc/init.d/</span><br><span class="line"><span class="comment"># Generate /etc/fw_env.config</span></span><br><span class="line">$&#123;Q&#125;python3 <span class="variable">$(COMMON_TOOLS_PATH)</span>/image_tool/mkcvipart.py <span class="variable">$(FLASH_PARTITION_XML)</span> <span class="variable">$(OUTPUT_DIR)</span>/rootfs/etc/ --fw_env</span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(CONFIG_FASTBOOT)</span>,y)</span><br><span class="line">if [ -f <span class="variable">$(ROOTFS_DIR)</span>/etc/init.d/fastboot ]; then $&#123;Q&#125;rm -rf <span class="variable">$(ROOTFS_DIR)</span>/etc/init.d/fastboot ; fi ;</span><br><span class="line">if [ -f <span class="variable">$(ROOTFS_DIR)</span>/etc/init.d/S11defer_init ]; then $&#123;Q&#125;rm -rf <span class="variable">$(ROOTFS_DIR)</span>/etc/init.d/S11defer_init; fi ;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure><p>上面从几个路径拷了文件，在使用 buildroot 时，可以选择只从 Project 路径拷贝。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CUST_FOLDER_NAME = cv1813ha_wevb_0007a_emmc</span><br><span class="line">CHIP_FOLDER_PATH = /data/song.yu/youdao2/v4.2.0-intl/ramdisk/rootfs/overlay/cv1813ha</span><br><span class="line">SDK_VER_FOLDER_PATH = /data/song.yu/youdao2/v4.2.0-intl/ramdisk/rootfs/overlay/cv181x_32bit</span><br><span class="line">CUST_FOLDER_PATH = /data/song.yu/youdao2/v4.2.0-intl/ramdisk/rootfs/overlay/cv1813ha_wevb_0007a_emmc</span><br></pre></td></tr></table></figure><p>将必需的文件放在 <code>ramdisk/rootfs/overlay/cv1813ha_wevb_0007a_emmc</code> 目录下就行。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">br-rootfs-prepare:</span></span><br><span class="line"><span class="variable">$(<span class="built_in">call</span> print_target)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Copy project overlay rootfs, like ramdisk/rootfs/overlay/cv1813ha_wevb_0007a_emmc</span></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="string">&quot;$(wildcard <span class="variable">$(CUST_FOLDER_PATH)</span>)&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">$&#123;Q&#125;cp -r <span class="variable">$(CUST_FOLDER_PATH)</span>/* <span class="variable">$(BR_OVERLAY_DIR)</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate /etc/inid.d/S10automount</span></span><br><span class="line">$&#123;Q&#125;python3 <span class="variable">$(COMMON_TOOLS_PATH)</span>/image_tool/create_automount.py <span class="variable">$(FLASH_PARTITION_XML)</span> <span class="variable">$(BR_OVERLAY_DIR)</span>/etc/init.d/</span><br><span class="line"><span class="comment"># Generate /etc/fw_env.config</span></span><br><span class="line">$&#123;Q&#125;python3 <span class="variable">$(COMMON_TOOLS_PATH)</span>/image_tool/mkcvipart.py <span class="variable">$(FLASH_PARTITION_XML)</span> <span class="variable">$(BR_OVERLAY_DIR)</span>/etc/ --fw_env</span><br><span class="line"></span><br><span class="line"><span class="keyword">ifneq</span> (<span class="variable">$(CONFIG_FASTBOOT)</span>,y)</span><br><span class="line">if [ -f <span class="variable">$(ROOTFS_DIR)</span>/etc/init.d/fastboot ]; then $&#123;Q&#125;rm -rf <span class="variable">$(ROOTFS_DIR)</span>/etc/init.d/fastboot ; fi ;</span><br><span class="line">if [ -f <span class="variable">$(ROOTFS_DIR)</span>/etc/init.d/S11defer_init ]; then $&#123;Q&#125;rm -rf <span class="variable">$(ROOTFS_DIR)</span>/etc/init.d/S11defer_init; fi ;</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># copy ko and mmf libs</span></span><br><span class="line">$&#123;Q&#125;mkdir -p <span class="variable">$(BR_OVERLAY_DIR)</span>/mnt/system</span><br><span class="line">$&#123;Q&#125;cp -arf $&#123;SYSTEM_OUT_DIR&#125;/* <span class="variable">$(BR_OVERLAY_DIR)</span>/mnt/system/</span><br><span class="line"><span class="comment"># strip</span></span><br><span class="line">$&#123;Q&#125;find <span class="variable">$(BR_OVERLAY_DIR)</span> -name <span class="string">&quot;*.ko&quot;</span> -type f -printf &#x27;striping %p\n&#x27; -exec <span class="variable">$(CROSS_COMPILE_KERNEL)</span>strip --strip-unneeded &#123;&#125; \;</span><br><span class="line">$&#123;Q&#125;find <span class="variable">$(BR_OVERLAY_DIR)</span> -name <span class="string">&quot;*.so*&quot;</span> -type f -printf &#x27;striping %p\n&#x27; -exec <span class="variable">$(CROSS_COMPILE_KERNEL)</span>strip --strip-all &#123;&#125; \;</span><br><span class="line">$&#123;Q&#125;find <span class="variable">$(BR_OVERLAY_DIR)</span> -executable -type f ! -name <span class="string">&quot;*.sh&quot;</span> ! -path <span class="string">&quot;*etc*&quot;</span> ! -path <span class="string">&quot;*.ko&quot;</span> -printf &#x27;striping %p\n&#x27; -exec <span class="variable">$(CROSS_COMPILE_SDK)</span>strip --strip-all &#123;&#125; 2&gt;/dev/null \;</span><br></pre></td></tr></table></figure><p>如果非要 rootfs&#x2F;public 下的工具，也在加上这个，不建议！还是直接修改 buildroot 配置更好。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> TARGET_PACKAGE_INSTALL_CMD_BR</span><br><span class="line">@echo &#x27;TARGET PACKAGE OUTPUT DIR=<span class="variable">$(BR_OVERLAY_DIR)</span>&#x27;;\</span><br><span class="line"><span class="variable">$(<span class="built_in">foreach</span> t,<span class="variable">$(TARGET_PACKAGES)</span>,\</span></span><br><span class="line"><span class="variable">$&#123;Q&#125;cd <span class="variable">$(TOP_DIR)</span>/ramdisk/rootfs/public/<span class="variable">$(t)</span>/<span class="variable">$(packages_arch)</span>/ &amp;&amp; \</span></span><br><span class="line"><span class="variable">$&#123;Q&#125;find . \( ! -type d ! -name &quot;*.a&quot; ! -path &quot;*include*&quot; ! -name &quot;.gitkeep&quot; \)</span> \</span><br><span class="line">-printf &#x27;Copy Package file <span class="variable">$(TOP_DIR)</span>/ramdisk/rootfs/public/<span class="variable">$(t)</span>/<span class="variable">$(packages_arch)</span>/%p\n&#x27; \</span><br><span class="line">-exec cp -a --remove-destination --parents &#x27;&#123;&#125;&#x27; <span class="variable">$(BR_OVERLAY_DIR)</span>/ \; ; )</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>❗❗注意：buildroot 目录下的 output&#x2F;xxx 中的文件，并不会自动删除。也就是说，overlay中第一次添加了某个文件，后面不需要这个文件了，仅从overlay目录删除还不够，必须从 output&#x2F;xxx&#x2F;target 中删除，而且有时候奇奇怪怪的编译报错，直接清空 output&#x2F;xxx 文件夹也能解决。</p><p>❗也不能简单地直接 <strong>只</strong> 删除output&#x2F;xxx&#x2F;target  中的文件，有一些文件、文件夹是在 buildroot 某个模块的编译过程中放进去的，只删除目标文件，而不清楚编译中间文件 output&#x2F;xxx&#x2F;build，那些文件也不会重新生成。</p><p>如果在流程中自动清空 output&#x2F;xxx 文件夹，会导致编译时间变得很长。</p></li><li><p>如何去掉开机必须输入用户名、密码？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">修改 getty 服务</span><br><span class="line">如果你使用的是 getty 来管理终端登录，可以在 /etc/inittab 文件中设置自动登录。</span><br><span class="line"></span><br><span class="line">编辑 /etc/inittab：</span><br><span class="line">打开 /etc/inittab 文件（如果存在），找到类似于以下的行：</span><br><span class="line"></span><br><span class="line">1:2345:respawn:/sbin/getty 38400 tty1</span><br><span class="line">修改为：</span><br><span class="line"></span><br><span class="line">1:2345:respawn:/sbin/getty --noclear tty1</span><br><span class="line">创建自动登录的脚本：</span><br><span class="line">在 /etc/init.d/ 下创建一个脚本，命名为 autologin，内容如下：</span><br><span class="line"></span><br><span class="line">#!/bin/sh</span><br><span class="line">exec /bin/login -f your_username</span><br><span class="line">替换 your_username 为你的实际用户名。</span><br><span class="line"></span><br><span class="line">使脚本可执行：</span><br><span class="line">chmod +x /etc/init.d/autologin</span><br></pre></td></tr></table></figure></li><li><p>不显示当前所在路径，增加 <code>/etc/profile</code> 文件。<code>\u: user \h: host</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#/etc/profile</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="string">&quot;/lib:/lib/3rd:/usr/lib:/mnt/system/lib:/mnt/system/usr/lib:/mnt/system/usr/lib/3rd:/mnt/data/lib&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:/mnt/system/usr/bin:/mnt/system/usr/sbin:/mnt/data/bin:/mnt/data/sbin&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$PS1</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;`id -u`&quot;</span> -eq 0 ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;# &#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;$ &#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PAGER=<span class="string">&#x27;/bin/more &#x27;</span></span><br><span class="line"><span class="built_in">export</span> EDITOR=<span class="string">&#x27;/bin/vi&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Source configuration files from /etc/profile.d</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> /etc/profile.d/*.sh ; <span class="keyword">do</span></span><br><span class="line"><span class="keyword">if</span> [ -r <span class="string">&quot;<span class="variable">$i</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">. <span class="variable">$i</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">unset</span> i</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> HOSTNAME=<span class="string">&quot;<span class="subst">$(hostname)</span>&quot;</span></span><br><span class="line"><span class="built_in">export</span> OLDPWD=/root</span><br><span class="line"></span><br><span class="line"><span class="comment"># \u: user \h: host</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&#x27;$USER&#x27;</span> == <span class="string">&#x27;root&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> PS1=<span class="string">&#x27;[\u@\h]\w\# &#x27;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">export</span> PS1=<span class="string">&#x27;[\u@\h]\w\$ &#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -alF&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> la=<span class="string">&#x27;ls -A&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l=<span class="string">&#x27;ls -CF&#x27;</span></span><br></pre></td></tr></table></figure><p>修改之后，就显示 <code>[root@cvitek]~# </code></p></li><li><p>使用 erofs 只读文件系统后，&#x2F;var&#x2F;run 中也只读，导致一些动态生成的文件（如 PID 文件、socket 文件等）无法写入。增加 &#96;&#x2F;etc&#x2F;fstab 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ramdisk/rootfs/common_arm/etc$ cat fstab</span><br><span class="line"># &lt;file system&gt; &lt;mount pt&gt;      &lt;type&gt;  &lt;options&gt;       &lt;dump&gt;  &lt;pass&gt;</span><br><span class="line">/dev/root       /               ext2    rw,noauto       0       1</span><br><span class="line">proc            /proc           proc    defaults        0       0</span><br><span class="line">devpts          /dev/pts        devpts  defaults,gid=5,mode=620,ptmxmode=0666   0       0</span><br><span class="line">tmpfs           /dev/shm        tmpfs   mode=0777       0       0</span><br><span class="line">tmpfs           /tmp            tmpfs   mode=1777       0       0</span><br><span class="line">tmpfs           /run            tmpfs   mode=0755,nosuid,nodev  0       0</span><br><span class="line">tmpfs           /var/run        tmpfs   mode=0755,nosuid,nodev  0       0</span><br><span class="line">tmpfs           /var/lock       tmpfs   mode=0755,nosuid,nodev  0       0</span><br><span class="line">tmpfs           /var/empty      tmpfs   mode=0755,nosuid,nodev  0       0</span><br><span class="line">sysfs           /sys            sysfs   defaults        0       0</span><br><span class="line">nodev           /sys/kernel/debug debugfs   defaults    0       0</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cvitek </tag>
            
            <tag> Buildroot </tag>
            
            <tag> Rootfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 系统编程-syslog</title>
      <link href="/2023/09/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-syslog/"/>
      <url>/2023/09/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-syslog/</url>
      
        <content type="html"><![CDATA[<h1 id="syslog"><a href="#syslog" class="headerlink" title="syslog"></a>syslog</h1><p>这里说的 <code>syslog</code> 仅仅是<code>api</code>，<code>man 3 syslog</code> 有详细的说明。简单来说，如下图所示，应用通过 <code>syslog()</code> 这个调用将日志信息传递给 <code>syslogd</code>（我们可以称为日志收集器）。<code>syslogd</code> 可以根据配置文件（一般位于 <code>/etc/syslog.conf</code> 来决定如何处理日志信息）。比如保存到某个文件、发送到远程主机、显示到控制台等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   app1               app2              app3 (产生日志)</span><br><span class="line">    │                   │                │</span><br><span class="line">    │                   │  syslog()      │ (AF_UNIX 传递日志)</span><br><span class="line">    │                   │                │</span><br><span class="line">    │           ┌───────▼──────┐         │</span><br><span class="line">    └──────────►│   syslogd    │◄────────┘ (接收日志)</span><br><span class="line">                └──────────────┘</span><br><span class="line">                       ▼</span><br><span class="line"> ┌──────────────┬──syslog.conf─┬──────────────┐ (处理日志)</span><br><span class="line"> │              │              │              │</span><br><span class="line"> │              │              │              │</span><br><span class="line"> ▼              ▼              ▼              ▼</span><br><span class="line">file          console        remote         drop</span><br></pre></td></tr></table></figure><p>我们要把日志信息传递给 <code>syslogd</code> 这个守护进程，实际上就是两个进程之间的通信，这里采用的是本地套接字 <code>AF_UNIX</code>这种方式实现。可以参考 [Linux 系统编程-进程通信](.&#x2F;Linux 系统编程-进程通信.md)</p><h2 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h2><p>对使用来说，很简单✨，就只涉及到 3 个 <code>API</code> 调用。</p><blockquote><p>虽然说 <code>syslog</code> 协议是可以通过网络将日志信息传递给其他网络地址，但这是 <code>syslogd</code> 这个守护进程的工作，对应用而言，它只需要将日志信息传递给 <code>syslogd</code>，后者会根据配置文件来决定如何处理这些日志信息。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;syslog.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> option, <span class="type">int</span> facility)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">closelog</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>openlog</code>：为当前应用和 <code>system logger</code> 建立连接！其实就是和 <code>syslogd</code> 通过本地套接字实现进程间通信。</li><li><code>syslog/vsyslog</code>：生成一条日志信息，它将被传递给日志收集器 <code>syslogd</code>；</li><li><code>closelog</code>：断开和 <code>system logger</code> 的连接。</li></ul><hr><h3 id="openlog"><a href="#openlog" class="headerlink" title="openlog"></a>openlog</h3><blockquote><p>建立本地套接字连接。对 <code>musl</code> 这个库而言，本地套接字文件位于 <code>/dev/log</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@cvitek]/dev<span class="comment"># ls -lh log</span></span><br><span class="line">srw-rw-rw-    1 root     root           0 Jan  1 08:00 <span class="built_in">log</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">openlog</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ident, <span class="type">int</span> option, <span class="type">int</span> facility)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>ident</code>：指向的字符串被添加到每条日志信息的前面，一般指定为程序名。如果 <code>ident</code> 为 <code>NULL</code>，则使用程序名称。</p><blockquote><p>因为 <code>syslog</code> 服务端（一般为 <code>syslogd</code>）会接收到很多客户端的消息，所以日志前面一定要带有程序名或其他标识字符串，这样才能确定日志消息的来源。</p></blockquote></li><li><p><code>option</code>：指定这个连接的一些特性。</p><blockquote><p>就像<code>open</code>打开文件时可以指定一些 <code>flags</code>，用来控制读写权限、非阻塞等等。不过这只是个比喻，与打开文件毫无关系。</p></blockquote></li><li><p><code>facility</code>：用于指定记录消息的程序类型，或者说消息来源。这是下面调用 <code>syslog</code> 时的一个默认值，不过实际调用时仍然可以改为其他类型。</p><blockquote><p>与 <code>ident</code> 细分来源哪个程序不同，<code>facility</code> 是按大类划分，比如来自内核的消息，或者来自用户态的消息。通过这样划分，可以为不同的大类设置不同的输出级别（通过配置文件设置）。比如内核的日志只记录<code>Info</code> 级别，而用户态的日志则设置为 <code>Debug</code>。</p></blockquote></li></ul><p><code>openlog()</code> 的使用是可选的，如果没有调用，它将在第一次调用 <code>syslog()</code> 时自动调用，在这种情况下，<code>ident</code> 将默认为 <code>NULL</code>。</p><hr><h3 id="option-类型"><a href="#option-类型" class="headerlink" title="option 类型"></a>option 类型</h3><ul><li><code>LOG_CONS</code>：如果发送到<code>system logger</code>时出现错误，则直接写入系统控制台 <code>console</code>。</li><li><code>LOG_NDELAY</code>：立即打开连接(通常，在记录第一条消息时打开连接)。这可能是有用的，例如，如果后续的 <code>chroot(2)</code> 将使日志记录工具内部使用的路径名不可达。</li><li><code>LOG_NOWAIT</code>：不要等待在记录消息时可能已经创建的子进程。(GNU C 库不创建子进程，所以这个选项对 Linux 没有影响。)</li><li><code>LOG_ODELAY</code>：<code>LOG_NDELAY</code> 的逆函数；连接的打开被延迟，直到 <code>syslog()</code> 被调用。(这是默认值，不需要指定。)</li><li><code>LOG_PERROR</code>：将消息记录到 <code>stderr</code>。(POSIX.1-2001 或 POSIX.1-2008 中没有。)</li><li><code>LOG_PID</code>：在每条消息中包含呼叫者的 PID。</li></ul><h3 id="facility-类型"><a href="#facility-类型" class="headerlink" title="facility 类型"></a>facility 类型</h3><ul><li><code>LOG_AUTH</code>: security&#x2F;authorization messages</li><li><code>LOG_AUTHPRIV</code>: security&#x2F;authorization messages (private)</li><li><code>LOG_CRON</code>: clock daemon (cron and at)</li><li><code>LOG_DAEMON</code>: system daemons without separate facility value</li><li><code>LOG_FTP</code>: ftp daemon</li><li><code>LOG_KERN</code>: kernel messages (these can’t be generated from user processes)</li><li><code>LOG_LOCAL0 through LOG_LOCAL7</code>: reserved for local use。这个可以用户自定义。</li><li><code>LOG_LPR</code>: line printer subsystem</li><li><code>LOG_MAIL</code>: mail subsystem</li><li><code>LOG_NEWS</code>: USENET news subsystem</li><li><code>LOG_SYSLOG</code>: messages generated internally by syslogd(8)</li><li><code>LOG_USER (default)</code>: generic user-level messages</li><li><code>LOG_UUCP</code>: UUCP subsystem</li></ul><h3 id="level-日志级别"><a href="#level-日志级别" class="headerlink" title="level 日志级别"></a>level 日志级别</h3><ul><li><code>LOG_EMERG</code>: system is unusable</li><li><code>LOG_ALERT</code>: action must be taken immediately</li><li><code>LOG_CRIT</code>: critical conditions</li><li><code>LOG_ERR</code>: error conditions</li><li><code>LOG_WARNING</code>: warning conditions</li><li><code>LOG_NOTICE</code>: normal, but significant, condition</li><li><code>LOG_INFO</code>: informational message</li><li><code>LOG_DEBUG</code>: debug-level message</li></ul><hr><h3 id="syslog-1"><a href="#syslog-1" class="headerlink" title="syslog"></a>syslog</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">syslog</span><span class="params">(<span class="type">int</span> priority, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>priority</code> 参数由一个 <code>facility</code> 值和一个 <code>level</code> 值一起组成。</p><blockquote><p>如果优先级中没有用到 <code>facility</code>，则使用 <code>openlog()</code> 设置的默认值，或者，如果之前没有 <code>openlog()</code> 调用，则使用默认值 <code>LOG_USER</code>。</p></blockquote></li><li><p><code>format</code>：一个格式字符串，后面跟该格式所需的任何参数，除了 <code>%m</code> 将被错误消息字符串 <code>strerror(errno)</code> 取代。</p><blockquote><p><strong>格式字符串不需要包含结束换行符</strong>。</p></blockquote></li></ul><p>比如输出一条 <code>DEBUG</code> 级别的日志如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syslog(LOG_USER|LOG_DEBUG, <span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"><span class="comment">// 不需要 \n</span></span><br><span class="line">syslog(LOG_DEBUG, <span class="string">&quot;hello world, num: %d&quot;</span>, num);</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>syslog</code> 配置文件用于控制 <code>syslogd</code> 守护进程如何处理日志消息。该文件通常位于 <code>/etc/syslog.conf</code> 中。</p><p><code>syslog</code> 配置文件由一行一行的配置项组成。每一行包含一个或多个关键字组成 + <code>action</code> 组成。关键字之间使用分号<code>;</code>分割，关键字和 <code>action</code> 之间使用空格<code> </code>分割。</p><p><strong>action</strong>：指定消息的处理方式。常见的 <code>action</code> 包括：</p><ul><li><code>file</code>：将消息写入文件。</li><li><code>remote</code>：将消息发送到远程主机。</li><li><code>console</code>：将消息显示在控制台。</li><li><code>null</code>：丢弃消息。</li></ul><h3 id="配置文件示例"><a href="#配置文件示例" class="headerlink" title="配置文件示例"></a>配置文件示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 将所有 info 级别和内核 debug 级别的消息写入 `/var/log/messages` 文件。</span><br><span class="line">*.info;kern.debug /var/log/messages</span><br><span class="line"></span><br><span class="line"># 将所有安全相关消息写入 `/var/log/auth.log` 文件</span><br><span class="line">auth.* /var/log/auth.log</span><br><span class="line"></span><br><span class="line"># 将所有信息、警告和错误级别的邮件消息写入 `/var/log/apache/access_log` 文件</span><br><span class="line">mail.info;mail.warn;mail.err /var/log/apache/access_log</span><br><span class="line"></span><br><span class="line"># 将所有错误消息发送到 root 用户的邮箱</span><br><span class="line">*.err root@localhost</span><br></pre></td></tr></table></figure><p><strong>配置文件注意事项</strong></p><ul><li><code>syslog</code> 配置文件是全局性的，对所有系统上的应用程序都有效。</li><li>可以使用 <code>-f</code> 选项指定 <code>syslogd</code> 守护进程使用的配置文件。</li></ul><h2 id="syslogd"><a href="#syslogd" class="headerlink" title="syslogd"></a>syslogd</h2><p><code>syslogd</code> 守护进程参数介绍：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-n              Run <span class="keyword">in</span> foreground</span><br><span class="line">                这个选项让 syslogd 在前端运行，而不是在后台运行。</span><br><span class="line">                如果这个选项被使用，syslogd 不会 fork 成后台进程。</span><br><span class="line">-R HOST[:PORT]  Log to HOST:PORT (default PORT:514)</span><br><span class="line">                让 syslogd 将日志消息发送到指定的主机和端口。默认的端口是 514。</span><br><span class="line">-L              Log locally and via network (default is network only <span class="keyword">if</span> -R)</span><br><span class="line">                同时将日志记录到本地和网络上。指定 -R 后默认只记录到网络</span><br><span class="line">-O FILE         Log to FILE (default: /var/log/messages, stdout <span class="keyword">if</span> -)</span><br><span class="line">                让 syslogd 将日志消息写入到指定的文件。默认 /var/log/messages✨✨</span><br><span class="line">                但如果 FILE 是<span class="string">&quot;-&quot;</span>，则 syslogd 会将日志消息写入到标准输出。</span><br><span class="line">-s SIZE         Max size (KB) before rotation (default 200KB, 0=off)</span><br><span class="line">                日志文件的最大大小（以 KB 为单位），超过该大小会新建一个日志文件。</span><br><span class="line">-b N            N rotated logs to keep (default 1, max 99, 0=purge)</span><br><span class="line">                要保留的已轮转日志文件的数量。</span><br><span class="line">-l N            Log only messages more urgent than prio N (1-8)</span><br><span class="line">                syslogd 只记录优先级高于 N 的日志消息。8 是 DEBUG 级别</span><br><span class="line">-S              Smaller output</span><br><span class="line">                syslogd 会减小 syslogd 的输出，使得日志文件更小。</span><br><span class="line">-t              Strip client-generated timestamps</span><br><span class="line">                移除由客户端生成的日志消息中的时间戳</span><br><span class="line">-f FILE         Use FILE as config (default:/etc/syslog.conf)</span><br><span class="line">                syslogd 使用指定的文件作为配置文件。默认文件是 /etc/syslog.conf</span><br></pre></td></tr></table></figure><p>Output File ⬇️（必须要加引号 <code>&quot;-&quot;</code> 才能到标准输出）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ syslogd -n -l 8 -O <span class="string">&quot;-&quot;</span></span><br><span class="line">Sep  3 00:28:38 panda syslog.info syslogd started: BusyBox v1.30.1</span><br></pre></td></tr></table></figure><p>Smaller Output 演示结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sep  2 23:50:01 panda user.debug syslog-test[2438]: hello world</span><br><span class="line">Sep  2 23:50:01 panda user.debug syslog-test[2438]: hello world</span><br><span class="line">Sep  2 23:50:01 panda user.debug syslog-test[2438]: hello 123</span><br><span class="line">Sep  2 23:50:39 panda syslog.info syslogd exiting</span><br><span class="line"><span class="comment"># 加上 -S 后 ⬇️</span></span><br><span class="line">Sep  3 00:20:37 syslogd started: BusyBox v1.30.1</span><br><span class="line">Sep  3 00:20:47 syslog-test[2693]: hello world</span><br><span class="line">Sep  3 00:20:47 syslog-test[2693]: hello world</span><br><span class="line">Sep  3 00:20:47 syslog-test[2693]: hello 123</span><br></pre></td></tr></table></figure><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>使用 <code>syslog</code> 时需要指定 <code>facility|level</code> 比较麻烦，在 <a href="https://github.com/sophgo/cvi_mmf_sdk/blob/v4.1.0/middleware/v2/include/cvi_debug.h"><code>middleware/v2/include/cvi_debug.h</code></a> 对 <code>syslog</code> 通过宏函数进行了一层封装☠️，在日志消息的基础上添加了“文件名、行号、函数名”，本意是好的，但是名字太长了！<code>TRACE</code> 和 <code>DBG</code> 毫无意义！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVI_TRACE_LOG(CVI_DBG_INFO, <span class="string">&quot;LT9611_MIPI_Input_Digtal: lt9611 set mipi port = 2\n&quot;</span>);</span><br></pre></td></tr></table></figure><p>相比之下，<code>openvswitch</code> 的命名更加简洁：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VLOG_DBG(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">VLOG_INFO(<span class="string">&quot;XXXX&quot;</span>);</span><br><span class="line">VLOG_ERR(<span class="string">&quot;XXX&quot;</span>);</span><br></pre></td></tr></table></figure><p>参照此方式，加个 <code>CVI_</code> 前缀也比较简洁啊！<code>CVI_VLOG_ERR(&quot;XXX&quot;);</code></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://datatracker.ietf.org/doc/html/rfc5424">rfc 5424 – The Syslog Protocol</a></li><li><a href="https://elixir.bootlin.com/musl/latest/source/include/syslog.h#L62">musl-syslog.h</a></li><li><a href="https://elixir.bootlin.com/musl/latest/source/src/misc/syslog.c#L138">musl-syslog.c</a></li><li>[Linux 系统编程-进程通信](.&#x2F;Linux 系统编程-进程通信.md)</li><li><a href="https://github.com/sophgo/cvi_mmf_sdk/blob/v4.1.0/middleware/v2/include/cvi_debug.h"><code>middleware/v2/include/cvi_debug.h</code></a></li></ul><h1 id="简单宏日志"><a href="#简单宏日志" class="headerlink" title="简单宏日志"></a>简单宏日志</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_NONE      0  <span class="comment">// 无日志输出</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_ERROR     1  <span class="comment">// 错误日志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_WARN      2  <span class="comment">// 警告日志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_INFO      3  <span class="comment">// 信息日志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL_DEBUG     4  <span class="comment">// 调试日志</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONE                 <span class="string">&quot;\e[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED                  <span class="string">&quot;\e[0;31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW               <span class="string">&quot;\e[1;33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE                 <span class="string">&quot;\e[0;34m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前日志级别</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_LEVEL MLOG_LEVEL_DEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FILENAME__ (strrchr(__FILE__, <span class="string">&#x27;/&#x27;</span>) ? strrchr(__FILE__, <span class="string">&#x27;/&#x27;</span>) + 1 : __FILE__)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG(level, level_str, fmt, ...)                                               \</span></span><br><span class="line"><span class="meta">    do &#123;                                                                    \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (level &lt;= MLOG_LEVEL) &#123;                                          \</span></span><br><span class="line"><span class="meta">            printf(level_str <span class="string">&quot; [%s:%d %s] &quot;</span> fmt, __FILENAME__, __LINE__, __func__, ##__VA_ARGS__); \</span></span><br><span class="line"><span class="meta">        &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 只对日志级别加上颜色 */</span></span><br><span class="line"><span class="comment">// #define MLOG_ERROR(fmt, ...) MLOG(MLOG_LEVEL_ERROR, RED &quot;[ERR]&quot; NONE, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="comment">// #define MLOG_WARN(fmt, ...)  MLOG(MLOG_LEVEL_WARN, YELLOW &quot;[WARN]&quot; NONE, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="comment">// #define MLOG_INFO(fmt, ...)  MLOG(MLOG_LEVEL_INFO, BLUE &quot;[INFO]&quot; NONE, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="comment">// #define MLOG_DEBUG(fmt, ...) MLOG(MLOG_LEVEL_DEBUG, &quot;[DBG]&quot;, fmt, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 所有日志行都上颜色 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_ERROR(fmt, ...) MLOG(MLOG_LEVEL_ERROR, RED <span class="string">&quot;[ERR]&quot;</span>, fmt NONE , ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_WARN(fmt, ...)  MLOG(MLOG_LEVEL_WARN, YELLOW <span class="string">&quot;[WARN]&quot;</span>, fmt NONE, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_INFO(fmt, ...)  MLOG(MLOG_LEVEL_INFO, BLUE <span class="string">&quot;[INFO]&quot;</span>, fmt NONE, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_DEBUG(fmt, ...) MLOG(MLOG_LEVEL_DEBUG, <span class="string">&quot;[DBG]&quot;</span>, fmt, ##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    MLOG_ERROR(<span class="string">&quot;This is an error message\n&quot;</span>);</span><br><span class="line">    MLOG_WARN(<span class="string">&quot;This is a warning message\n&quot;</span>);</span><br><span class="line">    MLOG_INFO(<span class="string">&quot;This is an info message\n&quot;</span>);</span><br><span class="line">    MLOG_DEBUG(<span class="string">&quot;This is a debug message\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为什么下面的这个 <code>&quot;\e[0;31m&quot;</code> 能决定输出的颜色呢？<br>这段代码是使用 ANSI 转义码来控制终端文本的颜色和样式。在 ANSI 转义码中，<code>\e</code>用于表示ASCII码中的Escape字符（十进制为27），它在终端中告诉终端模拟器去执行一些特定的操作，比如改变颜色或者样式。在 ANSI 转义码中，数字部分对应不同的颜色和样式。例如，<code>0;31</code> 表示红色文字（<code>0</code>是样式代码，<code>31</code>是颜色代码）。同样地，<code>1;33</code> 表示亮黄色文字，<code>0;34</code> 表示蓝色文字。</p><p>样式代码和颜色代码分别是啥？</p><p>ChatGPT</p><p>在 ANSI 转义码中，用于控制文本样式和颜色的代码分别是样式码和颜色码。</p><p>样式码:</p><ul><li><code>0</code>：重置所有文本属性，恢复默认状态。</li><li><code>1</code>：粗体或者高亮（取决于终端的实现）。</li><li><code>2</code>：暗色（并非所有终端都支持）。</li><li><code>3</code>：斜体（并非所有终端都支持）。</li><li><code>4</code>：下划线。</li><li><code>5</code>：闪烁（并非所有终端都支持）。</li><li><code>7</code>：反转显示，即前景色变背景色，背景色变前景色。</li><li><code>8</code>：隐藏（不可见）。</li></ul><p>颜色码（前景色）：</p><ul><li><code>30</code>：黑色</li><li><code>31</code>：红色</li><li><code>32</code>：绿色</li><li><code>33</code>：黄色</li><li><code>34</code>：蓝色</li><li><code>35</code>：洋红色（品红）</li><li><code>36</code>：青色</li><li><code>37</code>：白色</li></ul><p>这些代码可以通过组合使用来产生不同的效果。例如，<code>&quot;\e[1;33m&quot;</code>表示亮黄色文本（<code>1</code>代表高亮，<code>33</code>代表黄色）；<code>&quot;\e[0;31m&quot;</code>表示普通红色文本（<code>0</code>代表默认样式，<code>31</code>代表红色）。</p><p>请注意，并非所有终端都支持所有的样式码和颜色码，所以在不同的终端中可能会有不同的效果。</p></blockquote><p>或者更简单一点，不区分日志级别。可以用在简单库的 <code>.c</code> 文件中用于输出错误，警告等日志。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* LOG MACRO */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONE   <span class="string">&quot;\e[0m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RED    <span class="string">&quot;\e[1;31m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YELLOW <span class="string">&quot;\e[1;33m&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLUE   <span class="string">&quot;\e[0;34m&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __FILENAME__ \</span></span><br><span class="line"><span class="meta">(strrchr(__FILE__, <span class="string">&#x27;/&#x27;</span>) ? strrchr(__FILE__, <span class="string">&#x27;/&#x27;</span>) + 1 : __FILE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG(level_str, fmt, ...)                                       \</span></span><br><span class="line"><span class="meta">do &#123;                                                            \</span></span><br><span class="line"><span class="meta">printf(level_str <span class="string">&quot; [%s:%d %s] &quot;</span> NONE fmt, __FILENAME__, \</span></span><br><span class="line"><span class="meta">       __LINE__, __func__, ##__VA_ARGS__);              \</span></span><br><span class="line"><span class="meta">&#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_ERROR(fmt, ...) MLOG(RED <span class="string">&quot;[ERR]&quot;</span>, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_WARN(fmt, ...)  MLOG(YELLOW <span class="string">&quot;[WARN]&quot;</span>, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_INFO(fmt, ...)  MLOG(BLUE <span class="string">&quot;[INFO]&quot;</span>, fmt, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MLOG_DEBUG(fmt, ...) MLOG(<span class="string">&quot;[DBG]&quot;</span>, fmt, ##__VA_ARGS__)</span></span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><code>printf</code> 本身是一个<strong>不可重入函数</strong>，不能在中断、信号处理函数中使用。所以，这里的 <code>mlog</code> 同样不能在这些地方使用。</p><blockquote><p>因为printf函数内部调用了malloc函数，而malloc之前会利用静态mutex对其进行lock。设想这样一种情况，某线程在调用printf（内部执行至对静态mutex加锁操作）时中断，而在信号处理函数中同样调用了printf，则会产生死锁。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 日志系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 内核-中断</title>
      <link href="/2023/08/29/Linux%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/08/29/Linux%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-内核-—-中断"><a href="#Linux-内核-—-中断" class="headerlink" title="Linux 内核 — 中断"></a>Linux 内核 — 中断</h2><h2 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h2><blockquote><p>本节更多的是对中断涉及的内容进行简单介绍，后续才会对各个内容详细介绍。</p></blockquote><p>在 Linux 系统中，中断（<code>Interrupt</code>）是一种硬件或软件事件，<strong>它可以打断正在执行的 <code>CPU</code> 指令序列，使 <code>CPU</code> 转而处理某个特定事件</strong>。中断机制允许外部设备或系统组件通过发送信号来通知 <code>CPU</code> 某种事件的发生，这可以是来自硬件设备（如键盘、鼠标、硬盘等）的输入、定时器到期、网络数据包到达等等。</p><p>中断的主要目的是提供一种异步通信的方式，让 CPU 能够及时响应外部事件，而不需要持续地轮询检查事件是否发生。这样可以大大提高系统的效率和响应速度。</p><blockquote><p>但<strong>中断过多反而会降低系统的效率</strong>！在网络收包处理中，往往采用中断+轮询的方式。</p></blockquote><p>在 Linux 系统中，<strong>每种类型的中断都有一个唯一的标识号，被称为中断号</strong>。当一个中断事件发生时，CPU 会立即暂停当前执行的指令，保存当前上下文，然后跳转到与中断号相关联的中断处理程序。中断处理程序是一段预先编写好的代码，负责处理特定类型的中断事件。处理完中断事件后，CPU 会恢复之前保存的上下文，并继续执行被中断的指令。</p><blockquote><ol><li>中断号的分配方式。</li><li>大量中断触发时，上下文保存<code>_raw_spin_unlock_irq</code>与恢复<code>_raw_spin_unlock_irqrestore</code>往往会成为性能瓶颈。</li></ol></blockquote><p>Linux 内核有一个<strong>中断控制器</strong>（<code>Interrupt Controller</code>），它管理着所有中断并决定它们的优先级和处理顺序。中断可以分为两类：<strong>硬件中断</strong>和<strong>软件中断</strong>。硬件中断是由外部设备引发的，例如，当键盘按键被按下时会触发一个硬件中断。软件中断是通过特殊的指令来触发的，通常用于执行系统调用或与内核进行通信。</p><blockquote><ol><li>中断有优先级。</li><li>软件也可以触发中断。</li></ol></blockquote><p>总而言之，中断在 Linux 系统中是一种重要的机制，它允许外部事件以异步的方式通知 CPU，从而使系统能够更高效地响应各种事件。</p><h3 id="硬件中断和软件中断"><a href="#硬件中断和软件中断" class="headerlink" title="硬件中断和软件中断"></a>硬件中断和软件中断</h3><p>硬中断就是由<strong>外部</strong>硬件设备触发的，本质上来说，就是改变某个引脚的电压电平，比如引脚输入由高电平变为低电平（下降沿触发），该变化会被处理器的<strong>中断控制器</strong>检测到，从而跳转到中断处理程序执行。也有一些设备支持上升沿触发、或者<strong>电平触发</strong>，具体的触发方式需要参考设备的技术规格或文档。</p><blockquote><ol><li>中断控制器的原理。</li><li>中断处理程序和中断如何关联，如何切换到中断处理函数执行。</li><li>“外部”：这里所说的外部是针对 <code>CPU</code> 而言的，除了传统意义上的外设硬盘、键盘、鼠标、网络接口卡等，<code>TLB</code>、<code>DMA</code> 等模块也能发起硬件中断。</li></ol></blockquote><p>操作系统收到了中断请求，会打断其他进程的运行，所以<strong>中断请求的响应程序，也就是中断处理程序，要尽可能快的执行完，这样可以减少对正常进程运行调度地影响</strong>。而且中断处理程序可能会暂时关闭中断，这时如果中断处理程序执行时间过长，可能在还未执行完中断处理程序前，会丢失当前其他设备的中断请求</p><p>Linux 系统为了解决中断处理程序执行过长和中断丢失的问题，将<strong>中断过程分成了两个阶段</strong>，分别是<strong>「上半部和下半部分」</strong>。</p><ul><li>上半部用来<strong>快速处理中断</strong>，一般会暂时关闭中断请求，主要负责处理跟硬件紧密相关或者时间敏感的事情。</li><li>下半部用来<strong>延迟处理</strong>上半部未完成的工作，一般以<strong>「内核线程」</strong>的方式运行。</li></ul><blockquote><p>参考这里的例子：<a href="https://www.xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E4%B8%AD%E6%96%AD%E6%98%AF%E4%BB%80%E4%B9%88">什么是软中断</a></p></blockquote><ul><li><strong>上半部直接处理硬件请求，也就是硬中断</strong>，主要是负责耗时短的工作，特点是快速执行；</li><li><strong>下半部是由内核触发，也就说软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li></ul><blockquote><p><del>注意这里将下半部说为是软中断感觉并不太准确，应该是 <code>tasklet</code></del>。</p><p>软中断这个术语存在一定的歧义，这里他是作为<strong>可延迟函数</strong>的总称，既包括了 <code>softirq</code>，也包括 <code>tasklet</code>。需要根据上下文推断其意思。</p></blockquote><p>还有一个区别，硬中断（上半部）是会打断 CPU 正在执行的任务，然后立即执行中断处理程序，而软中断（下半部）是以内核线程的方式执行，并且每一个 CPU 都对应一个<strong>软中断内核线程</strong>，名字通常为<strong>「<code>ksoftirqd/CPU</code> 编号」</strong>，比如 <code>0</code> 号 CPU 对应的软中断内核线程的名字是 <code>ksoftirqd/0</code></p><blockquote><ol><li>软中断内核线程的作用，与实现</li><li>中断是与 <code>CPU</code> 绑定的！</li></ol></blockquote><p>不过，<strong>软中断不只是包括硬件设备中断处理程序的下半部，一些内核自定义事件也属于软中断</strong>，比如<strong>内核调度</strong>等、RCU 锁（内核里常用的一种锁）等。</p><blockquote><ol><li>系统调用也可以看作是一种软中断吧，涉及到特权级别的切换和上下文的保存与恢复。</li><li>我的理解是只要涉及到上下文的保存与恢复，就可以看作是一种中断。</li><li>内核调度这里是指线程切换的过程还是调度系统本身呢？</li></ol></blockquote><h3 id="同步中断与异步中断"><a href="#同步中断与异步中断" class="headerlink" title="同步中断与异步中断"></a>同步中断与异步中断</h3><p>将中断可以按触发源分为硬件中断和软件中断，另一种叫法为<strong>同步中断与异步中断</strong>：</p><ul><li><strong>同步中断和异常</strong>：这些由 CPU 自身产生，针对当前执行的程序。异常可能因种种原因触发：由于运行时发生的程序设计错误（典型的例子是除 0），或由于出现了异常的情况或条件，致使处理器需要“外部”的帮助才能处理。<br>  异常情况不见得是由进程直接导致的，但必须借助于内核才能修复。一个可能的例子是缺页异常，在进程试图访问虚拟地址空间的一页，而该页不在物理内存中时，才会发生此类异常。根据第 4 章的讨论，内核必须与 CPU 交互，确保将预期的数据取入物理内存。接下来，进程可以在发生异常的位置恢复执行。由于内核自动恢复了这种情况，进程甚至不会注意到缺页异常的存在。</li><li><strong>异步中断</strong>。这是经典的中断类型，由外部设备产生，可能发生在任意时间。不同于同步中断，异步中断并不与特定进程关联。它们可能发生在任何时间，而不牵涉系统当前执行的活动。网卡通过发出一个相关的中断来报告新分组的到达。因为数据可能在任意时刻到达系统，所以当前执行的很可能是与数据无关的某个进程或其他东西。为避免损害该进程，内核必须确保中断能够尽快处理完毕（通过缓冲数据），使得 CPU 时间能够返还给当前进程。这也是内核需要延期操作机制的原因。</li></ul><blockquote><p>从介绍可以看出，同步中断其实就是软件中断，异步中断为硬件中断，只是说法不同。</p></blockquote><p>两类中断的共同特性是什么？如果 CPU 当前不处于核心态，则发起从用户态到核心态的切换。接下来，在内核中执行一个专门的例程，称为中断服务例程（<code>interrupt service routine</code>，简称 <strong>ISR</strong>）或中断处理程序（<code>interrupt handler</code>）。</p><h3 id="IRQ-编号与中断号"><a href="#IRQ-编号与中断号" class="headerlink" title="IRQ 编号与中断号"></a>IRQ 编号与中断号</h3><p>每个中断都有一个编号。如果中断号 <code>n</code> 分配给一个网卡而 <code>m≠ n</code> 分配给 <code>SCSI</code> 控制器，那么内核即可区分两个设备，并在中断发生时调用对应的 <code>ISR</code> 来执行特定于设备的操作。当然，同样的原则也适应于异常，不同的异常指派了不同的编号。</p><p>遗憾的是，由于特别设计（通常是历史上的）的“特性”（<code>IA-32</code> 体系结构就是一个恰当的特例），情况并不总是像描述的那样简单。因为<strong>只有很少的编号可用于硬件中断，所以必须由几个设备共享一个编号</strong>。在 <code>IA-32</code> 处理器上，硬件中断的最大数目通常是 15，这个值可不怎么大，还有考虑到有些中断编号已经永久性地分配给了标准的系统组件（键盘、定时器，等等），因而限制了可用于其他外部设备的中断编号数目。这个过程称为<strong>中断共享</strong>（<code>interrupt sharing</code>）。但必须硬件和内核同时支持才能使用该技术，因为必须要识别出中断来源于哪个设备。</p><blockquote><p>很自然，精巧设计的总线系统无需该方案。这种系统为硬件设备提供了很多中断，根本不需要共享。</p></blockquote><p>中断不能由处理器外部的外设直接产生，而必须借助于一个称为<strong>中断控制器</strong> (<code>interrupt controller</code>) 的标准组件来<strong>请求</strong>，该组件存在于每个系统中。</p><p>外部设备（或其槽位），会有电路连接到用于向中断控制器发送中断请求的组件。控制器在执行了各种电工任务（我们对此没有更多兴趣）之后，<strong>将中断请求转发到 CPU 的中断输入</strong>。因为外部设备不能直接发出中断，而必须通过上述组件请求中断，所以这种请求更正确的叫法是<strong>IRQ</strong>，或<strong>中断请求（interrupt request）</strong>。因为就软件而言，IRQ 和中断之间的差别不是那么大，这两个术语通常可替换使用。</p><p>对大多数 <code>CPU</code> 来说，都只是从可用于处理硬件中断的整个中断号范围抽取一小部分使用。抽取出的范围通常位于所有中断号序列的中部，例如，<code>IA-32 CPU</code> 总共提供了 16 个中断号，从 32 到 47。</p><p>如果读者曾经在 IA-32 系统上配置过 I&#x2F;O 扩展卡，或研究过 <code>/proc/interrupts</code> 的内容，那么就会了解到，扩展卡的 <code>IRQ</code> 编号从 0 开始，到 15 结束，当然，前提是使用了典型的中断控制器 <code>8256A</code>。这意味着这里同样有 16 个不同的选项，但数值不同。中<strong>断控制器除了负责 <code>IRQ</code> 信号的电工处理之外，还会对 <code>IRQ</code> 编号和中断号进行一个“转换”</strong>。在 IA-32 系统上，加 32 即可。如果设备发出 <code>IRQ</code> 9，<code>CPU</code> 将产生中断 41，在安装中断处理程序时必须考虑到这一点。其他体系结构在中断号和 <code>IRQ</code> 编号之间采用其他映射方式，这里不会详细阐述。</p><blockquote><p>注意上面这个例子来理解 <code>IRQ</code> 编号与中断号的区别！<code>IRQ</code> <strong>号主要用于硬件中断的标识，而软件中断则使用其他机制来进行标识和处理</strong>。</p></blockquote><h3 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h3><p>在 <code>CPU</code> 得知发生中断后，它将进一步的处理委托给一个软件例程，该例程可能会修复故障、提供专门的处理或将外部事件通知用户进程。由于每个中断和异常都有唯一的编号，内核使用一个数组，数组项是指向处理程序函数的指针。相关的中断号根据数组项在数组中的位置判断，如图所示。</p><p><img src="/../images/Linux%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/image-20230829210639960.png" alt="image-20230829210639960"></p><ol><li><p><strong>进入和退出任务</strong>：如下图所示，中断处理划分为 3 部分。首先，必须建立一个适当的环境，使得处理程序函数能够在其中执行，接下来调用处理程序自身，最后将系统复原（在当前程序看来）到中断之前的状态。调用中断处理程序前后的两部分，分别称为<strong>进入路径</strong>（左边方框）和<strong>退出路径</strong>（右边方框）。</p><p> <img src="/../images/Linux%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/image-20230829211951196.png" alt="image-20230829211951196"></p><p> 进入和退出任务还负责确保处理器从用户态切换到核心态。进入路径的一个关键任务是，从用户态栈切换到核心态栈。但是，只有这一点还不够。因为内核还要使用 CPU 资源执行其代码，<strong>进入路径必须保存用户应用程序当前的寄存器状态</strong>，以便在中断活动结束后恢复。这与调度期间用于上下文切换的机制是相同的。</p><blockquote><p>在从用户态切换到内核态时，已经保存了一部分内核会用到的寄存器的状态。但内核没用到的（比如浮点数寄存器），并不保存。在进入中断处理程序前，需要保存这部分寄存器状态。</p><p>中断到达时，处理器可能正处于内核态，因而无需用户态切换到内核态等，总之，进入路径也会进行一系列检查。</p></blockquote></li><li><p><strong>中断处理程序</strong>：中断处理程序可能会遇到困难，特别是，在处理程序执行期间，发生了其他中断。尽管可以通过在处理程序执行期间禁用中断来防止，但这会引起其他问题，如遗漏重要的中断。<strong>屏蔽</strong>（Masking，这个术语用于表示选择性地禁用一个或多个中断）因而<strong>只能短时间使用</strong>。</p><p>因此 ISR 必须满足如下两个要求。</p><ol><li>实现（特别是在禁用其他中断时）必须包含尽可能少的代码，以支持快速处理。</li><li>可以在其他 ISR 执行期间调用的中断处理程序例程，不能彼此干扰。</li></ol><p>尽管后一个要求可以通过高超的编程和精巧的 ISR 设计来满足，然而前一个要求更难满足。根据具体的中断，必须运行某个程序，来满足中断处理的最低要求。因而代码长度无法任意缩减。</p><p>内核如何解决这种两难问题呢？并非 ISR 的每个部分都同等重要。通常，每个处理程序例程都可以划分为 3 个部分，具有不同的意义。</p><ol><li><strong>关键操作必须在中断发生后立即执行</strong>。否则，无法维持系统的稳定性，或计算机的正确运作。在执行此类操作期间，<strong>必须禁用其他中断</strong>。</li><li>非关键操作也应该尽快执行，但<strong>允许启用中断</strong>（因而可能被其他系统事件中断）。</li><li><strong>可延期操作不是特别重要</strong>，不必在中断处理程序中实现。内核可以延迟这些操作，在时间充裕时进行。<strong>内核提供了 <code>tasklet</code>，用于在稍后执行可延期操作</strong>。</li></ol></li></ol><blockquote><ol><li>这里进一步说明了中断的上半部、下半部。但与前面有点矛盾了，前面说的下半部就是软中断，这里说的 <code>tasklet</code>，后者并不等同与软中断。</li><li>关于 <code>tasklet</code>，先简单理解为一种“内核线程”。在硬中断的处理函数中，我们创建一个“线程 <code>tasklet</code>”去执行较复杂的处理代码，完成线程创建后，中断处理程序就可以退出，进而恢复原系统的进程处理。而我们创建的 “线程<code>tasklet</code>” 则进入内核的调度系统，就像普通的线程那样，由内核调度系统来安排时间片进行处理。（仅仅是这样猜测，具体情况看下面）。</li></ol></blockquote><h3 id="多核系统中断处理"><a href="#多核系统中断处理" class="headerlink" title="多核系统中断处理"></a>多核系统中断处理</h3><p>硬中断和软中断交给哪一个核进行处理的问题！</p><p>todo…</p><h3 id="中断统计信息"><a href="#中断统计信息" class="headerlink" title="中断统计信息"></a>中断统计信息</h3><p>在 <code>/proc</code> 目录下，有两个文件分别记录了硬中断和软中断的次数：<code>/proc/interrupts</code>、<code>/proc/softirqs</code>。在多核系统上，会显示出每一个核处理的对应中断的数量，这里只有单核。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@cvitek]~<span class="comment"># cat /proc/softirqs</span></span><br><span class="line">                    CPU0</span><br><span class="line">          HI:          0</span><br><span class="line">       TIMER:      37049</span><br><span class="line">      NET_TX:       1398</span><br><span class="line">      NET_RX:       2344</span><br><span class="line">       BLOCK:        139</span><br><span class="line">    IRQ_POLL:          0</span><br><span class="line">     TASKLET:         19</span><br><span class="line">       SCHED:          0</span><br><span class="line">     HRTIMER:          0</span><br><span class="line">         RCU:      11288</span><br></pre></td></tr></table></figure><p>软中断的数量是内核代码中固定的，而硬中断则与外设数量有关：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@cvitek]~<span class="comment"># cat /proc/interrupts</span></span><br><span class="line">           CPU0</span><br><span class="line">  2:          0  T-Head PLIC  76  cvi-tpu-tdma</span><br><span class="line">  5:      61141  RISC-V INTC   5  riscv-timer</span><br><span class="line"> 11:          0  T-Head PLIC  29  dw_dmac</span><br><span class="line"> 16:         60  T-Head PLIC  44  ttyS0</span><br><span class="line"> 21:          0  T-Head PLIC  49  4000000.i2c</span><br><span class="line"> 22:          0  T-Head PLIC  51  4020000.i2c</span><br><span class="line"> 23:          0  T-Head PLIC  52  4030000.i2c</span><br><span class="line"> 24:          0  T-Head PLIC  53  4040000.i2c</span><br><span class="line"> 25:       1443  T-Head PLIC  31  eth0</span><br><span class="line"> 26:       4296  T-Head PLIC  34  mmc0</span><br><span class="line"> 27:          0  T-Head PLIC  36  mmc1</span><br><span class="line"> 28:          0  T-Head PLIC  40  4100000.i2s</span><br><span class="line"> 29:          0  T-Head PLIC  43  4130000.i2s</span><br><span class="line"> 30:          0  T-Head PLIC  26  cif-irq0</span><br><span class="line"> 31:          0  T-Head PLIC  27  cif-irq1</span><br><span class="line"> 32:          0  T-Head PLIC  24  a000000.vi</span><br><span class="line"> 33:          0  T-Head PLIC  25  CVI_VIP_SCL</span><br><span class="line"> 34:          3  T-Head PLIC  97  a0a0000.ive</span><br><span class="line"> 35:          0  T-Head PLIC  28  CVI_VIP_DWA</span><br><span class="line"> 36:          0  T-Head PLIC  22  h265</span><br><span class="line"> 37:          0  T-Head PLIC  21  h264</span><br><span class="line"> 39:          0  T-Head PLIC  20  JPU_CODEC_IRQ</span><br><span class="line"> 40:          1  T-Head PLIC 101  mailbox</span><br><span class="line"> 49:          0  gpio-dwapb  13  cd-gpio-irq</span><br></pre></td></tr></table></figure><h2 id="硬中断"><a href="#硬中断" class="headerlink" title="硬中断"></a>硬中断</h2><blockquote><p>主要关注：</p><ol><li>怎么为某个外设注册中断，包括中断号的分配，中断处理程序的注册。</li><li>这个过程就会涉及到中断的实现原理，中断的优先级，如何在文件系统上看到中断的相关统计信息 <code>cat /proc/interrupts</code> 这种。</li></ol></blockquote><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>中断技术上的实现有两方面：</p><ul><li><strong>汇编语言代码</strong>，与处理器高度相关，用于处理特定平台上相关的底层细节；</li><li><strong>抽象接口</strong>，是设备驱动程序及其他内核代码安装和管理 <code>IRQ</code> 处理程序所需的。</li></ul><p>本节主要关注第二方面。</p><p><img src="/../images/Linux%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/image-20230830114231632.png" alt="image-20230830114231632"></p><h4 id="irq-desc"><a href="#irq-desc" class="headerlink" title="irq_desc"></a>irq_desc</h4><blockquote><p>每一个中断都对应一个中断描述符 <code>irq_desc</code>。</p></blockquote><p>为响应外部设备的 <code>IRQ</code>，内核必须为每个潜在的 <code>IRQ</code> 提供一个函数。<strong>该函数必须能够动态注册和注</strong>销。<code>IRQ</code> 相关信息管理的关键点是一个<strong>全局数组</strong>，每个数组项对应一个 <code>IRQ</code> 编号。因为数组位置和中断号是相同的，很容易定位与特定的 <code>IRQ</code> 相关的数组项：<code>IRQ</code> 0 在位置 0，<code>IRQ</code> 15 在位置 15，等等。不过 <code>IRQ</code> 最终映射到哪个处理器中断，在这里是不相关的。</p><blockquote><p>如前面所说的 <code>IRQ</code> 号与中断号的区别。<code>/proc/interrupts</code> 中展示的是 <code>IRQ</code> 号而不是中断号。</p><p>顺便提一嘴，内核代码都是采用的 <code>tab</code> 缩减，并且一个<code>1tab = 8space</code>，所以发现内核代码对齐有问题时，看看是不是你的<code>tab</code>设置不对。</p><p>本文参考的是内核版本是 <code>v5.10.186</code> 。与《深入 Linux 内核架构》使用的略有区别。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/kernel/irq/irqdesc.c#L554</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> <span class="title">irq_desc</span>[<span class="title">NR_IRQS</span>] __<span class="title">cacheline_aligned_in_smp</span> =</span> &#123;</span><br><span class="line">        [<span class="number">0</span> ... NR_IRQS<span class="number">-1</span>] = &#123;</span><br><span class="line">                .handle_irq     = handle_bad_irq,</span><br><span class="line">                .depth          = <span class="number">1</span>,</span><br><span class="line">                .lock           = __RAW_SPIN_LOCK_UNLOCKED(irq_desc-&gt;lock),</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>struct irq_desc irq_desc[NR_IRQS]</code>: 这是一个中断描述符数组，用于存储系统中所有可能的中断的描述信息。**<code>NR_IRQS</code> 表示中断总数<strong>，在不同的体系结构上，支持的中断数并不相同，32、64、128、512 等等。</strong>每个中断都对应一个 <a href="https://elixir.bootlin.com/linux/v5.10.186/source/include/linux/irqdesc.h#L55"><code>struct irq_desc</code></a> 的实例**（即中断描述符）。</li><li><code>__cacheline_aligned_in_smp</code>: 这个标志表明这个数组会被在多核系统中<strong>按缓存行对齐</strong>（一般为 <code>64 byte</code>），以提高效率。</li><li><code>[0 ... NR_IRQS-1]</code>: 这是一种初始化数组的语法，表示对数组中的每个元素进行初始化。</li><li><code>.handle_irq = handle_bad_irq</code>: 这将每个中断描述符的 <code>handle_irq</code> 成员初始化为 <code>handle_bad_irq</code>。<code>handle_irq</code> 是一个函数指针，指向中断处理函数，但在这里它被初始化为 <code>handle_bad_irq</code>，即处理“坏”中断的函数。这通常是一个占位符，表明默认情况下所有中断都将使用相同的处理函数。</li><li><code>.depth = 1</code>: 这将每个中断描述符的 <code>depth</code> 成员初始化为 1。**<code>depth</code> 表示中断嵌套的深度**，即在处理中断时，如果发生另一个中断，系统可以跟踪中断的嵌套级别。<code>depth</code> 有两个任务。它可用于确定 IRQ 电路是启用的还是禁用的。正值表示禁用，而 0 表示启用。为什么用正值表示禁用的 <code>IRQ</code> 呢？因为这使得内核能够区分启用和禁用的 <code>IRQ</code> 电路，以及重复禁用同一中断的情形。这个值相当于一个计数器，内核其余部分的代码每次禁用某个中断，则将对应的计数器加 1；每次中断被再次启用，则将计数器减 1。在 <code>depth</code> 归 0 时，硬件才能再次使用对应的 <code>IRQ</code>。这种方法能够支持对嵌套禁用中断的正确处理。</li><li><code>.lock = __RAW_SPIN_LOCK_UNLOCKED(irq_desc-&gt;lock)</code>: 这将每个中断描述符的 <code>lock</code> 成员初始化为未锁定的自旋锁。自旋锁是一种同步机制，<strong>用于保护对中断描述符的访问</strong>。<code>__RAW_SPIN_LOCK_UNLOCKED</code> 宏用于初始化自旋锁。</li></ol><p>下面是 <code>irq_desc</code> 的结构（有省略）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_common_data</span>  <span class="title">irq_common_data</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irq_data</span>         <span class="title">irq_data</span>;</span></span><br><span class="line">        <span class="comment">/* struct irq_data &#123;</span></span><br><span class="line"><span class="comment">                u32                     mask;</span></span><br><span class="line"><span class="comment">                unsigned int            irq;   // 哪一个是由设备树指定的呢？</span></span><br><span class="line"><span class="comment">                unsigned long           hwirq; // 这</span></span><br><span class="line"><span class="comment">                struct irq_common_data  *common;</span></span><br><span class="line"><span class="comment">                struct irq_chip         *chip;</span></span><br><span class="line"><span class="comment">                struct irq_domain       *domain;</span></span><br><span class="line"><span class="comment">                void                    *chip_data;</span></span><br><span class="line"><span class="comment">        &#125;; */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __percpu   *kstat_irqs;</span><br><span class="line">        <span class="type">irq_flow_handler_t</span>      handle_irq;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>        *<span class="title">action</span>;</span>        <span class="comment">/* IRQ action list */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            status_use_accessors;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            depth;          <span class="comment">/* nested irq disables */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            irq_count;      <span class="comment">/* For detecting broken IRQs */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span>            irqs_unhandled;</span><br><span class="line">        <span class="type">raw_spinlock_t</span>          lock;</span><br><span class="line">        <span class="type">int</span>                     parent_irq;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">module</span>           *<span class="title">owner</span>;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span>              *name;</span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure><ul><li><code>action</code>：提供了一个操作链，需要在中断发生时执行。由中断通知的设备驱动程序，可以将与之相关的处理程序函数放置在此处。有一个专门的数据结构用于表示这些操作。</li><li><code>irq_data-&gt;chip</code>：电流处理和芯片相关操作被封装在 <code>chip</code> 中。为此引入了一个专门的数据结构。</li><li><code>name</code>：指定了电流层处理程序的名称，对边沿触发中断，通常是 <code>edge</code>，对电平触发中断，通常是 <code>level</code>。</li><li><code>status_use_accessors</code>：<ul><li><code>IRQ_DISABLED</code> 用于表示被设备驱动程序禁用的 IRQ 电路。该标志通知内核不要进入处理程序。</li><li>在 IRQ 处理程序执行期间，状态设置为 <code>IRQ_INPROGRESS</code>。与 <code>IRQ_DISABLED</code> 类似，这会阻止其余的内核代码执行该处理程序。</li><li>在 CPU 注意到一个中断但尚未执行对应的处理程序时，<code>IRQ_PENDING</code> 标志位置位。</li><li>为正确处理发生在中断处理期间的中断，需要 <code>IRQ_MASKED</code> 标志。具体参见 14.1.4 节。</li><li>在某个 IRQ 只能发生在一个 CPU 上时，将设置 <code>IRQ_PER_CPU</code> 标志位。（在 SMP 系统中，该标志使几个用于防止并发访问的保护机制变得多余）。</li><li><code>IRQ_LEVEL</code> 用于 Alpha 和 PowerPC 系统，用于区分电平触发和边沿触发的 IRQ。</li><li><code>IRQ_REPLAY</code> 意味着该 IRQ 已经禁用，但此前尚有一个未确认的中断。</li><li><code>IRQ_AUTODETECT</code> 和 <code>IRQ_WAITING</code> 用于 IRQ 的自动检测和配置。</li></ul></li></ul><h4 id="IRQ-控制器抽象"><a href="#IRQ-控制器抽象" class="headerlink" title="IRQ 控制器抽象"></a>IRQ 控制器抽象</h4><h3 id="注册和分配-IRQ"><a href="#注册和分配-IRQ" class="headerlink" title="注册和分配 IRQ"></a>注册和分配 IRQ</h3><ol><li><p><strong>注册 IRQ</strong></p><p> 由设备驱动程序动态注册 ISR 的工作，可以使所述的数据结构非常简单地进行。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* request_irq - Add a handler for an interrupt line</span></span><br><span class="line"><span class="comment">* @irq:     The interrupt line to allocate</span></span><br><span class="line"><span class="comment">* @handler: Function to be called when the IRQ occurs.</span></span><br><span class="line"><span class="comment">*           Primary handler for threaded interrupts</span></span><br><span class="line"><span class="comment">*           If NULL, the default primary handler is installed</span></span><br><span class="line"><span class="comment">* @flags:   Handling flags</span></span><br><span class="line"><span class="comment">* @name:    Name of the device generating this interrupt</span></span><br><span class="line"><span class="comment">* @dev:     A cookie passed to the handler function</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This call allocates an interrupt and establishes a handler; see</span></span><br><span class="line"><span class="comment">* the documentation for request_threaded_irq() for details.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> __must_check</span><br><span class="line"><span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handler_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">char</span> *name, <span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> request_threaded_irq(irq, handler, <span class="literal">NULL</span>, flags, name, dev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <img src="/../images/Linux%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/image-20230830155455169.png" alt="image-20230830155455169"></p></li><li><p><strong>释放 IRQ</strong></p></li><li><p><strong>注册中断</strong></p></li></ol><h3 id="处理-IRQ"><a href="#处理-IRQ" class="headerlink" title="处理 IRQ"></a>处理 IRQ</h3><h4 id="1-切换到核心态："><a href="#1-切换到核心态：" class="headerlink" title="1. 切换到核心态："></a>1. 切换到核心态：</h4><p>到核心态的切换，是基于每个中断之后由处理器自动执行的汇编语言代码的。只有那些最为必要的操作直接在汇编语言代码中执行。内核试图尽快地返回到常规的 C 代码，因为 C 代码更容易处理。</p><p>在 C 语言中调用函数时，需要将所需的数据（返回地址和参数）按一定的顺序放到栈上。在用户态和核心态之间切换时，还需要将最重要的寄存器保存到栈上，以便以后恢复。这两个操作由平台相关的汇编语言代码执行。在大多数平台上，控制流接下来传递到 <code>C</code> 函数 <code>do_IRQ</code>，其实现也是平台相关的，但情况仍然得到了很大的简化。 根据平台不同，该函数的参数或者是<strong>处理器寄存器集合</strong>、或是中断号和指向处理器寄存器集合的指针。</p><p><img src="/../images/Linux%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/image-20230831095645760.png" alt="image-20230831095645760"></p><blockquote><p>这里理解一下如何保存寄存器值的，就是直接读取寄存器的值，然后存放在 <code>struct pt_regs</code> 这个结构体中。并且是存放在栈底的，不过寄存器集合也可以被复制到地址空间中栈以外的其他位置。在这种情况下，<code>do_IRQ</code> 的一个参数是指向 <code>pt_regs</code> 的指针，但这并没有改变以下事实：寄存器的内存已经被保存，可以由 C 代码读取。不同体系结构下，该结构体 <code>pt_regs</code> 的定义有区别。<a href="https://elixir.bootlin.com/linux/v5.10.186/source/arch/x86/include/asm/ptrace.h#L12">x86_32</a></p></blockquote><h4 id="2-IRQ-栈"><a href="#2-IRQ-栈" class="headerlink" title="2. IRQ 栈"></a>2. IRQ 栈</h4><ol><li><p>调用电流处理程序例程</p><p> <img src="/../images/Linux%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/image-20230830160703773.png" alt="image-20230830160703773"></p></li><li><p>调用高层 ISR</p></li><li><p>实现处理程序例程</p></li></ol><h2 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h2><blockquote><p>本节语境下的软中断不再是延迟执行的总称，而是特指 <code>softirq</code>！</p></blockquote><h3 id="软中断类型"><a href="#软中断类型" class="headerlink" title="软中断类型"></a>软中断类型</h3><p>不同于硬件中断（每个设备使用的外设数量和类型不同）需要支持动态地注册，软件中断的类型是已知的，因此是以静态的形式固化在内核代码中。各个软中断都有一个唯一的编号，这表明软中断是相对稀缺的资源，使用其必须谨慎，不能由各种设备驱动程序和内核组件随意使用。默认情况下，系统上只能使用 <code>32</code> 个软中断。虽然看起来很有限，但在目前的内核中，仅仅用到了 10 个软中断🛫。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//elixir.bootlin.com/linux/v5.10.186/source/include/linux/interrupt.h#L545</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        HI_SOFTIRQ=<span class="number">0</span>,     <span class="comment">// 与 TASKLET_SOFTIRQ 类似，用于需要优先处理的 tasklet</span></span><br><span class="line">        TIMER_SOFTIRQ,</span><br><span class="line">        NET_TX_SOFTIRQ,</span><br><span class="line">        NET_RX_SOFTIRQ,</span><br><span class="line">        BLOCK_SOFTIRQ,    <span class="comment">// 与块设备（如硬盘）相关的软中断，用于处理块设备的数据传输和 IO 操作</span></span><br><span class="line">        IRQ_POLL_SOFTIRQ, <span class="comment">// 用于轮询处理中断请求（IRQ），通常用于一些特殊的情况</span></span><br><span class="line">        TASKLET_SOFTIRQ,  <span class="comment">// 用于处理一些需要延迟执行的任务，被称为 tasklet，在软中断上下文中执行</span></span><br><span class="line">        SCHED_SOFTIRQ,    <span class="comment">// 与调度器相关的软中断，用于处理进程和线程的调度操作</span></span><br><span class="line">        HRTIMER_SOFTIRQ,  <span class="comment">// 用于高精度定时器的处理，这些定时器用于实现高分辨率的时间间隔</span></span><br><span class="line">        RCU_SOFTIRQ,    <span class="comment">/* Preferable RCU(Read-Copy-Update) should always be the last softirq */</span></span><br><span class="line"></span><br><span class="line">        NR_SOFTIRQS</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/kernel/softirq.c#L645</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> softirq_to_name[NR_SOFTIRQS] = &#123;</span><br><span class="line">        <span class="string">&quot;HI&quot;</span>, <span class="string">&quot;TIMER&quot;</span>, <span class="string">&quot;NET_TX&quot;</span>, <span class="string">&quot;NET_RX&quot;</span>, <span class="string">&quot;BLOCK&quot;</span>, <span class="string">&quot;IRQ_POLL&quot;</span>,</span><br><span class="line">        <span class="string">&quot;TASKLET&quot;</span>, <span class="string">&quot;SCHED&quot;</span>, <span class="string">&quot;HRTIMER&quot;</span>, <span class="string">&quot;RCU&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>内核借助于软中断来获知异常情况的发生，而该情况将在稍后由专门的处理程序例程解决。如上所述，内核在 <code>do_IRQ</code> 末尾处理所有待决软中断，因而可以确保软中断能够定期得到处理。</p><p>软中断机制的核心部分是一个表，包含 <code>NR_SOFTIRQS</code> 个 <code>softirq_action</code> 类型的数据项。该数据类型结构非常简单，只包含一个指向处理程序例程的指针，在软中断发生时由内核执行该处理程序例程。</p><blockquote><p>软中断是已知的，这些中断的处理程序也是内核中已经实现好了的。搜索 <a href="https://elixir.bootlin.com/linux/v5.10.186/C/ident/open_softirq"><code>open_softirq</code></a> 就可以看到 <code>timer</code>、<code>RCU</code> 等在各自的 <code>.c</code> 文件中<strong>静态注册</strong>了对应中断的处理程序。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>] __<span class="title">cacheline_aligned_in_smp</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/include/linux/interrupt.h#L559</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="type">void</span>    (*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">open_softirq</span><span class="params">(<span class="type">int</span> nr, <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *))</span></span><br><span class="line">&#123;</span><br><span class="line">        softirq_vec[nr].action = action;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/kernel/softirq.c#L636</span></span><br><span class="line">open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br></pre></td></tr></table></figure><blockquote><p>👀这个 <code>action</code> 函数指针，它的传入参数也是 <code>softirq_action</code>👻（从后面 <code>tasklet_action</code> 的例子来看根本没用到这个参数👀）</p></blockquote><h3 id="触发软中断"><a href="#触发软中断" class="headerlink" title="触发软中断"></a>触发软中断</h3><blockquote><p>触发软中断仅仅是发起了中断请求，会处理，但不一定会马上处理，而是要等调度器安排。</p></blockquote><p>不同于硬件中断直接由外设发起请求（经过中断控制器发起），软中断则是通过调用 <code>raise_softirq(int nr)</code> 来引发一个软中断（类似普通中断）。软中断的编号通过参数指定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">raise_softirq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> nr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">        local_irq_save(flags); <span class="comment">// 禁用本地 CPU 的硬件中断，同时将当前中断状态保存在 flags 变量中</span></span><br><span class="line">        raise_softirq_irqoff(nr); <span class="comment">// 触发指定的软中断，仅仅是标志为需要处理，需要等待调度系统安排 CPU cycle</span></span><br><span class="line">        local_irq_restore(flags); <span class="comment">// 在软中断触发完毕后，恢复先前保存的中断状态，即将中断重新打开</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>触发软中断仅仅是设置对应中断的标志位，并不会像硬件中断那样立刻执行！需要等待调度系统安排 CPU cycle。<br>所以这里虽然禁用了本地 CPU 硬件中断，但设置标志位之后就立马恢复，禁用的时间很短。</p><p>另外，这里禁用的是硬件中断！软件中断的执行是通过内核调度机制来触发和调度的，通常是为了在不阻塞其他操作的情况下执行一些延迟敏感的任务，因此在大多数情况下，它们不需要被显式禁用。</p></blockquote><p>该函数设置各 CPU 变量 <code>irq_stat[smp_processor_id].__softirq_pending</code> 中的对应比特位。该函数将相应的软中断标记为执行，但这个执行是延期执行。通过使用特定于处理器的位图，内核确保几个软中断（甚至是相同的）可以同时在不同的 CPU 上执行。</p><blockquote><p>这个变量好像和前面的没关系啊，有点奇怪。</p><p>todo…</p></blockquote><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><strong>软中断的编号形成了一个优先顺序</strong>，这并不影响各个处理程序例程执行的频率或它们相当于其他系统活动的优先级，但定义了多个软中断同时活动或待决时处理例程执行的次序。</p><blockquote><p>不影响频率是因为在一次 <code>do_IRQ</code> 执行中，每个软中断都会被遍历、执行，只是按照“优先级”（顺序）执行而已。</p><p>看看这个函数的代码  <a href="https://elixir.bootlin.com/linux/v5.10.186/source/kernel/softirq.c#L282"><code>__do_softirq</code></a> ，遍历 <code>softirq_vec</code> 的 <code>actions</code>。</p></blockquote><h3 id="开启软中断处理"><a href="#开启软中断处理" class="headerlink" title="开启软中断处理"></a>开启软中断处理</h3><p>有几种方法可开启软中断处理，但这些都归结为调用 <code>do_softirq</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示这是一个可见的、用于在汇编语言中调用的函数，用于执行软中断的处理</span></span><br><span class="line">asmlinkage __visible <span class="type">void</span> <span class="title function_">do_softirq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        __u32 pending;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前代码是否在一个中断上下文中执行，即不涉及硬件中断，因为软中断用于执行 ISR 中非时间关键部分，</span></span><br><span class="line">        <span class="comment">// 所以其代码本身一定不能在中断处理程序内调用。</span></span><br><span class="line">        <span class="keyword">if</span> (in_interrupt())</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        local_irq_save(flags); <span class="comment">// 禁用本地 CPU 的硬件中断，以确保在执行软中断处理时不会被其他硬件中断打断</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前待处理的软中断标志，即检查哪些软中断需要被执行.</span></span><br><span class="line">        <span class="comment">// 该函数还将原来的位图重置为 0。换句话说，清除所有软中断。</span></span><br><span class="line">        pending = local_softirq_pending();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首先检查是否有待处理的软中断，并且还会检查是否有专门的内核线程（如 ksoftirqd）</span></span><br><span class="line">        <span class="comment">// 正在运行来处理这些软中断。如果条件满足，就调用</span></span><br><span class="line">        <span class="keyword">if</span> (pending &amp;&amp; !ksoftirqd_running(pending))</span><br><span class="line">                <span class="comment">// 执行软中断的实际处理。这个函数会将软中断放在当前线程的栈上进行处理，</span></span><br><span class="line">                <span class="comment">// 以避免与其他上下文之间的干扰。这个函数会调用 __do_softirq();</span></span><br><span class="line">                do_softirq_own_stack();</span><br><span class="line"></span><br><span class="line">        local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/Linux%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/image-20230831101758366.png" alt="image-20230831101758366"></p><p><strong><code>softirq_vec</code> 中的 <code>action</code> 函数在一个 <code>while</code> 循环中针对各个待决的软中断被调用</strong>。也就是按照顺序（优先级）遍历所有需要处理的中断，依次处理。</p><blockquote><p><code>__do_softirq</code> 这里会调用软中断的处理函数，一般来说耗时是比较长的，不理解调用该函数时为什么禁用硬件中断。</p><p>这里需要进入 <a href="https://elixir.bootlin.com/linux/v5.10.186/source/kernel/softirq.c#L282"><code>__do_softirq</code></a> 内部查看，在正式执行处理函数之前，硬件中断实际上会被重新 <code>enable</code>。</p><p><del>不太清楚，不过总之事实就是这样，这也是软中断的一个“缺陷”，基于软中断的 <code>tasklet</code> 执行期间同样禁用了硬件中断。因此他们的处理函数执行时间仍然需要尽量短，以保持系统的响应性能。如果需要执行耗时较长的操作，可以考虑使用<strong>工作队列</strong>等其他机制，将这些操作从 <code>Tasklet</code> 中移出，以避免阻塞软中断的执行。</del>（<code>chatgpt</code> 🤮）</p></blockquote><p>在处理了所有标记出的软中断之后，内核检查在此期间是否有新的软中断标记到位图中。要求在前一轮循环中至少有一个没有处理的软中断，而重启的次数没有超过 <code>MAX_SOFTIRQ_RESTART</code>（通常设置为 10）。如果是这样，则再次按序处理标记的软中断。这操作会一直重复下去，直至在执行所有处理程序之后没有新的未处理软中断为止。</p><p>如果在 <code>MAX_SOFTIRQ_RESTART</code> 次重启处理过程之后，仍然有未处理的软中断，那么应该如何？内核将调用 <code>wakeup_softirqd</code> 唤醒软中断守护进程。</p><blockquote><p>上面描述的是在 <a href="https://elixir.bootlin.com/linux/v5.10.186/source/kernel/softirq.c#L255"><code>__do_softirq(void)</code></a> 中，重启不仅有次数限制，还有时间限制。</p></blockquote><h3 id="软中断守护进程"><a href="#软中断守护进程" class="headerlink" title="软中断守护进程"></a>软中断守护进程</h3><p>软中断守护进程的任务是，与其余内核代码异步执行软中断。为此，系统中的每个处理器都分配了自身的守护进程，名为 <code>ksoftirqd</code>。</p><p>内核中有两处调用 <code>wakeup_softirqd</code> 唤醒了该守护进程：</p><ul><li>在 <code>do_softirq</code> 中</li><li>由 <code>raise_softirq</code> 在内部调用</li></ul><p>唤醒函数本身只需要几行代码。首先，借助于一些宏，从一个各 <code>CPU</code> 变量读取指向当前 <code>CPU</code> 软中断守护进程的 <code>task_struct</code> 的指针。如果该进程当前的状态不是 <code>TASK_RUNNING</code>，则通过 <code>wake_up_process</code> 将其放置到<strong>就绪进程的列表末尾</strong>（参见第 2 章）。尽管这并不会立即开始处理所有待决软中断，但只要调度器没有更好的选择，就会选择该守护进程（优先级为 <code>19</code>）来执行。</p><blockquote><p>软中断的守护进程在内核中，与其余线程一起通过调度器来分配 CPU cycle，不过由于 <code>ksoftirqd</code> 的优先级较低，emmm，软中断的优先级这么低？？为什么？那如果系统比较繁忙的时候，这些中断岂不是很难得到处理？（虽然也和调度算法有关，linux 默认的调度算法也始终能保证线程不会饿死，是相对公平的算法。）</p><p>这也是软中断的特点吧，延迟执行，跟硬件中断立刻执行比不了的。</p></blockquote><p>在系统启动时用 <code>initcall</code> 机制（见附录 D）调用 <code>init</code> 不久，即创建了系统中的软中断守护进程。在初始化之后，各个守护进程都执行以下无限循环：</p><p><img src="/../images/Linux%E5%86%85%E6%A0%B8-%E4%B8%AD%E6%96%AD/image-20230830162923014.png" alt="image-20230830162923014"></p><blockquote><p>但新版内核似乎已经换了一种实现方式了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_ksoftirqd</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">        local_irq_disable();</span><br><span class="line">        <span class="keyword">if</span> (local_softirq_pending()) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * We can safely run softirq on inline stack, as we are not deep</span></span><br><span class="line"><span class="comment">                 * in the task stack here.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                __do_softirq(); <span class="comment">// 调用 __do_softirq() 处理</span></span><br><span class="line">                local_irq_enable();</span><br><span class="line">                cond_resched();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        local_irq_enable();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/kernel/softirq.c#L734</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">smp_hotplug_thread</span> <span class="title">softirq_threads</span> =</span> &#123;</span><br><span class="line">        .store                  = &amp;ksoftirqd,</span><br><span class="line">        .thread_should_run      = ksoftirqd_should_run,</span><br><span class="line">        .thread_fn              = run_ksoftirqd,</span><br><span class="line">        .thread_comm            = <span class="string">&quot;ksoftirqd/%u&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> __init <span class="type">int</span> <span class="title function_">spawn_ksoftirqd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">        cpuhp_setup_state_nocalls(CPUHP_SOFTIRQ_DEAD, <span class="string">&quot;softirq:dead&quot;</span>, <span class="literal">NULL</span>,</span><br><span class="line">                                  takeover_tasklets);</span><br><span class="line">        BUG_ON(smpboot_register_percpu_thread(&amp;softirq_threads));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">early_initcall(spawn_ksoftirqd);</span><br></pre></td></tr></table></figure><p>每一个 <code>core</code> 上都会启动一个 <code>ksoftirqd</code> 守护进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">song.yu@WORKSTATION-PAD3:~$ ps aux | grep softirq</span><br><span class="line">root           <span class="number">9</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>  <span class="number">16</span>:<span class="number">58</span> [ksoftirqd/<span class="number">0</span>]</span><br><span class="line">root          <span class="number">18</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>  <span class="number">14</span>:<span class="number">43</span> [ksoftirqd/<span class="number">1</span>]</span><br><span class="line">root          <span class="number">24</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>  <span class="number">13</span>:<span class="number">40</span> [ksoftirqd/<span class="number">2</span>]</span><br><span class="line">root          <span class="number">30</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>  <span class="number">10</span>:<span class="number">04</span> [ksoftirqd/<span class="number">3</span>]</span><br><span class="line">root          <span class="number">36</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">9</span>:<span class="number">21</span> [ksoftirqd/<span class="number">4</span>]</span><br><span class="line">root          <span class="number">42</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">9</span>:<span class="number">29</span> [ksoftirqd/<span class="number">5</span>]</span><br><span class="line">root          <span class="number">48</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>  <span class="number">11</span>:<span class="number">24</span> [ksoftirqd/<span class="number">6</span>]</span><br><span class="line">root          <span class="number">54</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">9</span>:<span class="number">39</span> [ksoftirqd/<span class="number">7</span>]</span><br><span class="line">root          <span class="number">60</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">9</span>:<span class="number">55</span> [ksoftirqd/<span class="number">8</span>]</span><br><span class="line">root          <span class="number">66</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">9</span>:<span class="number">12</span> [ksoftirqd/<span class="number">9</span>]</span><br><span class="line">root          <span class="number">72</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">8</span>:<span class="number">51</span> [ksoftirqd/<span class="number">10</span>]</span><br><span class="line">root          <span class="number">78</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">9</span>:<span class="number">24</span> [ksoftirqd/<span class="number">11</span>]</span><br><span class="line">root          <span class="number">84</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">7</span>:<span class="number">59</span> [ksoftirqd/<span class="number">12</span>]</span><br><span class="line">root          <span class="number">90</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">8</span>:<span class="number">01</span> [ksoftirqd/<span class="number">13</span>]</span><br><span class="line">root          <span class="number">96</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">8</span>:<span class="number">08</span> [ksoftirqd/<span class="number">14</span>]</span><br><span class="line">root         <span class="number">102</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">8</span>:<span class="number">30</span> [ksoftirqd/<span class="number">15</span>]</span><br><span class="line">root         <span class="number">108</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">7</span>:<span class="number">49</span> [ksoftirqd/<span class="number">16</span>]</span><br><span class="line">root         <span class="number">114</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">8</span>:<span class="number">00</span> [ksoftirqd/<span class="number">17</span>]</span><br><span class="line">root         <span class="number">120</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">9</span>:<span class="number">33</span> [ksoftirqd/<span class="number">18</span>]</span><br><span class="line">root         <span class="number">126</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">8</span>:<span class="number">20</span> [ksoftirqd/<span class="number">19</span>]</span><br><span class="line">root         <span class="number">132</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">8</span>:<span class="number">05</span> [ksoftirqd/<span class="number">20</span>]</span><br><span class="line">root         <span class="number">138</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">8</span>:<span class="number">28</span> [ksoftirqd/<span class="number">21</span>]</span><br><span class="line">root         <span class="number">144</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">8</span>:<span class="number">16</span> [ksoftirqd/<span class="number">22</span>]</span><br><span class="line">root         <span class="number">150</span>  <span class="number">0.0</span>  <span class="number">0.0</span>      <span class="number">0</span>     <span class="number">0</span> ?        S    <span class="number">4</span> 月 <span class="number">17</span>   <span class="number">8</span>:<span class="number">27</span> [ksoftirqd/<span class="number">23</span>]</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>软中断类型是有限的，就 10 来种，软中断的处理函数也是写死了的，不支持动态注册。</li><li>软中断是通过 <code>do_softirq</code> 这个函数调用开始执行的，该函数一般由 <code>ksoftirqd</code> 守护进程来调用执行（好像其他位置也可以调用，不过不清楚例子），该进程的优先级很低 <code>19</code>，所以<strong>软中断一般不能及时处理</strong>。</li><li>软中断可以并发运行在多个 CPU 上（即使同一类型的也可以），所以软中断的<strong>处理函数必须设计为可重入的函数</strong>。</li><li>软中断处理函数执行过程中，硬件中断没有被禁用！</li></ul><blockquote><p>✨✨✨✨</p><p>关于中断的时序：</p><ul><li>硬中断会打断硬中断（当然是不同类型的，以及没有被禁用）；</li><li>硬中断会打断软中断；</li><li>软中断不会打断硬中断，软中断也不会打断软中断。</li></ul></blockquote><h2 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h2><p>软中断是将操作推迟到未来时刻执行的最有效的方法。但该延期机制处理起来非常复杂。因为多个处理器可以同时且独立地处理软中断，<strong>同一个软中断的处理程序例程可以在几个 <code>CPU</code> 上同时运行</strong>。对软中断的效率来说，这是一个关键，多处理器系统上的网络实现显然受惠于此。但<strong>处理程序例程的设计必须是完全可重入且线程安全的</strong>。另外，临界区必须用自旋锁保护（或其他 IPC 机制，参见第 5 章），而这需要大量审慎的考虑。</p><p><code>tasklet</code> 和工作队列是延期执行工作的机制，其实现基于软中断，但它们更易于使用，因而更适合于设备驱动程序（以及其他一般性的内核代码）。</p><blockquote><p>有点类似与线程池的概念✨，线程池的大小就是 <code>ksoftirqd</code> 的数量，任务就是 <code>tasklet</code> 或者 <strong>工作队列</strong>，单个任务 <code>tasklet</code> 可能在任意一个 <code>ksoftirqd</code> 上运行，但是一个 <code>tasklet</code> 只能在一个 <code>ksoftirqd</code> 上运行。<code>tasklet</code> 也会用一个单向链表 <code>tasklet_vec</code> 来管理，<del>每次 <code>ksoftirqd</code> 取任务时都需要对该队列进行加锁保护。</del></p></blockquote><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="tasklet-struct"><a href="#tasklet-struct" class="headerlink" title="tasklet_struct"></a>tasklet_struct</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/include/linux/interrupt.h#L613</span></span><br><span class="line"><span class="comment">/* Tasklets --- multithreaded analogue of BHs.</span></span><br><span class="line"><span class="comment">   Properties:</span></span><br><span class="line"><span class="comment">   * If tasklet_schedule() is called, then tasklet is guaranteed</span></span><br><span class="line"><span class="comment">     to be executed on some cpu at least once after this.</span></span><br><span class="line"><span class="comment">   * If the tasklet is already scheduled, but its execution is still not</span></span><br><span class="line"><span class="comment">     started, it will be executed only once.</span></span><br><span class="line"><span class="comment">   * If this tasklet is already running on another CPU (or schedule is called</span></span><br><span class="line"><span class="comment">     from tasklet itself), it is rescheduled for later.</span></span><br><span class="line"><span class="comment">   * Tasklet is strictly serialized wrt itself, but not</span></span><br><span class="line"><span class="comment">     wrt another tasklets. If client needs some intertask synchronization,</span></span><br><span class="line"><span class="comment">     he makes it with spinlocks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> state;</span><br><span class="line">        <span class="type">atomic_t</span> count;</span><br><span class="line">        <span class="type">bool</span> use_callback;</span><br><span class="line">        <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">                <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span> data);</span><br><span class="line">                <span class="type">void</span> (*callback)(<span class="keyword">struct</span> tasklet_struct *t);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>next</code> 是一个指针，用于建立 <code>tasklet_struct</code> 实例的链表。这容许几个任务排队执行。</p></li><li><p><code>func</code> 指向一个函数的地址，该函数的执行将被延期。<code>data</code> 用作该函数执行时的参数。</p><blockquote><p> <code>data</code> 是 <code>unsigned long</code> 类型的，所以注意它可能是作为指针（值为内存地址）来用，而不是单纯的数字。内核中经常这样用。</p></blockquote></li><li><p><code>state</code> 表示任务的当前状态，类似于真正的进程。但只有两个选项，分别由 <code>state</code> 中的一个比特位表示，这也是二者可以独立设置&#x2F;清除的原因。</p><ul><li>在 <code>tasklet</code> 注册到内核，等待调度执行时，将设置 <code>TASKLET_STATE_SCHED</code>。</li><li><code>TASKLET_STATE_RUN</code> 表示 <code>tasklet</code> 当前正在执行。第二个状态只在 <code>SMP</code> 系统上有用。用于保护 <code>tasklet</code> 在多个处理器上并行执行。</li></ul></li><li><p>原子计数器 <code>count</code> 用于禁用已经调度的 <code>tasklet</code>。如果其值不等于 0，在接下来执行所有待决的 <code>tasklet</code> 时，将忽略对应的 <code>tasklet</code>。</p></li></ul><p>这个 <code>satat</code> 用于对 <code>tasklet</code> 加锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/include/linux/interrupt.h#L678</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">tasklet_trylock</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> !test_and_set_bit(TASKLET_STATE_RUN, &amp;(t)-&gt;state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_unlock</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line">&#123;</span><br><span class="line">        smp_mb__before_atomic();</span><br><span class="line">        clear_bit(TASKLET_STATE_RUN, &amp;(t)-&gt;state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册-tasklet"><a href="#注册-tasklet" class="headerlink" title="注册 tasklet"></a>注册 tasklet</h3><p><code>tasklet_schedule</code> 将一个 <code>tasklet</code> 注册到系统中。更准确地来说，是注册到调用 <code>tasklet_schedule</code> 这个函数的 <code>core</code> 中。每个核会维护一个链表 <code>tasklet_vec</code>，它的每个元素都是一个 <code>tasklet_struct</code> 实例，表示要执行的任务 <code>tasklet</code>。</p><p><code>tasklet_schedule</code> 用于将指定的 <code>tasklet</code> 添加到链表 <code>tasklet_vec</code> 末尾。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/kernel/softirq.c#L502</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_vec)</span>;</span><br><span class="line"><span class="type">static</span> <span class="title function_">DEFINE_PER_CPU</span><span class="params">(<span class="keyword">struct</span> tasklet_head, tasklet_hi_vec)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/include/linux/interrupt.h#L685</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">tasklet_schedule</span><span class="params">(<span class="keyword">struct</span> tasklet_struct *t)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">                __tasklet_schedule(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/kernel/softirq.c#L521</span></span><br><span class="line"><span class="type">void</span> __tasklet_schedule(<span class="keyword">struct</span> tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">        __tasklet_schedule_common(t, &amp;tasklet_vec,</span><br><span class="line">                                  TASKLET_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __tasklet_schedule_common(<span class="keyword">struct</span> tasklet_struct *t,</span><br><span class="line">                                      <span class="keyword">struct</span> tasklet_head __percpu *headp,</span><br><span class="line">                                      <span class="type">unsigned</span> <span class="type">int</span> softirq_nr)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_head</span> *<span class="title">head</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">        local_irq_save(flags);</span><br><span class="line">        head = this_cpu_ptr(headp);</span><br><span class="line">        t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        *head-&gt;tail = t;</span><br><span class="line">        head-&gt;tail = &amp;(t-&gt;next);</span><br><span class="line">        raise_softirq_irqoff(softirq_nr); <span class="comment">// 引起一次 TASKLET_SOFTIRQ 软中断，以便执行 tasklet</span></span><br><span class="line">        local_irq_restore(flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于 <code>tasklet_vec</code> 变量，首先它是一个 <code>per_cpu</code> 变量，每个核都会维护自己的链表。其次，每个核上的任务 <code>tasklet</code> 只能由它自己处理，其他核不会帮忙处理，因此可能就会涉及到如何合理的分配 <code>tasklet</code>。</p><p>此外，<code>tasklet</code> 执行完毕后是否会从 <code>tasklet_vec</code> 上移除？</p></blockquote><h3 id="执行-tasklet"><a href="#执行-tasklet" class="headerlink" title="执行 tasklet"></a>执行 tasklet</h3><p><code>tasklet</code> 的生命周期中最重要的部分就是其执行。因为 <code>tasklet</code> 基于软中断实现，它们总是在处理软中断时执行。</p><p><code>tasklet</code> 关联到 <code>TASKLET_SOFTIRQ</code> 软中断。因而，调用 <code>raise_softirq(TASKLET_SOFTIRQ)</code>，即可在下一个适当的时机执行当前处理器的 <code>tasklet</code>。内核使用 <code>tasklet_action</code> 作为该软中断的 <code>action</code> 函数。</p><blockquote><p>这个函数会取 <code>tasklet_vec</code> 链表中的 <code>tasklet</code> 依次执行</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/kernel/softirq.c#L636</span></span><br><span class="line">open_softirq(TASKLET_SOFTIRQ, tasklet_action);</span><br><span class="line">open_softirq(HI_SOFTIRQ, tasklet_hi_action);</span><br><span class="line"></span><br><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/kernel/softirq.c#L576</span></span><br><span class="line"><span class="type">static</span> __latent_entropy <span class="type">void</span> <span class="title function_">tasklet_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *a)</span></span><br><span class="line">&#123;</span><br><span class="line">        tasklet_action_common(a, this_cpu_ptr(&amp;tasklet_vec), TASKLET_SOFTIRQ);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tasklet_action_common</span><span class="params">(<span class="keyword">struct</span> softirq_action *a,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> tasklet_head *tl_head,</span></span><br><span class="line"><span class="params">                                  <span class="type">unsigned</span> <span class="type">int</span> softirq_nr)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里清空了 tasklet_vec 链表的，用临时变量 list 来访问 ✨</span></span><br><span class="line">        <span class="comment">// 因为预期是会将所有 tasklet 执行的，如果出现了意外情况，再添加回来</span></span><br><span class="line">        local_irq_disable();</span><br><span class="line">        <span class="built_in">list</span> = tl_head-&gt;head;</span><br><span class="line">        tl_head-&gt;head = <span class="literal">NULL</span>;</span><br><span class="line">        tl_head-&gt;tail = &amp;tl_head-&gt;head;</span><br><span class="line">        local_irq_enable();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">list</span>) &#123;</span><br><span class="line">                <span class="comment">// 遍历单向链表，依次执行</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> =</span> <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这个加锁、解锁，就是前面提到的 state 标志位的处理</span></span><br><span class="line">                <span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/include/linux/interrupt.h#L678</span></span><br><span class="line">                <span class="keyword">if</span> (tasklet_trylock(t)) &#123;</span><br><span class="line">                        <span class="comment">// 只有这个原子计数为 0 时才会继续执行该 tasklet</span></span><br><span class="line">                        <span class="keyword">if</span> (!<span class="type">atomic_read</span>(&amp;t-&gt;count)) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED,</span><br><span class="line">                                                        &amp;t-&gt;state))</span><br><span class="line">                                        BUG();</span><br><span class="line">                                <span class="comment">// 调用 tasklet 对应的函数指针</span></span><br><span class="line">                                <span class="keyword">if</span> (t-&gt;use_callback)</span><br><span class="line">                                        t-&gt;callback(t);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                        t-&gt;func(t-&gt;data);</span><br><span class="line">                                tasklet_unlock(t);</span><br><span class="line">                                <span class="comment">// 处理完就继续处理下一个 tasklet</span></span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        tasklet_unlock(t);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只有当 tasklet 已经在其他核处理了时，加锁失败才会到这里。</span></span><br><span class="line">                local_irq_disable();</span><br><span class="line">                t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">                *tl_head-&gt;tail = t;</span><br><span class="line">                tl_head-&gt;tail = &amp;t-&gt;next;</span><br><span class="line">                __raise_softirq_irqoff(softirq_nr);</span><br><span class="line">                local_irq_enable();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>因为一个 <code>tasklet</code> 只能在一个处理器上执行一次，但其他的 <code>tasklet</code> 可以并行运行，所以需要特定于 <code>tasklet</code> 的锁</strong>。 <code>state</code> 状态用作锁变量。在执行一个 <code>tasklet</code> 的处理程序函数之前，内核使用 <code>tasklet_trylock</code> 检查 <code>tasklet</code> 的状态是否为 <code>TASKLET_STATE_RUN</code>。换句话说，它是否已经在系统的另一个处理器上运行</p><blockquote><p>🧠🧠这里 <code>tasklet</code> 用完之后，没有销毁 <code>free</code> 诶？不怕内存泄漏吗？</p><p><code>tasklet</code> 不是每一个核执行它自己的吗？为什么会有一个 <code>tasklet</code> 可能在其他核上面执行？</p></blockquote><h3 id="HI-SOFTIRQ"><a href="#HI-SOFTIRQ" class="headerlink" title="HI_SOFTIRQ"></a>HI_SOFTIRQ</h3><p>除了普通的 <code>tasklet</code> 之外，内核还使用了另一种 <code>tasklet</code>，它具有“较高”的优先级。除以下修改之外，其实现与普通的 <code>tasklet</code> 完全相同。</p><ol><li><p>使用 <code>HI_SOFTIRQ</code> 作为软中断，而不是 <code>TASKLET_SOFTIRQ</code>，相关的 <code>action</code> 函数是 <code>tasklet_hi_action</code>。</p></li><li><p>注册的 <code>tasklet</code> 在 CPU 相关的变量 <code>tasklet_hi_vec</code> 中排队。这是使用 <code>tasklet_hi_schedule</code> 完成的。</p></li></ol><p>在这里，“较高优先级”是指该软中断的处理程序 <code>HI_SOFTIRQ</code> 在所有其他处理程序之前执行，<strong>尤其是在构成了软中断活动主体的网络处理程序之前执行</strong>。</p><blockquote><p>所有软中断其实本质上都是由 <code>ksoftirqd</code> 决定的较低优先级，只不过不同类型的软中断之间，优先级略有区别，按顺序执行而已。这里说的较高优先级也仅仅是这个意思。毕竟 <code>HI_SOFTIRQ</code> 是所有软中断中优先级最高的了。🛫🛫而且软中断的主要开销就是处理网络收发包，只要优先级比网络收发包高，就能够很快地执行了。</p></blockquote><p>当前，大部分声卡驱动程序都利用了这一选项，因为操作延迟时间太长可能损害音频输出的音质。<strong>而用于高速传输的网卡也可以得益于该机制</strong>。</p><blockquote><p>😮😮丧心病狂了吧，网络收发包的优先级本来就仅次于 <code>HI</code>、<code>TIMER</code>，这都还要来抢 <code>HI</code> ？</p></blockquote><p>简单看看代码，只能和上面说一模一样✨✨就优先处理了而已。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/kernel/softirq.c#L581</span></span><br><span class="line"><span class="type">static</span> __latent_entropy <span class="type">void</span> <span class="title function_">tasklet_hi_action</span><span class="params">(<span class="keyword">struct</span> softirq_action *a)</span></span><br><span class="line">&#123;</span><br><span class="line">        tasklet_action_common(a, this_cpu_ptr(&amp;tasklet_hi_vec), HI_SOFTIRQ);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul><li>一种特定类型的 <code>tasklet</code> 只能运行在一个 <code>CPU</code> 上，不能并行，只能串行执行。</li><li>多个不同类型的 <code>tasklet</code> 可以并行在多个 <code>CPU</code> 上。</li><li>软中断是静态分配的，在内核编译好之后，就不能改变。但 <code>tasklet</code> 就灵活许多，可以在运行时改变（比如添加模块时）。</li><li>软中断中不允许睡眠，而 <code>tasklet</code> 同样是在软中断上下文中执行的，因此同样不允许睡眠。而下文所提到的<strong>工作队列</strong>是允许睡眠的。</li></ul><h2 id="完成量"><a href="#完成量" class="headerlink" title="完成量"></a>完成量</h2><p>完成量与信号量有些相似，但是基于等待队列实现的。</p><h2 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h2><blockquote><p>工作队列其实和 <code>ksoftirqd + tasklet</code> 类似，不过它不是工作在软中断的上下文中，而是普通的内核线程。此外进程的数量也不在局限于 <code>core</code> 的数量，几乎可以任意创建。进程名以 <code>kworker</code> 为前缀！</p><p>其实还是和线程池的原理相似的。</p></blockquote><p>工作队列是另外一个处理延后函数的概念，它大体上和 <code>tasklets</code> 类似。工作队列运行于内核进程上下文，而 <code>tasklets</code> 运行于软中断上下文。这意味着工作队列函数不必像 <code>tasklets</code> 一样必须是原子性的。<code>Tasklets</code> 总是运行于它提交自的那个处理器，工作队列在默认情况下也是这样。工作队列在 <code>Linux</code> 内核代码 <a href="https://elixir.bootlin.com/linux/v5.10.186/source/kernel/workqueue.c#L200">kernel&#x2F;workqueue.c</a> 中由如下的数据结构表示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span>      *<span class="title">pool</span>;</span>          <span class="comment">/* I: the associated pool */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span>            <span class="comment">/* I: the owning workqueue */</span></span><br><span class="line">        <span class="type">int</span>                     work_color;     <span class="comment">/* L: current color */</span></span><br><span class="line">        <span class="type">int</span>                     flush_color;    <span class="comment">/* L: flushing color */</span></span><br><span class="line">        <span class="type">int</span>                     refcnt;         <span class="comment">/* L: reference count */</span></span><br><span class="line">        <span class="type">int</span>                     nr_in_flight[WORK_NR_COLORS];</span><br><span class="line">                                                <span class="comment">/* L: nr of in_flight works */</span></span><br><span class="line">        <span class="type">int</span>                     nr_active;      <span class="comment">/* L: nr of active works */</span></span><br><span class="line">        <span class="type">int</span>                     max_active;     <span class="comment">/* L: max active works */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">inactive_works</span>;</span> <span class="comment">/* L: inactive works */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">pwqs_node</span>;</span>      <span class="comment">/* WR: node on wq-&gt;pwqs */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">mayday_node</span>;</span>    <span class="comment">/* MD: node on wq-&gt;maydays */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Release of unbound pwq is punted to system_wq.  See put_pwq()</span></span><br><span class="line"><span class="comment">         * and pwq_unbound_release_workfn() for details.  pool_workqueue</span></span><br><span class="line"><span class="comment">         * itself is also RCU protected so that the first pwq can be</span></span><br><span class="line"><span class="comment">         * determined without grabbing wq-&gt;mutex.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>      <span class="title">unbound_release_work</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>         <span class="title">rcu</span>;</span></span><br><span class="line">&#125; __aligned(<span class="number">1</span> &lt;&lt; WORK_STRUCT_FLAG_BITS);</span><br></pre></td></tr></table></figure><p>工作队列最基础的用法，是作为创建内核线程的接口来处理提交到队列里的工作任务。所有这些内核线程称之为 <code>worker thread</code>。工作队列内的任务是由代码 <a href="https://elixir.bootlin.com/linux/v5.10.186/source/include/linux/workqueue.h#L102">include&#x2F;linux&#x2F;workqueue.h</a> 中定义的 <code>work_struct</code> 表示的，其定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">        <span class="type">atomic_long_t</span> data;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">        <span class="type">work_func_t</span> func;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里有两个字段比较有意思：<code>func</code> –将被工作队列调度执行的函数，<code>data</code> –这个函数的参数。</p><blockquote><p>为什么内核使用 <code>atomic_long_t</code> 作为指向任意数据的指针的数据类型，而不是通常的 <code>void *</code>？</p><p>这里内核使用了一点小技巧，显然有点近乎于“肮脏”，以便将更多信息放入该结构，而又不付出更多代价。因为指针在所有支持的体系结构上都对齐到 4 字节边界，而前两个比特位保证为 0。因而可以“滥用”这两个比特位，将其用作标志位。剩余的比特位照旧保存指针的信息。以下的宏用于屏蔽标志位：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://elixir.bootlin.com/linux/v5.10.186/source/include/linux/workqueue.h#L90</span></span><br><span class="line">WORK_STRUCT_FLAG_MASK = (<span class="number">1UL</span> &lt;&lt; WORK_STRUCT_FLAG_BITS) - <span class="number">1</span>,</span><br><span class="line">WORK_STRUCT_WQ_DATA_MASK = ~WORK_STRUCT_FLAG_MASK,</span><br></pre></td></tr></table></figure><p>当前只定义了一个标志：<code>WORK_STRUCT_PENDING</code> 用来查找当前是否有待决（该标志位置位）的可延迟工作项。辅助宏 <code>work_pending(work)</code>用来检查该标志位。请注意，将 <code>data</code> 设置为原子数据类型，确保对该比特位的修改不会带来并发问题。</p></blockquote><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>⭐⭐🔥🔥《深入 Linux 内核架构》第 14 章，书讲得更好一些，下面的可以参考一下。</li><li>⭐⭐🔥🔥<a href="https://github.com/MintCN/linux-insides-zh/blob/master/Interrupts/README.md">《Linux 内核揭秘》</a> 这本书讲得也很好，而且更贴近代码讲解。</li><li><a href="https://www.xiaolincoding.com/os/1_hardware/soft_interrupt.html#%E4%B8%AD%E6%96%AD%E6%98%AF%E4%BB%80%E4%B9%88">什么是软中断</a></li><li><a href="https://zhuanlan.zhihu.com/p/265705850">Linux 内核中的软中断、tasklet 和工作队列详解</a></li><li><a href="https://www.toutiao.com/article/7153606983776731651/?wid=1693292862137">理解内核的硬软中断（详细讲解~）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设备树语法介绍</title>
      <link href="/2023/08/08/Linux%E5%86%85%E6%A0%B8-%E8%AE%BE%E5%A4%87%E6%A0%91/"/>
      <url>/2023/08/08/Linux%E5%86%85%E6%A0%B8-%E8%AE%BE%E5%A4%87%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="设备树语法"><a href="#设备树语法" class="headerlink" title="设备树语法"></a>设备树语法</h2><ol><li><p>什么是设备？<br> 直观点：键盘、鼠标、内存、CPU、显示器、<code>wifi</code>、网卡、显卡是设备。<br> 底层点：<code>SPI</code> 、<code>I2C</code>、<code>I2S</code> 、<code>mipi</code>、<code>gpio</code>、<code>USB</code> 等控制器。</p></li><li><p>Linux &#x2F; Uboot 是如何管理这些设备的呢？<br> <strong>父子关系</strong><br> <code>I2C</code> 等控制器与通过该控制器接入的设备，明显就是父子关系。<br> <strong>根设备</strong></p><p> <code>SPI</code>、 <code>I2C</code> 控制器这样看起来没有关联的设备，他们就直接挂靠在根设备下。</p><p> <img src="/../images/Linux%E5%86%85%E6%A0%B8-%E8%AE%BE%E5%A4%87%E6%A0%91/image-20231230124213784.png" alt="image-20231230124213784"></p></li><li><p>为什么要有设备树？</p><p> 这个和 Linux 的设备-驱动模型对应，驱动 - 设备分离，通过 <code>Kconfig</code> 定义的配置项决定是否启用驱动。设备是否启用则是由设备树来决定。<br> Linux 支持的设备类型很多很多，不可能将所有设备都启用（会浪费大量的内存、CPU资源）。设备树就是用来告诉 Kernel 需要启用哪些设备。</p></li></ol><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><p><strong>设备树 <code>dtsi</code> 文件中使用 c 语言的方式注释 <code>/* 注释 */</code> 以及 <code>// 注释</code>，特别注意 <code>#</code> 是有特殊意义的，不是注释！！</strong></p><p>设备之间的父子关系，用文本表示出来是用 <code>&#123;&#125;</code> 管理的包含关系。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/ &#123; <span class="comment">// ‘/’ 表示根设备</span></span><br><span class="line">spi0: spi0@<span class="number">04180000</span> &#123; <span class="comment">// spi0 是 SPI 控制器</span></span><br><span class="line">        compatible = <span class="string">&quot;snps,dw-apb-ssi&quot;</span>;</span><br><span class="line">        reg = &lt;<span class="number">0x0</span> <span class="number">0x04180000</span> <span class="number">0x0</span> <span class="number">0x10000</span>&gt;;</span><br><span class="line">        clocks = &lt;&amp;clk CV181X_CLK_SPI&gt;;</span><br><span class="line"></span><br><span class="line">panel@<span class="number">0</span> &#123; <span class="comment">// panel 是 SPI0 的一个子设备</span></span><br><span class="line">            compatible = <span class="string">&quot;xxx,st7789v&quot;</span>;</span><br><span class="line">            spi-frequency = &lt;<span class="number">48000000</span>&gt;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>好了，接下来就看 <a href="https://www.devicetree.org/">devicetree.org  的标准文档</a>，英文的，篇幅不长。</p><h2 id="节点格式"><a href="#节点格式" class="headerlink" title="节点格式"></a><strong>节点格式</strong></h2><p>一个节点就代表一个设备。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label: node-name@unit-address</span><br></pre></td></tr></table></figure><p>其中：</p><blockquote><ul><li>label：标签（可以省略），它的作用是为了方便地引用 <code>node</code>。</li><li>node-name：节点名字，设备</li><li>unit-address：单元地址（可以没有）</li></ul></blockquote><h3 id="引用节点"><a href="#引用节点" class="headerlink" title="引用节点"></a>引用节点</h3><p><code>label</code> 的作用是为了方便地引用 <code>node</code>。引用的目的一般是为了 <strong>追加&#x2F;修改节点内容</strong>，比如 ：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/&#123;</span><br><span class="line">    uart0: uart@fe001000 &#123;</span><br><span class="line">        compatible=<span class="string">&quot;ns16550&quot;</span>;</span><br><span class="line">        reg=&lt;<span class="number">0xfe001000</span> <span class="number">0x100</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以使用下面 2 种方法来修改 <code>uart@fe001000</code> 这个 <code>node</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在根节点之外使用 label 引用 node</span></span><br><span class="line">&amp;uart0 &#123;</span><br><span class="line">    status=<span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或在根节点之外使用全路径，（不使用标签）</span></span><br><span class="line">&amp;&#123;/uart@fe001000&#125; &#123;</span><br><span class="line">    status=<span class="string">&quot;disabled&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="属性格式"><a href="#属性格式" class="headerlink" title="属性格式"></a><strong>属性格式</strong></h2><p>简单地说， <code>properties</code> 就是 <code>name=value</code>， <code>value</code> 有多种取值方式。示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个 32 位的数据，用尖括号包围起来，可以用十六进制，也可以用十进制，如</span></span><br><span class="line">interrupts = &lt;<span class="number">0xc</span>&gt;;</span><br><span class="line">interrupts = &lt;<span class="number">17</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 64 位数据（只能使用 2 个 32 位数据表示），用尖括号包围起来，如：</span></span><br><span class="line">clock-frequency = &lt;<span class="number">0x00000001</span> <span class="number">0x00000000</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以传递多个值，具体看驱动如何解析</span></span><br><span class="line">test-property = &lt;<span class="number">11</span> <span class="number">22</span> <span class="number">33</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有结束符的字符串，用双引号包围起来，如：</span></span><br><span class="line">compatible = <span class="string">&quot;simple-bus&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字节序列，用中括号包围起来，如：</span></span><br><span class="line">local-mac-address = [<span class="number">00</span> <span class="number">00</span> <span class="number">12</span> <span class="number">34</span> <span class="number">56</span> <span class="number">78</span>]; <span class="comment">// 每个 byte 使用 2 个 16 进制数来表示</span></span><br><span class="line">local-mac-address = [<span class="number">000012345678</span>];      <span class="comment">// 每个 byte 使用 2 个 16 进制数来表示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以是各种值的组合，用逗号隔开，如：</span></span><br><span class="line">compatible = <span class="string">&quot;ns16550&quot;</span>, <span class="string">&quot;ns8250&quot;</span>;</span><br><span class="line">example = &lt;<span class="number">0xf00f0000</span> <span class="number">19</span>&gt;, <span class="string">&quot;a strange property format&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="一些标准属性"><a href="#一些标准属性" class="headerlink" title="一些标准属性"></a><strong>一些标准属性</strong></h2><h3 id="compatible-属性"><a href="#compatible-属性" class="headerlink" title="compatible 属性"></a><strong>compatible 属性</strong></h3><p>“compatible” 表示 “兼容”，对于某个 LED，内核中可能有 A、B、C 三个驱动都支持它，那可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">led &#123;</span><br><span class="line">    compatible = “A”, “B”, “C”;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>内核启动时，<strong>就会为这个 LED 按这样的优先顺序为它找到驱动程序</strong>：A、B、C。</p><h4 id="model-属性"><a href="#model-属性" class="headerlink" title="model 属性"></a><strong>model 属性</strong></h4><p>用来表示设备型号而已。没啥用。</p><p>model 属性与 <code>compatible</code> 属性有些类似，但是有差别。<code>compatible</code> 属性是一个字符串列表，表示可以你的硬件兼容 A、B、C 等驱动；model 用来准确地定义这个硬件是什么。比如根节点中可以这样写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    compatible = <span class="string">&quot;samsung,smdk2440&quot;</span>, <span class="string">&quot;samsung,mini2440&quot;</span>;</span><br><span class="line">    model = <span class="string">&quot;jz2440_v3&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>它表示这个单板，可以兼容内核中的 “smdk2440”，也兼容 “mini2440”。</p><p>从 <code>compatible</code> 属性中可以知道它兼容哪些板，但是它到底是什么板？用 model 属性来明确。</p><h3 id="status-属性"><a href="#status-属性" class="headerlink" title="status 属性"></a><strong>status 属性</strong></h3><p>status 属性看名字就知道是和设备状态有关的， status 属性值也是字符串，字符串是设备的状态信息，可选的状态如下所示：</p><p><img src="/../images/Linux%E5%86%85%E6%A0%B8-%E8%AE%BE%E5%A4%87%E6%A0%91/property.png" alt="property"></p><h3 id="address-cells-和-size-cells-属性"><a href="#address-cells-和-size-cells-属性" class="headerlink" title="#address-cells 和 #size-cells 属性"></a><strong>#address-cells 和 #size-cells 属性</strong></h3><p>格式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># address-cells：address    要用多少个 32 位数来表示；</span></span><br><span class="line"><span class="meta"># size-cells：size          要用多少个 32 位数来表示。</span></span><br></pre></td></tr></table></figure><p>比如一段内存，怎么描述它的起始地址和大小？</p><p>下例中，<code>address-cells</code> 为 1，所以 reg 中用 1 个数来表示地址，即用 0x80000000 来表示地址；size-cells 为 1，所以 reg 中用 1 个数来表示大小，即用 0x20000000 表示大小：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">    <span class="meta"># address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta"># size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    memory &#123;</span><br><span class="line">        reg = &lt;<span class="number">0x80000000</span> <span class="number">0x20000000</span>&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="reg-属性"><a href="#reg-属性" class="headerlink" title="reg 属性"></a><strong>reg 属性</strong></h3><p><code>reg</code> 属性的值，是一系列的 <code>&lt;address size&gt;</code>，用多少个 32 位的数来表示 <code>address</code> 和 <code>size</code>，由其<strong>父节点</strong>的 <code>#address-cells</code>、<code>#size-cells</code> 决定。示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">    <span class="meta"># address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta"># size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="comment">// 这里 memory 这个节点的父节点的 address-cells = 1, 表示地址长度为 32 位，</span></span><br><span class="line">    <span class="comment">// size-cells = 1 表示长度是用 32 位的数来表示，size-cells=2 表示长度是用 64 位的数来表示。</span></span><br><span class="line">    memory &#123;</span><br><span class="line">         reg = &lt;<span class="number">0x8000</span> <span class="number">0x10</span> <span class="number">0xA000</span> <span class="number">0x100</span>&gt;; <span class="comment">// 有两个寄存器块，地址位于 0x800，长度为 16 byte，和位于 0xA000，256 字节</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><del>不过，从实际文件中来看，reg 的用法更像是 <code>reg=&lt;0x00 addr 0x00 size&gt;</code> 如下所示</del>🤦‍♂️，比如 I2C 设备的 reg 用来表示设备地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">memory@<span class="number">80000000</span> &#123;</span><br><span class="line">device_type = <span class="string">&quot;memory&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x00</span> CVIMMAP_KERNEL_MEMORY_ADDR <span class="number">0x00</span> CVIMMAP_KERNEL_MEMORY_SIZE&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fast_image &#123;</span><br><span class="line">compatible = <span class="string">&quot;cvitek,rtos_image&quot;</span>;</span><br><span class="line">reg-names = <span class="string">&quot;rtos_region&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x0</span> CVIMMAP_FREERTOS_ADDR <span class="number">0x0</span> CVIMMAP_FREERTOS_SIZE&gt;;</span><br><span class="line">ion-size = &lt;CVIMMAP_FREERTOS_RESERVED_ION_SIZE&gt;;<span class="comment">//reserved ion size for freertos</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实这里就是上面 <code>#address-cells</code> 和 <code>#size-cells</code> 属性的作用，因为在 <code>cv181x_base.dtsi</code> 中，根节点有设置这两个属性为2，那么就需要用2个32bit来表示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/ &#123;</span><br><span class="line">compatible = <span class="string">&quot;cvitek,cv181x&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#size-cells = <span class="string">&lt;0x2&gt;</span>;</span></span><br><span class="line"><span class="meta">#address-cells = <span class="string">&lt;0x2&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">top_misc:top_misc_ctrl@<span class="number">3000000</span> &#123;</span><br><span class="line">compatible = <span class="string">&quot;syscon&quot;</span>;</span><br><span class="line">reg = &lt;<span class="number">0x0</span> <span class="number">0x03000000</span> <span class="number">0x0</span> <span class="number">0x8000</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a><strong>name 属性</strong></h3><p>过时了，建议不用。它的值是字符串，用来表示节点的名字。在跟 <code>platform_driver</code> 匹配时，优先级最低。<code>compatible</code> 属性在匹配过程中，优先级最高。</p><h3 id="device-type-属性"><a href="#device-type-属性" class="headerlink" title="device_type 属性"></a><strong>device_type 属性</strong></h3><p>过时了，建议不用。它的值是字符串，用来表示节点的类型。在跟 <code>platform_driver</code> 匹配时，优先级为中。<code>compatible</code> 属性在匹配过程中，优先级最高。</p><h3 id="phandle-属性"><a href="#phandle-属性" class="headerlink" title="phandle 属性"></a><strong>phandle 属性</strong></h3><p>全局唯一的ID，用来引用设备。但一般也不用，直接用 <code>&amp;label</code> 来引用设备。</p><p><code>phandle</code> 属性为 <code>devicetree</code> 中唯一的节点指定一个数字标识符，节点中的 <code>phandle</code> 性，它的取值必须是唯一的(不要跟其他的 <code>phandle</code> 值一样)，例如:</p><h3 id="gpio-属性"><a href="#gpio-属性" class="headerlink" title="gpio 属性"></a>gpio 属性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx-gpios =</span><br><span class="line">sda-gpios = &lt;&amp;portb 24 GPIO_ACTIVE_HIGH&gt;;</span><br></pre></td></tr></table></figure><p>解析后，内核中提取时只要 <code>-</code> 前面的值。这里代表 <code>XGPIOB[24]</code> 这组脚。后面的 <code>GPIO_ACTIVE_HIGH</code> 表示高电平使能。某些<code>spi</code> 设备通信时，片选信号线 <code>cs</code> 是低电平使能，这里就要改为 <code>GPIO_ACTIVE_LOW</code>，这样就不需要去修改代码中的逻辑。</p><p>可以理解为内核驱动中将GPIO设置为1，只是将其使能，具体是高电平还是低电平，还要看这个属性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sda_gpiod = devm_gpiod_get(&amp;pdev-&gt;dev, <span class="string">&quot;sda&quot;</span>, GPIOD_IN);</span><br></pre></td></tr></table></figure><h2 id="常用的节点"><a href="#常用的节点" class="headerlink" title="常用的节点"></a>常用的节点</h2><h3 id="根节点"><a href="#根节点" class="headerlink" title="根节点"></a>根节点</h3><p>用 <code>/</code> 标识根节点，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/dts-v1/;</span><br><span class="line">/ &#123;</span><br><span class="line">    model = <span class="string">&quot;SMDK24440&quot;</span>;</span><br><span class="line">    compatible = <span class="string">&quot;samsung,smdk2440&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta"># address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta"># size-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="CPU-节点"><a href="#CPU-节点" class="headerlink" title="CPU 节点"></a>CPU 节点</h3><p>一般不需要我们设置，在 <code>dtsi</code> 文件中都定义好了，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cpus &#123;</span><br><span class="line">    <span class="meta"># address-cells = <span class="string">&lt;1&gt;</span>;</span></span><br><span class="line">    <span class="meta"># size-cells = <span class="string">&lt;0&gt;</span>;</span></span><br><span class="line"></span><br><span class="line">    cpu0: cpu@<span class="number">0</span> &#123;</span><br><span class="line">     .......</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="memory-节点"><a href="#memory-节点" class="headerlink" title="memory 节点"></a>memory 节点</h3><p>芯片厂家不可能事先确定你的板子使用多大的内存，所以 <code>memory</code> 节点需要板厂设置，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory &#123;</span><br><span class="line">    reg = &lt;<span class="number">0x80000000</span> <span class="number">0x20000000</span>&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="chosen-节点"><a href="#chosen-节点" class="headerlink" title="chosen 节点"></a>chosen 节点</h3><p>chosen子节点不代表实际硬件，它主要用于给内核传递参数。 这里只设置了“stdout-path &#x3D;”serial0:115200n8”;”一条属性，表示系统标准输出stdout使用串口serial0。 此外这个节点还用作uboot向linux内核传递配置参数的“通道”， 我们在Uboot中设置的参数就是通过这个节点传递到内核的， 这部分内容是uboot和内核自动完成的，作为初学者我们不必深究。</p><p>我们可以通过设备树文件给内核传入一些参数，这要在 <code>chosen</code> 节点中设置 <code>bootargs</code> 属性：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">chosen &#123;</span><br><span class="line">    bootargs = <span class="string">&quot;noinitrd root=/dev/mtdblock4 rw init=/linuxrc console=ttySAC0,115200&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">chosen &#123;</span><br><span class="line">    <span class="built_in">stdout</span>-path = <span class="string">&quot;serial0&quot;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="aliases-节点"><a href="#aliases-节点" class="headerlink" title="aliases 节点"></a>aliases 节点</h3><p>就是给某些节点设置别名，比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">aliases &#123;</span><br><span class="line">    i2c0 = &amp;i2c0;</span><br><span class="line">    i2c1 = &amp;i2c1;</span><br><span class="line">    i2c2 = &amp;i2c2;</span><br><span class="line">    i2c3 = &amp;i2c3;</span><br><span class="line">    i2c4 = &amp;i2c4;</span><br><span class="line">    serial0 = &amp;uart0;</span><br><span class="line">    serial1 = &amp;uart1;</span><br><span class="line">    serial2 = &amp;uart2;</span><br><span class="line">    serial3 = &amp;uart3;</span><br><span class="line">    serial4 = &amp;uart4;</span><br><span class="line">    ethernet0 = &amp;ethernet0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="如何获取设备树节点信息"><a href="#如何获取设备树节点信息" class="headerlink" title="如何获取设备树节点信息"></a>如何获取设备树节点信息</h2><blockquote><p>参考：<a href="https://doc.embedfire.com/linux/stm32mp1/driver/zh/latest/linux_driver/base_driver_tree.html#id9">8. Linux设备树</a></p></blockquote><p>内核提供了一组函数用于从设备节点获取资源（设备节点中定义的属性）的函数，这些函数以of_开头，称为OF操作函数。 常用的OF函数介绍看 <a href="https://doc.embedfire.com/linux/stm32mp1/driver/zh/latest/linux_driver/base_driver_tree.html#id9">8. Linux设备树</a></p><h3 id="提取属性值的of函数"><a href="#提取属性值的of函数" class="headerlink" title="提取属性值的of函数"></a>提取属性值的of函数</h3><p><a href="https://doc.embedfire.com/linux/stm32mp1/driver/zh/latest/linux_driver/base_driver_tree.html#of">https://doc.embedfire.com/linux/stm32mp1/driver/zh/latest/linux_driver/base_driver_tree.html#of</a></p><h3 id="内存映射相关of函数"><a href="#内存映射相关of函数" class="headerlink" title="内存映射相关of函数"></a>内存映射相关of函数</h3><p><a href="https://doc.embedfire.com/linux/stm32mp1/driver/zh/latest/linux_driver/base_driver_tree.html#id20">https://doc.embedfire.com/linux/stm32mp1/driver/zh/latest/linux_driver/base_driver_tree.html#id20</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.devicetree.org/">devicetree.org  的标准文档</a>，英文的，篇幅不长。</li><li><a href="https://doc.embedfire.com/linux/stm32mp1/driver/zh/latest/linux_driver/base_driver_tree.html#id9">8. Linux设备树</a> 野火相关教程。</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzUxMjEyNDgyNw==&mid=2247507125&idx=1&sn=6100723c3d3d012e40f4706ed16fd2d1&chksm=f96bae41ce1c2757c842713f7828b01b7fa8914b23b5e3d2dfba7aa064d0e822eca24645d1c0&from=industrynews&version=4.1.7.6018&platform=win&poc_token=HI3X0WSjwJWFv7kC545w1yAqOg0r4p8YYUUMe1UV">微信-整理了一份 Linux 设备树基础知识，建议收藏！</a></li><li><a href="https://tinylab.org/linux-dts-1/">Device Tree 初探</a></li><li><a href="https://elinux.org/Device_Tree_Usage">elinux.org&#x2F;Device_Tree_Usage</a></li><li><a href="http://hulc.xyz/2021/11/11/linux%E8%AE%BE%E5%A4%87%E6%A0%91%E8%A7%A3%E6%9E%90/">Linux 设备树解析</a></li><li><a href="http://hulc.xyz/2021/11/16/linux%E8%AE%BE%E5%A4%87%E6%A0%91device-node%E8%BD%AC%E6%8D%A2%E6%88%90platform-device/">Linux 设备树 device_node 转换成 platform_device</a></li><li><a href="https://bbs.huaweicloud.com/blogs/411120">https://bbs.huaweicloud.com/blogs/411120</a></li></ul><hr><h2 id="💡编译、反编译"><a href="#💡编译、反编译" class="headerlink" title="💡编译、反编译"></a>💡编译、反编译</h2><p>要将设备树二进制文件（<strong>DTB</strong>，Device Tree Blob）反编译为设备树源文件（<strong>DTS</strong>，Device Tree Source），你可以使用 Linux 中的 <code>dtc</code>（Device Tree Compiler）工具。以下是具体的步骤：</p><ol><li><p><strong>安装 <code>dtc</code> 工具</strong>（如果尚未安装）：</p><ul><li>在基于 Debian 的系统（如 Ubuntu）中，可以通过以下命令安装：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install device-tree-compiler</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>反编译 DTB 文件</strong>：<br>使用 <code>dtc</code> 命令将 DTB 文件反编译为 DTS 文件。假设你的 DTB 文件名为 <code>example.dtb</code>，你可以运行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dtc -I dtb -O dts -o example.dts example.dtb</span><br></pre></td></tr></table></figure><ul><li><code>-I dtb</code>：指定输入格式为 DTB。</li><li><code>-O dts</code>：指定输出格式为 DTS。</li><li><code>-o example.dts</code>：输出的 DTS 文件名。</li><li><code>example.dtb</code>：要反编译的 DTB 文件。</li></ul></li><li><p><strong>查看 DTS 文件</strong>：<br>反编译完成后，你可以使用文本编辑器查看生成的 <code>.dts</code> 文件。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Kernel </tag>
            
            <tag> DTS </tag>
            
            <tag> Uboot </tag>
            
            <tag> 设备树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cvitek-安全启动</title>
      <link href="/2023/08/03/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/"/>
      <url>/2023/08/03/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Cvitek-安全启动"><a href="#Cvitek-安全启动" class="headerlink" title="Cvitek-安全启动"></a>Cvitek-安全启动</h2><blockquote><p>注：仅考虑 <code>cv181x</code></p></blockquote><p>安全启动的意义：</p><ul><li>防止用户烧录未经授权的固件。（签名）</li><li>防止通过固件拷贝，来抄袭产品。（签名+加密）</li></ul><h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><h3 id="加密算法介绍"><a href="#加密算法介绍" class="headerlink" title="加密算法介绍"></a>加密算法介绍</h3><blockquote><ul><li><a href="https://mp.weixin.qq.com/s/XBYJFZ2jRF2slrlym3svQw">盘点五种最常见加密算法！</a></li><li><a href="https://mp.weixin.qq.com/s/Hu1VBMSHh82n6bujWxr9nw">密码学基本概念</a></li></ul></blockquote><p>算法整体上可以分为**<del>不可逆加密</del><strong>，以及</strong>可逆加密<strong>，可逆加密又可以分为</strong>对称加密<strong>和</strong>非对称加密**。</p><blockquote><p>不可逆这部分称为 <strong>消息摘要</strong> 更好，<strong>摘要算法</strong>就是我们常说的散列函数、哈希函数（Hash Function），它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。</p></blockquote><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/640.png" alt="图片"></p><h4 id="消息摘要"><a href="#消息摘要" class="headerlink" title="消息摘要"></a>消息摘要</h4><p>散列算法，就是一种不可逆算法，无法从散列结果中反推出明文。<strong>可以用来检验数据是否被更改</strong>。</p><p>散列算法中，明文通过散列算法生成散列值，<strong>散列值是长度固定的数据，和明文长度无关</strong>。</p><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/640-1694590307639-3.png" alt="图片"></p><p>散列算法的具体实现有很多种，常见的包括 <code>MD5</code>、<code>SHA1</code>、<code>SHA-224</code>、<code>SHA-256</code> 等等。</p><p>散列算法常用于<strong>数字签名</strong>、消息认证、密码存储等场景。</p><blockquote><p>本文中，对 <code>kernel</code>、<code>rootfs</code> 的签名就是基于 <code>sha256</code> 实现（不过还用到了下面的 <code>RSA</code>）。</p></blockquote><table><thead><tr><th>名称</th><th>介绍：都是用于将任意长度的数据映射为固定长度的散列值，只是映射长度和实现算法不同</th></tr></thead><tbody><tr><td><code>MD5</code></td><td><code>MD5</code>（Message-Digest Algorithm 5），<code>MD5</code> 算法的输出长度为 <code>128</code> 位，通常用 <code>32</code> 个 <code>16</code> 进制数表示。</td></tr><tr><td><code>SHA1</code></td><td><code>SHA-1</code> 系列存在缺陷，已经不再被推荐使用</td></tr><tr><td><code>SHA2</code></td><td><code>SHA-2</code> 算法包括<code>SHA-224</code>、<code>SHA-256</code>、<code>SHA-384</code>和<code>SHA-512</code>四种散列函数，<br />分别将任意长度的数据映射为 <code>224</code> 位、<code>256</code> 位、<code>384</code> 位和 <code>512</code> 位的散列值。</td></tr></tbody></table><h4 id="对称加密-–-AES-算法"><a href="#对称加密-–-AES-算法" class="headerlink" title="对称加密 – AES 算法"></a>对称加密 – AES 算法</h4><p>对称加密算法，使用同一个密钥进行加密和解密。</p><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/640-1694591480328-6.png" alt="图片"></p><p>加密和解密过程使用的是相同的密钥，因此密钥的安全性至关重要。如果密钥泄露，攻击者可以轻易地破解加密数据。</p><p>常见的对称加密算法包括 <code>DES</code>、<code>3DES</code>、<code>AES</code> 等。其中，**<code>AES</code> 算法是目前使用最广泛的对称加密算法之一，具有比较高的安全性和加密效率<strong>。</strong><code>AES</code> 算法使用的密钥长度为 <code>128</code> 位、<code>192</code> 位或 <code>256</code> 位**（这里的位是 <code>bit</code>）</p><blockquote><p>我们使用的 <code>AES</code> 秘钥是 128 位。</p></blockquote><h4 id="非对称加密-–-RSA-算法"><a href="#非对称加密-–-RSA-算法" class="headerlink" title="非对称加密 – RSA 算法"></a>非对称加密 – RSA 算法</h4><p>非对称加密算法需要两个密钥，这两个密钥互不相同，但是相互匹配，一个称为<strong>公钥</strong>，另一个称为<strong>私钥</strong>。</p><p><strong>使用其中的一个加密，则使用另一个进行解密</strong>。例如使用公钥加密，则需要使用私钥解密。</p><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/640-1694591564320-9.png" alt="图片"></p><p><code>RSA</code> 算法的<strong>优点是安全性高</strong>，公钥可以公开，私钥必须保密，保证了数据的安全性；可用于数字签名、密钥协商等多种应用场景。</p><p><strong>缺点是加密、解密速度较慢</strong>，密钥长度越长，加密、解密时间越长；密钥长度过短容易被暴力破解，密钥长度过长则会增加计算量和存储空间的开销。</p><p><code>RSA</code> 的秘钥（包括公钥和私钥）由两部分组成：模数和指数</p><ul><li><p><strong>公钥</strong>：包括模数 <code>N</code> 和<strong>公钥指数</strong> <code>E</code>。公钥用于<strong>验证数字签名</strong>。</p></li><li><p><strong>私钥</strong>：包括模数 <code>N</code> 和<strong>私钥指数</strong> <code>D</code>。私钥用于<strong>生成数字签名</strong>。</p><blockquote><p>具体来说，数字签名过程通常涉及以下步骤：</p><ol><li><strong>使用哈希函数对要签名的数据进行哈希处理，生成消息摘要。</strong></li><li><strong>使用私钥对消息摘要进行加密，生成数字签名。</strong></li><li>将原始数据、数字签名和公钥发送给接收方。</li></ol><p>验证数字签名的过程如下：</p><ol><li><strong>使用公钥对数字签名进行解密，得到消息摘要。</strong></li><li><strong>使用相同的哈希函数对原始数据进行哈希处理，生成另一个消息摘要。</strong></li><li>比较这两个消息摘要，如果相同，则表示签名有效，否则表示签名无效。</li></ol><p>因此，公钥通常用于验证签名的有效性，而不是用于生成数字签名。</p></blockquote></li></ul><p>在一个标准的 <code>RSA</code> 密钥对中，公钥的 <code>E</code>和 <code>N</code> 通常也包含在私钥中，<strong>模数 <code>N</code> 是 <code>RSA</code> 密钥对的关键部分，它在公钥和私钥中都是相同的</strong>。<code>E</code> 和 <code>D</code> 是指数，它们通常不同，因为它们在不同的数学运算中使用。</p><ul><li><code>E</code> 通常被设置为常数值 65537（0x10001），因为这个值在二进制中有很多 1，使得加密操作更加高效。</li><li><code>N</code> 是一个大整数，它是两个大质数的乘积，<strong>它决定了 <code>RSA</code> 密钥的长度和强度</strong>。</li></ul><p>在 RSA 算法中，公钥和私钥都包含模数 <code>N</code>，而 <code>N</code> 是两个大质数 <code>p</code> 和 <code>q</code> 的乘积。公钥还包含一个指数 <code>e</code>，而私钥包含另一个指数 <code>d</code>。这两个指数 <code>e</code> 和 <code>d</code> 的选择要满足一个特定的条件，也就是满足 <code>e*d ≡ 1 (mod φ(N))</code> 的关系。在这里，<code>φ(N)</code> 是 Euler’s totient 函数，它对于 <code>N=p*q</code>，值为<code>φ(N)=(p-1)(q-1)</code>。</p><p>也就是说，虽然两对密钥（公钥和私钥）有不同的指数 <code>e</code> 和 d，但 <code>e</code> 和 <code>d</code> 是满足相应数学关系的。使得用公钥进行加密的密文用私钥能解密，用私钥进行加密的密文用公钥能解密。在这里，”模 N” 是指在所有的加密和解密操作都在模 N 的意义下进行。实则，”互逆”是在指 <code>e</code> 和 <code>d</code> 相对于 <code>φ(N)</code> 模逆的关系。</p><blockquote><p><code>e*d ≡ 1(mod φ(N))</code> 是一个同余方程，描述的是 <code>e</code> 和 <code>d</code> 在模 <code>φ(N)</code> 下的乘积同余于 1。</p><p>在数学中，”同余”是一种等价关系，a 和 b “模 m 同余”，如果它们除以 m 得到的余数相同。在此处的上下文中，这意味着当你将 e*d 除以 φ(N)，得到的余数是 1。<br>这个关系确保了公钥（N，e）和私钥（N，d）彼此互逆。即，如果你使用公钥加密消息 m，得到 <code>c=m^e (mod N)</code>，那么你可以用私钥解密消息 c，得到 <code>m=c^d (mod N)</code>，反之亦然。<br>这样设计的原因在于，如果第三方只知道公钥（N，e），他们无法计算出相应的私钥 d，除非他们能因数分解 N，这在实际中是非常困难的，使得这一加密系统具有很高的安全性。</p><p>N 只是公钥和私钥共有的模数而已，它是两个大质数的乘积。要推导出私钥，除了需要知道 N 值外，还需要知道这两个质数，然而，当 N 是一个足够大的数时，要分解 N，找到这两个质数，基本上是不可能的（对于一个 N 值，有且只有一对质数的乘积等于 N）。</p><p>2048 位的 RSA 密钥中的 N 值，是由两个 1024 位的质数相乘得到的，所以它的长度大约在 616 到 617 位之间。在十进制下，它的值大约在 2 的 2048 次方到 2 的 2049 次方之间，即大约在 10 的 617 次方到 10 的 618 次方之间，这是一个非常非常大的数。</p></blockquote><h4 id="RSA-示例"><a href="#RSA-示例" class="headerlink" title="RSA 示例"></a>RSA 示例</h4><p>使用 OpenSSL 命令行工具，你可以执行 RSA 数字签名和验证操作。下面是一个示例，演示如何生成 RSA 密钥对，使用私钥对文件进行数字签名，然后使用公钥验证签名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成私钥</span></span><br><span class="line">openssl genrsa -out private.pem 2048</span><br><span class="line"><span class="comment"># 从私钥中提取公钥</span></span><br><span class="line">openssl rsa -<span class="keyword">in</span> private.pem -pubout -out public.pem</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 123456789 &gt; test.txt</span><br><span class="line"><span class="comment"># 使用私钥对文件进行签名</span></span><br><span class="line">openssl dgst -sha256 -sign private.pem -out signature.bin test.txt</span><br><span class="line"><span class="comment"># 使用公钥验证签名</span></span><br><span class="line">openssl dgst -sha256 -verify public.pem -signature signature.bin test.txt</span><br><span class="line"><span class="comment">## 输出 Verified OK</span></span><br></pre></td></tr></table></figure><p>在这个示例中：</p><ul><li><code>private.pem</code>是生成的私钥文件</li><li><code>public.pem</code>是从私钥中提取的公钥文件</li><li><code>test.txt</code>是要签名和验证的文件</li><li><code>signature.bin</code>是使用私钥对文件生成的签名文件</li></ul><p>下面是一个 python 示例，签名的流程和 <code>fipsign.py</code> 中类似。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Signature <span class="keyword">import</span> pkcs1_15</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"><span class="keyword">from</span> Crypto <span class="keyword">import</span> Random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 RSA 密钥对</span></span><br><span class="line">random_generator = Random.new().read</span><br><span class="line">key = RSA.generate(<span class="number">2048</span>, random_generator)</span><br><span class="line">public_key = key.publickey()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 原始数据</span></span><br><span class="line">message = <span class="string">b&quot;This is a test message.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算哈希值</span></span><br><span class="line">h = SHA256.new(message)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用私钥对原始数据的哈希值进行签名</span></span><br><span class="line">signature = pkcs1_15.new(key).sign(h)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用公钥验证签名</span></span><br><span class="line">verifier = pkcs1_15.new(public_key)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    verifier.verify(h, signature)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The signature is valid.&quot;</span>)</span><br><span class="line"><span class="keyword">except</span> (ValueError, TypeError):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The signature is not valid.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：在真实应用中，你不应该直接在代码中硬编码密钥，而应该使用安全的方式来存储和访问它们。</span></span><br></pre></td></tr></table></figure><p><strong>问题：为什么要先hash，再对hash 进行签名？</strong></p><p>在数字签名中，通常先对消息进行哈希（hashing），然后再对哈希值进行签名，而不是直接对原始消息进行签名。这样做有几个重要的原因：</p><ol><li><p><strong>性能</strong>：哈希函数比签名算法快得多。哈希函数可以将任意长度的数据压缩成一个固定长度的哈希值，而签名算法则需要对整个消息（或哈希值）进行复杂的数学运算。由于哈希函数的快速性，即使对于非常大的消息，也可以快速生成哈希值，然后再对哈希值进行签名，从而大大<strong>提高了签名的效率</strong>。</p></li><li><p><strong>安全性</strong>：哈希函数被设计为具有“雪崩效应”（avalanche effect），这意味着即使原始消息中只有一个微小的变化，也会导致哈希值发生显著的变化。这种性质使得哈希值对篡改非常敏感。如果直接对原始消息进行签名，那么任何对消息的微小篡改都可能需要重新进行整个签名过程，这既耗时又容易暴露给攻击者更多的信息。通过对哈希值进行签名，可以确保即使原始消息被篡改，签名也会立即失效，从而<strong>提高了安全性</strong>。</p></li><li><p><strong>可验证性</strong>：哈希函数是单向的，这意味着从哈希值不能恢复出原始消息（或者说恢复原始消息是非常困难的）。但是，给定相同的消息，任何人都可以计算出相同的哈希值。因此，当接收者收到一个签名和相应的消息时，他们可以自己计算消息的哈希值，并使用签名者的公钥来验证签名是否有效。这种方式允许任何人验证签名的真实性，而不需要与签名者进行通信或交换任何额外的信息。</p></li><li><p><strong>签名长度</strong>：<strong>直接对长消息进行签名可能会导致生成的签名非常长</strong>，从而增加了存储和传输的负担。通过对哈希值进行签名，可以确保签名长度始终固定且相对较短，这有利于节省空间和带宽。</p></li></ol><p>综上所述，先对消息进行哈希，再对哈希值进行签名是一种常见的做法，它结合了哈希函数和签名算法的优点，提供了高效、安全和可验证的数字签名方案。</p><h3 id="启动流程简介"><a href="#启动流程简介" class="headerlink" title="启动流程简介"></a>启动流程简介</h3><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/image-20230913160851943.png" alt="image-20230913160851943"></p><p>我们使用的是第三个，<strong>一个完整的启动流程</strong>为：由板端固定的 <code>ROM</code> 中的代码（<code>ZSBL</code>）初始化环境后，调用 <code>FSBL</code>，然后 <code>FSBL</code> 调用 <code>OpenSBI</code>，进而调用 <code>U-Boot</code>，由 <code>U-Boot</code> 来启动内核。<strong>烧录流程</strong>（<code>update</code>）只是没有 <code>U-Boot</code> 来启动内核这一步骤。</p><blockquote><p>到 <code>uboot</code> 之后，就主要是由 <code>CONFIG_BOOTCOMMAND</code> 来控制后续操作，可以看到先尝试显示 <code>LOGO</code>，然后检测是否需要升级，<code>cvi_update</code> 它会检查是否有 <code>SD</code> 卡中有没有 <code>fip.bin</code> 或 <code>USB</code> 升级。这里使用的是 <code>||</code> ，就意味着前面执行成功，就不会执行后续的。升级之后，不会自动进入内核就是这个原因。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// u-boot-2021.10/include/configs/cv181x-asic.h:302</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTCOMMAND    SHOWLOGOCMD <span class="string">&quot;cvi_update || run norboot || run nandboot || run emmcboot&quot;</span></span></span><br></pre></td></tr></table></figure></blockquote><p>整个启动流程我们用到的硬件存储设备有：<code>eFuse</code>、<code>flash(nor/emmc/nand)</code>、<code>SD</code>、<code>ddr</code> 这 4 个。</p><h4 id="编译流程"><a href="#编译流程" class="headerlink" title="编译流程"></a>编译流程</h4><p>这里只关注会生成哪些文件，以及每个文件对应的模块。</p><table><thead><tr><th>模块</th><th>生成文件</th></tr></thead><tbody><tr><td>fsbl</td><td>bl2.bin，编译 fsbl 之后会创建 fip.bin （该文件打包了 bl2.bin fw_dynamic.bin u-boot-raw.bin）</td></tr><tr><td>opensbi</td><td>fw_dynamic.bin</td></tr><tr><td>uboot</td><td>u-boot-raw.bin</td></tr><tr><td>kernel</td><td>boot.spinor</td></tr><tr><td>ramdisk</td><td>rootfs.spinor</td></tr></tbody></table><h4 id="烧录流程"><a href="#烧录流程" class="headerlink" title="烧录流程"></a>烧录流程</h4><p>先说升级（烧录流程），它的作用就是将 <code>opensbi</code>、<code>uboot</code>、<code>kernel</code> 等二进制文件烧录到 <code>flash</code> 上，每个文件在 <code>flash</code> 上的写入地址都是通过文件 <code>partition.xml</code> 指定，如：</p><blockquote><p>不是指定写入地址，而是指定文件的大小，他们在 <code>flash</code> 上紧挨着排列，比如第 <code>0-1024</code>存储着 <code>fip.bin</code>，<code>1024-4096</code> 存储着 <code>boot.spinor</code>。即使 <code>fip.bin</code> 的实际大小没有 1024，<code>boot.spinor</code> 仍然是从第 1024 开始。<strong>要注意 <code>flash</code> 的大小限制，不要超出了 <code>flash</code> 的大小</strong>。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">physical_partition</span> <span class="attr">type</span>=<span class="string">&quot;spinor&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">partition</span> <span class="attr">label</span>=<span class="string">&quot;fip&quot;</span> <span class="attr">size_in_kb</span>=<span class="string">&quot;1024&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;false&quot;</span> <span class="attr">file</span>=<span class="string">&quot;fip.bin&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">partition</span> <span class="attr">label</span>=<span class="string">&quot;BOOT&quot;</span> <span class="attr">size_in_kb</span>=<span class="string">&quot;3072&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;false&quot;</span> <span class="attr">file</span>=<span class="string">&quot;boot.spinor&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">partition</span> <span class="attr">label</span>=<span class="string">&quot;APPCFG&quot;</span> <span class="attr">size_in_kb</span>=<span class="string">&quot;64&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;false&quot;</span> <span class="attr">file</span>=<span class="string">&quot;app_cfg.bin&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">partition</span> <span class="attr">label</span>=<span class="string">&quot;APPCFGDEF&quot;</span> <span class="attr">size_in_kb</span>=<span class="string">&quot;64&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;false&quot;</span> <span class="attr">file</span>=<span class="string">&quot;app_cfg_def.bin&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">partition</span> <span class="attr">label</span>=<span class="string">&quot;sig&quot;</span> <span class="attr">size_in_kb</span>=<span class="string">&quot;64&quot;</span> <span class="attr">file</span>=<span class="string">&quot;sig.bin&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">partition</span> <span class="attr">label</span>=<span class="string">&quot;ENV&quot;</span> <span class="attr">size_in_kb</span>=<span class="string">&quot;64&quot;</span> <span class="attr">file</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">partition</span> <span class="attr">label</span>=<span class="string">&quot;ENV_BAK&quot;</span> <span class="attr">size_in_kb</span>=<span class="string">&quot;64&quot;</span> <span class="attr">file</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">partition</span> <span class="attr">label</span>=<span class="string">&quot;ROOTFS&quot;</span> <span class="attr">size_in_kb</span>=<span class="string">&quot;8192&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;false&quot;</span> <span class="attr">file</span>=<span class="string">&quot;rootfs.spinor&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">partition</span> <span class="attr">label</span>=<span class="string">&quot;MISC&quot;</span> <span class="attr">size_in_kb</span>=<span class="string">&quot;512&quot;</span> <span class="attr">file</span>=<span class="string">&quot;logo.jpg&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">partition</span> <span class="attr">label</span>=<span class="string">&quot;DATA&quot;</span>  <span class="attr">readonly</span>=<span class="string">&quot;false&quot;</span> <span class="attr">file</span>=<span class="string">&quot;&quot;</span> <span class="attr">mountpoint</span>=<span class="string">&quot;/mnt/data&quot;</span> <span class="attr">type</span>=<span class="string">&quot;jffs2&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">physical_partition</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>写 <code>partition</code> 时还要注意对齐问题，这个与 <code>flash</code> 有关，比如在 <code>1812h_nand</code> 使用的 <code>flash</code> 是 <code>W25N02KVxxIR/U</code>，查看其数据手册可以看到，最小的块应该是 <code>128KB</code>，如果仍然将 <code>sig.bin</code> 的大小设置为 <code>size_in_kb=&quot;64&quot;</code> ，烧录的时候就会报错！</p><p>另外，也要注意 <code>parititon</code> 中的大小要和 <code>cv181x-asic.h</code> 中设置的 <code>CONFIG_NANDBOOTCOMMAND</code> 中一致。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flexible Architecture with 128KB blocks</span><br><span class="line">– Uniform 128K-Byte Block Erase</span><br><span class="line">– Flexible page data load methods</span><br></pre></td></tr></table></figure></blockquote><p>由于 <code>fw_dynamic.bin u-boot-raw.bin</code> 放入了 <code>fip.bin</code> 文件中，因此，我们进行 <code>update</code> 的时候只需要准备 3 个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fip.bin</span><br><span class="line">boot.spinor</span><br><span class="line">rootfs.spinor</span><br></pre></td></tr></table></figure><p>虽然 <code>upgrade.zip</code> 解压后，能看到 <code>partition.xml</code> ，不过这玩意可以不要，因为编译过程中，已经从该文件生成了分区的 <code>.h</code> 头文件嵌入到的代码中，实际烧录时并不会用到。</p><p>另外，由于 <code>partition</code> 的分区划分，不同区域固定起始地址并且不会重叠，因此升级过程中，我们也可以只烧录一部分，比如与上一次烧录相比，只有 <code>u-boot</code> 发生了变化，那么我们的 <code>SD</code> 卡中只需要准备 <code>fip.bin</code> 就行。如果 <code>kernel</code> 发生了变化，就需要 <code>fip.bin</code> 和 <code>boot.spinor</code>，避免重复烧录 <code>rootfs.spinor</code> 可以加快一点点效率。</p><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/sd%E5%8D%A1%E5%8D%87%E7%BA%A7.png" alt="sd 卡升级"></p><p>升级流程为：</p><ol><li><code>rom</code> 中 <code>bl1</code> 代码将 <code>bld.bin</code>（<code>BL2</code> 代码）搬移到 <code>SRAM</code> 中；</li><li>执行 <code>BL2</code> 代码，初始化 <code>ddr</code>，将 <code>bldp.bin</code> 和 <code>u-boot.bin</code> 搬移到 <code>ddr</code> 中；</li><li>执行 <code>bldp.bin</code>（<code>BL31</code> 代码）；</li><li>执行 <code>uboot（BL33）</code>代码，将 <code>boot.xxx</code>、<code>rootfs.xxx</code>、<code>fip.bin</code> 拷贝到 <code>spinor(nand/emmc)</code>（中间需要经过 <code>ddr</code>，上图中没有展示该过程）；</li><li>继续执行 <code>uboot</code> 代码，将 <code>boot.xxx</code> 从 <code>spinor(nand/emmc)</code> 读入 <code>ddr</code>，开始启动 <code>kernel</code>；</li></ol><p><strong>4、5 两步由 <code>uboot</code> 下 <code>cvi_update</code> 和 <code> run norboot/nandboot/emmcboot</code> 指令完成</strong>，具体来说，<code>cvi_update</code> 主要完成的事情有：</p><ol><li>从升级的源头上拷贝 <code>boot.xxx、rootfs.xxx、fip.bin</code> 到 <code>ddr</code>；（这里源头可以是 <code>uart</code>、<code>sd</code> 卡、<code>usb</code> 甚至是 <code>ethernet</code>）</li><li>将以上文件写入存储介质（<code>spinor、spinand、emmc</code>）；后续就可以直接从 <code>flash</code> 启动。</li></ol><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>启动流程的前三级 <code>fsbl, opensbi, uboot</code> 和烧录流程是一致的，只有到 <code>uboot</code> 这里执行的内容不同。</p><p>再说启动流程，在 <code>uboot</code> 启动内核时，<code>nor flash</code> 与 <code>emmc/nand</code> 有点区别，因为 <code>nor</code> 可以直接运行代码，而 <code>emmc/nand</code> 需要先将 <code>kernel</code> 从 <code>flash</code> 中加载到 <code>ddr</code>，然后再运行。不过，下面我们使用安全启动时，由于需要校验 <code>kernel</code> 的签名，所以即使是 <code>nor</code> 也需要将 <code>kernel</code> 加载到 <code>ddr</code>。</p><h3 id="签名加密流程介绍"><a href="#签名加密流程介绍" class="headerlink" title="签名加密流程介绍"></a>签名加密流程介绍</h3><p>从上面的烧录流程可以看到，前期到 <code>uboot</code> 运行阶段都与 <code>fip.bin</code> 有关，因此首先我们要保证 <code>fip.bin</code> 的安全性，要保证它不被篡改。不过这里并没有采用直接对 <code>fip.bin</code> 这整个文件进行加密，而是对 <code>fip.bin</code> 中每个小模块逐个加密、签名。一个 <code>fip.bin</code> 文件的构成如下图所示：</p><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/image1.jpg" alt="_images/image1.jpg"></p><p>主要也就是前面说的 <code>fsbl, opensbi, u-boot</code>，不过还额外增加了各级的签名（可选的）。生成 <code>fip.bin</code> 的脚本是<code>fsbl/plat/cv181x/ fiptool.py </code>，对 <code>fip.bin</code> 进行签名和加密的脚本也在该目录下。</p><blockquote><p>具体的 <code>fip</code> 构成可以看 <code>fsbl/plat/cv181x/fiptool.py:143</code> <code>FIP</code> 这个类的定义，<code>FIP</code> 就是按这里定义的顺序，由五个部分组成：<code>param1, body1, param2, body2, ldr_2nd_hdr</code>。下面是生成 <code>fip</code> 的编译日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">fsbl/plat/cv181x/fiptool.py -v genfip \</span><br><span class="line">        <span class="string">&#x27;/data/song.yu/cvi_mmf_sdk-intl/fsbl/build/cv1811h_wevb_0007a_spinor/fip.bin&#x27;</span> \</span><br><span class="line">        --MONITOR_RUNADDR=<span class="string">&quot;<span class="variable">$&#123;MONITOR_RUNADDR&#125;</span>&quot;</span> \</span><br><span class="line">        --BLCP_2ND_RUNADDR=<span class="string">&quot;<span class="variable">$&#123;BLCP_2ND_RUNADDR&#125;</span>&quot;</span> \</span><br><span class="line">        --CHIP_CONF=<span class="string">&#x27;/data/song.yu/cvi_mmf_sdk-intl/fsbl/build/cv1811h_wevb_0007a_spinor/chip_conf.bin&#x27;</span> \</span><br><span class="line">        --NOR_INFO=<span class="string">&#x27;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF&#x27;</span> \</span><br><span class="line">        --NAND_INFO=<span class="string">&#x27;00000000&#x27;</span>\</span><br><span class="line">        --BL2=<span class="string">&#x27;/data/song.yu/cvi_mmf_sdk-intl/fsbl/build/cv1811h_wevb_0007a_spinor/bl2.bin&#x27;</span> \</span><br><span class="line">        --BLCP_IMG_RUNADDR=0x05200200 \</span><br><span class="line">        --BLCP_PARAM_LOADADDR=0 \</span><br><span class="line">        --BLCP=<span class="built_in">test</span>/empty.bin \</span><br><span class="line">        --DDR_PARAM=<span class="string">&#x27;test/cv181x/ddr_param.bin&#x27;</span> \</span><br><span class="line">        --BLCP_2ND=<span class="string">&#x27;/data/song.yu/cvi_mmf_sdk-intl/freertos/cvitek/install/bin/cvirtos.bin&#x27;</span> \</span><br><span class="line">        --MONITOR=<span class="string">&#x27;../opensbi/build/platform/generic/firmware/fw_dynamic.bin&#x27;</span> \</span><br><span class="line">        --LOADER_2ND=<span class="string">&#x27;/data/song.yu/cvi_mmf_sdk-intl/u-boot-2021.10/build/cv1811h_wevb_0007a_spinor/u-boot-raw.bin&#x27;</span> \</span><br><span class="line">        --compress=<span class="string">&#x27;lzma&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="准备秘钥"><a href="#准备秘钥" class="headerlink" title="准备秘钥"></a>准备秘钥</h4><p>首先我们需要准备好秘钥，从秘钥的后缀可以看出其类型，<code>.key</code> 为 <code>AES</code> 加密使用的，<code>.pem</code> 为 <code>RSA</code> 算法使用的。</p><table><thead><tr><th>文件</th><th>作用</th><th>使用位置</th></tr></thead><tbody><tr><td>rsa_hash0.pem</td><td>用于给 <code>bl_priv.pem</code> 签名的 <code>RSA</code> 私钥，公钥（的 <code>hash</code> 值）被烧到 <code>HASH0_PUBLIC</code></td><td><code>rom code</code></td></tr><tr><td>bl_priv.pem</td><td>用于给 <code>fsbl/opensbi/u-boot</code> 生成签名的 <code>RSA</code> 私钥</td><td><code>fsbl</code></td></tr><tr><td>loader_ek.key</td><td>用于给 <code>bl_ek.key</code> 加、解密的 <code>AES</code> 秘钥，也会被烧写到 <code>eFuse</code></td><td><code>rom code</code></td></tr><tr><td>bl_ek.key</td><td>用于给 <code>fsbl/opensbi/u-boot</code> 加、解密的 <code>AES</code> 秘钥</td><td><code>fsbl</code></td></tr></tbody></table><p><code>RSA</code> 密钥使用 <code>2048 bits</code> 和第 4 费马数，<strong>用于签名</strong>：</p><blockquote><p><strong>虽然这里说“签名”，<del>但和前面所说的“消息摘要”并不是一个概念，需要注意</del>！🙄🙄是一个概念，但签名会用到私钥，而不仅仅是直接使用 sha256 算法之类的。</strong>私钥签名，公钥验证。</p><p><code>PKCS#1 v1.5</code> 是一种公钥密码学标准，用于数字签名和验证消息的完整性。它通常与 <code>RSA</code> 密钥对一起使用。</p><ol><li><strong>数字签名</strong>：签名过程会使用<strong>私钥</strong>生成一个与消息相关联的<strong>数字签名</strong>，以便在以后验证消息的完整性和真实性。</li><li><strong>数字签名验证</strong>：验证过程会使用与签名相关的<strong>公钥</strong>来验证消息的完整性，以确保消息没有被篡改，并且确实是由私钥持有者签名的。</li></ol></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host$ openssl genrsa -out rsa_hash0.pem -F4 2048</span><br><span class="line">host$ openssl genrsa -out bl_priv.pem -F4 2048</span><br></pre></td></tr></table></figure><blockquote><p>为什么这里两个 <code>rsa</code> 秘钥都是私钥❓公钥在哪呢❓</p><p>答：<code>RSA</code> 算法的私钥中实际上包含了公钥的一部分信息，具体来说，包括了<strong>模数</strong>和<strong>公钥指数</strong>，通过这两个参数就可以推出公钥😮。不过公钥是无法推出私钥的，这是 <code>rsa</code> 算法的安全保障。</p></blockquote><p><code>AES</code> 的秘钥<strong>使用长度 16 的随机数</strong>（<code>AES-128</code>），<strong>用于加密</strong>：（只签名不加密就用不到这个）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host$ <span class="built_in">head</span> -c 16 /dev/random &gt; loader_ek.key</span><br><span class="line">host$ <span class="built_in">head</span> -c 16 /dev/random &gt; bl_ek.key</span><br></pre></td></tr></table></figure><h4 id="fip-组成结构"><a href="#fip-组成结构" class="headerlink" title="fip 组成结构"></a>fip 组成结构</h4><p>这里得看一下 <code>fip.bin</code> 的构成，在 <code>fsbl/plat/cv181x/fiptool.py:143</code> 中定义，下面有省略：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FIP</span>:</span><br><span class="line">    <span class="comment"># FIP 就是按这里定义的顺序：param1, body1, param2, body2, ldr_2nd_hdr</span></span><br><span class="line">    param1 = OrderedDict(</span><br><span class="line">        [</span><br><span class="line">            Entry.make(<span class="string">&quot;MAGIC1&quot;</span>, <span class="number">8</span>, <span class="built_in">int</span>, <span class="string">b&quot;CVBL01\n\0&quot;</span>),</span><br><span class="line">            Entry.make(<span class="string">&quot;MAGIC2&quot;</span>, <span class="number">4</span>, <span class="built_in">int</span>),</span><br><span class="line">            Entry.make(<span class="string">&quot;BL2_IMG_CKSUM&quot;</span>, <span class="number">4</span>, <span class="built_in">int</span>),</span><br><span class="line">            Entry.make(<span class="string">&quot;BL2_IMG_SIZE&quot;</span>, <span class="number">4</span>, <span class="built_in">int</span>),</span><br><span class="line">            Entry.make(<span class="string">&quot;BLD_IMG_SIZE&quot;</span>, <span class="number">4</span>, <span class="built_in">int</span>),</span><br><span class="line">            Entry.make(<span class="string">&quot;BL_EK&quot;</span>, <span class="number">32</span>, <span class="built_in">bytes</span>),             <span class="comment"># 存储 bl_ek ？</span></span><br><span class="line">            Entry.make(<span class="string">&quot;ROOT_PK&quot;</span>, <span class="number">512</span>, <span class="built_in">bytes</span>),          <span class="comment"># 存储 rsa_hash0.pem ? 512 字节只是最大长度吧</span></span><br><span class="line">            Entry.make(<span class="string">&quot;BL_PK&quot;</span>, <span class="number">512</span>, <span class="built_in">bytes</span>),            <span class="comment"># 存储 bl_priv.pem ?</span></span><br><span class="line">            Entry.make(<span class="string">&quot;BL_PK_SIG&quot;</span>, <span class="number">512</span>, <span class="built_in">bytes</span>),        <span class="comment"># 存储 bl_priv.pem 的签名</span></span><br><span class="line">            Entry.make(<span class="string">&quot;CHIP_CONF_SIG&quot;</span>, <span class="number">512</span>, <span class="built_in">bytes</span>),</span><br><span class="line">            Entry.make(<span class="string">&quot;BL2_IMG_SIG&quot;</span>, <span class="number">512</span>, <span class="built_in">bytes</span>),      <span class="comment"># 存储 bl2(fsbl) 镜像的签名</span></span><br><span class="line">            Entry.make(<span class="string">&quot;BLCP_IMG_SIG&quot;</span>, <span class="number">512</span>, <span class="built_in">bytes</span>),     <span class="comment"># 存储 blcp 镜像的签名</span></span><br><span class="line">        ]</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    body1 = OrderedDict(</span><br><span class="line">        [</span><br><span class="line">            Entry.make(<span class="string">&quot;BLCP&quot;</span>, <span class="literal">None</span>, <span class="built_in">bytes</span>),            <span class="comment"># 填充 blcp</span></span><br><span class="line">            Entry.make(<span class="string">&quot;BL2&quot;</span>, <span class="literal">None</span>, <span class="built_in">bytes</span>),             <span class="comment"># 填充 bl2</span></span><br><span class="line">        ]</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>param1</code> 中存储着 <code>BL2</code> （也就是 <code>fsbl</code> 镜像）的签名。从 <code>fsbl/plat/cv181x/fipsign.py:sign</code> 中可以看到具体的赋值过程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 签名的主函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sign</span>(<span class="params">self</span>):</span><br><span class="line">    logging.info(<span class="string">&quot;sign fip.bin&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 处理 fip 的 param1 部分</span></span><br><span class="line">    self.param1[<span class="string">&quot;FIP_FLAGS&quot;</span>].content = self.FIP_FLAGS_SCS_MASK | self.param1[<span class="string">&quot;FIP_FLAGS&quot;</span>].toint()</span><br><span class="line">    self.sign_bl_pk()</span><br><span class="line">    cc = self.param1[<span class="string">&quot;CHIP_CONF&quot;</span>].content</span><br><span class="line">    cc_size = unpack(<span class="string">&quot;&lt;I&quot;</span>, self.param1[<span class="string">&quot;CHIP_CONF_SIZE&quot;</span>].content)[<span class="number">0</span>]</span><br><span class="line">    logging.debug(<span class="string">&quot;CHIP_CONF_SIZE=%#x&quot;</span>, cc_size)</span><br><span class="line">    cc = cc[:cc_size]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主要关注这里 3 个 sign_by_bl_priv</span></span><br><span class="line">    self.param1[<span class="string">&quot;CHIP_CONF_SIG&quot;</span>].content = self.sign_by_bl_priv(cc)</span><br><span class="line">    self.param1[<span class="string">&quot;BL2_IMG_SIG&quot;</span>].content = self.sign_by_bl_priv(self.body1[<span class="string">&quot;BL2&quot;</span>].content)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.body1[<span class="string">&quot;BLCP&quot;</span>].content:</span><br><span class="line">        logging.debug(<span class="string">&quot;sign blcp&quot;</span>)</span><br><span class="line">        self.param1[<span class="string">&quot;BLCP_IMG_SIG&quot;</span>].content = self.sign_by_bl_priv(self.body1[<span class="string">&quot;BLCP&quot;</span>].content)</span><br><span class="line"></span><br><span class="line">    self.sign_fip2()</span><br></pre></td></tr></table></figure><p>主要关注这里 3 个 <code>sign_by_bl_priv</code>，将 <code>BL2</code> 镜像通过 <code>bl_priv.pem</code> 私钥进行签名，然后将签名结果放在 <code>param1[&quot;BL2_IMG_SIG&quot;]</code>。板端通过写在 <code>efuse</code> 的公钥，对 <code>BL2</code> 又计算一次签名，和 <code>fip</code> 中的签名对比，如果一致则说明该 <code>fip</code> 确实是私钥持有者提供的。</p><p>上面只是对 <code>bl2</code> 进行了签名，<code>FIP</code> 的后半部分还有 <code>opensbi</code>， <code>uboot</code>（同样有省略）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">param2 = OrderedDict(</span><br><span class="line">    [</span><br><span class="line">        Entry.make(<span class="string">&quot;MAGIC1&quot;</span>, <span class="number">8</span>, <span class="built_in">int</span>, <span class="string">b&quot;CVLD02\n\0&quot;</span>),</span><br><span class="line">        Entry.make(<span class="string">&quot;MONITOR_CKSUM&quot;</span>, <span class="number">4</span>, <span class="built_in">int</span>),                <span class="comment"># ATF-BL31 or OpenSBI</span></span><br><span class="line">        Entry.make(<span class="string">&quot;MONITOR_LOADADDR&quot;</span>, <span class="number">4</span>, <span class="built_in">int</span>),</span><br><span class="line">        Entry.make(<span class="string">&quot;LOADER_2ND_RESERVED0&quot;</span>, <span class="number">4</span>, <span class="built_in">int</span>),         <span class="comment"># uboot</span></span><br><span class="line">        Entry.make(<span class="string">&quot;LOADER_2ND_LOADADDR&quot;</span>, <span class="number">4</span>, <span class="built_in">int</span>),          <span class="comment"># Reserved</span></span><br><span class="line">        Entry.make(<span class="string">&quot;RESERVED_LAST&quot;</span>, <span class="number">4096</span> - <span class="number">16</span> * <span class="number">5</span>, <span class="built_in">bytes</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">body2 = OrderedDict(</span><br><span class="line">    [</span><br><span class="line">        Entry.make(<span class="string">&quot;MONITOR&quot;</span>, <span class="literal">None</span>, <span class="built_in">bytes</span>),     <span class="comment"># 填充 opensbi 镜像</span></span><br><span class="line">        Entry.make(<span class="string">&quot;LOADER_2ND&quot;</span>, <span class="literal">None</span>, <span class="built_in">bytes</span>),  <span class="comment"># 填充 uboot 镜像</span></span><br><span class="line">    ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ldr_2nd_hdr = OrderedDict(</span><br><span class="line">    [</span><br><span class="line">        Entry.make(<span class="string">&quot;MAGIC&quot;</span>, <span class="number">4</span>, <span class="built_in">int</span>),</span><br><span class="line">        Entry.make(<span class="string">&quot;CKSUM&quot;</span>, <span class="number">4</span>, <span class="built_in">int</span>),</span><br><span class="line">        Entry.make(<span class="string">&quot;SIZE&quot;</span>, <span class="number">4</span>, <span class="built_in">int</span>),</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>与 <code>param1</code> 不同，这里 <code>param2</code> 中并没有成员专门记录 <code>uboot</code> 的签名，而是直接放在了镜像的末尾，而且也没有对 <code>opensbi</code> 进行签名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">e = self.body2[<span class="string">&quot;LOADER_2ND&quot;</span>] <span class="comment"># e 就是 uboot 的镜像</span></span><br><span class="line"><span class="comment"># 在末尾预留签名的空间，再填充 \0 按 IMAGE_ALIGN 对齐</span></span><br><span class="line">e.content = self.pad(e.content + <span class="string">b&quot;\xCE&quot;</span> * sig_size, IMAGE_ALIGN)</span><br><span class="line"><span class="comment"># SIZE is after CKSUM, update it before signing</span></span><br><span class="line">self._update_ldr_2nd_hdr()</span><br><span class="line"></span><br><span class="line">image = <span class="built_in">bytearray</span>(e.content)</span><br><span class="line"><span class="comment"># 计算签名，不包含最后预留给存储”签名“的内容。</span></span><br><span class="line">sig = self.sign_by_bl_priv(image[self.ldr_2nd_hdr[<span class="string">&quot;CKSUM&quot;</span>].end : -sig_size])</span><br><span class="line"><span class="keyword">assert</span> sig_size == <span class="built_in">len</span>(sig)</span><br><span class="line">image[-sig_size:] = sig</span><br><span class="line"></span><br><span class="line">e.content = image</span><br></pre></td></tr></table></figure><h4 id="efuse-介绍"><a href="#efuse-介绍" class="headerlink" title="efuse 介绍"></a>efuse 介绍</h4><p><code>eFuse</code> 也就是<strong>可编程电子熔丝</strong>，简单来说，它存储的数据只能写 <code>1</code> 不能写 <code>0</code>，最初全为 0，一旦写入就无法更改。具有以下主要特点：</p><ol><li><strong>不可逆性</strong>：一旦配置，<code>eFuse</code> 通常无法被擦除或重置。这意味着一旦信息被写入 <code>eFuse</code>，它将永久存储在其中，不能再次修改或清除。这种不可逆性增强了存储在 <code>eFuse</code> 中的信息的安全性。（不可擦除）</li><li><strong>电气可编程</strong>：<code>eFuse</code> 可以通过电气编程方式进行配置，而不需要使用额外的设备或工具。这种可编程性使得它在制造过程中或设备的生命周期中可以根据需要进行配置。（可写入）</li><li><strong>高可靠性</strong>：<code>eFuse</code> 通常具有高度的可靠性和稳定性，可以在广泛的温度范围和环境条件下正常工作。这使得它适用于各种应用，包括极端环境下的用途。</li><li><strong>物理安全</strong>：<code>eFuse</code> <strong>通常集成在芯片内部</strong>，难以物理上访问或破坏。这增强了存储在其中的敏感信息的物理安全性，防止了硬件级别的攻击。</li></ol><p><code>eFuse</code> 的上述特点，很适合用来存储板端的秘钥。</p><h4 id="fip-签名流程"><a href="#fip-签名流程" class="headerlink" title="fip 签名流程"></a>fip 签名流程</h4><blockquote><p>直接使用 <code>fipsign.py</code> 这个脚本，<code>fip.bin</code> 为原始镜像，<code>fip_sign.bin</code> 为签名后的镜像。注意这里仅使用了 <code>RSA</code> 秘钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./fipsign.py sign \</span><br><span class="line">      --root-priv=rsa_hash0.pem \</span><br><span class="line">      --bl-priv=bl_priv.pem \</span><br><span class="line">      fip.bin fip_sign.bin</span><br></pre></td></tr></table></figure></blockquote><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8.drawio.png" alt="安全启动.drawio"></p><blockquote><p>图中 <code>PK</code> 表示公钥的 <code>N</code> 值，<code>_SIG/sign</code> 表示数字签名。</p></blockquote><ol><li><p>修改 <code>FIP_FLAGS</code> 表明这个 <code>fip.bin</code> 中有签名，需要验证。</p></li><li><p>从私钥 <code>rsa_hash0.pem</code> 中提取 <code>N</code> 值并写到 <code>fip.bin</code> 中，该 <code>N</code> 值和 <code>rom</code> 中固化的 <code>E=0x10001</code> 可组成公钥，用于签名验证。</p></li><li><p><code>N</code> 值的 <code>sha256</code> 散列值会被写入到 <code>efuse</code> 的 <code>LOCK_HASH0_PUBLIC </code>，验证时先计算 <code>fip.bin</code> 中的 <code>N</code> 值的散列值，与 <code>efuse</code> 中存储的散列值比较，来确认 <code>N</code> 值（或者说公钥）是否与最初的一致。</p></li><li><p>提取 <code>bl_priv.pem</code> 的 <code>N</code> 值写入到 <code>fip.bin</code> 中。</p></li><li><p>计算 <code>bl_priv.pem</code> 的 <code>N</code> 值的数字签名，并写入到 <code>fip.bin</code> 中。该签名是通过 <code>rsa_hash0.pem</code> 这个私钥计算 ，可用 <code>rsa_hash0.pem</code> 的公钥验证。</p><blockquote><p>实际是 <code>bl_priv.pem</code> 的 <code>N</code> 值的 SHA256 散列值的数字签名，这里简单点说方便理解。</p></blockquote></li><li><p>计算 <code>bl2.bin(fsbl)</code> 的数字签名，该签名通过 <code>bl_priv.pem</code> 这个私钥计算，用 <code>BL_PK</code> 验证。</p></li><li><p>计算 <code>fw_dynamic.bin(opensbi)</code> 的数字签名，该签名通过 <code>bl_priv.pem</code> 这个私钥计算，用 <code>BL_PK</code> 验证。</p></li><li><p>计算 <code>u-boot-raw.bin(uboot)</code> 的数字签名，该签名通过 <code>bl_priv.pem</code> 这个私钥计算，用 <code>BL_PK</code> 验证。</p></li></ol><h4 id="fip-签名-加密流程"><a href="#fip-签名-加密流程" class="headerlink" title="fip 签名+加密流程"></a>fip 签名+加密流程</h4><blockquote><p>直接使用 <code>fipsign.py</code> 这个脚本，<code>fip.bin</code> 为原始镜像，<code>fip_enc.bin</code> 为签名+加密后的镜像。这里使用了 <code>RSA</code> 和 <code>AES</code> 秘钥。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./fipsign.py sign-enc \</span><br><span class="line">         --root-priv=rsa_hash0.pem \</span><br><span class="line">         --bl-priv=bl_priv.pem \</span><br><span class="line">         --ldr-ek=loader_ek.key \</span><br><span class="line">         --bl-ek=bl_ek.key \</span><br><span class="line">         fip.bin fip_enc.bin</span><br></pre></td></tr></table></figure></blockquote><p><code>fip</code> 的签名并加密也就是在上面签名的基础上，再对各个 <code>bin</code> 文件进行加密。加密主要依赖两个 <code>AES</code> 秘钥，<code>loader_ek</code> 和 <code>bl_ek</code>。前者会被写入 <code>efuse</code>，并用于对 <code>bl_ek</code> 的加、解密。<code>bl_ek</code> 加密后放入 <code>fip.bin</code> 中，<code>bl_ek</code> 用于对各个 <code>bin</code> 文件进行加密。验证时先通过 <code>efuse</code> 中的明文的 <code>loader_ek</code> 秘钥对 fip.bin 中加密后的 <code>bl_ek</code> 进行解密得到 <code>bl_ek</code>。然后用它对各个 <code>bin</code> 文件进行解密。</p><p>验证的流程相反，先解密后再验证签名。</p><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8-sign-enc-fip.drawio.png" alt="安全启动-sign-enc-fip.drawio"></p><ol><li>将 <code>loader_ek.key</code> 明文写入 <code>efuse</code>。</li><li>用 <code>loader_ek.key</code> 加密 <code>bl_ek.key</code> 后写入 <code>fip.bin</code>。</li><li>用 <code>bl_ek.key</code> 对 <code>bl2.bin</code> 进行加密。</li><li>用 <code>bl_ek.key</code> 对 <code>fw_dynamic.bin</code> 进行加密。</li><li>用 <code>bl_ek.key</code> 对 <code>u-boot-raw.bin</code> 进行加密。</li></ol><p>具体签名的实现涉及到 <code>fsbl/plat/cv181x/</code> 目录下的 <code>fipsign.py</code> 和 <code>fiptool.py</code>。前面 [fip 组成结构](#fip 组成结构) 也提到了部分实现。</p><blockquote><p><code>param2/ldr_2nd_hdr</code> 中记录的信息也会随着签名、加密更新，这里并不关注这些细节。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">encrypt_fip</span><br><span class="line">  ├─►read_fip</span><br><span class="line">  ├─►sign</span><br><span class="line">  │   ├─►sign_bl_pk</span><br><span class="line">  │   ├─►sign_by_bl_priv(BL2</span><br><span class="line">  │   ├─►sign_by_bl_priv(MONITOR</span><br><span class="line">  │   └─►sign_by_bl_priv(LOADER_2ND_LOADADDR</span><br><span class="line">  └─►encrypt</span><br><span class="line">      ├─►_aes_encrypt(LOADER_EK, BL_EK)  # (秘钥，待加密内容)</span><br><span class="line">      ├─►_aes_encrypt(BL_EK, BL2)</span><br><span class="line">      ├─►_aes_encrypt(BL_EK, MONITOR)</span><br><span class="line">      └─►_aes_encrypt(BL_EK, LOADER_2ND_LOADADDR)</span><br></pre></td></tr></table></figure><hr><h4 id="fip-校验流程"><a href="#fip-校验流程" class="headerlink" title="fip 校验流程"></a>fip 校验流程</h4><p><code>fip.bin</code>  的校验由两部分组成，一部分代码是位于 <code>ROM</code> 中（没有权限查看，只能合理猜测 <code>fsbl</code> 中缺少的就是在 <code>rom</code> 中完成的）：不用猜测，测试就行，<code>ROOT_PK</code>，<code>BL_PK</code>，<code>BL2</code>的签名校验都是在 <code>rom code</code> 中完成。<del>从 <code>efuse</code> 读取 AES 秘钥 <code>LOADER_EK</code></del>。校验不通过则不进行烧录，直接从 <code>flash</code> 加载 <code>fsbl</code>，日志信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">C.SCS/3/3.URPL.SDI/25000000/6000000.BS/SD.PS.SD/0x0/0x1000/0x1000/0.VRK4. E:verify root (-14)</span><br><span class="line"> W:DL cancelled. Load flash. (1).</span><br><span class="line">BS/NOR.PS.VRK4.VBK.DK4.VCC.PE.BS.DB2.VB2.BE.J.</span><br><span class="line">FSBL Jb2829:ga05fb6172-dirty:2023-09-19T10:28:45+08:00</span><br><span class="line"></span><br><span class="line">C.SCS/3/3.URPL.SDI/25000000/6000000.BS/SD.PS.SD/0x0/0x1000/0x1000/0.VRK4. E:verify bl_pk (-14)</span><br><span class="line">C.SCS/3/3.URPL.SDI/25000000/6000000.BS/SD.PS.SD/0x0/0x1000/0x1000/0.VRK4. E:verify BL2 (-14)</span><br></pre></td></tr></table></figure><p>而 <code>FSBL</code> 中的解密、验签的流程如下：加载时，才去解密 + 校验。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bl2_main</span><br><span class="line">   │</span><br><span class="line">   └─►load_rest</span><br><span class="line">         │</span><br><span class="line">         ├──►load_blcp_2nd ───┐</span><br><span class="line">         │                    │</span><br><span class="line">         ├──►load_monitor ────┼──►dec_verify_image</span><br><span class="line">         │                    │       │</span><br><span class="line">         └──►load_loader_2nd ─┘       ├──►security_is_tee_encrypted</span><br><span class="line">                                      │         │</span><br><span class="line">                                      │         └───►cryptodma_aes_decrypt</span><br><span class="line">                                      └──►verify_rsa</span><br></pre></td></tr></table></figure><h3 id="kernel-x2F-rootfs-的签名"><a href="#kernel-x2F-rootfs-的签名" class="headerlink" title="kernel &#x2F; rootfs 的签名"></a>kernel &#x2F; rootfs 的签名</h3><p>除 <code>fip.bin</code> 外，还有 <code>kernel</code> 的产物 <code>boot.xxx</code> 和文件系统的产物 <code>rootfs.xxx</code>。</p><h4 id="准备秘钥-1"><a href="#准备秘钥-1" class="headerlink" title="准备秘钥"></a>准备秘钥</h4><blockquote><p>1️⃣这里的秘钥的名称与上面不一样，因为是不同时期针对不同板子写的，不过逻辑是一样的，后面再考虑统一名称。<br>2️⃣这里没有进行加密，所以不需要生成 <code>AES</code> 秘钥。</p></blockquote><table><thead><tr><th>文件</th><th>作用</th></tr></thead><tbody><tr><td>NTKC_PRIV.pem</td><td>用于给 <code>REE_OS_PK</code> 签名的私钥。公钥（的 <code>hash</code> 值）被烧到 <code>HASH0_PUBLIC</code></td></tr><tr><td>REEOS_PRIV.pem</td><td>用于给 <code>boot, rootfs</code> 签名的私钥</td></tr><tr><td>boot.crl</td><td>黑名单，<code>REEOS_PK.pem</code> 不能是 <code>boot.crl</code> 中的值</td></tr></tbody></table><p>和上面一样，使用 <code>openssl</code> 生成 <code>2048</code> 位的秘钥：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host$ openssl genrsa -out NTKC_PRIV.pem -F4 2048</span><br><span class="line">host$ openssl genrsa -out REEOS_PRIV.pem -F4 2048</span><br></pre></td></tr></table></figure><h4 id="签名流程"><a href="#签名流程" class="headerlink" title="签名流程"></a>签名流程</h4><p>与前面直接将签名信息直接写入到 <code>fip.bin</code> 不同，对 <code>kernel</code> 和 <code>rootfs</code> 的签名专门生成了一个 <code>sig.bin</code> 文件来存储。其结构如下图所示，分为三部分，公钥、签名、文件大小信息。</p><blockquote><p>1️⃣在这里的设计中，文件系统 <code>rootfs</code> 有两份，一份就是正常大小的 <code>upgrade</code>，另一份为删减了一些非必要文件的 <code>minerfs</code>。不过在后续的流程中，我并没有对 <code>rootfs</code> 进行裁剪，也就是说 <code>upgrade == minerfs == rootfs.spinor</code> ，先走通流程，后续再考虑是否精简。<br>2️⃣只进行了签名操作，没有进行加密！<br>3️⃣文件大小信息是板端重新对 <code>kernel/rootfs</code> 计算签名的时候用到的。</p></blockquote><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8-sign-boot-rootfs.drawio.png" alt="安全启动-sign-boot-rootfs.drawio"></p><ol><li>由 <code>NTKC_PRIV.pem</code> 私钥得到公钥。 <code>NTKC_PRIV.pem</code> 的公钥需要记录在 <code>efuse</code> 里面，而 <code>efuse</code> 空间有限，签名 <code>rsa_hash0.pem</code> 已经用了，所以这两个必须相等 <code>NTKC_PRIV.pem == rsa_hash0.pem</code> 。</li><li>由 <code>REEOS_PRIV.pem</code> 私钥得到公钥。该私钥感觉也可以与前面的 <code>bl_priv.pem</code> 相同。</li><li>用 <code>NTKC_PRIV.pem</code> 计算 <code>REEOS_PK.pem</code> 的数字签名</li><li>用 <code>NTKC_PRIV.pem</code> 计算数字签名。<code>boot.crl</code> 是作为黑名单使用的，即 <code>REEOS_PK.pem</code> 不能是 <code>boot.crl</code> 中的值（这里面的值是已经泄漏的秘钥）。</li><li>用 <code>REEOS_PRIV.pem</code> 计算数字签名。</li><li>用 <code>REEOS_PRIV.pem</code> 计算数字签名。这里不区分 <code>minerfs/upgrade</code> ，都记录为 <code>rootfs</code> 的签名。</li></ol><p>对 <code>kernel</code> 和 <code>rootfs</code> 的签名的实现是在 <code>make_sig_img.sh</code> 这个脚本中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e -o pipefail</span><br><span class="line"></span><br><span class="line">SIG_TMP_PATH=<span class="string">&quot;<span class="variable">$&#123;BUILD_PATH&#125;</span>/tools/common/sign_tools/sig_files&quot;</span></span><br><span class="line">NTKC_PRIV_PATH=<span class="string">&quot;<span class="variable">$&#123;BUILD_PATH&#125;</span>/tools/common/sign_tools/NTKC_PRIV.pem&quot;</span></span><br><span class="line">REEOS_PRIV_PATH=<span class="string">&quot;<span class="variable">$&#123;BUILD_PATH&#125;</span>/tools/common/sign_tools/REEOS_PRIV.pem&quot;</span></span><br><span class="line">BOOT_CRL_PATH=<span class="string">&quot;<span class="variable">$&#123;BUILD_PATH&#125;</span>/tools/common/sign_tools/boot.crl&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sig.bin 中不同部分的分割符</span></span><br><span class="line">SIG_IMG_SEP=$(<span class="built_in">printf</span> <span class="string">&#x27;\xe8\x6c\xdc\x26\x7b\xcb\xf6\x4b\x8d\xd8\xa2\x2c\x86\xa6\x58\x73\xf9\x42\xbc\x3a\x70\x58\x02\x43\xbe\x79\x56\x66\x23\x2a\x0a\x7e&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">int_to_bytes</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    python3 -c <span class="string">&#x27;import sys; sys.stdout.buffer.write(int(sys.argv[1]).to_bytes(4, &quot;little&quot;))&#x27;</span> <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># create sig.bin</span></span><br><span class="line"><span class="keyword">function</span> make_sig_img()</span><br><span class="line">(</span><br><span class="line">    <span class="comment"># 这里顺序要和 u-boot 中 cvi_verify.c 中对应</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;FUNCNAME[0]&#125;</span>()&quot;</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cat</span> <span class="variable">$SIG_TMP_PATH</span>/NTKC_PK.pem</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&#x27;%s&#x27;</span> <span class="string">&quot;<span class="variable">$SIG_IMG_SEP</span>&quot;</span></span><br><span class="line">        <span class="built_in">cat</span> <span class="variable">$SIG_TMP_PATH</span>/REEOS_PK.pem</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&#x27;%s&#x27;</span> <span class="string">&quot;<span class="variable">$SIG_IMG_SEP</span>&quot;</span></span><br><span class="line">        <span class="built_in">cat</span> <span class="string">&quot;<span class="variable">$&#123;BOOT_CRL_PATH&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&#x27;%s&#x27;</span> <span class="string">&quot;<span class="variable">$SIG_IMG_SEP</span>&quot;</span></span><br><span class="line">        <span class="built_in">cat</span> <span class="variable">$SIG_TMP_PATH</span>/REEOS_PK.pem.sig</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&#x27;%s&#x27;</span> <span class="string">&quot;<span class="variable">$SIG_IMG_SEP</span>&quot;</span></span><br><span class="line">        <span class="built_in">cat</span> <span class="variable">$SIG_TMP_PATH</span>/boot.crl.sig</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&#x27;%s&#x27;</span> <span class="string">&quot;<span class="variable">$SIG_IMG_SEP</span>&quot;</span></span><br><span class="line">        <span class="built_in">cat</span> <span class="variable">$SIG_TMP_PATH</span>/boot.<span class="variable">$STORAGE_TYPE</span>.sig</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&#x27;%s&#x27;</span> <span class="string">&quot;<span class="variable">$SIG_IMG_SEP</span>&quot;</span></span><br><span class="line">        <span class="built_in">cat</span> <span class="variable">$SIG_TMP_PATH</span>/minerfs.sig</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&#x27;%s&#x27;</span> <span class="string">&quot;<span class="variable">$SIG_IMG_SEP</span>&quot;</span></span><br><span class="line">        <span class="built_in">cat</span> <span class="variable">$SIG_TMP_PATH</span>/upgrade.sig</span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&#x27;%s&#x27;</span> <span class="string">&quot;<span class="variable">$SIG_IMG_SEP</span>&quot;</span></span><br><span class="line">        int_to_bytes <span class="string">&quot;<span class="subst">$(stat -c &#x27;%s&#x27; $OUTPUT_DIR/rawimages/boot.$STORAGE_TYPE)</span>&quot;</span></span><br><span class="line">        int_to_bytes <span class="string">&quot;<span class="subst">$(stat -c &#x27;%s&#x27; $OUTPUT_DIR/rawimages/rootfs.$STORAGE_TYPE)</span>&quot;</span></span><br><span class="line">        int_to_bytes <span class="string">&quot;<span class="subst">$(stat -c &#x27;%s&#x27; $OUTPUT_DIR/rawimages/rootfs.$STORAGE_TYPE)</span>&quot;</span></span><br><span class="line">        <span class="built_in">printf</span> <span class="string">&#x27;%s&#x27;</span> <span class="string">&quot;<span class="variable">$SIG_IMG_SEP</span>&quot;</span></span><br><span class="line">    &#125; &gt; <span class="string">&quot;<span class="variable">$OUTPUT_DIR</span>/rawimages/sig.bin&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在文件 sig.bin 前面加上一段前缀字符串，表示是 cvitek 的镜像</span></span><br><span class="line">    python3 <span class="string">&quot;<span class="variable">$BUILD_PATH</span>/tools/common/image_tool/raw2cimg.py&quot;</span> <span class="string">&quot;<span class="variable">$OUTPUT_DIR</span>/rawimages/sig.bin&quot;</span> <span class="string">&quot;<span class="variable">$OUTPUT_DIR</span>&quot;</span> <span class="string">&quot;<span class="variable">$FLASH_PARTITION_XML</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Save to <span class="variable">$OUTPUT_DIR</span>/sig.bin&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对镜像用私钥进行加密、签名</span></span><br><span class="line"><span class="keyword">function</span> sign_image()</span><br><span class="line">(</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;FUNCNAME[0]&#125;</span>()&quot;</span></span><br><span class="line">    <span class="comment"># 由私钥得到公钥</span></span><br><span class="line">    openssl rsa -<span class="keyword">in</span> <span class="variable">$&#123;NTKC_PRIV_PATH&#125;</span> -pubout -out <span class="string">&quot;<span class="variable">$SIG_TMP_PATH</span>/NTKC_PK.pem&quot;</span></span><br><span class="line">    openssl rsa -<span class="keyword">in</span> <span class="variable">$&#123;NTKC_PRIV_PATH&#125;</span> -pubout -outform DER | <span class="built_in">sha256sum</span> &gt; <span class="string">&quot;<span class="variable">$SIG_TMP_PATH</span>/NTKC_PK.der.sha256&quot;</span></span><br><span class="line">    openssl rsa -<span class="keyword">in</span> <span class="string">&quot;<span class="variable">$&#123;REEOS_PRIV_PATH&#125;</span>&quot;</span> -pubout -out <span class="string">&quot;<span class="variable">$SIG_TMP_PATH</span>/REEOS_PK.pem&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成数字签名</span></span><br><span class="line">    openssl dgst -sha256 -sign <span class="variable">$&#123;NTKC_PRIV_PATH&#125;</span> -out <span class="string">&quot;<span class="variable">$SIG_TMP_PATH</span>/REEOS_PK.pem.sig&quot;</span> <span class="string">&quot;<span class="variable">$SIG_TMP_PATH</span>/REEOS_PK.pem&quot;</span></span><br><span class="line">    openssl dgst -sha256 -sign <span class="variable">$&#123;NTKC_PRIV_PATH&#125;</span> -out <span class="string">&quot;<span class="variable">$SIG_TMP_PATH</span>/boot.crl.sig&quot;</span> <span class="variable">$&#123;BOOT_CRL_PATH&#125;</span></span><br><span class="line"></span><br><span class="line">    openssl dgst -sha256 -sign <span class="string">&quot;<span class="variable">$&#123;REEOS_PRIV_PATH&#125;</span>&quot;</span> -out <span class="string">&quot;<span class="variable">$SIG_TMP_PATH</span>/boot.<span class="variable">$STORAGE_TYPE</span>.sig&quot;</span> <span class="string">&quot;<span class="variable">$OUTPUT_DIR</span>/rawimages/boot.<span class="variable">$STORAGE_TYPE</span>&quot;</span></span><br><span class="line">    <span class="comment"># 这里没有区分 upgrade/minerfs，暂时不确定是否需要区分，所以保留两个</span></span><br><span class="line">    openssl dgst -sha256 -sign <span class="string">&quot;<span class="variable">$&#123;REEOS_PRIV_PATH&#125;</span>&quot;</span> -out <span class="string">&quot;<span class="variable">$SIG_TMP_PATH</span>/minerfs.sig&quot;</span> <span class="string">&quot;<span class="variable">$OUTPUT_DIR</span>/rawimages/rootfs.<span class="variable">$STORAGE_TYPE</span>&quot;</span></span><br><span class="line">    openssl dgst -sha256 -sign <span class="string">&quot;<span class="variable">$&#123;REEOS_PRIV_PATH&#125;</span>&quot;</span> -out <span class="string">&quot;<span class="variable">$SIG_TMP_PATH</span>/upgrade.sig&quot;</span> <span class="string">&quot;<span class="variable">$OUTPUT_DIR</span>/rawimages/rootfs.<span class="variable">$STORAGE_TYPE</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;sign_image done!&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="string">&quot;<span class="variable">$SIG_TMP_PATH</span>&quot;</span></span><br><span class="line">(</span><br><span class="line">    <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$SIG_TMP_PATH</span>&quot;</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Clear <span class="variable">$SIG_TMP_PATH</span>&quot;</span></span><br><span class="line">    <span class="built_in">rm</span> -f ./*</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;start sign&quot;</span></span><br><span class="line">sign_image</span><br><span class="line">make_sig_img</span><br></pre></td></tr></table></figure><h4 id="校验流程"><a href="#校验流程" class="headerlink" title="校验流程"></a>校验流程</h4><ol><li>计算 <code>sig.bin</code> 中 <code>NTKC_PK.pem</code> 的散列值，与 <code>efuse</code> 中存储的散列值对比，如果相同则说明 <code>NTKC_PK.pem</code> 可信。</li><li>利用 <code>NTKC_PK.pem</code> 计算 <code>REEOS_PK.pem</code> 的数字签名，和 <code>REEOS_PK.pem.sig</code> 对比，相同则说明 <code>REEOS_PK.pem</code> 可信。</li><li>利用 <code>REEOS_PK.pem</code> 为 <code>boot / rootfs</code> 计算数字签名，并与对应的 <code>.sig</code> 对比，相同则说明对应的文件没有被篡改，可信。</li><li>校验完毕，可以正常启动 <code>kernel</code> 了。</li></ol><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><h3 id="1️⃣使用注意"><a href="#1️⃣使用注意" class="headerlink" title="1️⃣使用注意"></a>1️⃣使用注意</h3><ol><li><strong>配置参数</strong>，<code>fip.bin</code> 的加密通过设置配置选项 <code>CONFIG_FSBL_SECURE_BOOT_SUPPORT=y</code> 启用，而 <code>kernel</code> 和 <code>rootfs</code> 则是通过环境变量 <code>UBOOT_VBOOT=1</code> 来启用。分开配置是必要的，因为第一次需要未加密的 <code>fip.bin</code> 来实现烧写 <code>efuse</code>，在 <code>efuse</code> 还未烧写的情况下，加密了的 <code>fip.bin</code> 无法加载。</li><li><strong>修改</strong> <code>partition.xml</code>，其实就是增加一项 <code>sig.bin</code>，需要注意其大小对齐，具体大小要看对应 <code>flash</code> 数据手册，不过一般为 <code>64k/128k</code>。</li><li><strong>修改</strong> <code>cv18xx-asic.h</code>，在 <code>uboot</code>启动 <code>kernel</code> 之前，需要先对 <code>kernel</code> 和 <code>rootfs</code> 进行签名校验，而这一过程需要先将对应的内容从 <code>flash</code> 读取到内存中，目前只测试了 <code>spinor/spinand</code>，<code>emmc</code> 还未测试。<strong>另外注意</strong>：读取时各个分区占据的内存不要重叠，分区的大小最好与 <code>partition.xml</code> 中一致。</li></ol><h3 id="2️⃣raw2cimg-py"><a href="#2️⃣raw2cimg-py" class="headerlink" title="2️⃣raw2cimg.py"></a>2️⃣raw2cimg.py</h3><p>在我们的编译流程中，编译得到的原始文件比如 <code>boot.spinand</code>， <code>rootfs.spinor</code> 等是放在 <code>$OUTPUT_DIR/rawimages</code> 目录下的，不过编译流程中还会调用 <code>raw2cimg.py</code> 对这些二进制文件加上一段前缀<code>Header</code>，<code>upgrade.zip</code> 中打包的也是这些添加”<code>header</code>“后的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ hexdump sig.bin</span><br><span class="line">0000000 4943 474d 0001 0000 0040 0000 0001 0000</span><br><span class="line">0000010 0bb5 0000 6973 0067 0000 0000 0000 0000</span><br><span class="line">0000020 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0000040 0001 0000 0b75 0000 0000 00b2 0000 0002</span><br><span class="line">0000050 dd1b 0ee4 0000 0000 0000 0000 0000 0000</span><br><span class="line">0000060 0000 0000 0000 0000 0000 0000 0000 0000</span><br><span class="line">*</span><br><span class="line">0000080 2d2d 2d2d 422d 4745 4e49 5020 4255 494c <span class="comment"># 这一行开始是正式内容</span></span><br><span class="line">0000090 2043 454b 2d59 2d2d 2d2d 4d0a 4949 4942</span><br></pre></td></tr></table></figure><p><del>问题在于💢：前面 <code>sig.bin</code> 中使用的是 <code>rawimages</code> 下的文件生成的签名，而烧写到 <code>flash</code> 的是增加了一段前缀后的文件，两个文件有差异，那么在进行 <code>kernel</code> 和 <code>rootfs</code> 签名校验的时候，应该无法通过才对❗💢💢但它确实能通过校验，并且使用 <code>rawimages</code> 下的文件反而无法通过🤦‍♂️也没有找到哪里有对前缀进行裁剪之类的代码🤦‍♂️🤦‍♂️🤦‍♂️</del>。</p><p><strong>是在烧录的过程中就进行了裁剪</strong>。在 <code>cvi_update</code> 过程中，会检查各个文件是否存在 <code>Header</code>，如果不存在或者不一致，会无法烧录到 <code>flash</code>。此外，在实际烧录时也会裁剪掉 <code>header</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">do_cvi_update</span><br><span class="line">    │</span><br><span class="line">    └►_storage_update</span><br><span class="line">         │</span><br><span class="line">         └─►_checkHeader</span><br><span class="line">              │</span><br><span class="line">              ├──►uint32_t pos = HEADER_SIZE;</span><br><span class="line">              └──►snprintf(cmd, 255, &quot;fatload %s %p %s 0x%x 0x%x;&quot;, strStorage,</span><br><span class="line">                   (void *)UPDATE_ADDR, file, load_size, pos);</span><br></pre></td></tr></table></figure><p>使用未添加 <code>Header</code> 的 <code>sig.bin</code>，<code>boot.spinor</code>，<code>rootfs.spinor</code> 烧录的时候，会提示下面的错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File:sig.bin Magic number is wrong, skip it</span><br><span class="line">File:rootfs.spinor Magic number is wrong, skip it</span><br></pre></td></tr></table></figure><h3 id="3️⃣烧录-efuse"><a href="#3️⃣烧录-efuse" class="headerlink" title="3️⃣烧录 efuse"></a>3️⃣烧录 efuse</h3><p>目前是将烧录 <code>efuse</code> 的流程是绑定在对 <code>kernel</code> 签名的。只要启用了 <code>UBOOT_VBOOT=1</code>，启动过程中就会检查是否设置了安全启动（通过读取 <code>efuse</code> 的数据判断），如果没有设置就会烧写 <code>efuse</code>，包括 <code>HASH0_PUBLIC</code> 和 <code>loader_ek</code>。</p><p>如果每次编译的 <code>boot.xxx</code> 都带有这些信息，容易导致秘钥泄漏。前者没有问题，因为烧写到 <code>efuse</code> 的是公钥，即使知道公钥也推不出私钥。不过后者是 <code>AES</code> 明文的秘钥，存在隐患。<del>所以，在非必要的时候应该注释掉相关内容</del>。已增加配置环境变量 <code>UBOOT_WRITE_EFUSE=1</code> 来控制。</p><h3 id="⭐更新"><a href="#⭐更新" class="headerlink" title="⭐更新"></a>⭐更新</h3><p>由于客户要求，只签名，不对 <code>fip.bin</code> 进行加密，希望能以宏进行控制，因此需要对部分代码进行更新。</p><ol><li>使用环境变量 <code>ONLY_SIGN_FIP=1</code> 来表示仅对 <code>fip.bin</code> 进行签名，未设置或设置为0表示签名+加密。</li><li>代码主要更新：<ol><li>编译流程中 <code>fip_v2.mk</code> 调用 <code>fipsign.py</code> 之前检查环境变量。</li><li>编译流程中 <code>build/Makefile</code> 将 <code>loader_ek</code> 复制到 <code>uboot</code> 目录下的过程，需要先检查环境变量。</li><li><code>efuse.c</code> 中烧写 <code>efuse</code> 时，检查环境变量，不烧写 <code>loader_ek</code>。</li><li>在 <code>uboot/*/cvitek.mk</code> 中还要增加 <code>-DONLY_SIGN_FIP</code>，这样才能影响到 <code>efuse.c</code> 中的代码。</li></ol></li></ol><h3 id="4️⃣使用方法"><a href="#4️⃣使用方法" class="headerlink" title="4️⃣使用方法"></a>4️⃣使用方法</h3><ol><li><p>准备以下几个秘钥文件，如何生成秘钥可以看前面的介绍。</p><table><thead><tr><th>fip.bin</th><th>kernel&#x2F;rootfs</th><th></th></tr></thead><tbody><tr><td>rsa_hash0.pem</td><td>NTKC_PRIV.pem</td><td>用于给 <code>bl_priv.pem</code> 签名的 <code>RSA</code> 私钥，公钥（的 <code>hash</code> 值）被烧到 <code>HASH0_PUBLIC</code></td></tr><tr><td>bl_priv.pem</td><td></td><td>用于给 <code>fsbl/opensbi/u-boot</code> 生成签名的 <code>RSA</code> 私钥</td></tr><tr><td>loader_ek.key</td><td></td><td>用于给 <code>bl_ek.key</code> 加、解密的 <code>AES</code> 秘钥，也会被烧写到 <code>eFuse</code></td></tr><tr><td>bl_ek.key</td><td></td><td>用于给 <code>fsbl/opensbi/u-boot</code> 加、解密的 <code>AES</code> 秘钥</td></tr><tr><td></td><td>REEOS_PRIV.pem</td><td>用于给 <code>boot, rootfs</code> 签名的私钥</td></tr><tr><td></td><td>boot.crl</td><td>黑名单，<code>REEOS_PK.pem</code> 不能是 <code>boot.crl</code> 中的值，<strong>不能为空文件</strong></td></tr></tbody></table></li><li><p>在一个空白的板子上，此时板子的 <code>efuse</code> 还没有写过，首先需要烧写 <code>efuse</code>，此时不能加密 <code>fip.bin</code>。</p><p> <code>export UBOOT_VBOOT=1 UBOOT_WRITE_EFUSE=1; source build/xxx</code></p></li><li><p><strong>完成烧录后，拔卡，重新上电</strong>，才会进行 <code>efuse</code> 的烧写。</p></li><li><p>烧写完毕，后续编译的镜像就必须对 <code>fip.bin</code> 进行加密了，否则无法烧录。<br> 完成烧录后，也不要再使用 <code>UBOOT_WRITE_EFUSE=1</code>，否则 <code>boot.xxx</code> 中会带有 <code>loader_ek.key</code> 的明文，容易导致秘钥泄漏。</p><p> <code>export UBOOT_VBOOT=1; source build/xxx</code>，再通过 <code>menuconfig</code> 启用 <code>CONFIG_FSBL_SECURE_BOOT_SUPPORT</code>(这个可以写在对应板卡目录下的 xxx_defconfig 文件中 )</p></li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li><p>秘钥都是写在 efuse 中的，那别人岂不是可以直接读 efuse 获取到秘钥？这样不很容易破解吗？</p><blockquote><p>efuse 中存了两个秘钥：</p><ol><li>HASH0_PUBLIC 区存放的 RSA 算法的公钥的 sha256 哈希值。</li><li>LOADER_EK 区存放的 AES 的秘钥。</li></ol><p>正常情况下是可读写的，不过烧写下面两个字段，就可以禁用对应区域的读写。<a href="https://doc.sophgo.com/cvitek-develop-docs/master/docs_latest_release/CV180x_CV181x/zh/01.software/BSP/eFuse_User_Guide/build/html/2_eFuse_User_Guide/eFuse_Overview.html">see doc</a></p><table><thead><tr><th>LOCK_LOADER_EK</th><th>锁定安全启动AES加密密钥区域，让此区域无法读写</th></tr></thead><tbody><tr><td>LOCK_DEVICE_EK</td><td>锁定DEVICE_EK，让此区域无法读写</td></tr></tbody></table><p><strong>那如果不能读写？启动过程又是怎么验签和解密的呢？</strong></p><p>这两个秘钥的内容是在 rom code 中读取的，rom code 有特权吧。efuse 区分安全介面和非安全介面，锁读写只是非安全界面的读写，安全界面至少能读。</p></blockquote></li><li><p><del>fip 的签名校验都是在 fsbl 中完成</del>，如果能获得 fsbl 的源码，修改后能跳过签名校验过程吗？</p><blockquote><p>看 [fip 校验流程](#fip 校验流程) ，在 rom code 中会首先对 fip 进行校验，也就是说，即使你能修改 fsbl 的流程，但没有 RSA 秘钥，无法对 fip 进行签名，那么在 rom code 阶段就被卡住了。</p><p>如果秘钥都泄漏了，那改不改 fsbl 的流程都一样了。</p></blockquote></li><li><p>公钥不小心泄漏了，能被人利用吗？前面介绍的公钥是直接存放在 fip.bin 中的，fip.bin 本身又不大，知道公钥的位数，总能穷举出来吧。</p><blockquote><p>除了穷举，还可以随便创建一个公钥私钥，用私钥签名 <code>fip.bin</code> 然后查看公钥对应 <code>fip.bin</code> 中的偏移量。不就可以知道任意一个 <code>fip.bin</code> 中的公钥了吗？</p><p>假设已经知道了公钥，rom code 里面如果仅仅对公钥本身进行了校验，那也就是说我可以使用自己编译的一个 fip.bin，替换里面的公钥，就可以进入 fsbl 阶段了。那我岂不是可以修改 fsbl，跳过签名、解密的过程？这不就破解了？？？uboot就可以烧录任何固件了…. ？？？</p><p>👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇👇</p><p>公钥确实容易获取，查看 <code>fiptool.py</code> 可以看到 <code>ROOT_PK</code> 在 <code>fip.bin</code> 中的偏移量为 <code>0X400</code>。不过这并没有安全风险。因为目前是一级一级校验的。</p><ul><li><code>rom code</code> 中会校验 <code>BL2(FSBL)</code> 的签名，保证了 <code>FSBL</code> 无法被篡改。或者说篡改后的 <code>FSBL</code> 无法通过 <code>ROM</code> 的校验。<em>对应下图中的 2,4,5,6 步</em>。</li><li><code>FSBL</code> 中校验 <code>UBOOT</code>，也就保证了 <code>uboot</code> 无法被篡改。<em>对应下图中的 7,8 步</em>。</li><li><code>uboot</code> 校验 <code>kernel/rootfs</code>，保证了它们无法被篡改。</li></ul><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8-sign-enc-fip.drawio.png" alt="安全启动-sign-enc-fip.drawio"></p><p>回到上面的问题，<code>rom</code> 中并不是只校验了 <code>ROOT_PK</code>，而是校验了 <code>bl2</code> 的签名。即使 <code>root pk</code> 泄露了，也不会影响 <code>bl2</code> 的签名校验（这需要 root 和 bl 的私钥）。不存在安全风险。</p><p>另一方面，目前 <code>kernel</code> 和 <code>rootfs</code> 的校验做的不太好，理论上 <code>uboot</code> 阶段去校验 <code>kernel</code> 和 <code>rootfs</code> 的签名时，应该使用新的秘钥，而不是 <code>root pk</code>。也就是 <code>NTKC_PRIV.pem</code> 的公钥也可以记录在 <code>fip.bin</code> 中，<code>fsbl</code> 中对 <code>uboot</code> 验签的时候，用 <code>bl_pk</code> 对 <code>sig.bin</code> 进行验签，也就是将 <code>sig.bin</code> 中的 <code>NTKC_PK.pem</code> 换为 <code>bl_pk</code>，这样就是一层一层的依赖关系。而不是现在 <code>uboot</code> 直接用 <code>root</code> 的公钥。。不过也还好，影响不大。</p><p><img src="/../images/Cvitek-%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8/%E5%AE%89%E5%85%A8%E5%90%AF%E5%8A%A8-sign-boot-rootfs.drawio.png" alt="安全启动-sign-boot-rootfs.drawio"></p></blockquote></li><li><p><strong>安全启动的意义</strong></p><blockquote><ul><li><p>防止用户烧录未经授权的固件。（签名）</p><blockquote><p>启用安全启动之后，只能烧录签名后的固件。</p></blockquote></li><li><p>防止通过固件拷贝，来抄袭产品。（签名+加密）</p><blockquote><p>A 卖芯片，提供 SDK。</p><p>B 买芯片，画板子，用 A 提供的 芯片 + SDK 做产品卖。</p><p>C 抄 B 的板子，并直接拷 B <code>flash</code> 中的固件，再买 A 的同款芯片。理论上用很低的成本就完成了对 B 产品的完全复制。</p><p>如何避免呢？</p><ol><li>安全启动（仅签名），C 的视角来看，固件有了，问题在于芯片上的 <code>efuse</code> 烧写。不过仅签名的话，只会用到 <code>root_pk</code>，而这是可以从固件 <code>fip.bin</code> 中获得的。因此 <code>C</code> 还是可以抄袭。</li><li>安全启动（签名 + 加密），C 的视角来看，固件有了，还差 <code>LOADER_EK</code>，而这无法读取。因此，无法抄袭。</li></ol></blockquote></li></ul></blockquote></li><li><p>从上面可以看到，还有一个关键在于 <code>efuse</code> 中的 <code>AES</code> 秘钥，绝不能被窃取。如何实现呢？安全介面和非安全介面</p><blockquote></blockquote></li></ol><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://doc.sophgo.com/cvitek-develop-docs/master/docs_latest_release/CV180x_CV181x/zh/01.software/BSP/Secure_Boot_User_Guide/build/html/3_Secure_Image_Generation.html">安全启动使用指南</a></li><li><a href="https://doc.sophgo.com/cvitek-develop-docs/master/docs_latest_release/CV180x_CV181x/zh/01.software/BSP/eFuse_User_Guide/build/html/index.html">eFuse 使用指南</a></li><li><a href="https://cloud.tencent.com/developer/article/1693368">图解|什么是 RSA 算法</a></li><li><a href="https://mp.weixin.qq.com/s/XBYJFZ2jRF2slrlym3svQw">盘点五种最常见加密算法！</a></li><li><a href="https://mp.weixin.qq.com/s/Hu1VBMSHh82n6bujWxr9nw">密码学基本概念</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cvitek </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cvitek </tag>
            
            <tag> uboot </tag>
            
            <tag> 启动流程 </tag>
            
            <tag> sha256 </tag>
            
            <tag> rsa </tag>
            
            <tag> aes </tag>
            
            <tag> openssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb</title>
      <link href="/2023/04/14/gdb/"/>
      <url>/2023/04/14/gdb/</url>
      
        <content type="html"><![CDATA[<h1 id="GDB-备忘清单"><a href="#GDB-备忘清单" class="headerlink" title="GDB 备忘清单"></a>GDB 备忘清单</h1><p>本清单提供了对 <a href="https://en.wikipedia.org/wiki/GNU_Debugger">GDB</a> 的入门简要概述，以及 <code>GDB</code> 常用示例，完整文档参阅 <a href="https://www.eecs.umich.edu/courses/eecs373/readings/Debugger.pdf">Debugging with gdb</a>，该文档最后有 <code>GDB index</code>，可以快速查找命令。</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><!--rehype:body-class=cols-2--><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><!--rehype:wrap-class=row-span-2--><p><code>[]</code> 内为命令缩写</p><table><thead><tr><th align="left">命令 <code>[缩写]</code></th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>help[h]</code></td><td align="left"><strong>查看命令帮助</strong>。如 <code>help run</code></td></tr><tr><td align="left"><code>run[r]</code></td><td align="left"><strong>运行程序</strong>。可搭配参数使用</td></tr><tr><td align="left"><code>start</code></td><td align="left"><strong>运行程序，停在第一条执行语句</strong>。可搭配参数使用</td></tr><tr><td align="left"><code>list[l]</code></td><td align="left"><strong>查看程序源码</strong></td></tr><tr><td align="left"><code>break[b]</code></td><td align="left"><strong>设置断点</strong>。可指定文件名、函数名和行号等参数来设置断点</td></tr><tr><td align="left"><code>watch</code></td><td align="left"><strong>设置监视点</strong>。当监视的变量发生更改时，程序会被中断</td></tr><tr><td align="left"><code>delete</code></td><td align="left"><strong>删除断点等</strong>。可用于删除断点、监视点、<code>display</code> 等</td></tr><tr><td align="left"><code>continue[c]</code></td><td align="left"><strong>继续执行程序</strong>。让程序继续执行，到下一个断点或程序结束</td></tr><tr><td align="left"><code>next[n]</code></td><td align="left"><strong>单步执行程序，跳过函数调用</strong></td></tr><tr><td align="left"><code>step[s]</code></td><td align="left"><strong>单步执行程序，进入函数调用</strong></td></tr><tr><td align="left"><code>finish</code></td><td align="left"><strong>结束当前函数</strong>。返回到函数调用点</td></tr><tr><td align="left"><code>kill</code></td><td align="left"><strong>杀死当前的调试进程</strong></td></tr><tr><td align="left"><code>backtrace[bt]</code></td><td align="left"><strong>查看函数调用栈</strong>。它会打印出当前的函数调用栈</td></tr><tr><td align="left"><code>frame[fr]</code></td><td align="left"><strong>切换栈帧</strong>。以查看该栈帧中的局部变量和参数等</td></tr><tr><td align="left"><code>info</code></td><td align="left"><strong>查看程序状态信息</strong>。例如断点、寄存器、线程、局部变量等</td></tr><tr><td align="left"><code>show</code></td><td align="left"><strong>查看 <code>gdb</code> 配置信息</strong>。与 <code>info</code> 不同， <code>show</code> 查看 <code>GDB</code> 本身的配置信息</td></tr><tr><td align="left"><code>set</code></td><td align="left"><strong>设置变量值</strong>。有时指定变量类型才能设置，如 <code>set *(int*)(&amp;a) = 3</code></td></tr><tr><td align="left"><code>whatis</code></td><td align="left"><strong>查看变量、函数类型</strong>。例如，<code>whatis a</code> 可以显示变量 <code>a</code> 的类型</td></tr><tr><td align="left"><code>ptype</code></td><td align="left"><strong>查看变量、函数类型</strong>。会显示完整的结构体类型</td></tr><tr><td align="left"><code>print[p]</code></td><td align="left"><strong>打印变量的值</strong>。例如，<code>print x</code> 可以显示变量 <code>x</code> 的当前值</td></tr><tr><td align="left"><code>display</code></td><td align="left"><strong>持续打印变量的值</strong>。与 <code>print</code> 类似，但它会在每次停下时自动输出值</td></tr><tr><td align="left"><code>thread</code></td><td align="left"><strong>切换线程</strong>。例如，<code>thread 2</code> 切换到编号为 <code>2</code> 的线程</td></tr><tr><td align="left"><code>signal</code></td><td align="left"><strong>向进程发送信号</strong>。例如，<code>signal 9</code> 发送编号为 <code>9</code> 的信号</td></tr></tbody></table><!--rehype:className=left-align--><h3 id="启动调试"><a href="#启动调试" class="headerlink" title="启动调试"></a>启动调试</h3><p>启动进程，不带参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gdb &lt;program&gt;</span></span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><p>启动进程，带参数 <code>&lt;args&gt;</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gdb &lt;program&gt;</span></span><br><span class="line">(gdb) run &lt;args&gt;</span><br></pre></td></tr></table></figure><p>启动 <code>gdb</code> 时传入参数，<code>run</code> 就不用传入了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gdb --args &lt;program&gt; 1 2 3</span></span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><p>通过 <code>set</code> 设置参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gdb &lt;program&gt;</span></span><br><span class="line">(gdb) <span class="built_in">set</span> args 1 2 3</span><br><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><p>显示运行时将要或已经传递给程序的参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show args</span><br></pre></td></tr></table></figure><p>在启动进程前，添加环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">set</span> <span class="built_in">env</span> DEBUG 1</span><br></pre></td></tr></table></figure><p>在启动进程前，清除环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) <span class="built_in">unset</span> <span class="built_in">env</span> DEBUG</span><br></pre></td></tr></table></figure><p>通过进程号 <code>123</code> 连接到正在运行的进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) attach 123</span><br></pre></td></tr></table></figure><h3 id="core-dump-文件"><a href="#core-dump-文件" class="headerlink" title="core dump 文件"></a>core dump 文件</h3><!--rehype:wrap-class=row-span-2--><p>默认情况下，<code>linux</code> 系统中程序崩溃时也不会生成 <code>core dump</code> 文件，需要先启用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/tmp/core-%e-%p-%t&quot;</span> &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>调试 <code>core</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb program /tmp/core-file</span><br></pre></td></tr></table></figure><h3 id="查看源码"><a href="#查看源码" class="headerlink" title="查看源码"></a>查看源码</h3><!--rehype:wrap-class=row-span-2--><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>(gdb) list 30</code></td><td align="left">查看第 <code>30</code> 行为中心的上下 <code>5</code> 行源码</td></tr><tr><td align="left"><code>(gdb) list main</code></td><td align="left">查看 <code>main</code> 函数为中心的上下 <code>5</code> 行源码</td></tr><tr><td align="left"><code>(gdb) list file.c:30</code></td><td align="left">查看 <code>file.c</code> 文件中 <code>30</code> 行的源码</td></tr><tr><td align="left"><code>(gdb) list file.c:main</code></td><td align="left">查看 <code>file.c</code> 文件中 <code>main</code> 函数</td></tr><tr><td align="left"><code>(gdb) disassemble</code></td><td align="left">查看当前可执行文件的汇编源码</td></tr><tr><td align="left"><code>(gdb) disassemble myfun</code></td><td align="left">查看指定函数的汇编源码</td></tr></tbody></table><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><!--rehype:wrap-class=row-span-2--><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>(gdb) step[s]</code></td><td align="left">执行源码级别的单步进入操作</td></tr><tr><td align="left"><code>(gdb) stepi[si]</code></td><td align="left">执行指令级别的单步进入操作</td></tr><tr><td align="left"><code>(gdb) next[n]</code></td><td align="left">执行源码级别的单步跳过操作</td></tr><tr><td align="left"><code>(gdb) nexti[ni]</code></td><td align="left">执行指令级别的单步跳过操作</td></tr><tr><td align="left"><code>(gdb) continue[c]</code></td><td align="left">继续执行，到下一个断点或程序结束</td></tr><tr><td align="left"><code>(gdb) finish</code></td><td align="left">运行完当前函数，并返回到函数调用点</td></tr><tr><td align="left"><code>(gdb) return</code></td><td align="left">直接退出当前函数，不执行剩下代码块</td></tr><tr><td align="left"><code>(gdb) return expression</code></td><td align="left">可以指定返回值的内容</td></tr><tr><td align="left"><code>(gdb) until</code></td><td align="left">结束当前循环</td></tr></tbody></table><h3 id="断点命令"><a href="#断点命令" class="headerlink" title="断点命令"></a>断点命令</h3><!--rehype:wrap-class=row-span-2--><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>(gdb) break main</code></td><td align="left">在所有名为 <code>main</code> 的函数处设置一个断点</td></tr><tr><td align="left"><code>(gdb) break test.c:12</code></td><td align="left">在文件 <code>test.c</code> 的第 <code>12</code> 行设置断点</td></tr><tr><td align="left"><code>(gdb) break test.c:func</code></td><td align="left">在文件 <code>test.c</code> 的 <code>func</code> 函数处设置断点</td></tr><tr><td align="left"><code>(gdb) rbreak regular-expression</code></td><td align="left">在正则表达式匹配的函数名上设置断点</td></tr><tr><td align="left"><code>(gdb) break foo if a &lt; 100</code></td><td align="left">设置<strong>条件断点</strong>，条件满足才停止</td></tr><tr><td align="left"><code>(gdb) info break</code></td><td align="left">列出所有断点位置、编号</td></tr><tr><td align="left"><code>(gdb) delete 2</code></td><td align="left">删除指定编号的断点</td></tr><tr><td align="left"><code>(gdb) clear</code></td><td align="left">删除刚才停止处的断点</td></tr><tr><td align="left"><code>(gdb) disable 1</code></td><td align="left"><code>disable</code> 指定编号的断点</td></tr><tr><td align="left"><code>(gdb) enable 1</code></td><td align="left"><code>enable</code> 指定编号的断点</td></tr></tbody></table><h3 id="watch-命令"><a href="#watch-命令" class="headerlink" title="watch 命令"></a>watch 命令</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>(gdb) watch var</code></td><td align="left">监视变量，当值变化时会输出新、旧值</td></tr><tr><td align="left"><code>(gdb) info break</code></td><td align="left">列出断点，也包括 <code>watchpoint</code></td></tr><tr><td align="left"><code>(gdb) i watch</code></td><td align="left">只列出 <code>watchpoint</code></td></tr><tr><td align="left"><code>(gdb) delete 1</code></td><td align="left">删除指定的 <code>watchpoint</code></td></tr></tbody></table><h3 id="查看变量"><a href="#查看变量" class="headerlink" title="查看变量"></a>查看变量</h3><!--rehype:wrap-class=row-span-2--><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>(gdb) info args</code></td><td align="left">查看传入参数信息</td></tr><tr><td align="left"><code>(gdb) info local</code></td><td align="left">查看当前栈帧（函数）的本地变量</td></tr><tr><td align="left"><code>(gdb) print var</code></td><td align="left">查看指定变量的值</td></tr><tr><td align="left"><code>(gdb) print/x var</code></td><td align="left">以十六进制输出变量的值</td></tr><tr><td align="left"><code>(gdb) print ptr</code></td><td align="left">假设 <code>int *ptr=&amp;a</code>，输出变量 <code>a</code> 的地址</td></tr><tr><td align="left"><code>(gdb) print *ptr</code></td><td align="left">假设 <code>int *ptr=&amp;a</code>，输出变量 <code>a</code> 的值</td></tr><tr><td align="left"><code>(gdb) print *ptr@5</code></td><td align="left">假设 <code>int ptr[5]</code>，输出数组的值</td></tr><tr><td align="left"><code>(gdb) display var</code></td><td align="left">与 <code>print</code> 作用相同，但每次停下来都自动输出变量的值</td></tr><tr><td align="left"><code>(gdb) info display</code></td><td align="left">列出所有设置了 <code>display</code> 的变量</td></tr><tr><td align="left"><code>(gdb) undisplay 1</code></td><td align="left">与 <code>display</code> 相反，不能指定变量名，只能是编号</td></tr><tr><td align="left"><code>(gdb) delete display 1</code></td><td align="left">与 <code>undisplay</code> 类似，通过编号取消显示</td></tr><tr><td align="left"><code>(gdb) whatis var</code></td><td align="left">查看变量类型</td></tr><tr><td align="left"><code>(gdb) ptype var</code></td><td align="left">比 <code>type</code> 更详细，会给出结构体的定义</td></tr></tbody></table><h3 id="导入符号表"><a href="#导入符号表" class="headerlink" title="导入符号表"></a>导入符号表</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>(gdb) add-symbol-file xxx.so 0xd0832000</code></td><td>导入 <code>xxx.so</code> 中 <code>.text</code> 部分的内容</td></tr><tr><td><code>(gdb) add-symbol-file xxx.so 0xd0832000 -s .bss 0xxxxxx</code></td><td>通过 <code>-s</code> 可以导入额外的段</td></tr><tr><td><code>(gdb) add-symbol-file xxx.so 0xd0832000 -s .data 0xxxxxx</code></td><td></td></tr></tbody></table><h3 id="frame-栈帧"><a href="#frame-栈帧" class="headerlink" title="frame 栈帧"></a>frame 栈帧</h3><p>每当一个函数被调用时，一个新的栈帧 <code>frame</code> 就会被压入栈中，栈帧包含了该函数的局部变量、参数、返回地址和其他信息，当函数执行完毕后，这个栈帧会被弹出栈并销毁。</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>(gdb) frame</code></td><td align="left">显示当前栈帧和源代码行</td></tr><tr><td align="left"><code>(gdb) backtrace</code></td><td align="left">打印出当前正在执行的所有栈帧</td></tr><tr><td align="left"><code>(gdb) backtrace 5</code></td><td align="left">只显示最近调用的 <code>5</code> 个栈帧</td></tr><tr><td align="left"><code>(gdb) frame 2</code></td><td align="left">切换到第 <code>2</code> 个栈帧，以查看信息</td></tr><tr><td align="left"><code>(gdb) up</code></td><td align="left">切换到上一级调用栈帧</td></tr><tr><td align="left"><code>(gdb) down</code></td><td align="left">切换到下一级调用栈帧</td></tr></tbody></table><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p><code>call</code> 和 <code>print</code> 调用的函数如果存在全局变量、静态变量的修改，在函数返回后会恢复到调用之前的值，这两个调用不会影响程序的状态</p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>(gdb) call func(a, b)</code></td><td align="left">调用指定的函数，不影响主线程变量</td></tr><tr><td align="left"><code>(gdb) print func(a, b)</code></td><td align="left">与 <code>call</code> 类似</td></tr><tr><td align="left"><code>(gdb) finish</code></td><td align="left">结束当前运行的函数</td></tr></tbody></table><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><!--rehype:wrap-class=row-span-2--><p><code>linux</code> 下使用 <code>kill -l</code> 查看信号编号与信号名，使用 <code>info signal</code> 查看信号的处理方式、描述等：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info signal</span><br><span class="line">Signal        Stop  Print   Pass to program Description</span><br><span class="line"></span><br><span class="line">SIGHUP        Yes   Yes     Yes             Hangup</span><br><span class="line">SIGINT        Yes   Yes     No              Interrupt</span><br><span class="line">SIGQUIT       Yes   Yes     Yes             Quit</span><br><span class="line">SIGILL        Yes   Yes     Yes             Illegal instruction</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>(gdb) signal SIGKILL</code></td><td align="left">向进程发送信号，用信号名或编号表示</td></tr><tr><td align="left"><code>(gdb) signal 9</code></td><td align="left">向进程发送信号，用信号名或编号表示</td></tr><tr><td align="left"><code>(gdb) handle &lt;signal&gt; actions</code></td><td align="left">指定信号的处理方式，选择如下，可以组合</td></tr><tr><td align="left"><code>stop/nostop</code></td><td align="left">收到信号是否停止进程，类似断点</td></tr><tr><td align="left"><code>print/noprint</code></td><td align="left">收到信号是否输出消息</td></tr><tr><td align="left"><code>pass/nopass</code></td><td align="left">是否将信号传递给程序</td></tr></tbody></table><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>(gdb) info threads</code></td><td align="left">列出所有线程，标识当前所在线程</td></tr><tr><td align="left"><code>(gdb) thread 2</code></td><td align="left">切换到编号为 <code>2</code> 的线程</td></tr><tr><td align="left"><code>(gdb) break file.c:23 thread all</code></td><td align="left">在所有线程中相应的行上设置断点</td></tr><tr><td align="left"><code>(gdb) thread apply all command</code></td><td align="left">让所有线程执行 <code>gdb</code> 命令</td></tr><tr><td align="left"><code>(gdb) thread apply ID1 ID2 command</code></td><td align="left">让指定线程执行 <code>gdb</code> 命令</td></tr><tr><td align="left"><code>(gdb) set scheduler-locking off</code></td><td align="left">所有线程都执行，这是默认值</td></tr><tr><td align="left"><code>(gdb) set scheduler-locking on</code></td><td align="left">只让当前线程执行</td></tr></tbody></table><h2 id="另见"><a href="#另见" class="headerlink" title="另见"></a>另见</h2><ul><li><a href="https://carlyleliu.github.io/2022/%E5%BA%94%E7%94%A8%E5%B4%A9%E6%BA%83%E8%B0%83%E8%AF%95%E5%88%86%E6%9E%90">应用崩溃调试分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>十大经典排序算法（动图演示）</title>
      <link href="/2022/12/18/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/"/>
      <url>/2022/12/18/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文来源于 <a href="https://www.cnblogs.com/onepixel/articles/7674659.html">www.cnblogs.com</a>，将代码实现改为了 <code>c++</code><br>文中的动态图也可以在：<a href="https://visualgo.net/zh/sorting">visualgo.net&#x2F;zh&#x2F;sorting</a> 查看，还有其他算法的可视化！<br>另一个可视化排序过程的网站：<a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">cs.usfca.edu&#x2F;~galles&#x2F;visualization&#x2F;Algorithms.html</a>，还包括数据结构的可视化</p></blockquote><h2 id="0、算法概述"><a href="#0、算法概述" class="headerlink" title="0、算法概述"></a>0、算法概述</h2><h3 id="0-1-算法分类"><a href="#0-1-算法分类" class="headerlink" title="0.1 算法分类"></a>0.1 算法分类</h3><p>十种常见排序算法可以分为两大类：</p><ul><li><strong>比较类排序</strong>：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 <code>O(nlogn)</code>，因此也称为非线性时间比较类排序。</li><li><strong>非比较类排序</strong>：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。</li></ul><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20190306165258970-1789860540.png" alt="algorithm"></p><h3 id="0-2-算法复杂度"><a href="#0-2-算法复杂度" class="headerlink" title="0.2 算法复杂度"></a>0.2 算法复杂度</h3><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20180402133438219-1946132192.png" alt="complex"></p><p><strong>相关概念</strong>：</p><ul><li><strong>稳定</strong>：如果 <code>a</code> 原本在 <code>b</code> 前面，而 <code>a=b</code>，排序之后 <code>a</code> 仍然在 <code>b</code> 的前面。</li><li><strong>不稳定</strong>：如果 <code>a</code> 原本在 <code>b</code> 的前面，而 <code>a=b</code>，排序之后 <code>a</code> 可能会出现在 <code>b</code> 的后面。</li><li><strong>时间复杂度</strong>：对排序数据的总的操作次数。反映当 <code>n</code> 变化时，操作次数呈现什么规律。</li><li><strong>空间复杂度：</strong>是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 <code>n</code> 的函数。</li></ul><h2 id="1、冒泡排序（Bubble-Sort）"><a href="#1、冒泡排序（Bubble-Sort）" class="headerlink" title="1、冒泡排序（Bubble Sort）"></a>1、冒泡排序（Bubble Sort）</h2><p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p><h3 id="1-1-算法描述"><a href="#1-1-算法描述" class="headerlink" title="1.1 算法描述"></a>1.1 算法描述</h3><ul><li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>针对所有的元素重复以上的步骤，除了最后一个；</li><li>重复步骤 1~3，直到排序完成。</li></ul><h3 id="1-2-动图演示"><a href="#1-2-动图演示" class="headerlink" title="1.2 动图演示"></a>1.2 动图演示</h3><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015223238449-2146169197.gif" alt="bubblesort"></p><h3 id="1-3-代码实现"><a href="#1-3-代码实现" class="headerlink" title="1.3 代码实现"></a>1.3 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、选择排序（Selection-Sort）"><a href="#2、选择排序（Selection-Sort）" class="headerlink" title="2、选择排序（Selection Sort）"></a>2、选择排序（Selection Sort）</h2><p>选择排序 (Selection-sort) 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h3 id="2-1-算法描述"><a href="#2-1-算法描述" class="headerlink" title="2.1 算法描述"></a>2.1 算法描述</h3><p><code>n</code> 个记录的直接选择排序可经过 <code>n-1</code> 趟直接选择排序得到有序结果。具体算法描述如下：</p><ul><li>初始状态：无序区为 <code>R[1..n]</code>，有序区为空；</li><li>第 <code>i</code> 趟排序 (<code>i=1,2,3…n-1</code>) 开始时，当前有序区和无序区分别为 <code>R[1..i-1]</code>和 <code>R(i..n)</code>。该趟排序从当前无序区中 - 选出关键字最小的记录 <code>R[k]</code>，将它与无序区的第 <code>1</code> 个记录 <code>R</code> 交换，使 <code>R[1..i]</code>和 <code>R[i+1..n)</code>分别变为记录个数增加 <code>1</code> 个的新有序区和记录个数减少 <code>1</code> 个的新无序区；</li><li><code>n-1</code> 趟结束，数组有序化了。</li></ul><h3 id="2-2-动图演示"><a href="#2-2-动图演示" class="headerlink" title="2.2 动图演示"></a>2.2 动图演示</h3><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015224719590-1433219824.gif" alt="selectsort">　　</p><h3 id="2-3-代码实现"><a href="#2-3-代码实现" class="headerlink" title="2.3 代码实现"></a>2.3 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> minIdx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        minIdx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])</span><br><span class="line">                minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minIdx != i)</span><br><span class="line">            <span class="built_in">swap</span>(arr[minIdx], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-算法分析"><a href="#2-4-算法分析" class="headerlink" title="2.4 算法分析"></a>2.4 算法分析</h3><p>表现最稳定的排序算法之一，因为无论什么数据进去都是 <code>O(n2)</code> 的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。</p><h2 id="3、插入排序（Insertion-Sort）"><a href="#3、插入排序（Insertion-Sort）" class="headerlink" title="3、插入排序（Insertion Sort）"></a>3、插入排序（Insertion Sort）</h2><p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><blockquote><p>core: 左边是有序数组，将右边未排序的第一个数插入到左边有序数组中。</p></blockquote><h3 id="3-1-算法描述"><a href="#3-1-算法描述" class="headerlink" title="3.1 算法描述"></a>3.1 算法描述</h3><p>一般来说，插入排序都采用 <code>in-place</code> 在数组上实现。具体算法描述如下：</p><ul><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤 2~5。</li></ul><h3 id="3-2-动图演示"><a href="#3-2-动图演示" class="headerlink" title="3.2 动图演示"></a>3.2 动图演示</h3><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015225645277-1151100000.gif" alt="insertsort"></p><h3 id="3-3-代码实现"><a href="#3-3-代码实现" class="headerlink" title="3.3 代码实现"></a>3.3 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> currVal, currIdx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        currIdx = i;</span><br><span class="line">        currVal = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(currIdx &gt; <span class="number">0</span> &amp;&amp; currVal &lt; arr[currIdx<span class="number">-1</span>]) &#123;</span><br><span class="line">            arr[currIdx] = arr[currIdx<span class="number">-1</span>];</span><br><span class="line">            currIdx--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[currIdx] = currVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-算法分析"><a href="#3-4-算法分析" class="headerlink" title="3.4 算法分析"></a>3.4 算法分析</h3><p>插入排序在实现上，通常采用 <code>in-place</code> 排序（即只需用到 <code>O(1)</code> 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><h2 id="4、希尔排序（Shell-Sort）"><a href="#4、希尔排序（Shell-Sort）" class="headerlink" title="4、希尔排序（Shell Sort）"></a>4、希尔排序（Shell Sort）</h2><p>1959 年 Shell 发明，第一个突破 <code>O(n2)</code> 的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫<strong>缩小增量排序</strong>。</p><blockquote><p>core: 分组插入排序，看下图吧。</p></blockquote><h3 id="4-1-算法描述"><a href="#4-1-算法描述" class="headerlink" title="4.1 算法描述"></a>4.1 算法描述</h3><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列 <code>t1，t2，…，tk</code>，其中 <code>ti&gt;tj</code>，<code>tk=1</code>；</li><li>按增量序列个数 <code>k</code>，对序列进行 <code>k</code> 趟排序；</li><li>每趟排序，根据对应的增量 <code>ti</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 <code>1</code> 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h3 id="4-2-动图演示"><a href="#4-2-动图演示" class="headerlink" title="4.2 动图演示"></a>4.2 动图演示</h3><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20180331170017421-364506073.gif" alt="shellsort"></p><h3 id="4-3-代码实现"><a href="#4-3-代码实现" class="headerlink" title="4.3 代码实现"></a>4.3 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> currVal, currIdx;</span><br><span class="line">    <span class="comment">/* gap 就是上面的 t1, t2, ... , tk，也是动图中两个相同颜色方框的间距 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = len/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap = gap/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* 希尔排序是基于插入排序，下面的过程和插入排序一致，</span></span><br><span class="line"><span class="comment">         * 通过 gap 实现了分组插入排序</span></span><br><span class="line"><span class="comment">         * 这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            currIdx = i;</span><br><span class="line">            currVal = arr[i];</span><br><span class="line">            <span class="keyword">while</span>(currIdx-gap &gt;= <span class="number">0</span> &amp;&amp; currVal &lt; arr[currIdx-gap]) &#123;</span><br><span class="line">                arr[currIdx] = arr[currIdx-gap];</span><br><span class="line">                currIdx -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[currIdx] = currVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-算法分析"><a href="#4-4-算法分析" class="headerlink" title="4.4 算法分析"></a>4.4 算法分析</h3><p>希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第 4 版）》的合著者 Robert Sedgewick 提出的。</p><h2 id="5、归并排序（Merge-Sort）"><a href="#5、归并排序（Merge-Sort）" class="headerlink" title="5、归并排序（Merge Sort）"></a>5、归并排序（Merge Sort）</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 <strong>2-路归并</strong>。</p><h3 id="5-1-算法描述"><a href="#5-1-算法描述" class="headerlink" title="5.1 算法描述"></a>5.1 算法描述</h3><ul><li>把长度为 <code>n</code> 的输入序列分成两个长度为 <code>n/2</code> 的子序列；</li><li>对这两个子序列分别采用归并排序；</li><li>将两个排序好的子序列合并成一个最终的排序序列。</li></ul><h3 id="5-2-动图演示"><a href="#5-2-动图演示" class="headerlink" title="5.2 动图演示"></a>5.2 动图演示</h3><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015230557043-37375010.gif" alt="mergesort"></p><h3 id="5-3-代码实现"><a href="#5-3-代码实现" class="headerlink" title="5.3 代码实现"></a>5.3 代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对外提供的接口只传入数组 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = arr.size();</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">2</span>)</span><br><span class="line">        mergeSortSplit(arr, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拆分数组，不能用额外空间，就只有记录左右下标 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mergeSortSplit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 还可拆分就继续分 */</span></span><br><span class="line">    <span class="type">int</span> mid = l + (r-l)/<span class="number">2</span>; <span class="comment">/* or l + ((r-l)&gt;&gt;1); 注意 &gt;&gt; 优先级低于 + */</span></span><br><span class="line">    mergeSortSplit(arr, l, mid);</span><br><span class="line">    mergeSortSplit(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">/* 到此就可以保证 (l,mid), (mid+1,r) 这两个数组是有序的了，</span></span><br><span class="line"><span class="comment">     * 现在要将这两个有序数组合并为一个有序数组 */</span></span><br><span class="line">    merge(arr, l, r, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 合并两个有序数组 (l,mid), (mid+1,r)</span></span><br><span class="line"><span class="comment"> * 下面是借助一个额外数组的合并方法，一般都用此方法 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mid)</span> &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">tmp</span><span class="params">(r-l+<span class="number">1</span>)</span>;</span><br><span class="line">    <span class="type">int</span> i = l, j = mid+<span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            tmp[t++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[t++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[t++] = arr[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        arr[i] = tmp[i-l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 合并两个有序数组 (l,mid), (mid+1,r)</span></span><br><span class="line"><span class="comment"> * 下面是原地合并方法，不过时间复杂度较高 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp; arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = l;</span><br><span class="line">    <span class="type">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="comment">// 比较两个数组的当前元素，将较小的加入结果数组</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> temp = arr[j]; <span class="comment">// 保存第二个数组的当前元素</span></span><br><span class="line">            <span class="comment">// 将第一个数组中 i 到 j-1 的所有元素向后移动一位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = j<span class="number">-1</span>; k &gt;= i; k--) &#123;</span><br><span class="line">                arr[k+<span class="number">1</span>] = arr[k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将第二个数组的当前元素插入到第一个数组的当前位置</span></span><br><span class="line">            arr[i] = temp;</span><br><span class="line">            <span class="comment">// 更新指针位置</span></span><br><span class="line">            i++;</span><br><span class="line">            mid++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-算法分析"><a href="#5-4-算法分析" class="headerlink" title="5.4 算法分析"></a>5.4 算法分析</h3><p>归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn）的时间复杂度。代价是需要额外的内存空间。</p><p>在递归过程中，每层递归都需要使用一个临时数组来存储合并的结果。但是，归并排序的递归深度最多是 <code>logn</code> 层，因此使用的临时数组的总数也是 <code>logn</code> 个。所以，空间复杂度是 <code>O(nlogn)</code>。但是，由于常数较小，在实际使用中空间复杂度通常被认为是 <code>O(n)</code>。</p><h2 id="6、快速排序（Quick-Sort）"><a href="#6、快速排序（Quick-Sort）" class="headerlink" title="6、快速排序（Quick Sort）"></a>6、快速排序（Quick Sort）</h2><p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><blockquote><p>core: 选择基准，调整数组使得比基准值小的摆放在基准前面，比基准值大的摆在基准的后面。在递归处理子数组。</p></blockquote><h3 id="6-1-算法描述"><a href="#6-1-算法描述" class="headerlink" title="6.1 算法描述"></a>6.1 算法描述</h3><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li>从数列中挑出一个元素，称为 “基准”（<code>pivot</code>）；</li><li>重新排序数列，<strong>所有元素比基准值小的摆放在基准前面</strong>，<strong>所有元素比基准值大的摆在基准的后面</strong>（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（<code>partition</code>）操作；</li><li>递归地（<code>recursive</code>）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul><h3 id="6-2-动图演示"><a href="#6-2-动图演示" class="headerlink" title="6.2 动图演示"></a>6.2 动图演示</h3><blockquote><p><a href="https://visualgo.net/zh/sorting">如果觉得太快，可在该网页逐步查看过程</a></p></blockquote><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015230936371-1413523412.gif" alt="quicksort"></p><h3 id="6-3-代码实现"><a href="#6-3-代码实现" class="headerlink" title="6.3 代码实现"></a>6.3 代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = partition(arr, l, r);</span><br><span class="line">    quickSort(arr, l, mid<span class="number">-1</span>);</span><br><span class="line">    quickSort(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 动图中的算法，如果不理解可以点开那个可视化的网页，可以逐步查看 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[l];</span><br><span class="line">    <span class="type">int</span> bigIdx = l+<span class="number">1</span>; <span class="comment">/* 记录第一个大于pivot的值的下标, -1表示不存在 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 找到pivot右边第一个大于pivot的下标 */</span></span><br><span class="line">    <span class="keyword">while</span>(bigIdx &lt;= r &amp;&amp; arr[bigIdx] &lt;= pivot) bigIdx++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果pivot右边不存在大于pivot的数，该循环不会进行，bigIdx为r+1 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = bigIdx+<span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</span><br><span class="line">            swap(arr[i], arr[bigIdx]);</span><br><span class="line">            bigIdx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 无论pivot右边是否存在大于pivot的数，bigIdx-1都是合法的下标</span></span><br><span class="line"><span class="comment">     * 如果存在，就将最后一个小于等于pivot的数和pivot交换</span></span><br><span class="line"><span class="comment">     * 如果不存在，就将数组最后一个数（也是最后一个小于等于pivot的数）和pivot交换 */</span></span><br><span class="line">    swap(arr[bigIdx<span class="number">-1</span>], arr[l]);</span><br><span class="line">    <span class="keyword">return</span> bigIdx<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意：此处的实现与动图中不一样！</span></span><br><span class="line"><span class="comment"> * 以arr[start]为基准pivot，实现arr中左边的数都小于pivot,</span></span><br><span class="line"><span class="comment"> * arr右边的数都大于pivot，返回pivot的下标。</span></span><br><span class="line"><span class="comment"> * 后续再对 pivot 的左右数组分别排序 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l = start, r = end, pivot = arr[start];</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; pivot &lt;= arr[r]) r--; <span class="comment">// 从右向左找到第一个小于基准数的数</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[l++] = arr[r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; pivot &gt;= arr[l]) l++; <span class="comment">// 从左向右找到第一个大于基准数的数</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            arr[r--] = arr[l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    arr[l] = pivot;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7、堆排序（Heap-Sort）"><a href="#7、堆排序（Heap-Sort）" class="headerlink" title="7、堆排序（Heap Sort）"></a>7、堆排序（Heap Sort）</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p><h3 id="7-1-算法描述"><a href="#7-1-算法描述" class="headerlink" title="7.1 算法描述"></a>7.1 算法描述</h3><ul><li>将初始待排序关键字序列 (<code>R1,R2...Rn</code>) 构<strong>建成大顶堆</strong>，此堆为初始的无序区；</li><li>将堆顶元素 <code>R[1]</code>与最后一个元素 <code>R[n]</code>交换，此时得到新的无序区 (<code>R1,R2,……Rn-1</code>) 和新的有序区(<code>Rn</code>), 且满足 <code>R[1,2…n-1]&lt;=R[n]</code>；</li><li>由于交换后新的堆顶 <code>R[1]</code>可能违反堆的性质，因此需要对当前无序区 (<code>R1,R2,……Rn-1</code>) 调整为新堆，然后再次将 <code>R[1]</code>与无序区最后一个元素交换，得到新的无序区 (<code>R1,R2….Rn-2</code>) 和新的有序区(<code>Rn-1,Rn</code>)。不断重复此过程直到有序区的元素个数为 <code>n-1</code>，则整个排序过程完成。</li></ul><h3 id="7-2-动图演示"><a href="#7-2-动图演示" class="headerlink" title="7.2 动图演示"></a>7.2 动图演示</h3><blockquote><p><a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html">堆排序在线演示</a></p></blockquote><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015231308699-356134237.gif" alt="heapsort"></p><h3 id="7-3-代码实现"><a href="#7-3-代码实现" class="headerlink" title="7.3 代码实现"></a>7.3 代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数组本身就可以表示堆（完全二叉树） */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = arr.size();</span><br><span class="line">    <span class="comment">/* 构建大顶堆 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 从第一个非叶子结点从下至上，从右至左调整结构 */</span></span><br><span class="line">        adjustHeap(arr, i, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        swap(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="comment">/* 重新对堆进行调整 */</span></span><br><span class="line">        adjustHeap(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> i, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (temp = arr[i]; <span class="number">2</span> * i + <span class="number">1</span> &lt; n; i = child) &#123;</span><br><span class="line">        child = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果有右孩子，且右孩子大于左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父节点大于任何一个孩子的值，则直接跳出</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= arr[child]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把较大的孩子往上移动，替换它的父节点</span></span><br><span class="line">        arr[i] = arr[child];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8、计数排序（Counting-Sort）"><a href="#8、计数排序（Counting-Sort）" class="headerlink" title="8、计数排序（Counting Sort）"></a>8、计数排序（Counting Sort）</h2><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h3 id="8-1-算法描述"><a href="#8-1-算法描述" class="headerlink" title="8.1 算法描述"></a>8.1 算法描述</h3><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；</li><li>对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。</li></ul><h3 id="8-2-动图演示"><a href="#8-2-动图演示" class="headerlink" title="8.2 动图演示"></a>8.2 动图演示</h3><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015231740840-6968181.gif" alt="counting sort"></p><h3 id="8-3-代码实现"><a href="#8-3-代码实现" class="headerlink" title="8.3 代码实现"></a>8.3 代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(maxValue+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">/* 计数 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重建 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxValue; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(count[i]--)</span><br><span class="line">            arr[t++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-算法分析"><a href="#8-4-算法分析" class="headerlink" title="8.4 算法分析"></a>8.4 算法分析</h3><p>计数排序是一个稳定的排序算法。当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法。当 k 不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。</p><h2 id="9、桶排序（Bucket-Sort）"><a href="#9、桶排序（Bucket-Sort）" class="headerlink" title="9、桶排序（Bucket Sort）"></a>9、桶排序（Bucket Sort）</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高<strong>效与否的关键就在于这个映射函数的确定</strong>。桶排序 (Bucket sort) 的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。</p><p><strong>桶排序最重要的原则：将数据分到桶的过程中，<code>映射函数</code>，必须保证 第<code>i-1</code>个桶中的数 &lt; 第 <code>i</code> 个桶中的数 &lt; 第 <code>i+1</code> 个桶中的数</strong>，这样才能使合并过程更加高效。比如使用映射函数：<code>int bucketIndex = (int)(nums[i] * bucketNum / (maxNum - minNum + 1));</code></p><h3 id="9-1-算法描述"><a href="#9-1-算法描述" class="headerlink" title="9.1 算法描述"></a>9.1 算法描述</h3><ul><li>设置一个定量的数组当作空桶；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把排好序的数据拼接起来。</li></ul><h3 id="9-2-图片演示"><a href="#9-2-图片演示" class="headerlink" title="9.2 图片演示"></a>9.2 图片演示</h3><blockquote><p><a href="https://www.cs.usfca.edu/~galles/visualization/BucketSort.html">动态演示的网页</a></p></blockquote><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015232107090-1920702011.png" alt="bucketsort"></p><h3 id="9-3-代码实现"><a href="#9-3-代码实现" class="headerlink" title="9.3 代码实现"></a>9.3 代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bucketNum = <span class="number">10</span>; <span class="comment">/* 桶的数量 */</span></span><br><span class="line">    <span class="type">int</span> bucketIndex;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&gt; bucket(bucketNum, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取数组的最大值和最小值 */</span></span><br><span class="line">    <span class="type">int</span> maxNum = arr[<span class="number">0</span>], minNum = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">        maxNum = max(maxNum, arr[i]);</span><br><span class="line">        minNum = min(minNum, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将数据映射到桶中 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">        bucketIndex = (<span class="type">int</span>)(arr[i] * bucketNum / (maxNum - minNum + <span class="number">1</span>));</span><br><span class="line">        <span class="comment">/* 这里可能出现 bucketIndex == bucketNum，需要特殊处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketIndex == bucketNum) --bucketIndex;</span><br><span class="line">        bucket[bucketIndex].emplace_back(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对每个桶中的数据排序，可以选用快排等，这里为了简洁直接调用sort */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        sort(bucket[i].begin(), bucket[i].end());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将各个桶中的数据按顺序取出，得到排序后的数组</span></span><br><span class="line"><span class="comment">     * 之所以合并过程不需要再次判断，是因为前面映射函数保证了</span></span><br><span class="line"><span class="comment">     * 第 i-1 个桶中的数 &lt; 第 i 个桶中的数 &lt; 第 i+1 个桶中的数 */</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp; v : bucket[i])</span><br><span class="line">            arr[t++] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-4-算法分析"><a href="#9-4-算法分析" class="headerlink" title="9.4 算法分析"></a>9.4 算法分析</h3><p>桶排序最好情况下使用线性时间 <code>O(n)</code>，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 <code>O(n)</code>。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><h2 id="10、基数排序（Radix-Sort）"><a href="#10、基数排序（Radix-Sort）" class="headerlink" title="10、基数排序（Radix Sort）"></a>10、基数排序（Radix Sort）</h2><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。</p><h3 id="10-1-算法描述"><a href="#10-1-算法描述" class="headerlink" title="10.1 算法描述"></a>10.1 算法描述</h3><ul><li>取得数组中的最大数，并取得位数；</li><li><code>arr</code> 为原始数组，从最低位开始取每个位组成 <code>radix</code> 数组；</li><li>对 <code>radix</code> 进行计数排序（利用计数排序适用于小范围数的特点）；</li></ul><h3 id="10-2-动图演示"><a href="#10-2-动图演示" class="headerlink" title="10.2 动图演示"></a>10.2 动图演示</h3><blockquote><p>注意看，重建时，采用的FIFO的方式</p></blockquote><p><img src="/../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015232453668-1397662527.gif" alt="radixsort"></p><h3 id="10-3-代码实现"><a href="#10-3-代码实现" class="headerlink" title="10.3 代码实现"></a>10.3 代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; &amp;arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">/* 用于判断是否继续比较高位 */</span></span><br><span class="line">    <span class="type">int</span> mod = <span class="number">10</span>, dev = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> len = arr.size();</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;&gt; radix(<span class="number">10</span>, <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(count) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 放到桶中 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            radix[(arr[i]%mod)/dev].push(arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (arr[i]/mod &gt; <span class="number">0</span>)</span><br><span class="line">                ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        mod *= <span class="number">10</span>;</span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 重建 arr */</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!radix[i].empty()) &#123;</span><br><span class="line">                arr[t++] = radix[i].front();</span><br><span class="line">                radix[i].pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-4-算法分析"><a href="#10-4-算法分析" class="headerlink" title="10.4 算法分析"></a>10.4 算法分析</h3><p>基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 <code>O(n)</code> 的时间复杂度，而且分配之后得到新的关键字序列又需要 <code>O(n)</code> 的时间复杂度。假如待排数据可以分为 <code>d</code> 个关键字，则基数排序的时间复杂度将是 <code>O(d*2n)</code> ，当然 <code>d</code> 要远远小于 <code>n</code>，因此基本上还是线性级别的。</p><p>基数排序的空间复杂度为 <code>O(n+k)</code>，其中 <code>k</code> 为桶的数量。一般来说 <code>n&gt;&gt;k</code>，因此额外空间需要大概 <code>n</code> 个左右。</p><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j+<span class="number">1</span>])</span><br><span class="line">                <span class="built_in">swap</span>(arr[j], arr[j+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> minIdx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        minIdx = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIdx])</span><br><span class="line">                minIdx = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minIdx != i)</span><br><span class="line">            <span class="built_in">swap</span>(arr[minIdx], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> currVal, currIdx;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        currIdx = i;</span><br><span class="line">        currVal = arr[i];</span><br><span class="line">        <span class="keyword">while</span>(currIdx &gt; <span class="number">0</span> &amp;&amp; currVal &lt; arr[currIdx<span class="number">-1</span>]) &#123;</span><br><span class="line">            arr[currIdx] = arr[currIdx<span class="number">-1</span>];</span><br><span class="line">            currIdx--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[currIdx] = currVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> currVal, currIdx;</span><br><span class="line">    <span class="comment">/* gap 就是上面的 t1, t2, ... , tk，也是动图中两个相同颜色方框的间距 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> gap = len/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap = gap/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">/* 希尔排序是基于插入排序，下面的过程和插入排序一致，</span></span><br><span class="line"><span class="comment">         * 通过 gap 实现了分组插入排序</span></span><br><span class="line"><span class="comment">         * 这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行 */</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            currIdx = i;</span><br><span class="line">            currVal = arr[i];</span><br><span class="line">            <span class="keyword">while</span>(currIdx-gap &gt;= <span class="number">0</span> &amp;&amp; currVal &lt; arr[currIdx-gap]) &#123;</span><br><span class="line">                arr[currIdx] = arr[currIdx-gap];</span><br><span class="line">                currIdx -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[currIdx] = currVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 合并两个有序数组 (l,mid), (mid+1,r)</span></span><br><span class="line"><span class="comment"> * 下面是借助一个额外数组的合并方法，一般都用此方法 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">tmp</span><span class="params">(r-l+<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = l, j = mid+<span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[j]) &#123;</span><br><span class="line">            tmp[t++] = arr[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[t++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[t++] = arr[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tmp[t++] = arr[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        arr[i] = tmp[i-l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 拆分数组，不能用额外空间，就只有记录左右下标 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSortSplit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">/* 还可拆分就继续分 */</span></span><br><span class="line">    <span class="type">int</span> mid = l + (r-l)/<span class="number">2</span>; <span class="comment">/* or l + ((r-l)&gt;&gt;1); 注意 &gt;&gt; 优先级低于 + */</span></span><br><span class="line">    <span class="built_in">mergeSortSplit</span>(arr, l, mid);</span><br><span class="line">    <span class="built_in">mergeSortSplit</span>(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">/* 到此就可以保证 (l,mid), (mid+1,r) 这两个数组是有序的了，</span></span><br><span class="line"><span class="comment">     * 现在要将这两个有序数组合并为一个有序数组 */</span></span><br><span class="line">    <span class="built_in">merge</span>(arr, l, r, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对外提供的接口只传入数组 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">mergeSortSplit</span>(arr, <span class="number">0</span>, len<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 动图中的算法，如果不理解可以点开那个可视化的网页，可以逐步查看 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = arr[l];</span><br><span class="line">    <span class="type">int</span> bigIdx = l+<span class="number">1</span>; <span class="comment">/* 记录第一个大于pivot的值的下标, -1表示不存在 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 找到pivot右边第一个大于pivot的下标 */</span></span><br><span class="line">    <span class="keyword">while</span>(bigIdx &lt;= r &amp;&amp; arr[bigIdx] &lt;= pivot) bigIdx++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果pivot右边不存在大于pivot的数，该循环不会进行，bigIdx为r+1 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = bigIdx+<span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[bigIdx]);</span><br><span class="line">            bigIdx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 无论pivot右边是否存在大于pivot的数，bigIdx-1都是合法的下标</span></span><br><span class="line"><span class="comment">     * 如果存在，就将最后一个小于等于pivot的数和pivot交换</span></span><br><span class="line"><span class="comment">     * 如果不存在，就将数组最后一个数（也是最后一个小于等于pivot的数）和pivot交换 */</span></span><br><span class="line">    <span class="built_in">swap</span>(arr[bigIdx<span class="number">-1</span>], arr[l]);</span><br><span class="line">    <span class="keyword">return</span> bigIdx<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = <span class="built_in">partition</span>(arr, l, r);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, l, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">quickSort</span>(arr, mid+<span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">adjustHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> i, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (temp = arr[i]; <span class="number">2</span> * i + <span class="number">1</span> &lt; n; i = child) &#123;</span><br><span class="line">        child = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果有右孩子，且右孩子大于左孩子</span></span><br><span class="line">        <span class="keyword">if</span> (child + <span class="number">1</span> &lt; n &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>]) &#123;</span><br><span class="line">            child++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果父节点大于任何一个孩子的值，则直接跳出</span></span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= arr[child]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把较大的孩子往上移动，替换它的父节点</span></span><br><span class="line">        arr[i] = arr[child];</span><br><span class="line">    &#125;</span><br><span class="line">    arr[i] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 数组本身就可以表示堆（完全二叉树） */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">/* 构建大顶堆 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">/* 从第一个非叶子结点从下至上，从右至左调整结构 */</span></span><br><span class="line">        <span class="built_in">adjustHeap</span>(arr, i, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将堆顶元素与末尾元素交换，将最大元素&quot;沉&quot;到数组末端 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="comment">/* 重新对堆进行调整 */</span></span><br><span class="line">        <span class="built_in">adjustHeap</span>(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">countingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> maxValue)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(maxValue+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">/* 计数 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        count[arr[i]]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 重建 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxValue; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(count[i]--)</span><br><span class="line">            arr[t++] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> bucketNum = <span class="number">10</span>; <span class="comment">/* 桶的数量 */</span></span><br><span class="line">    <span class="type">int</span> bucketIndex;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bucket</span>(bucketNum, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 获取数组的最大值和最小值 */</span></span><br><span class="line">    <span class="type">int</span> maxNum = arr[<span class="number">0</span>], minNum = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        maxNum = <span class="built_in">max</span>(maxNum, arr[i]);</span><br><span class="line">        minNum = <span class="built_in">min</span>(minNum, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将数据映射到桶中 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        bucketIndex = (<span class="type">int</span>)(arr[i] * bucketNum / (maxNum - minNum + <span class="number">1</span>));</span><br><span class="line">        <span class="comment">/* 这里可能出现 bucketIndex == bucketNum，需要特殊处理 */</span></span><br><span class="line">        <span class="keyword">if</span> (bucketIndex == bucketNum) --bucketIndex;</span><br><span class="line">        bucket[bucketIndex].<span class="built_in">emplace_back</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 对每个桶中的数据排序，可以选用快排等，这里为了简洁直接调用sort */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(bucket[i].<span class="built_in">begin</span>(), bucket[i].<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 将各个桶中的数据按顺序取出，得到排序后的数组</span></span><br><span class="line"><span class="comment">     * 之所以合并过程不需要再次判断，是因为前面映射函数保证了</span></span><br><span class="line"><span class="comment">     * 第 i-1 个桶中的数 &lt; 第 i 个桶中的数 &lt; 第 i+1 个桶中的数 */</span></span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; bucketNum; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> &amp; v : bucket[i])</span><br><span class="line">            arr[t++] = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">1</span>; <span class="comment">/* 用于判断是否继续比较高位 */</span></span><br><span class="line">    <span class="type">int</span> mod = <span class="number">10</span>, dev = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> len = arr.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;queue&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">radix</span>(<span class="number">10</span>, <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(count) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 放到桶中 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            radix[(arr[i]%mod)/dev].<span class="built_in">push</span>(arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (arr[i]/mod &gt; <span class="number">0</span>)</span><br><span class="line">                ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        mod *= <span class="number">10</span>;</span><br><span class="line">        dev *= <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 重建 arr */</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!radix[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                arr[t++] = radix[i].<span class="built_in">front</span>();</span><br><span class="line">                radix[i].<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">67</span>,<span class="number">23</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">65</span>,<span class="number">23</span>,<span class="number">4</span>,<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// bubbleSort(arr);</span></span><br><span class="line">    <span class="comment">// selectionSort(arr);</span></span><br><span class="line">    <span class="comment">// insertionSort(arr);</span></span><br><span class="line">    <span class="comment">// shellSort(arr);</span></span><br><span class="line">    <span class="comment">// mergeSort(arr);</span></span><br><span class="line">    <span class="comment">// quickSort(arr, 0, arr.size()-1);</span></span><br><span class="line">    <span class="comment">// heapSort(arr);</span></span><br><span class="line">    <span class="comment">// countingSort(arr, 67);</span></span><br><span class="line">    <span class="comment">// bucketSort(arr);</span></span><br><span class="line">    <span class="built_in">radixSort</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printArray</span>(arr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Algorithm </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenVSwitch-数据结构</title>
      <link href="/2022/11/01/OpenVSwitch-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2022/11/01/OpenVSwitch-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="常用宏"><a href="#常用宏" class="headerlink" title="常用宏"></a>常用宏</h2><blockquote><p>include&#x2F;openvswitch&#x2F;util.h #119</p></blockquote><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof不是C语言本身的关键词或运算符，它是GCC的一个扩展，作用正如其字面意思，用某种已有东西（变量、函数等）的类型去定义新的变量类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typeof(<span class="type">int</span> *)a, b;     <span class="comment">// 等价于 int *a, *b;</span></span><br><span class="line">typeof(a) c;           <span class="comment">// 等价于 int *c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVS_TYPEOF(OBJECT) typeof(OBJECT)</span></span><br></pre></td></tr></table></figure><h3 id="offsetof"><a href="#offsetof" class="headerlink" title="offsetof"></a>offsetof</h3><p>获取结构体<code>TYPE</code>中某个成员<code>MEMBER</code>的偏移量（相对于结构体地址）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* /usr/lib/gcc/x86_64-linux-gnu/9/include/stddef.h */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER) __builtin_offsetof (TYPE, MEMBER)</span></span><br><span class="line"><span class="comment">/* 类似于 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(TYPE, MEMBER)    ((size_t)&amp;((TYPE *)0)-&gt;MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用方法 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">char</span> a[];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output is compiler dependent */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;offsets: i=%zd; c=%zd; d=%zd a=%zd\n&quot;</span>,</span><br><span class="line">            offsetof(<span class="keyword">struct</span> s, i), offsetof(<span class="keyword">struct</span> s, c),</span><br><span class="line">            offsetof(<span class="keyword">struct</span> s, d), offsetof(<span class="keyword">struct</span> s, a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct s)=%zd\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> s));</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OBJECT-OFFSETOF"><a href="#OBJECT-OFFSETOF" class="headerlink" title="OBJECT_OFFSETOF"></a>OBJECT_OFFSETOF</h3><p>给定一个指向结构体的指针<code>OBJECT</code>，返回其成员<code>MEMBER</code>的偏移量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_OFFSETOF(OBJECT, MEMBER) offsetof(typeof(*(OBJECT)), MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用方法 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_OFFSETOF(OBJECT, MEMBER) offsetof(typeof(*(OBJECT)), MEMBER)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">char</span> a[];</span><br><span class="line">    &#125; *obj = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Output is compiler dependent */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;offsets: i=%zd; c=%zd; d=%zd a=%zd\n&quot;</span>,</span><br><span class="line">            OBJECT_OFFSETOF(obj, i), OBJECT_OFFSETOF(obj, c),</span><br><span class="line">            OBJECT_OFFSETOF(obj, d), OBJECT_OFFSETOF(obj, a));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct s)=%zd\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> s));</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CONTAINER-OF"><a href="#CONTAINER-OF" class="headerlink" title="CONTAINER_OF"></a>CONTAINER_OF</h3><p>已知结构体<code>STRUCT</code>中某个成员<code>MEMBER</code>的地址为<code>POINTER</code>，返回该结构体<code>STRUCT</code>的首地址。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* include/openvswitch/util.h #119 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTAINER_OF(POINTER, STRUCT, MEMBER)                           \</span></span><br><span class="line"><span class="meta">        ((STRUCT *) (void *) ((char *) (POINTER) - offsetof (STRUCT, MEMBER)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用方法 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONTAINER_OF(POINTER, STRUCT, MEMBER)                           \</span></span><br><span class="line"><span class="meta">        ((STRUCT *) (void *) ((char *) (POINTER) - offsetof (STRUCT, MEMBER)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">char</span> a[];</span><br><span class="line">    &#125; obj;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj addr: %p\n&quot;</span>, &amp;obj);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj addr from i: %p\n&quot;</span>, CONTAINER_OF(&amp;obj.i, <span class="keyword">struct</span> s, i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj addr from c: %p\n&quot;</span>, CONTAINER_OF(&amp;obj.c, <span class="keyword">struct</span> s, c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj addr from d: %p\n&quot;</span>, CONTAINER_OF(&amp;obj.d, <span class="keyword">struct</span> s, d));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj addr from a: %p\n&quot;</span>, CONTAINER_OF(&amp;obj.a, <span class="keyword">struct</span> s, a));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OBJECT-CONTAINING"><a href="#OBJECT-CONTAINING" class="headerlink" title="OBJECT_CONTAINING"></a>OBJECT_CONTAINING</h4><p>已知某个结构体对象中某个成员<code>MEMBER</code>的地址为<code>POINTER</code>，返回该对象的地址。</p><p>与<code>CONTAINER_OF</code>类似，<strong>只是由<code>STRUCT</code>替换为指向该结构体的指针<code>OBJECT</code>，且<code>OBJECT</code>是否为空无影响，只是用于通过<code>type_of</code>获取结构体类型。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_CONTAINING(POINTER, OBJECT, MEMBER)                      \</span></span><br><span class="line"><span class="meta">    ((OVS_TYPEOF(OBJECT)) (void *)                                      \</span></span><br><span class="line"><span class="meta">     ((char *) (POINTER) - OBJECT_OFFSETOF(OBJECT, MEMBER)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用方法 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_OFFSETOF(OBJECT, MEMBER) offsetof(typeof(*(OBJECT)), MEMBER)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OVS_TYPEOF(OBJECT) typeof(OBJECT)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OBJECT_CONTAINING(POINTER, OBJECT, MEMBER)                      \</span></span><br><span class="line"><span class="meta">    ((OVS_TYPEOF(OBJECT)) (void *)                                      \</span></span><br><span class="line"><span class="meta">     ((char *) (POINTER) - OBJECT_OFFSETOF(OBJECT, MEMBER)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="type">double</span> d;</span><br><span class="line">        <span class="type">char</span> a[];</span><br><span class="line">    &#125; obj;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">s</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>; <span class="comment">/* p 为空，但无影响 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj addr: %p\n&quot;</span>, &amp;obj);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj addr from i: %p\n&quot;</span>, OBJECT_CONTAINING(&amp;obj.i, p, i));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj addr from c: %p\n&quot;</span>, OBJECT_CONTAINING(&amp;obj.c, p, c));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj addr from d: %p\n&quot;</span>, OBJECT_CONTAINING(&amp;obj.d, p, d));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;obj addr from a: %p\n&quot;</span>, OBJECT_CONTAINING(&amp;obj.a, p, a));</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ASSIGN-CONTAINER"><a href="#ASSIGN-CONTAINER" class="headerlink" title="ASSIGN_CONTAINER"></a>ASSIGN_CONTAINER</h4><p>同上，已知某个结构体对象中某个成员<code>MEMBER</code>的地址为<code>POINTER</code>，但是<strong>将该结构体的地址赋值给<code>OBJECT</code>，返回</strong><code>(void)0</code>。</p><p><code>,</code>逗号运算符的优先级最低！所以这里是先对<code>OBJECT</code>赋值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASSIGN_CONTAINER(OBJECT, POINTER, MEMBER) \</span></span><br><span class="line"><span class="meta">    ((OBJECT) = OBJECT_CONTAINING(POINTER, OBJECT, MEMBER), (void) 0)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>; <span class="comment">/* p 为空，但无影响 */</span></span><br><span class="line">ASSIGN_CONTAINER(p, &amp;obj.i, i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;obj addr from i: %p\n&quot;</span>, p); <span class="comment">/* p == &amp;obj */</span></span><br></pre></td></tr></table></figure><h4 id="INIT-CONTAINER"><a href="#INIT-CONTAINER" class="headerlink" title="INIT_CONTAINER"></a>INIT_CONTAINER</h4><p>同上，就多个一个对<code>OBJECT</code>初始化为<code>NULL</code>的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INIT_CONTAINER(OBJECT, POINTER, MEMBER) \</span></span><br><span class="line"><span class="meta">    ((OBJECT) = NULL, ASSIGN_CONTAINER(OBJECT, POINTER, MEMBER))</span></span><br></pre></td></tr></table></figure><h3 id="BUILD-ASSERT-TYPE"><a href="#BUILD-ASSERT-TYPE" class="headerlink" title="BUILD_ASSERT_TYPE"></a>BUILD_ASSERT_TYPE</h3><p>编译过程做类型一致性检查。如果<code>POINTER</code>与指定的类型<code>TYPE</code>不匹配的话，会报编译错误。但如果给定的<code>TYPE</code>是<code>void *</code>，则可以与任意类型的<code>POINTER</code>匹配。</p><ul><li><strong>sizeof</strong>：<code>POINTER</code><strong>可以是表达式</strong>，所以这里用<code>sizeof</code><strong>来确保表达式不会被执行</strong>。</li><li>**(void)**：通过<code>(void)</code><strong>忽略</strong>函数或表达式的值，这里是<code>sizeof</code>的返回值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUILD_ASSERT_TYPE(POINTER, TYPE) \</span></span><br><span class="line"><span class="meta">    ((void) sizeof ((int) ((POINTER) == (TYPE) (POINTER))))</span></span><br></pre></td></tr></table></figure><h3 id="CONST-CAST"><a href="#CONST-CAST" class="headerlink" title="CONST_CAST"></a>CONST_CAST</h3><p>将<code>const</code>修饰的指针转为指定<code>TYPE</code>的<code>non-const</code>类型。当指定的类型<code>TYPE</code>与指针<code>POINTER</code>类型不匹配时，编译会有警告。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_CAST(TYPE, POINTER)                               \</span></span><br><span class="line"><span class="meta">    (BUILD_ASSERT_TYPE(POINTER, TYPE),                          \</span></span><br><span class="line"><span class="meta">     (TYPE) (POINTER))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用方法 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUILD_ASSERT_TYPE(POINTER, TYPE) \</span></span><br><span class="line"><span class="meta">    ((void) sizeof ((int) ((POINTER) == (TYPE) (POINTER))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONST_CAST(TYPE, POINTER)                               \</span></span><br><span class="line"><span class="meta">    (BUILD_ASSERT_TYPE(POINTER, TYPE),                          \</span></span><br><span class="line"><span class="meta">     (TYPE) (POINTER))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> constant = <span class="number">26</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>* const_p = &amp;constant;</span><br><span class="line">    <span class="type">int</span>* modifier = CONST_CAST(<span class="type">int</span> *, const_p);</span><br><span class="line">    <span class="comment">/* int* modifier = CONST_CAST(double *, const_p);</span></span><br><span class="line"><span class="comment">     * 当指定的类型 double* 与指针类型不匹配时，编译会有警告 */</span></span><br><span class="line">    *modifier = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;constant: %d\n&quot;</span>, constant);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;*modifier: %d\n&quot;</span>, *modifier);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ovs-assert"><a href="#ovs-assert" class="headerlink" title="ovs_assert"></a>ovs_assert</h3><p>当条件不满足时，会报错并输出发生错误的位置信息，用于调试阶段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ovs_assert(CONDITION)                                           \</span></span><br><span class="line"><span class="meta">    (OVS_LIKELY(CONDITION)                                              \</span></span><br><span class="line"><span class="meta">     ? (void) 0                                                         \</span></span><br><span class="line"><span class="meta">     : ovs_assert_failure(OVS_SOURCE_LOCATOR, __func__, #CONDITION))</span></span><br></pre></td></tr></table></figure><h2 id="ovs-list"><a href="#ovs-list" class="headerlink" title="ovs_list"></a>ovs_list</h2><blockquote><p>include&#x2F;openvswitch&#x2F;list.h</p><p><a href="https://zhuanlan.zhihu.com/p/58087261">Linux内核中常用的数据结构</a></p></blockquote><p>双向链表结构！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ovs_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ovs_list</span> *<span class="title">prev</span>;</span>     <span class="comment">/* Previous list element. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ovs_list</span> *<span class="title">next</span>;</span>     <span class="comment">/* Next list element. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ovs_list</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当某个结构体需要实现链表时，只需要将该<code>ovs_list</code>嵌入到结构体中。</p><p><img src="/../images/OpenVSwitch-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/OVS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-ovs_list.drawio.png" alt="ovs_list"></p><p><code>prev/next</code>指向的是<code>struct s</code>中的<code>node</code>，当需要<code>s</code>的地址时，需要通过上面的宏<code>CONTAINER_OF</code>或者<code>OBJECT_CONTAINING</code>。</p><p><strong>LIST_FOR_EACH</strong>：<code>ITER</code>为结构体的空指针<code>struct s *p = NULL</code>，遍历过程中会指向当前节点；<code>MEMBER</code>为结构体中<code>ovs_list</code>成员的名称<code>node</code>；<code>LIST</code>为链表的头节点（或者任意链表中的任意一个节点），<code>LIST</code>自身不会被遍历到；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FOR_EACH(ITER, MEMBER, LIST)                               \</span></span><br><span class="line"><span class="meta">    for (INIT_CONTAINER(ITER, (LIST)-&gt;next, MEMBER);                    \</span></span><br><span class="line"><span class="meta">         &amp;(ITER)-&gt;MEMBER != (LIST);                                     \</span></span><br><span class="line"><span class="meta">         ASSIGN_CONTAINER(ITER, (ITER)-&gt;MEMBER.next, MEMBER))</span></span><br></pre></td></tr></table></figure><p><strong>LIST_FOR_EACH_CONTINUE</strong>：同上，但<code>ITER</code>有初始值，从当前位置的下一个节点开始遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FOR_EACH_CONTINUE(ITER, MEMBER, LIST)                      \</span></span><br><span class="line"><span class="meta">    for (ASSIGN_CONTAINER(ITER, (ITER)-&gt;MEMBER.next, MEMBER);             \</span></span><br><span class="line"><span class="meta">         &amp;(ITER)-&gt;MEMBER != (LIST);                                     \</span></span><br><span class="line"><span class="meta">         ASSIGN_CONTAINER(ITER, (ITER)-&gt;MEMBER.next, MEMBER))</span></span><br></pre></td></tr></table></figure><p><strong>LIST_FOR_EACH_REVERSE</strong>：与<code>LIST_FOR_EACH</code>类似，但反向遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LIST_FOR_EACH_REVERSE(ITER, MEMBER, LIST)                       \</span></span><br><span class="line"><span class="meta">    for (INIT_CONTAINER(ITER, (LIST)-&gt;prev, MEMBER);                    \</span></span><br><span class="line"><span class="meta">         &amp;(ITER)-&gt;MEMBER != (LIST);                                     \</span></span><br><span class="line"><span class="meta">         ASSIGN_CONTAINER(ITER, (ITER)-&gt;MEMBER.prev, MEMBER))</span></span><br></pre></td></tr></table></figure><p>一个例子：</p><ul><li>将该代码放在<code>ovs</code>源码根目录下，编译时指定头文件路径：<code>gcc test.c -o test -I include</code>。</li><li>将宏定义展开：<code>gcc -E -P test.c -o test.i</code> ，直接跳转到最后看。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;openvswitch/list.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ovs_list</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">A</span> =</span> &#123;.name = <span class="string">&#x27;A&#x27;</span>, .age = <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">B</span> =</span> &#123;.name = <span class="string">&#x27;B&#x27;</span>, .age = <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">C</span> =</span> &#123;.name = <span class="string">&#x27;C&#x27;</span>, .age = <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">D</span> =</span> &#123;.name = <span class="string">&#x27;D&#x27;</span>, .age = <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ovs_list</span> <span class="title">head</span>;</span>   <span class="comment">/* 可创建一个单独的 ovs_list 作为 head */</span></span><br><span class="line">    ovs_list_init(&amp;head);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入：在 head 前面插入 A */</span></span><br><span class="line">    ovs_list_insert(&amp;head, &amp;A.node);    <span class="comment">/* A - head */</span></span><br><span class="line">    ovs_list_insert(&amp;head, &amp;B.node);    <span class="comment">/* A - B - head */</span></span><br><span class="line">    ovs_list_insert(&amp;B.node, &amp;C.node);  <span class="comment">/* A - C - B - head */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 替换：用 D 替换原来 C 的位置 */</span></span><br><span class="line">    ovs_list_replace(&amp;D.node, &amp;C.node); <span class="comment">/* A - D - B - head */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 遍历链表，输出：A - D - B */</span></span><br><span class="line">    LIST_FOR_EACH(p, node, &amp;head) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;name: %c\n&quot;</span>, p-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 删除：删除指定节点，返回删除元素的下一个节点 */</span></span><br><span class="line">    ovs_list *pl = ovs_list_remove(&amp;D.node); <span class="comment">/* pl == &amp;B.node */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hmap"><a href="#hmap" class="headerlink" title="hmap"></a>hmap</h2><blockquote><p>include&#x2F;openvswitch&#x2F;hmap.h<br>lib&#x2F;hmap.c</p><p><a href="https://www.sdnlab.com/15552.html">深入分析Hmap</a></p></blockquote><p><strong>A hash map.</strong></p><p>一种哈希桶实现。</p><ul><li>桶的数量可自动扩容、收缩，且总是<code>2^n</code>。</li><li>哈希函数就是<code>key &amp; mask</code>，这里<code>mask = 2^n-1</code>。</li><li>通过开链法解决哈希冲突。</li><li>节点数量为0或1时比较特殊。</li></ul><blockquote><p>将哈希桶的大小设置为<code>2^n</code>是为了加速。假设桶的大小为<code>len</code>，那么哈希函数就应该为<code>key % len</code>，而当<code>len = 2^n</code>时，<code>key % len == key &amp; (len - 1)</code>，相比之下，<code>&amp;</code>操作比<code>%</code>更快。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hmap</span> &#123;</span></span><br><span class="line">    <span class="comment">/* buckets 就是哈希桶，本质为指针数组（hmap_node *）</span></span><br><span class="line"><span class="comment">     * 如果 mask == 0, buckets = &amp;one */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> **<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="comment">/* one 只有当 mask == 0 时才存储数据，mask != 0, 则 one = NULL; */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> *<span class="title">one</span>;</span></span><br><span class="line">    <span class="comment">/* buckets 数组的大小为 mask + 1 */</span></span><br><span class="line">    <span class="type">size_t</span> mask;</span><br><span class="line">    <span class="comment">/* hmap 中有效 hmap_node 节点个数 */</span></span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 一个哈希映射节点，用于嵌入到被映射的数据结构中 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> hash;                <span class="comment">/* 哈希值 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> *<span class="title">next</span>;</span>     <span class="comment">/* 单链表 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/../images/OpenVSwitch-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/OVS%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-hmap.drawio.png" alt="hmap"></p><p>同样，通过<code>hmap</code>得到<code>hmap_node</code>的地址后，需要通过<code>CONTAINER_OF</code>获取对应结构体对象的地址。</p><p>常用方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">hmap_init</span><span class="params">(<span class="keyword">struct</span> hmap *)</span>;   <span class="comment">/* 初始化 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hmap_insert(HMAP, NODE, HASH)   <span class="comment">/* 插入节点 */</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_remove</span><span class="params">(<span class="keyword">struct</span> hmap *, <span class="keyword">struct</span> hmap_node *)</span>;  <span class="comment">/* 删除指定节点 */</span></span><br><span class="line"><span class="keyword">struct</span> hmap_node *<span class="title function_">hmap_random_node</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *)</span>; <span class="comment">/* 随机返回一个节点 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hmap_contains</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *, <span class="type">const</span> <span class="keyword">struct</span> hmap_node *)</span>; <span class="comment">/* 判断hmap是否包含该节点 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_destroy</span><span class="params">(<span class="keyword">struct</span> hmap *)</span>;  <span class="comment">/* 销毁hmap，释放buckets的内存，但不负责销毁hmap_node对应的资源 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_clear</span><span class="params">(<span class="keyword">struct</span> hmap *)</span>;    <span class="comment">/* 将 buckets 数组清0，大小不变，只是所有指针置为 NULL(0) */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_remove</span><span class="params">(<span class="keyword">struct</span> hmap *hmap, <span class="keyword">struct</span> hmap_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> **<span class="title">bucket</span> =</span> &amp;hmap-&gt;buckets[node-&gt;hash &amp; hmap-&gt;mask];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*bucket != node) &#123;</span><br><span class="line">        bucket = &amp;(*bucket)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    *bucket = node-&gt;next;</span><br><span class="line">    hmap-&gt;n--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HMAP_FOR_EACH_WITH_HASH</strong>：遍历 <code>HMAP</code> 中所有 <code>hash_node-&gt;hash</code> 值等于 <code>HASH</code> 的节点，<code>Node</code>实际<code>struct</code>的指针；</p><p>根据<code>HASH</code>找到哈希桶所在的下标，然后遍历对应的链表。链表中，有可能不同<code>hash</code>值的节点，这些节点会被跳过。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_WITH_HASH(NODE, MEMBER, HASH, HMAP)               \</span></span><br><span class="line"><span class="meta">    for (INIT_CONTAINER(NODE, hmap_first_with_hash(HMAP, HASH), MEMBER); \</span></span><br><span class="line"><span class="meta">         (NODE != OBJECT_CONTAINING(NULL, NODE, MEMBER))                \</span></span><br><span class="line"><span class="meta">         || ((NODE = NULL), false);                                     \</span></span><br><span class="line"><span class="meta">         ASSIGN_CONTAINER(NODE, hmap_next_with_hash(&amp;(NODE)-&gt;MEMBER),   \</span></span><br><span class="line"><span class="meta">                          MEMBER))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回下一个具有相同 hmap_node-&gt;hash 值的节点，没有返回 NULL，会跳过hash值不同的节点 */</span></span><br><span class="line"><span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_next_with_hash</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap_node *node)</span></span><br></pre></td></tr></table></figure><p><strong>HMAP_FOR_EACH_IN_BUCKET</strong>：同上，但遍历链表时，<strong>不会跳过</strong>有不同<code>hash</code>值的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_IN_BUCKET(NODE, MEMBER, HASH, HMAP)               \</span></span><br><span class="line"><span class="meta">    for (INIT_CONTAINER(NODE, hmap_first_in_bucket(HMAP, HASH), MEMBER); \</span></span><br><span class="line"><span class="meta">         (NODE != OBJECT_CONTAINING(NULL, NODE, MEMBER))                \</span></span><br><span class="line"><span class="meta">         || ((NODE = NULL), false);                                     \</span></span><br><span class="line"><span class="meta">         ASSIGN_CONTAINER(NODE, hmap_next_in_bucket(&amp;(NODE)-&gt;MEMBER), MEMBER))</span></span><br></pre></td></tr></table></figure><p><strong>HMAP_FOR_EACH</strong>：遍历<code>HMAP</code>中的所有节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH(NODE, MEMBER, HMAP) \</span></span><br><span class="line"><span class="meta">    HMAP_FOR_EACH_INIT(NODE, MEMBER, HMAP, (void) 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_INIT(NODE, MEMBER, HMAP, ...)                     \</span></span><br><span class="line"><span class="meta">    for (INIT_CONTAINER(NODE, hmap_first(HMAP), MEMBER), __VA_ARGS__;   \</span></span><br><span class="line"><span class="meta">         (NODE != OBJECT_CONTAINING(NULL, NODE, MEMBER))                \</span></span><br><span class="line"><span class="meta">         || ((NODE = NULL), false);                                     \</span></span><br><span class="line"><span class="meta">         ASSIGN_CONTAINER(NODE, hmap_next(HMAP, &amp;(NODE)-&gt;MEMBER), MEMBER))</span></span><br></pre></td></tr></table></figure><p><strong>HMAP_FOR_EACH_SAFE</strong>：遍历<code>HMAP</code>中的所有节点。</p><p>与<code>HMAP_FOR_EACH</code>相比，在进行循环条件判断时，会通过<code>NEXT</code>预取下一个节点，这意味着即使在循环过程中将<code>NODE</code>从<code>HMAP</code>中移除，仍然可正确遍历后续节点。</p><p>其实如果只是从<code>HMAP</code>中移除，上面的<code>HMAP_FOR_EACH</code>也可以，不过要是还调用了<code>free(NODE)</code>，上面的就会导致段错误，或者一些奇怪的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_SAFE(NODE, NEXT, MEMBER, HMAP) \</span></span><br><span class="line"><span class="meta">    HMAP_FOR_EACH_SAFE_INIT(NODE, NEXT, MEMBER, HMAP, (void) 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_SAFE_INIT(NODE, NEXT, MEMBER, HMAP, ...)          \</span></span><br><span class="line"><span class="meta">    for (INIT_CONTAINER(NODE, hmap_first(HMAP), MEMBER), __VA_ARGS__;   \</span></span><br><span class="line"><span class="meta">         ((NODE != OBJECT_CONTAINING(NULL, NODE, MEMBER))               \</span></span><br><span class="line"><span class="meta">          || ((NODE = NULL), false)                                     \</span></span><br><span class="line"><span class="meta">          ? INIT_CONTAINER(NEXT, hmap_next(HMAP, &amp;(NODE)-&gt;MEMBER), MEMBER), 1 \</span></span><br><span class="line"><span class="meta">          : 0);                                                         \</span></span><br><span class="line"><span class="meta">         (NODE) = (NEXT))</span></span><br></pre></td></tr></table></figure><p><strong>HMAP_FOR_EACH_CONTINUE</strong>：可以从中间某个位置（<code>NODE</code>所在位置）开始遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_CONTINUE(NODE, MEMBER, HMAP) \</span></span><br><span class="line"><span class="meta">    HMAP_FOR_EACH_CONTINUE_INIT(NODE, MEMBER, HMAP, (void) 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_CONTINUE_INIT(NODE, MEMBER, HMAP, ...)            \</span></span><br><span class="line"><span class="meta">    for (ASSIGN_CONTAINER(NODE, hmap_next(HMAP, &amp;(NODE)-&gt;MEMBER), MEMBER), \</span></span><br><span class="line"><span class="meta">         __VA_ARGS__;                                                   \</span></span><br><span class="line"><span class="meta">         (NODE != OBJECT_CONTAINING(NULL, NODE, MEMBER))                \</span></span><br><span class="line"><span class="meta">         || ((NODE = NULL), false);                                     \</span></span><br><span class="line"><span class="meta">         ASSIGN_CONTAINER(NODE, hmap_next(HMAP, &amp;(NODE)-&gt;MEMBER), MEMBER))</span></span><br></pre></td></tr></table></figure><p><strong>hmap_insert</strong>：向<code>HMAP</code>中插入节点<code>NODE</code>，新节点的哈希值为<code>HASH</code>。</p><p>该插入函数在插入节点时不会检查是否已经有同样哈希值的节点，也就是说<code>hmap</code>中可能存在哈希值相同的节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> hmap_insert(HMAP, NODE, HASH) \</span></span><br><span class="line"><span class="meta">    hmap_insert_at(HMAP, NODE, HASH, OVS_SOURCE_LOCATOR)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_insert_at</span><span class="params">(<span class="keyword">struct</span> hmap *hmap, <span class="keyword">struct</span> hmap_node *node, <span class="type">size_t</span> hash,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">char</span> *where)</span></span><br><span class="line">&#123;</span><br><span class="line">    hmap_insert_fast(hmap, node, hash);</span><br><span class="line">    <span class="keyword">if</span> (hmap-&gt;n / <span class="number">2</span> &gt; hmap-&gt;mask) &#123;</span><br><span class="line">        hmap_expand_at(hmap, where);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">hmap_insert_fast(<span class="keyword">struct</span> hmap *hmap, <span class="keyword">struct</span> hmap_node *node, <span class="type">size_t</span> hash)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> **<span class="title">bucket</span> =</span> &amp;hmap-&gt;buckets[hash &amp; hmap-&gt;mask];</span><br><span class="line">    node-&gt;hash = hash;</span><br><span class="line">    node-&gt;next = *bucket;</span><br><span class="line">    *bucket = node;</span><br><span class="line">    hmap-&gt;n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个例子：</p><ul><li>将该代码放在<code>ovs</code>源码根目录下，编译时指定头文件路径：<code>gcc test.c -o test -I include</code>，<code>hmap.h</code>也需要一点修改才能编译。</li><li>将宏定义展开：<code>gcc -E -P test.c -o test.p -I include -I .</code> ，直接跳转到最后看。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;openvswitch/hmap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">element</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> <span class="title">node</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i, N_ELEMS = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> values[N_ELEMS];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">elem</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap</span> <span class="title">hmap</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> *<span class="title">data</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    hmap_init(&amp;hmap);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N_ELEMS; i++) &#123;</span><br><span class="line">        <span class="comment">/* 动态分配元素，设置每个元素的hash为 下标+1 */</span></span><br><span class="line">        elem = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> element));</span><br><span class="line">        elem-&gt;value = i+<span class="number">1</span>;</span><br><span class="line">        hmap_insert(&amp;hmap, &amp;elem-&gt;node, i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">/* 查看 hmap 自动扩容 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i+1 = %ld, hmap.mask = %ld, .n = %ld\n&quot;</span>, i, hmap.mask, hmap.n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------遍历 hash 值为3的节点 \n&quot;</span>);</span><br><span class="line">    HMAP_FOR_EACH_WITH_HASH(elem, node, <span class="number">3</span>, &amp;hmap) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;elem .value = %d, .hash = %ld\n&quot;</span>, elem-&gt;value, elem-&gt;node.hash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------遍历 hash 值为3 所在 buckets 的全部节点 \n&quot;</span>);</span><br><span class="line">    HMAP_FOR_EACH_IN_BUCKET(elem, node, <span class="number">3</span>, &amp;hmap) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;elem .value = %d, .hash = %ld\n&quot;</span>, elem-&gt;value, elem-&gt;node.hash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------遍历 map，删除值为10的节点 \n&quot;</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">element</span> *<span class="title">next</span>;</span></span><br><span class="line">    HMAP_FOR_EACH_SAFE(elem, next, node, &amp;hmap) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;elem .value = %d, .hash = %ld\n&quot;</span>, elem-&gt;value, elem-&gt;node.hash);</span><br><span class="line">        <span class="keyword">if</span> (elem-&gt;value == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;free elem\n&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(elem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;--------------------遍历 hmap，删除值为11的节点 \n&quot;</span>);</span><br><span class="line">    HMAP_FOR_EACH(elem, node, &amp;hmap) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;elem .value = %d, .hash = %ld\n&quot;</span>, elem-&gt;value, elem-&gt;node.hash);</span><br><span class="line">        <span class="keyword">if</span> (elem-&gt;value == <span class="number">11</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;free elem\n&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(elem);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hmap_destroy(&amp;hmap);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>include&#x2F;openvswitch&#x2F;hmap.h 需要将<code>hmap.c</code>中的实现暂时放到<code>hmap.h</code>中才能正确编译，而且还注释了一些其他外部函数调用。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HMAP_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_H 1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;openvswitch/util.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* A hash map node, to be embedded inside the data structure being mapped. */</span></span><br><span class="line"><span class="comment">/* 一个哈希映射节点，用于嵌入到被映射的数据结构中。 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> hash;                <span class="comment">/* Hash value. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> *<span class="title">next</span>;</span>     <span class="comment">/* Next in linked list. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the hash value embedded in &#x27;node&#x27;. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">hmap_node_hash</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_NODE_NULL ((struct hmap_node *) 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_NODE_NULL_INITIALIZER &#123; 0, HMAP_NODE_NULL &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns true if &#x27;node&#x27; has been set to null by hmap_node_nullify() and has</span></span><br><span class="line"><span class="comment"> * not been un-nullified by being inserted into an hmap. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">hmap_node_is_null</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;next == HMAP_NODE_NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Marks &#x27;node&#x27; with a distinctive value that can be tested with</span></span><br><span class="line"><span class="comment"> * hmap_node_is_null().  */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_node_nullify</span><span class="params">(<span class="keyword">struct</span> hmap_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    node-&gt;next = HMAP_NODE_NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A hash map. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hmap</span> &#123;</span></span><br><span class="line">    <span class="comment">/* buckets 就是哈希桶，本质为指针数组（hmap_node *）</span></span><br><span class="line"><span class="comment">     * 如果 mask == 0, buckets = &amp;one */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> **<span class="title">buckets</span>;</span></span><br><span class="line">    <span class="comment">/* one 只有当 mask == 0 时才存储数据，mask != 0, 则 one = NULL; */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> *<span class="title">one</span>;</span></span><br><span class="line">    <span class="comment">/* buckets 数组的大小为 mask + 1, mask总是 2^n - 1.</span></span><br><span class="line"><span class="comment">    * (节点hash值 &amp; mask)：该节点在buckets数组中的下标 */</span></span><br><span class="line">    <span class="type">size_t</span> mask;</span><br><span class="line">    <span class="comment">/* buckets 中实际有效 hmap_node 节点个数，当 n &gt; 2*mask + 1时才会扩容 */</span></span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initializer for an empty hash map. */</span></span><br><span class="line"><span class="comment">/* 初始化 hmap &#123;buckets = &amp;one, one = NULL, mask = 0, n = 0&#125; */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_INITIALIZER(HMAP) \</span></span><br><span class="line"><span class="meta">    &#123; (struct hmap_node **const) &amp;(HMAP)-&gt;one, NULL, 0, 0 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initializer for an immutable struct hmap &#x27;HMAP&#x27; that contains &#x27;N&#x27; nodes</span></span><br><span class="line"><span class="comment"> * linked together starting at &#x27;NODE&#x27;.  The hmap only has a single chain of</span></span><br><span class="line"><span class="comment"> * hmap_nodes, so &#x27;N&#x27; should be small. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_CONST(HMAP, N, NODE) &#123;                                 \</span></span><br><span class="line"><span class="meta">        CONST_CAST(struct hmap_node **, &amp;(HMAP)-&gt;one), NODE, 0, N &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initialization. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_init</span><span class="params">(<span class="keyword">struct</span> hmap *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_destroy</span><span class="params">(<span class="keyword">struct</span> hmap *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_clear</span><span class="params">(<span class="keyword">struct</span> hmap *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_swap</span><span class="params">(<span class="keyword">struct</span> hmap *a, <span class="keyword">struct</span> hmap *b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_moved</span><span class="params">(<span class="keyword">struct</span> hmap *hmap)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span> <span class="title function_">hmap_count</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">hmap_is_empty</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Adjusting capacity. */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_expand_at</span><span class="params">(<span class="keyword">struct</span> hmap *, <span class="type">const</span> <span class="type">char</span> *where)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hmap_expand(HMAP) hmap_expand_at(HMAP, OVS_SOURCE_LOCATOR)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_shrink_at</span><span class="params">(<span class="keyword">struct</span> hmap *, <span class="type">const</span> <span class="type">char</span> *where)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hmap_shrink(HMAP) hmap_shrink_at(HMAP, OVS_SOURCE_LOCATOR)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_reserve_at</span><span class="params">(<span class="keyword">struct</span> hmap *, <span class="type">size_t</span> capacity, <span class="type">const</span> <span class="type">char</span> *where)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hmap_reserve(HMAP, CAPACITY) \</span></span><br><span class="line"><span class="meta">    hmap_reserve_at(HMAP, CAPACITY, OVS_SOURCE_LOCATOR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Insertion and deletion. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hmap_insert_at</span><span class="params">(<span class="keyword">struct</span> hmap *, <span class="keyword">struct</span> hmap_node *,</span></span><br><span class="line"><span class="params">                                  <span class="type">size_t</span> hash, <span class="type">const</span> <span class="type">char</span> *where)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> hmap_insert(HMAP, NODE, HASH) \</span></span><br><span class="line"><span class="meta">    hmap_insert_at(HMAP, NODE, HASH, OVS_SOURCE_LOCATOR)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hmap_insert_fast</span><span class="params">(<span class="keyword">struct</span> hmap *,</span></span><br><span class="line"><span class="params">                                    <span class="keyword">struct</span> hmap_node *, <span class="type">size_t</span> hash)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hmap_remove</span><span class="params">(<span class="keyword">struct</span> hmap *, <span class="keyword">struct</span> hmap_node *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hmap_node_moved</span><span class="params">(<span class="keyword">struct</span> hmap *, <span class="keyword">struct</span> hmap_node *, <span class="keyword">struct</span> hmap_node *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">hmap_replace</span><span class="params">(<span class="keyword">struct</span> hmap *, <span class="type">const</span> <span class="keyword">struct</span> hmap_node *old,</span></span><br><span class="line"><span class="params">                                <span class="keyword">struct</span> hmap_node *new_node)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hmap_node *<span class="title function_">hmap_random_node</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * HMAP_FOR_EACH_WITH_HASH 遍历 HMAP 中所有hash值等于HASH的 NODE。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * HMAP_FOR_EACH_IN_BUCKET 在HMAP中所有与HASH属于同一桶的节点上迭代 NODE。</span></span><br><span class="line"><span class="comment"> * iterates NODE over all of the nodes in HMAP that would fall in the same bucket as HASH.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NODE 是包含 &#x27;struct hmap_node&#x27; 的结构体名称。</span></span><br><span class="line"><span class="comment"> * MEMBER 必须是 NODE中 &#x27;struct hmap_node&#x27; 成员的名称。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These macros may be used interchangeably to search for a particular value in</span></span><br><span class="line"><span class="comment"> * an hmap, see, e.g. shash_find() for an example.  Usually, using</span></span><br><span class="line"><span class="comment"> * HMAP_FOR_EACH_WITH_HASH provides an optimization, because comparing a hash</span></span><br><span class="line"><span class="comment"> * value is usually cheaper than comparing an entire hash map key.  But for</span></span><br><span class="line"><span class="comment"> * simple hash map keys, it makes sense to use HMAP_FOR_EACH_IN_BUCKET because</span></span><br><span class="line"><span class="comment"> * it avoids doing two comparisons when a single simple comparison suffices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The loop should not change NODE to point to a different node or insert or</span></span><br><span class="line"><span class="comment"> * delete nodes in HMAP (unless it &quot;break&quot;s out of the loop to terminate</span></span><br><span class="line"><span class="comment"> * iteration).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * HASH is only evaluated once.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When the loop terminates normally, meaning the iteration has completed</span></span><br><span class="line"><span class="comment"> * without using &#x27;break&#x27;, NODE will be NULL.  This is true for all of the</span></span><br><span class="line"><span class="comment"> * HMAP_FOR_EACH_*() macros.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_WITH_HASH(NODE, MEMBER, HASH, HMAP)               \</span></span><br><span class="line"><span class="meta">    for (INIT_CONTAINER(NODE, hmap_first_with_hash(HMAP, HASH), MEMBER); \</span></span><br><span class="line"><span class="meta">         (NODE != OBJECT_CONTAINING(NULL, NODE, MEMBER))                \</span></span><br><span class="line"><span class="meta">         || ((NODE = NULL), false);                                     \</span></span><br><span class="line"><span class="meta">         ASSIGN_CONTAINER(NODE, hmap_next_with_hash(&amp;(NODE)-&gt;MEMBER),   \</span></span><br><span class="line"><span class="meta">                          MEMBER))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_IN_BUCKET(NODE, MEMBER, HASH, HMAP)               \</span></span><br><span class="line"><span class="meta">    for (INIT_CONTAINER(NODE, hmap_first_in_bucket(HMAP, HASH), MEMBER); \</span></span><br><span class="line"><span class="meta">         (NODE != OBJECT_CONTAINING(NULL, NODE, MEMBER))                \</span></span><br><span class="line"><span class="meta">         || ((NODE = NULL), false);                                     \</span></span><br><span class="line"><span class="meta">         ASSIGN_CONTAINER(NODE, hmap_next_in_bucket(&amp;(NODE)-&gt;MEMBER), MEMBER))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *<span class="title function_">hmap_first_with_hash</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *,</span></span><br><span class="line"><span class="params">                                                     <span class="type">size_t</span> hash)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *<span class="title function_">hmap_next_with_hash</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap_node *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *<span class="title function_">hmap_first_in_bucket</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *,</span></span><br><span class="line"><span class="params">                                                     <span class="type">size_t</span> hash)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *<span class="title function_">hmap_next_in_bucket</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap_node *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hmap_contains</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *, <span class="type">const</span> <span class="keyword">struct</span> hmap_node *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Iteration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The *_INIT variants of these macros additionally evaluate the expressions</span></span><br><span class="line"><span class="comment"> * supplied following the HMAP argument once during the loop initialization.</span></span><br><span class="line"><span class="comment"> * This makes it possible for data structures that wrap around hmaps to insert</span></span><br><span class="line"><span class="comment"> * additional initialization into their iteration macros without having to</span></span><br><span class="line"><span class="comment"> * completely rewrite them.  In particular, it can be a good idea to insert</span></span><br><span class="line"><span class="comment"> * BUILD_ASSERT_TYPE checks for map and node types that wrap hmap, since</span></span><br><span class="line"><span class="comment"> * otherwise it is possible for clients to accidentally confuse two derived</span></span><br><span class="line"><span class="comment"> * data structures that happen to use the same member names for struct hmap and</span></span><br><span class="line"><span class="comment"> * struct hmap_node. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Iterates through every node in HMAP. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH(NODE, MEMBER, HMAP) \</span></span><br><span class="line"><span class="meta">    HMAP_FOR_EACH_INIT(NODE, MEMBER, HMAP, (void) 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_INIT(NODE, MEMBER, HMAP, ...)                     \</span></span><br><span class="line"><span class="meta">    for (INIT_CONTAINER(NODE, hmap_first(HMAP), MEMBER), __VA_ARGS__;   \</span></span><br><span class="line"><span class="meta">         (NODE != OBJECT_CONTAINING(NULL, NODE, MEMBER))                \</span></span><br><span class="line"><span class="meta">         || ((NODE = NULL), false);                                     \</span></span><br><span class="line"><span class="meta">         ASSIGN_CONTAINER(NODE, hmap_next(HMAP, &amp;(NODE)-&gt;MEMBER), MEMBER))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Safe when NODE may be freed (not needed when NODE may be removed from the</span></span><br><span class="line"><span class="comment"> * hash map but its members remain accessible and intact). */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_SAFE(NODE, NEXT, MEMBER, HMAP) \</span></span><br><span class="line"><span class="meta">    HMAP_FOR_EACH_SAFE_INIT(NODE, NEXT, MEMBER, HMAP, (void) 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_SAFE_INIT(NODE, NEXT, MEMBER, HMAP, ...)          \</span></span><br><span class="line"><span class="meta">    for (INIT_CONTAINER(NODE, hmap_first(HMAP), MEMBER), __VA_ARGS__;   \</span></span><br><span class="line"><span class="meta">         ((NODE != OBJECT_CONTAINING(NULL, NODE, MEMBER))               \</span></span><br><span class="line"><span class="meta">          || ((NODE = NULL), false)                                     \</span></span><br><span class="line"><span class="meta">          ? INIT_CONTAINER(NEXT, hmap_next(HMAP, &amp;(NODE)-&gt;MEMBER), MEMBER), 1 \</span></span><br><span class="line"><span class="meta">          : 0);                                                         \</span></span><br><span class="line"><span class="meta">         (NODE) = (NEXT))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Continues an iteration from just after NODE. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_CONTINUE(NODE, MEMBER, HMAP) \</span></span><br><span class="line"><span class="meta">    HMAP_FOR_EACH_CONTINUE_INIT(NODE, MEMBER, HMAP, (void) 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_CONTINUE_INIT(NODE, MEMBER, HMAP, ...)            \</span></span><br><span class="line"><span class="meta">    for (ASSIGN_CONTAINER(NODE, hmap_next(HMAP, &amp;(NODE)-&gt;MEMBER), MEMBER), \</span></span><br><span class="line"><span class="meta">         __VA_ARGS__;                                                   \</span></span><br><span class="line"><span class="meta">         (NODE != OBJECT_CONTAINING(NULL, NODE, MEMBER))                \</span></span><br><span class="line"><span class="meta">         || ((NODE = NULL), false);                                     \</span></span><br><span class="line"><span class="meta">         ASSIGN_CONTAINER(NODE, hmap_next(HMAP, &amp;(NODE)-&gt;MEMBER), MEMBER))</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_pop_helper__</span><span class="params">(<span class="keyword">struct</span> hmap *hmap, <span class="type">size_t</span> *bucket)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; *bucket &lt;= hmap-&gt;mask; (*bucket)++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> *<span class="title">node</span> =</span> hmap-&gt;buckets[*bucket];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            hmap_remove(hmap, node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HMAP_FOR_EACH_POP(NODE, MEMBER, HMAP)                               \</span></span><br><span class="line"><span class="meta">    for (size_t bucket__ = 0;                                               \</span></span><br><span class="line"><span class="meta">         INIT_CONTAINER(NODE, hmap_pop_helper__(HMAP, &amp;bucket__), MEMBER),  \</span></span><br><span class="line"><span class="meta">         (NODE != OBJECT_CONTAINING(NULL, NODE, MEMBER))                    \</span></span><br><span class="line"><span class="meta">         || ((NODE = NULL), false);)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *<span class="title function_">hmap_first</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *<span class="title function_">hmap_next</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *,</span></span><br><span class="line"><span class="params">                                          <span class="type">const</span> <span class="keyword">struct</span> hmap_node *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hmap_position</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> bucket;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> offset;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hmap_node *<span class="title function_">hmap_at_position</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *,</span></span><br><span class="line"><span class="params">                                   <span class="keyword">struct</span> hmap_position *)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the number of nodes currently in &#x27;hmap&#x27;. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">hmap_count</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *hmap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hmap-&gt;n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the maximum number of nodes that &#x27;hmap&#x27; may hold before it should be</span></span><br><span class="line"><span class="comment"> * rehashed. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">hmap_capacity</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *hmap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hmap-&gt;mask * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns true if &#x27;hmap&#x27; currently contains no nodes,</span></span><br><span class="line"><span class="comment"> * false otherwise.</span></span><br><span class="line"><span class="comment"> * Note: While hmap in general is not thread-safe without additional locking,</span></span><br><span class="line"><span class="comment"> * hmap_is_empty() is. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span></span><br><span class="line"><span class="title function_">hmap_is_empty</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *hmap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hmap-&gt;n == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Inserts &#x27;node&#x27;, with the given &#x27;hash&#x27;, into &#x27;hmap&#x27;.  &#x27;hmap&#x27; is never</span></span><br><span class="line"><span class="comment"> * expanded automatically. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_insert_fast</span><span class="params">(<span class="keyword">struct</span> hmap *hmap, <span class="keyword">struct</span> hmap_node *node, <span class="type">size_t</span> hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> **<span class="title">bucket</span> =</span> &amp;hmap-&gt;buckets[hash &amp; hmap-&gt;mask];</span><br><span class="line">    node-&gt;hash = hash;</span><br><span class="line">    node-&gt;next = *bucket;</span><br><span class="line">    *bucket = node;</span><br><span class="line">    hmap-&gt;n++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用给定的&#x27;hash&#x27;值将&#x27;node&#x27;插入到&#x27;hmap&#x27;中，并在必要时扩容&#x27;hmap&#x27;以优化搜索性能</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;where&#x27;用于调试日志记录。通常使用 hmap_insert() 自动提供</span></span><br><span class="line"><span class="comment"> * 调用者的源文件和where的行号。*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_insert_at</span><span class="params">(<span class="keyword">struct</span> hmap *hmap, <span class="keyword">struct</span> hmap_node *node, <span class="type">size_t</span> hash,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">char</span> *where)</span></span><br><span class="line">&#123;</span><br><span class="line">    hmap_insert_fast(hmap, node, hash);</span><br><span class="line">    <span class="comment">/* 如果hmap中实际节点的数量超过容量的一半时，进行翻倍扩容 */</span></span><br><span class="line">    <span class="keyword">if</span> (hmap-&gt;n / <span class="number">2</span> &gt; hmap-&gt;mask) &#123;</span><br><span class="line">        hmap_expand_at(hmap, where);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Removes &#x27;node&#x27; from &#x27;hmap&#x27;.  Does not shrink the hash table; call</span></span><br><span class="line"><span class="comment"> * hmap_shrink() directly if desired. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_remove</span><span class="params">(<span class="keyword">struct</span> hmap *hmap, <span class="keyword">struct</span> hmap_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> **<span class="title">bucket</span> =</span> &amp;hmap-&gt;buckets[node-&gt;hash &amp; hmap-&gt;mask];</span><br><span class="line">    <span class="keyword">while</span> (*bucket != node) &#123;</span><br><span class="line">        bucket = &amp;(*bucket)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    *bucket = node-&gt;next;</span><br><span class="line">    hmap-&gt;n--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Puts &#x27;new_node&#x27; in the position in &#x27;hmap&#x27; currently occupied by &#x27;old_node&#x27;.</span></span><br><span class="line"><span class="comment"> * The &#x27;new_node&#x27; must hash to the same value as &#x27;old_node&#x27;.  The client is</span></span><br><span class="line"><span class="comment"> * responsible for ensuring that the replacement does not violate any</span></span><br><span class="line"><span class="comment"> * client-imposed invariants (e.g. uniqueness of keys within a map).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Afterward, &#x27;old_node&#x27; is not part of &#x27;hmap&#x27;, and the client is responsible</span></span><br><span class="line"><span class="comment"> * for freeing it (if this is desirable). */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_replace</span><span class="params">(<span class="keyword">struct</span> hmap *hmap,</span></span><br><span class="line"><span class="params">             <span class="type">const</span> <span class="keyword">struct</span> hmap_node *old_node, <span class="keyword">struct</span> hmap_node *new_node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> **<span class="title">bucket</span> =</span> &amp;hmap-&gt;buckets[old_node-&gt;hash &amp; hmap-&gt;mask];</span><br><span class="line">    <span class="keyword">while</span> (*bucket != old_node) &#123;</span><br><span class="line">        bucket = &amp;(*bucket)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    *bucket = new_node;</span><br><span class="line">    new_node-&gt;hash = old_node-&gt;hash;</span><br><span class="line">    new_node-&gt;next = old_node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_next_with_hash__</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap_node *node, <span class="type">size_t</span> hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">NULL</span> &amp;&amp; node-&gt;hash != hash) &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CONST_CAST(<span class="keyword">struct</span> hmap_node *, node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the first node in &#x27;hmap&#x27; with the given &#x27;hash&#x27;, or a null pointer if</span></span><br><span class="line"><span class="comment"> * no nodes have that hash value. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_first_with_hash</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *hmap, <span class="type">size_t</span> hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hmap_next_with_hash__(hmap-&gt;buckets[hash &amp; hmap-&gt;mask], hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the first node in &#x27;hmap&#x27; in the bucket in which the given &#x27;hash&#x27;</span></span><br><span class="line"><span class="comment"> * would land, or a null pointer if that bucket is empty. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_first_in_bucket</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *hmap, <span class="type">size_t</span> hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hmap-&gt;buckets[hash &amp; hmap-&gt;mask];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the next node in the same bucket as &#x27;node&#x27;, or a null pointer if</span></span><br><span class="line"><span class="comment"> * there are no more nodes in that bucket.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the hash map has been reallocated since &#x27;node&#x27; was visited, some nodes</span></span><br><span class="line"><span class="comment"> * may be skipped; if new nodes with the same hash value have been added, they</span></span><br><span class="line"><span class="comment"> * will be skipped.  (Removing &#x27;node&#x27; from the hash map does not prevent</span></span><br><span class="line"><span class="comment"> * calling this function, since node-&gt;next is preserved, although freeing</span></span><br><span class="line"><span class="comment"> * &#x27;node&#x27; of course does.) */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_next_in_bucket</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> node-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the next node in the same hash map as &#x27;node&#x27; with the same hash</span></span><br><span class="line"><span class="comment"> * value, or a null pointer if no more nodes have that hash value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the hash map has been reallocated since &#x27;node&#x27; was visited, some nodes</span></span><br><span class="line"><span class="comment"> * may be skipped; if new nodes with the same hash value have been added, they</span></span><br><span class="line"><span class="comment"> * will be skipped.  (Removing &#x27;node&#x27; from the hash map does not prevent</span></span><br><span class="line"><span class="comment"> * calling this function, since node-&gt;next is preserved, although freeing</span></span><br><span class="line"><span class="comment"> * &#x27;node&#x27; of course does.) */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_next_with_hash</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hmap_next_with_hash__(node-&gt;next, node-&gt;hash);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_next__</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *hmap, <span class="type">size_t</span> start)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = start; i &lt;= hmap-&gt;mask; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> *<span class="title">node</span> =</span> hmap-&gt;buckets[i];</span><br><span class="line">        <span class="keyword">if</span> (node) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the first node in &#x27;hmap&#x27;, in arbitrary order, or a null pointer if</span></span><br><span class="line"><span class="comment"> * &#x27;hmap&#x27; is empty. */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_first</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *hmap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hmap_next__(hmap, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the next node in &#x27;hmap&#x27; following &#x27;node&#x27;, in arbitrary order, or a</span></span><br><span class="line"><span class="comment"> * null pointer if &#x27;node&#x27; is the last node in &#x27;hmap&#x27;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the hash map has been reallocated since &#x27;node&#x27; was visited, some nodes</span></span><br><span class="line"><span class="comment"> * may be skipped or visited twice.  (Removing &#x27;node&#x27; from the hash map does</span></span><br><span class="line"><span class="comment"> * not prevent calling this function, since node-&gt;next is preserved, although</span></span><br><span class="line"><span class="comment"> * freeing &#x27;node&#x27; of course does.) */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_next</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *hmap, <span class="type">const</span> <span class="keyword">struct</span> hmap_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (node-&gt;next</span><br><span class="line">            ? node-&gt;next</span><br><span class="line">            : hmap_next__(hmap, (node-&gt;hash &amp; hmap-&gt;mask) + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Initializes &#x27;hmap&#x27; as an empty hash table. */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_init</span><span class="params">(<span class="keyword">struct</span> hmap *hmap)</span></span><br><span class="line">&#123;</span><br><span class="line">    hmap-&gt;buckets = &amp;hmap-&gt;one;</span><br><span class="line">    hmap-&gt;one = <span class="literal">NULL</span>;</span><br><span class="line">    hmap-&gt;mask = <span class="number">0</span>;</span><br><span class="line">    hmap-&gt;n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Frees memory reserved by &#x27;hmap&#x27;.  It is the client&#x27;s responsibility to free</span></span><br><span class="line"><span class="comment"> * the nodes themselves, if necessary. */</span></span><br><span class="line"><span class="comment">/* 释放 hmap 分配的内存，但仅仅释放 hmap 自身的指针数组的内存，</span></span><br><span class="line"><span class="comment"> * 并不负责释放 嵌入hmap_node的结构 的内存 */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_destroy</span><span class="params">(<span class="keyword">struct</span> hmap *hmap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (hmap &amp;&amp; hmap-&gt;buckets != &amp;hmap-&gt;one) &#123;</span><br><span class="line">        <span class="built_in">free</span>(hmap-&gt;buckets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 移除 hmap 的 buckets 中的所有节点，留出空间接收新的节点，没有释放hamp的内存</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is appropriate when &#x27;hmap&#x27; will soon have about as many</span></span><br><span class="line"><span class="comment"> * elements as it did before.  If &#x27;hmap&#x27; will likely have fewer elements than</span></span><br><span class="line"><span class="comment"> * before, use hmap_destroy() followed by hmap_init() to save memory and</span></span><br><span class="line"><span class="comment"> * iteration time.</span></span><br><span class="line"><span class="comment"> * 当&#x27;hmap&#x27;很快将拥有和以前一样多的元素时，此函数是合适的。如果&#x27;hmap&#x27;可能比以前有更少的元素，</span></span><br><span class="line"><span class="comment"> * 使用hmap_destroy()和hmap_init()来节省内存和迭代时间。*/</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_clear</span><span class="params">(<span class="keyword">struct</span> hmap *hmap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (hmap-&gt;n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        hmap-&gt;n = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* 将 buckets 数组清0 */</span></span><br><span class="line">        <span class="built_in">memset</span>(hmap-&gt;buckets, <span class="number">0</span>, (hmap-&gt;mask + <span class="number">1</span>) * <span class="keyword">sizeof</span> *hmap-&gt;buckets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exchanges hash maps &#x27;a&#x27; and &#x27;b&#x27;. */</span></span><br><span class="line"><span class="comment">/* 注意此处不是指针赋值！！而是结构体赋值（每个成员赋值）*/</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_swap</span><span class="params">(<span class="keyword">struct</span> hmap *a, <span class="keyword">struct</span> hmap *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap</span> <span class="title">tmp</span> =</span> *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">    hmap_moved(a);</span><br><span class="line">    hmap_moved(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Adjusts &#x27;hmap&#x27; to compensate for having moved position in memory (e.g. due</span></span><br><span class="line"><span class="comment"> * to realloc()). */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_moved</span><span class="params">(<span class="keyword">struct</span> hmap *hmap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hmap-&gt;mask) &#123;</span><br><span class="line">        hmap-&gt;buckets = &amp;hmap-&gt;one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 1. 先以新的容量大小new_mask+1创建一个临时hmap，</span></span><br><span class="line"><span class="comment"> * 2. 再遍历原hmap中的节点，调用hmap_insert 插入到临时hmap中。</span></span><br><span class="line"><span class="comment"> * 3. 交换两个hmap, swap(hmap, tmp);</span></span><br><span class="line"><span class="comment"> * 4. 销毁tmp(即原来的hmap)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">resize</span><span class="params">(<span class="keyword">struct</span> hmap *hmap, <span class="type">size_t</span> new_mask, <span class="type">const</span> <span class="type">char</span> *where)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap</span> <span class="title">tmp</span>;</span></span><br><span class="line">    <span class="type">size_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 再次检查指定的mask是否合理（2^n - 1） */</span></span><br><span class="line">    <span class="comment">// ovs_assert(is_pow2(new_mask + 1));</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 1. 先以新的容量大小new_mask+1创建一个临时hmap */</span></span><br><span class="line">    hmap_init(&amp;tmp);</span><br><span class="line">    <span class="keyword">if</span> (new_mask) &#123;</span><br><span class="line">        tmp.buckets = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *tmp.buckets * (new_mask + <span class="number">1</span>));</span><br><span class="line">        tmp.mask = new_mask;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= tmp.mask; i++) &#123;</span><br><span class="line">            tmp.buckets[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n_big_buckets = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> biggest_count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n_biggest_buckets = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 2. 再遍历原hmap中的节点，调用hmap_insert 插入到临时hmap中 */</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= hmap-&gt;mask; i++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> *<span class="title">node</span>, *<span class="title">next</span>;</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (node = hmap-&gt;buckets[i]; node; node = next) &#123;</span><br><span class="line">            next = node-&gt;next;</span><br><span class="line">            hmap_insert_fast(&amp;tmp, node, node-&gt;hash);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            n_big_buckets++;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; biggest_count) &#123;</span><br><span class="line">                biggest_count = count;</span><br><span class="line">                n_biggest_buckets = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == biggest_count) &#123;</span><br><span class="line">                n_biggest_buckets++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 3. 交换两个hmap, swap(hmap, tmp); */</span></span><br><span class="line">    hmap_swap(hmap, &amp;tmp);</span><br><span class="line">    <span class="comment">/* 4. 销毁tmp (即原来的hmap) */</span></span><br><span class="line">    hmap_destroy(&amp;tmp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if (n_big_buckets) &#123;</span></span><br><span class="line">    <span class="comment">//     static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(10, 10);</span></span><br><span class="line">    <span class="comment">//     COVERAGE_INC(hmap_pathological);</span></span><br><span class="line">    <span class="comment">//     VLOG_DBG_RL(&amp;rl, &quot;%s: %d bucket%s with 6+ nodes, &quot;</span></span><br><span class="line">    <span class="comment">//                 &quot;including %d bucket%s with %d nodes &quot;</span></span><br><span class="line">    <span class="comment">//                 &quot;(%&quot;PRIuSIZE&quot; nodes total across %&quot;PRIuSIZE&quot; buckets)&quot;,</span></span><br><span class="line">    <span class="comment">//                 where,</span></span><br><span class="line">    <span class="comment">//                 n_big_buckets, n_big_buckets &gt; 1 ? &quot;s&quot; : &quot;&quot;,</span></span><br><span class="line">    <span class="comment">//                 n_biggest_buckets, n_biggest_buckets &gt; 1 ? &quot;s&quot; : &quot;&quot;,</span></span><br><span class="line">    <span class="comment">//                 biggest_count,</span></span><br><span class="line">    <span class="comment">//                 hmap-&gt;n, hmap-&gt;mask + 1);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* hmap的buckets的大小必须是2^n，capacity只是一个参考值，</span></span><br><span class="line"><span class="comment"> * 经过计算，实际取的大小是 &lt;= capacity 的一个2^n 的数，而mask则是2^n - 1.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">calc_mask</span><span class="params">(<span class="type">size_t</span> capacity)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> mask = capacity / <span class="number">2</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">2</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">4</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">8</span>;</span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">16</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SIZE_MAX &gt; UINT32_MAX</span></span><br><span class="line">    mask |= mask &gt;&gt; <span class="number">32</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we need to dynamically allocate buckets we might as well allocate at</span></span><br><span class="line"><span class="comment">     * least 4 of them. */</span></span><br><span class="line">    mask |= (mask &amp; <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果需要，扩容“hmap”以优化搜索的性能。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;where&#x27; 用于DEBUG日志记录。通常使用 hmap_insert() 自动提供调用者的源文件</span></span><br><span class="line"><span class="comment"> * 和 &#x27;where&#x27; 的行号。*/</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_expand_at</span><span class="params">(<span class="keyword">struct</span> hmap *hmap, <span class="type">const</span> <span class="type">char</span> *where)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> new_mask = calc_mask(hmap-&gt;n);</span><br><span class="line">    <span class="keyword">if</span> (new_mask &gt; hmap-&gt;mask) &#123;</span><br><span class="line">        <span class="comment">// COVERAGE_INC(hmap_expand);</span></span><br><span class="line">        resize(hmap, new_mask, where);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果需要，收缩“hmap”以优化迭代的性能</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;where&#x27; 用于DEBUG日志记录。通常使用 hmap_insert() 自动提供调用者的源文件</span></span><br><span class="line"><span class="comment"> * 和 &#x27;where&#x27; 的行号。*/</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_shrink_at</span><span class="params">(<span class="keyword">struct</span> hmap *hmap, <span class="type">const</span> <span class="type">char</span> *where)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> new_mask = calc_mask(hmap-&gt;n);</span><br><span class="line">    <span class="keyword">if</span> (new_mask &lt; hmap-&gt;mask) &#123;</span><br><span class="line">        <span class="comment">// COVERAGE_INC(hmap_shrink);</span></span><br><span class="line">        resize(hmap, new_mask, where);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果有必要，扩容&#x27;hmap&#x27;，以优化当它有&#x27;n&#x27;个元素时的搜索性能。</span></span><br><span class="line"><span class="comment"> * (但是在一个已分配容量远远高于当前节点数量的哈希映射中，迭代速度会很慢)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &#x27;where&#x27; 用于DEBUG日志记录。通常使用 hmap_insert() 自动提供调用者的源文件</span></span><br><span class="line"><span class="comment"> * 和 &#x27;where&#x27; 的行号。*/</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_reserve_at</span><span class="params">(<span class="keyword">struct</span> hmap *hmap, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span> *where)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> new_mask = calc_mask(n);</span><br><span class="line">    <span class="keyword">if</span> (new_mask &gt; hmap-&gt;mask) &#123;</span><br><span class="line">        <span class="comment">// COVERAGE_INC(hmap_reserve);</span></span><br><span class="line">        resize(hmap, new_mask, where);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Adjusts &#x27;hmap&#x27; to compensate for &#x27;old_node&#x27; having moved position in memory</span></span><br><span class="line"><span class="comment"> * to &#x27;node&#x27; (e.g. due to realloc()). */</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">hmap_node_moved</span><span class="params">(<span class="keyword">struct</span> hmap *hmap,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> hmap_node *old_node, <span class="keyword">struct</span> hmap_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> **<span class="title">bucket</span> =</span> &amp;hmap-&gt;buckets[node-&gt;hash &amp; hmap-&gt;mask];</span><br><span class="line">    <span class="keyword">while</span> (*bucket != old_node) &#123;</span><br><span class="line">        bucket = &amp;(*bucket)-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    *bucket = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从&#x27;hmap&#x27;中选择并返回一个随机选择的节点，该 hmap 不能为空</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I wouldn&#x27;t depend on this algorithm to be fair, since I haven&#x27;t analyzed it.</span></span><br><span class="line"><span class="comment"> * But it does at least ensure that any node in &#x27;hmap&#x27; can be chosen. */</span></span><br><span class="line"><span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_random_node</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *hmap)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> *<span class="title">bucket</span>, *<span class="title">node</span>;</span></span><br><span class="line">    <span class="type">size_t</span> n, i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Choose a random non-empty bucket. */</span></span><br><span class="line">    <span class="comment">// for (;;) &#123;</span></span><br><span class="line">    <span class="comment">//     bucket = hmap-&gt;buckets[random_uint32() &amp; hmap-&gt;mask];</span></span><br><span class="line">    <span class="comment">//     if (bucket) &#123;</span></span><br><span class="line">    <span class="comment">//         break;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Count nodes in bucket. */</span></span><br><span class="line">    <span class="comment">// n = 0;</span></span><br><span class="line">    <span class="comment">// for (node = bucket; node; node = node-&gt;next) &#123;</span></span><br><span class="line">    <span class="comment">//     n++;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Choose random node from bucket. */</span></span><br><span class="line">    <span class="comment">// i = random_range(n);</span></span><br><span class="line">    <span class="comment">// i = n-1;</span></span><br><span class="line">    <span class="comment">// for (node = bucket; i-- &gt; 0; node = node-&gt;next) &#123;</span></span><br><span class="line">    <span class="comment">//     continue;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns the next node in &#x27;hmap&#x27; in hash order, or NULL if no nodes remain in</span></span><br><span class="line"><span class="comment"> * &#x27;hmap&#x27;.  Uses &#x27;*pos&#x27; to determine where to begin iteration, and updates</span></span><br><span class="line"><span class="comment"> * &#x27;*pos&#x27; to pass on the next iteration into them before returning.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It&#x27;s better to use plain HMAP_FOR_EACH and related functions, since they are</span></span><br><span class="line"><span class="comment"> * faster and better at dealing with hmaps that change during iteration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Before beginning iteration, set &#x27;*pos&#x27; to all zeros. */</span></span><br><span class="line"><span class="keyword">struct</span> hmap_node *</span><br><span class="line"><span class="title function_">hmap_at_position</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *hmap,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> hmap_position *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> offset;</span><br><span class="line">    <span class="type">size_t</span> b_idx;</span><br><span class="line"></span><br><span class="line">    offset = pos-&gt;offset;</span><br><span class="line">    <span class="keyword">for</span> (b_idx = pos-&gt;bucket; b_idx &lt;= hmap-&gt;mask; b_idx++) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> *<span class="title">node</span>;</span></span><br><span class="line">        <span class="type">size_t</span> n_idx;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (n_idx = <span class="number">0</span>, node = hmap-&gt;buckets[b_idx]; node != <span class="literal">NULL</span>;</span><br><span class="line">             n_idx++, node = node-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n_idx == offset) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;next) &#123;</span><br><span class="line">                    pos-&gt;bucket = node-&gt;hash &amp; hmap-&gt;mask;</span><br><span class="line">                    pos-&gt;offset = offset + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    pos-&gt;bucket = (node-&gt;hash &amp; hmap-&gt;mask) + <span class="number">1</span>;</span><br><span class="line">                    pos-&gt;offset = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        offset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos-&gt;bucket = <span class="number">0</span>;</span><br><span class="line">    pos-&gt;offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Returns true if &#x27;node&#x27; is in &#x27;hmap&#x27;, false otherwise. */</span></span><br><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">hmap_contains</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmap *hmap, <span class="type">const</span> <span class="keyword">struct</span> hmap_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (p = hmap_first_in_bucket(hmap, node-&gt;hash); p; p = p-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p == node) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>  __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* hmap.h */</span></span></span><br></pre></td></tr></table></figure><h2 id="smap"><a href="#smap" class="headerlink" title="smap"></a>smap</h2><p><strong>a map from string to string.</strong></p><p>同样是在<code>hmap</code>上进行扩展，该结构的<code>key</code>和<code>value</code>均为字符串，<code>hash</code>由<code>key</code>计算得到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">smap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap</span> <span class="title">map</span>;</span>           <span class="comment">/* Contains &quot;struct smap_node&quot;s. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">smap_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> <span class="title">node</span>;</span>     <span class="comment">/* In struct smap&#x27;s &#x27;map&#x27; hmap. */</span></span><br><span class="line">    <span class="type">char</span> *key;</span><br><span class="line">    <span class="type">char</span> *value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="simap"><a href="#simap" class="headerlink" title="simap"></a>simap</h2><p><strong>A map from strings to unsigned integers.</strong></p><p>与<code>smap</code>类似，<code>hash</code>值是由字符串<code>name</code>计算得到，只不过<code>value</code>变为了<code>unsigned int</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simap</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap</span> <span class="title">map</span>;</span>            <span class="comment">/* Contains &quot;struct simap_node&quot;s. */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simap_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> <span class="title">node</span>;</span>      <span class="comment">/* In struct simap&#x27;s &#x27;map&#x27; hmap. */</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="shash"><a href="#shash" class="headerlink" title="shash"></a>shash</h2><p><strong>a map from string(char *name) to</strong> <code>void *data</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shash_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> <span class="title">node</span>;</span></span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shash</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap</span> <span class="title">map</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>SHASH_FOR_EACH</strong>：遍历<code>SHASH</code>这个map中的节点，将节点地址赋值给<code>SHASH_NODE</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHASH_FOR_EACH(SHASH_NODE, SHASH)                               \</span></span><br><span class="line"><span class="meta">    HMAP_FOR_EACH_INIT (SHASH_NODE, node, &amp;(SHASH)-&gt;map,                \</span></span><br><span class="line"><span class="meta">                        BUILD_ASSERT_TYPE(SHASH_NODE, struct shash_node *), \</span></span><br><span class="line"><span class="meta">                        BUILD_ASSERT_TYPE(SHASH, struct shash *))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shash</span> <span class="title">wanted_ports</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shash_node</span> *<span class="title">port_node</span>;</span></span><br><span class="line">SHASH_FOR_EACH (port_node, &amp;wanted_ports) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ovsrec_port</span> *<span class="title">port_cfg</span> =</span> port_node-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 向 shash 中插入一个elem，插入时先做检查，如果已经存在，就返回false，不存在才添加 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">shash_add_once</span><span class="params">(<span class="keyword">struct</span> shash *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">void</span> *)</span>;</span><br><span class="line"><span class="comment">/* 字面意思，如果sh中已经存在该key(name)，那就替换value为新的data，并返回旧的data（得free掉）。</span></span><br><span class="line"><span class="comment"> * 如果sh中不存在该name，那就将其加进去。字符串name会被拷贝！！data不会被拷贝。 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shash_replace</span><span class="params">(<span class="keyword">struct</span> shash *sh, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">void</span> *data)</span>;</span><br><span class="line"><span class="comment">/* 同上，但name也不会被拷贝 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shash_replace_nocopy</span><span class="params">(<span class="keyword">struct</span> shash *, <span class="type">char</span> *name, <span class="type">const</span> <span class="type">void</span> *data)</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="sset"><a href="#sset" class="headerlink" title="sset"></a>sset</h2><p><strong>A set of strings.</strong></p><p><code>hash</code>值是由<code>name</code>计算得到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sset_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> <span class="title">hmap_node</span>;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">1</span>];   <span class="comment">/* 不定长结构 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sset</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap</span> <span class="title">map</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>sset_add</strong>：添加一个字符串<code>name</code>到<code>sset</code>中，如果<code>name</code>已经存在，则返回<code>NULL</code>，否则返回新建的<code>sset_node</code>节点。</p><p>注意传递的字符串会进行拷贝，<code>malloc</code> 的大小是基于字符串的长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> sset_node *</span><br><span class="line"><span class="title function_">sset_add</span><span class="params">(<span class="keyword">struct</span> sset *<span class="built_in">set</span>, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> length = <span class="built_in">strlen</span>(name);</span><br><span class="line">    <span class="type">uint32_t</span> hash = hash_name__(name, length);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (sset_find__(<span class="built_in">set</span>, name, hash)</span><br><span class="line">            ? <span class="literal">NULL</span></span><br><span class="line">            : sset_add__(<span class="built_in">set</span>, name, length, hash));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> sset_node *</span><br><span class="line"><span class="title function_">sset_add__</span><span class="params">(<span class="keyword">struct</span> sset *<span class="built_in">set</span>, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">size_t</span> length, <span class="type">size_t</span> hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sset_node</span> *<span class="title">node</span> =</span> xmalloc(length + <span class="keyword">sizeof</span> *node); <span class="comment">/* malloc的大小是基于字符串的长度 */</span></span><br><span class="line">    <span class="built_in">memcpy</span>(node-&gt;name, name, length + <span class="number">1</span>);</span><br><span class="line">    hmap_insert(&amp;<span class="built_in">set</span>-&gt;<span class="built_in">map</span>, &amp;node-&gt;hmap_node, hash);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hmapx"><a href="#hmapx" class="headerlink" title="hmapx"></a>hmapx</h2><p><strong>A set of</strong> <code>void *</code> <strong>pointers</strong>.</p><p>在<code>hmap</code>上进行了扩展，实现了一个<code>set</code>。</p><p><code>hmap</code>在使用时，往往是将<code>hmap_node</code>嵌入到某个结构体中，结构体是可以用户自定义的。而且该节点的<code>key</code>也就是<code>hash</code>值是用户指定的。</p><p><code>hmapx</code>就没有<code>hmap</code>那样的通用性，<code>hmapx_node</code>就是上面描述的嵌入了<code>hmap_node</code>的结构体，该结构体只有一个成员<code>void *data</code>。另一个特殊在于节点的<code>hash</code>值不能指定，而是基于<code>data</code>的地址自动计算。</p><p><code>hmapx</code>也可以看作<code>key-value</code>，<code>key</code>是<code>void *data</code>，<code>value</code>也是，所以不会存在两个节点相同，也就是实现了<code>set</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hmapx_node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap_node</span> <span class="title">hmap_node</span>;</span></span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hmapx</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmap</span> <span class="title">map</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> hmapx_node *</span><br><span class="line"><span class="title function_">hmapx_add</span><span class="params">(<span class="keyword">struct</span> hmapx *<span class="built_in">map</span>, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> hash = hash_pointer(data, <span class="number">0</span>);  <span class="comment">/* 基于data存储的地址计算hash */</span></span><br><span class="line">    <span class="keyword">return</span> (hmapx_find__(<span class="built_in">map</span>, data, hash)</span><br><span class="line">            ? <span class="literal">NULL</span></span><br><span class="line">            : hmapx_add__(<span class="built_in">map</span>, data, hash));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hmapx</code>查找是否存在某个<code>data</code>时，是通过直接比较<code>data</code>指针是否相等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> hmapx_node *</span><br><span class="line"><span class="title function_">hmapx_find</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmapx *<span class="built_in">map</span>, <span class="type">const</span> <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hmapx_find__(<span class="built_in">map</span>, data, hash_pointer(data, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> hmapx_node *</span><br><span class="line"><span class="title function_">hmapx_find__</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hmapx *<span class="built_in">map</span>, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> hash)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hmapx_node</span> *<span class="title">node</span>;</span></span><br><span class="line"></span><br><span class="line">    HMAP_FOR_EACH_IN_BUCKET (node, hmap_node, hash, &amp;<span class="built_in">map</span>-&gt;<span class="built_in">map</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;data == data) &#123;   <span class="comment">/* 比较指针是否相等 */</span></span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HMAPX_FOR_EACH</strong>：遍历<code>hmapx</code>中的每一个<code>hmapx_node</code>节点。<code>struct hmap_node *NODE;</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HMAPX_FOR_EACH(NODE, HMAPX)                                     \</span></span><br><span class="line"><span class="meta">    HMAP_FOR_EACH_INIT(NODE, hmap_node, &amp;(HMAPX)-&gt;map,                  \</span></span><br><span class="line"><span class="meta">                       BUILD_ASSERT_TYPE(NODE, struct hmapx_node *),    \</span></span><br><span class="line"><span class="meta">                       BUILD_ASSERT_TYPE(HMAPX, struct hmapx *))</span></span><br></pre></td></tr></table></figure><p><strong>HMAPX_FOR_EACH_SAFE</strong>：与<code>HMAP_FOR_EACH_SAFE</code>类似。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HMAPX_FOR_EACH_SAFE(NODE, NEXT, HMAPX)                          \</span></span><br><span class="line"><span class="meta">    HMAP_FOR_EACH_SAFE_INIT(NODE, NEXT, hmap_node, &amp;(HMAPX)-&gt;map,       \</span></span><br><span class="line"><span class="meta">                            BUILD_ASSERT_TYPE(NODE, struct hmapx_node *), \</span></span><br><span class="line"><span class="meta">                            BUILD_ASSERT_TYPE(NEXT, struct hmapx_node *), \</span></span><br><span class="line"><span class="meta">                            BUILD_ASSERT_TYPE(HMAPX, struct hmapx *))</span></span><br></pre></td></tr></table></figure><h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><hr><h2 id="cmap"><a href="#cmap" class="headerlink" title="cmap"></a>cmap</h2><blockquote><p><a href="https://www.youtube.com/watch?v=GPiJUtdiUlo">How Cuckoo Hashing Work Part 1 (Introduction to Cuckoo Hashing)</a><br><a href="https://www.youtube.com/watch?v=wGjOZhK11ms">How Cuckoo Hashing Work Part 2 - Introduction to Cuckoo Hashing</a></p><p><a href="https://jishuin.proginn.com/p/763bfbd338d0">五大类共13种哈希算法</a></p></blockquote><p><strong>Concurrent hash map.</strong></p><p>实现不再是基于<code>hmap</code>，完全是另一套方式，最主要的特点是<strong>支持并发操作</strong>。</p><p>基本结构与<code>hmap</code>类似，也是一种哈希桶，<code>mask</code>和<code>n</code>的意义也相同。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmap</span> &#123;</span></span><br><span class="line">    OVSRCU_TYPE(<span class="keyword">struct</span> cmap_impl *) impl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmap_impl</span> &#123;</span></span><br><span class="line">    PADDED_MEMBERS_CACHELINE_MARKER(CACHE_LINE_SIZE, cacheline0,</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> n;             <span class="comment">/* Number of in-use elements. */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> max_n;         <span class="comment">/* Max elements before enlarging. */</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> min_n;         <span class="comment">/* Min elements before shrinking. */</span></span><br><span class="line">        <span class="type">uint32_t</span> mask;              <span class="comment">/* Number of &#x27;buckets&#x27;, minus one. */</span></span><br><span class="line">        <span class="type">uint32_t</span> basis;             <span class="comment">/* Basis for rehashing client&#x27;s</span></span><br><span class="line"><span class="comment">                                       hash values. */</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    PADDED_MEMBERS_CACHELINE_MARKER(CACHE_LINE_SIZE, cacheline1,</span><br><span class="line">        <span class="keyword">struct</span> cmap_bucket buckets[<span class="number">1</span>];</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="skiplist"><a href="#skiplist" class="headerlink" title="skiplist"></a>skiplist</h2><blockquote><p>lib&#x2F;skiplist.h<br>lib&#x2F;skiplist.c</p><p><a href="https://www.jianshu.com/p/9d8296562806">Skip List–跳表</a></p></blockquote><p><img src="/../images/OpenVSwitch-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/webp.webp" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Skiplist container */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">skiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplist_node</span> *<span class="title">header</span>;</span> <span class="comment">/* Pointer to head node (not first</span></span><br><span class="line"><span class="comment">                                   * data node). */</span></span><br><span class="line">    skiplist_comparator *cmp;     <span class="comment">/* Pointer to the skiplist&#x27;s comparison</span></span><br><span class="line"><span class="comment">                                   * function. */</span></span><br><span class="line">    <span class="type">void</span> *cfg;                    <span class="comment">/* Pointer to optional comparison</span></span><br><span class="line"><span class="comment">                                   * configuration, used by the comparator. */</span></span><br><span class="line">    <span class="type">int</span> level;                    <span class="comment">/* Maximum level currently in use. */</span></span><br><span class="line">    <span class="type">uint32_t</span> size;                <span class="comment">/* Current number of nodes in skiplist. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="pvector"><a href="#pvector" class="headerlink" title="pvector"></a>pvector</h2><blockquote><p>lib&#x2F;pvector.h</p></blockquote><p><strong>Concurrent Priority Vector</strong>.</p><p>优先级<code>vector</code>，支持并发操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pvector_entry</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pvector_impl</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_size_t</span> size;   <span class="comment">/* Number of entries in the vector. */</span></span><br><span class="line">    <span class="type">size_t</span> allocated;     <span class="comment">/* Number of allocated entries. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pvector_entry</span> <span class="title">vector</span>[];</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Concurrent priority vector. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pvector</span> &#123;</span></span><br><span class="line">    OVSRCU_TYPE(<span class="keyword">struct</span> pvector_impl *) impl;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pvector_impl</span> *<span class="title">temp</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="ds"><a href="#ds" class="headerlink" title="ds"></a>ds</h2><blockquote><p>include&#x2F;openvswitch&#x2F;dynamic-string.h</p></blockquote><p>动态扩容的字符串结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ds</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> *<span class="built_in">string</span>;       <span class="comment">/* Null-terminated string. */</span></span><br><span class="line">    <span class="type">size_t</span> length;      <span class="comment">/* Bytes used, not including null terminator. */</span></span><br><span class="line">    <span class="type">size_t</span> allocated;   <span class="comment">/* Bytes allocated, not including null terminator. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="svec"><a href="#svec" class="headerlink" title="svec"></a>svec</h2><blockquote><p>lib&#x2F;svec.h</p></blockquote><p>字符串<code>vector</code>，可自动扩容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">svec</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> **names;</span><br><span class="line">    <span class="type">size_t</span> n;</span><br><span class="line">    <span class="type">size_t</span> allocated;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>svec</code>中的字符串可能是无序的，提供了方法<code>svec_sort</code>对其按字典序排序（快排），调用其某些方法要求先对其排序。</p><hr><h2 id="pbytes"><a href="#pbytes" class="headerlink" title="pbytes"></a>pbytes</h2><blockquote><p>lib&#x2F;byteq.h</p></blockquote><p><strong>General-purpose circular queue of bytes.</strong> 以字节为单位的循环队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">byteq</span> &#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> *buffer;            <span class="comment">/* Circular queue. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> size;          <span class="comment">/* Number of bytes allocated for &#x27;buffer&#x27;. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> head;          <span class="comment">/* Head of queue. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> tail;          <span class="comment">/* Chases the head. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="ovs-rcu"><a href="#ovs-rcu" class="headerlink" title="ovs-rcu"></a>ovs-rcu</h2><blockquote><p>lib&#x2F;ovs-rcu.h</p><p><a href="https://blog.csdn.net/qq_33095733/article/details/123708142">Linux RCU机制</a></p></blockquote><p> 原子指针变量可以很方便地实现一个无锁算法；但有一个大问题：当 writer 将这个针指向一个新的数据结构时，其他线程可能正在读旧的版本，问题是，当所有用到这个旧的版本的线程完成操作后，怎么 free 这个旧的版本！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="ovs-thread"><a href="#ovs-thread" class="headerlink" title="ovs-thread"></a>ovs-thread</h2><blockquote><p>lib&#x2F;ovs-thread.h<br>lib&#x2F;ovs-thread.c</p></blockquote><h3 id="一次性初始化"><a href="#一次性初始化" class="headerlink" title="一次性初始化"></a>一次性初始化</h3><p>在多线程环境下，某些初始化函数要求执行一次，并且也<strong>只能执行一次</strong>。所以需要一些机制来保证。</p><p>在<code>pthread</code>库中，实现了函数<code>pthread_once(once,void (*init)(void)))</code>，其中<code>once</code>是一个静态变量，用于记录该初始化操作是否执行过，而<code>init</code>是进行初始化操作的函数。</p><p><code>ovs</code>对此进行了一点扩展，或者说实现了一套类似的机制：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ovsthread_once</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> done;               <span class="comment">/* Non-atomic, false negatives possible. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ovs_mutex</span> <span class="title">mutex</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="poll-loop"><a href="#poll-loop" class="headerlink" title="poll-loop"></a>poll-loop</h2><blockquote><p>include&#x2F;openvswitch&#x2F;poll-loop.h</p><p>这里也涉及到线程一次性初始化和线程特有数据，参见《Linux-Unix系统编程手册》第31章。</p></blockquote><hr><h2 id="coverage"><a href="#coverage" class="headerlink" title="coverage"></a>coverage</h2><blockquote><p>lib&#x2F;coverage.h<br>lib&#x2F;coverage.c</p><p><a href="https://segmentfault.com/a/1190000011375770">gcov的例子</a></p></blockquote><p><strong>统计代码覆盖率</strong>（用于检查某段代码执行了多少次），可以看看<a href="https://segmentfault.com/a/1190000011375770">gcov</a>的例子，不过<code>OVS</code>中使用的<code>coverage</code>很轻量级，而且需要主动调用<code>COVERAGE_INC</code>才能进行统计。</p><hr><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><blockquote><p>include&#x2F;openvswitch&#x2F;json.h<br>lib&#x2F;json.c</p><p><a href="https://www.runoob.com/json/json-syntax.html">JSON 语法</a></p></blockquote><p><strong>JSON 的两种结构</strong>：</p><p><strong>1、对象：</strong>大括号 <strong>{}</strong> 保存的对象是一个无序的<strong>名称&#x2F;值</strong>对集合。一个对象以左括号 <strong>{</strong> 开始， 右括号 <strong>}</strong> 结束。每个”键”后跟一个冒号 <strong>:<strong>，</strong>名称&#x2F;值</strong>对使用逗号 <strong>,</strong> 分隔。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;菜鸟教程&quot;</span> <span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span><span class="string">&quot;www.runoob.com&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>2、数组：</strong>中括号 <strong>[]</strong> 保存的数组是值（value）的有序集合。一个数组以左中括号 <strong>[</strong> 开始， 右中括号 <strong>]</strong> 结束，值之间使用逗号 <strong>,</strong> 分隔。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;sites&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;菜鸟教程&quot;</span> <span class="punctuation">,</span> <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span><span class="string">&quot;www.runoob.com&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;google&quot;</span> <span class="punctuation">,</span> <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span><span class="string">&quot;www.google.com&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;微博&quot;</span> <span class="punctuation">,</span> <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span><span class="string">&quot;www.weibo.com&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>一个<code>json</code>对象中，数据是以<code>key:value</code>的形式存在的，<code>key</code>总是字符串<code>&quot;string&quot;</code>，<code>value</code>是可以嵌套的，可以是：</p><ul><li>数字（整数或浮点数）<code>&quot;key&quot; : 3.14</code></li><li>字符串（在双引号中）<code>&quot;key&quot; : &quot;value&quot;</code></li><li>逻辑值（true 或 false）<code>&quot;key&quot; : true</code></li><li>数组（在中括号中，多个<code>value</code>）<code>&quot;key&quot; : [3.14, 6, 7, 8]</code></li><li>对象（在大括号中）<code>&quot;key&quot; : &#123; &quot;subkey&quot;: &quot;subvalue&quot; &#125;</code></li><li>null, <code>&quot;key&quot; : null</code></li></ul><p>在<code>ovs</code>中，<code>json</code>的<code>value</code>的结构为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A JSON value. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">json</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">json_type</span> <span class="title">type</span>;</span></span><br><span class="line">    <span class="type">size_t</span> count;  <span class="comment">/* type为object时，表示对象中键值对的个数，其他类型时count=1 */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">shash</span> *<span class="title">object</span>;</span>   <span class="comment">/* Contains &quot;struct json *&quot;s. */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">json_array</span> <span class="title">array</span>;</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> integer;</span><br><span class="line">        <span class="type">double</span> real;</span><br><span class="line">        <span class="type">char</span> *<span class="built_in">string</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>value</code>只可能是上面列举的几种类型之一，因此这里用<code>union</code>结构。并通过<code>json_type</code>指示<code>value</code>的类型，从而进行不同的操作。另外，对于逻辑值<code>true/false</code>以及<code>null</code>，只需要用<code>json_type</code>就足以说明，因此<code>union</code>中并不存在这三者的成员。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type of a JSON value. */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">json_type</span> &#123;</span></span><br><span class="line">    JSON_NULL,                  <span class="comment">/* null */</span></span><br><span class="line">    JSON_FALSE,                 <span class="comment">/* false */</span></span><br><span class="line">    JSON_TRUE,                  <span class="comment">/* true */</span></span><br><span class="line">    JSON_OBJECT,                <span class="comment">/* &#123;&quot;a&quot;: b, &quot;c&quot;: d, ...&#125; */</span></span><br><span class="line">    JSON_ARRAY,                 <span class="comment">/* [1, 2, 3, ...] */</span></span><br><span class="line">    JSON_INTEGER,               <span class="comment">/* 123. */</span></span><br><span class="line">    JSON_REAL,                  <span class="comment">/* 123.456. */</span></span><br><span class="line">    JSON_STRING,                <span class="comment">/* &quot;...&quot; */</span></span><br><span class="line">    JSON_N_TYPES                <span class="comment">/* 没有实现 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>json</code>数组中存储的值也都是一个<code>value</code>，分配内存采用了<code>c++</code>中<code>vector</code>这些容器类似的策略，先预分配<code>n_allocated</code>大小的容量，当实际在使用的数量<code>n</code>变大后，再扩容。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* A JSON array. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">json_array</span> &#123;</span></span><br><span class="line">    <span class="type">size_t</span> n, n_allocated;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">json</span> **<span class="title">elems</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>这里分析的都是<code>value</code>，<code>json</code>对象里面不还有字符串<code>key</code>吗？</strong>其实已经看到了，只是比较隐蔽。</p><p>在上面的<code>union</code>中，<code>json</code>对象是用<code>struct shash *object;</code>表示，而<code>shash</code>（看看前面）是*<em>a map from string(char <em>name) to</em></em> <code>void *data</code>，这里的<code>name</code>就是<code>key</code>，<code>data</code>当然就是指向<code>struct json</code>了。</p><p><strong>创建</strong><code>value</code>：</p><blockquote><p>这里都是几种<code>value</code>，严格来说它并不是<code>json</code>对象。因为它<strong>不能单独存在</strong>，没有<code>key</code>！。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_null_create</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_boolean_create</span><span class="params">(<span class="type">bool</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_string_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span>; <span class="comment">/* 会复制传入的字符串 */</span></span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_string_create_nocopy</span><span class="params">(<span class="type">char</span> *)</span>;</span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_integer_create</span><span class="params">(<span class="type">long</span> <span class="type">long</span> <span class="type">int</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_real_create</span><span class="params">(<span class="type">double</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>创建<code>array</code>类型的<code>json</code>对象</strong>：</p><blockquote><p>这就是前面提到的<code>json</code>的两种结构之一：数组。可以单独存在，哪怕是一个空的，序列化为字符串为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>如果其中有对象（不是上面的<code>value</code>），序列化为字符串为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;value1&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span> <span class="number">3.14</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个空的 array 对象 */</span></span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_array_create_empty</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* 向指定的 array 对象中插入一个成员element！并不会拷贝element */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">json_array_add</span><span class="params">(<span class="keyword">struct</span> json *, <span class="keyword">struct</span> json *element)</span>;</span><br><span class="line"><span class="comment">/* 如果分配的空间大小n_allocated &gt; n, 就收缩到 n */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">json_array_trim</span><span class="params">(<span class="keyword">struct</span> json *)</span>;</span><br><span class="line"><span class="comment">/* elements是json对象数组，长度为n，创建一个array对象来存储elements，不会进行拷贝，n_allocated=n */</span></span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_array_create</span><span class="params">(<span class="keyword">struct</span> json **elements, <span class="type">size_t</span> n)</span>;</span><br><span class="line"><span class="comment">/* 下面三个函数类似，传入参数就是创建的array对象中的成员，n_allocated和n就是传入参数的数量 */</span></span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_array_create_1</span><span class="params">(<span class="keyword">struct</span> json *)</span>;</span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_array_create_2</span><span class="params">(<span class="keyword">struct</span> json *, <span class="keyword">struct</span> json *)</span>;</span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_array_create_3</span><span class="params">(<span class="keyword">struct</span> json *, <span class="keyword">struct</span> json *, <span class="keyword">struct</span> json *)</span>;</span><br></pre></td></tr></table></figure><p><strong>创建<code>object</code>类型的<code>json</code>对象</strong>：</p><blockquote><p>这是<code>json</code>的另一种结构，一个完整的对象！如果为空，序列化为字符串为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>插入成员后，序列化为字符串为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;key1&quot;</span><span class="punctuation">:</span><span class="string">&quot;value1&quot;</span> <span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;key2&quot;</span><span class="punctuation">:</span> <span class="number">3.14</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 创建一个空的 json object 对象，是一个shash结构！ */</span></span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_object_create</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">/* 向 object 中插入一个键值对，键为name，值为一个json value.</span></span><br><span class="line"><span class="comment"> * 如果该object中已经存在该name，则会用新的value替换旧的，并free旧的value</span></span><br><span class="line"><span class="comment"> * name会被拷贝，value不会 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">json_object_put</span><span class="params">(<span class="keyword">struct</span> json *object, <span class="type">const</span> <span class="type">char</span> *name, <span class="keyword">struct</span> json *value)</span>;</span><br><span class="line"><span class="comment">/* 同上，但name也不会被拷贝 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">json_object_put_nocopy</span><span class="params">(<span class="keyword">struct</span> json *, <span class="type">char</span> *name, <span class="keyword">struct</span> json *value)</span>;</span><br><span class="line"><span class="comment">/* 插入一个值为字符串的json值，是基于传入参数value创建 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">json_object_put_string</span><span class="params">(<span class="keyword">struct</span> json *,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *value)</span>;</span><br><span class="line"><span class="comment">/* 同上，只不过字符串是采用类似于printf的方式格式化得到的 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">json_object_put_format</span><span class="params">(<span class="keyword">struct</span> json *,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">char</span> *name, <span class="type">const</span> <span class="type">char</span> *format, ...)</span></span><br><span class="line">    <span class="title function_">OVS_PRINTF_FORMAT</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>)</span>;</span><br></pre></td></tr></table></figure><p><strong>创建<code>json</code>对象的其他方式</strong>：函数名已经说得很清楚了！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_from_string</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_from_file</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file_name)</span>;</span><br><span class="line"><span class="keyword">struct</span> json *<span class="title function_">json_from_stream</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>还提供了一些其他有用的方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将type转为字符串并返回，注意是 const char *，不能修改字符串的内容 */</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">json_type_to_string</span><span class="params">(<span class="keyword">enum</span> json_type)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><strong>const char *<strong>与</strong>char const *</strong> 效果一样，都是不允许修改指针指向的地址空间的值，即把值作为常量，而<strong>char * const</strong>则是不允许修改指针自身，不能再指向其他地方，把指针自己当作常量使用。需要注意的是，使用<strong>char * const</strong> 定一个常量指针的时候一定记得赋初始值，否则再其他地方就没法赋值了。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 拿json实例计算hash值，该实例可以是上面的任何enum json_type */</span></span><br><span class="line"><span class="type">size_t</span> <span class="title function_">json_hash</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> json *, <span class="type">size_t</span> basis)</span>;</span><br><span class="line"><span class="comment">/* 判断两个json对象是否相等，也区分类型，如果是简单类型，整数、实数，</span></span><br><span class="line"><span class="comment"> * 就判断值是否相等。如果是字符串类型，就通过 strcmp 进行比较。</span></span><br><span class="line"><span class="comment"> * 如果是object或array，由于值可以嵌套，所以比较时也要嵌套地调用 json_equal 进行比较 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">json_equal</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> json *, <span class="type">const</span> <span class="keyword">struct</span> json *)</span>;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> OpenVSwitch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> OpenVSwitch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析命令行选项</title>
      <link href="/2022/10/05/Linux%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9/"/>
      <url>/2022/10/05/Linux%E8%A7%A3%E6%9E%90%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>支持短选项和长选项！</p><ul><li><strong>短选项</strong>：形如<code>-a</code>，<code>-v</code>，以<code>-</code>加单个字符组成。<code>-</code>叫做选项标识符，选项标识符后面可以紧跟一个字符，这个字符叫做<strong>选项字符</strong>。选项字符后面可以<strong>紧跟</strong>一个或多个字符，这些字符叫做<strong>选项参数</strong>。如<code>-lpthread</code>选项字符为<code>l</code>，参数为<code>pthread</code>。</li><li><strong>长选项</strong>：形如<code>--all</code>，<code>--version</code>，以<code>--</code>加一个单词组成，用<code>=</code>跟参数。如<code>--data=format</code>选项为<code>data</code>，参数为<code>format</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-lpthread -d format</span><br><span class="line">--data=format</span><br></pre></td></tr></table></figure><h2 id="短选项解析-getopt"><a href="#短选项解析-getopt" class="headerlink" title="短选项解析 getopt()"></a>短选项解析 <code>getopt()</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getopt</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> * <span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">           <span class="type">const</span> <span class="type">char</span> *optstring)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *optarg;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> optind, opterr, optopt;</span><br></pre></td></tr></table></figure><ul><li><code>argc, argv</code>为<code>main</code>函数参数中的<code>argc, argv</code>，代表命令行参数！</li><li><code>optstring</code>为</li><li><code>optind</code>为<code>argv</code>中下一个待处理的选项下标。默认值为1，当然如果要重新解析<code>argv</code>，可以手动重置其为1。</li></ul><h2 id="长命令"><a href="#长命令" class="headerlink" title="长命令"></a>长命令</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;getopt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">parse_client_options</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        OPT_SRCIP = <span class="number">256</span>,</span><br><span class="line">        OPT_DSTIP,</span><br><span class="line">        OPT_SRCPORT,</span><br><span class="line">        OPT_DSTPORT</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// : 选项后面必须有参数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *short_options = <span class="string">&quot;hp:t:s:n:i:b:&quot;</span>;</span><br><span class="line">    <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">option</span> <span class="title">long_options</span>[] =</span> &#123;</span><br><span class="line">        &#123;<span class="string">&quot;help&quot;</span>,      no_argument,       <span class="literal">NULL</span>, <span class="string">&#x27;h&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;srcip&quot;</span>,     required_argument, <span class="literal">NULL</span>, OPT_SRCIP &#125;,</span><br><span class="line">        &#123;<span class="string">&quot;dstip&quot;</span>,     required_argument, <span class="literal">NULL</span>, OPT_DSTIP &#125;,</span><br><span class="line">        &#123;<span class="string">&quot;srcport&quot;</span>,   required_argument, <span class="literal">NULL</span>, OPT_SRCPORT &#125;,</span><br><span class="line">        &#123;<span class="string">&quot;dstport&quot;</span>,   required_argument, <span class="literal">NULL</span>, OPT_DSTPORT &#125;,</span><br><span class="line">        &#123;<span class="string">&quot;proto&quot;</span>,     required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;p&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;tos&quot;</span>,       required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;t&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pktsize&quot;</span>,   required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;s&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;interval&quot;</span>,  required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;i&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;bandwidth&quot;</span>, required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;b&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;pktnums&quot;</span>,   required_argument, <span class="literal">NULL</span>, <span class="string">&#x27;n&#x27;</span>&#125;,</span><br><span class="line">        &#123;<span class="number">0</span>,         <span class="number">0</span>,                 <span class="number">0</span>,  <span class="number">0</span> &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line">    <span class="keyword">while</span>((opt = getopt_long_only(</span><br><span class="line">                 argc, argv, short_options, long_options, <span class="literal">NULL</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: client_help_info(); <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;p&#x27;</span>:</span><br><span class="line">                pkts.proto = atoi(optarg);</span><br><span class="line">                <span class="keyword">if</span> (pkts.proto != TCP &amp;&amp; pkts.proto != UDP) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;参数错误: %d，只能为TCP(6)/UDP(17)\n&quot;</span>, pkts.proto);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;t&#x27;</span>: pkts.tos = atoi(optarg); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                pkts.pktsize = atoi(optarg);</span><br><span class="line">                <span class="keyword">if</span> (pkts.pktsize &lt; <span class="number">64</span> || pkts.pktsize &gt; <span class="number">1500</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;数据包大小应该在[64, 1500]的范围内\n&quot;</span>);</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;n&#x27;</span>: pkts.pktnums = atoi(optarg); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>: pkts.interval = atoi(optarg); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: pkts.bandwidth = atoi(optarg); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OPT_SRCIP: <span class="built_in">strncpy</span>(pkts.srcip, optarg, <span class="number">16</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OPT_DSTIP: <span class="built_in">strncpy</span>(pkts.dstip, optarg, <span class="number">16</span>); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OPT_SRCPORT: pkts.srcport = atoi(optarg); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> OPT_DSTPORT: pkts.dstport = atoi(optarg); <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                client_help_info();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="短命令-only"><a href="#短命令-only" class="headerlink" title="短命令 only"></a>短命令 only</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解析命令行参数处理函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">parse_args</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> &#123;</span><br><span class="line">    <span class="type">int</span> opt;</span><br><span class="line"></span><br><span class="line">    mdelay = <span class="number">1000000</span>;      <span class="comment">// 默认刷新率为1秒</span></span><br><span class="line">    x1 = <span class="number">0</span>;                <span class="comment">// 默认区域为全屏</span></span><br><span class="line">    x2 = vinfo.xres - <span class="number">1</span>;</span><br><span class="line">    y1 = <span class="number">0</span>;</span><br><span class="line">    y2 = vinfo.yres - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((opt = getopt(argc, argv, <span class="string">&quot;hrsd:m:x:y:&quot;</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;r&#x27;</span>: <span class="comment">// 全屏刷新标志</span></span><br><span class="line">                rect = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;s&#x27;</span>:</span><br><span class="line">                show_fps = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;d&#x27;</span>: <span class="comment">// 帧间隔 ms</span></span><br><span class="line">                mdelay = atoi(optarg) * <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;m&#x27;</span>:</span><br><span class="line">                mode = atoi(optarg);</span><br><span class="line">                <span class="keyword">if</span> (mode &gt; <span class="number">1</span> || mode &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;mode must be 0 or 1\n\n&quot;</span>);</span><br><span class="line">                    help_info();</span><br><span class="line">                    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>: <span class="comment">// 指定x区域</span></span><br><span class="line">                <span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%d:%d&quot;</span>, &amp;x1, &amp;x2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;y&#x27;</span>: <span class="comment">// 指定y区域</span></span><br><span class="line">                <span class="built_in">sscanf</span>(optarg, <span class="string">&quot;%d:%d&quot;</span>, &amp;y1, &amp;y2);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;y1, y2: %d, %d\n&quot;</span>, y1, y2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;h&#x27;</span>: <span class="comment">// FALLTHROUGH</span></span><br><span class="line">            <span class="keyword">default</span>: <span class="comment">/* &#x27;?&#x27; */</span></span><br><span class="line">                help_info();</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他资料"><a href="#其他资料" class="headerlink" title="其他资料"></a>其他资料</h2><ul><li><a href="https://www.cnblogs.com/liwei0526vip/p/4873111.html">getopt例子</a></li><li><a href="https://blog.csdn.net/liao20081228/article/details/76557548">getopt系列函数</a></li><li><a href="https://blog.csdn.net/Mculover666/article/details/106646339">getopt</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++三方库</title>
      <link href="/2022/09/19/Cpp%E4%B8%89%E6%96%B9%E5%BA%93/"/>
      <url>/2022/09/19/Cpp%E4%B8%89%E6%96%B9%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h2><p>格式化字符串，好像已经纳入C++20标准库，使用很方便！而且说是比<code>printf</code>还快~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/fmtlib/fmt.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">fmt</span>/</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j</span><br><span class="line"></span><br><span class="line">sudo make install</span><br><span class="line"><span class="comment"># g++ test.cpp -o debug -lfmt</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/fmtlib/fmt">github 仓库，README中文档也较详细、使用简单</a></p><p><a href="https://hackingcpp.com/cpp/libs/fmt.html">官方文档、有代码示例</a></p></blockquote><h2 id="fmtlog"><a href="#fmtlog" class="headerlink" title="fmtlog"></a>fmtlog</h2><p>基于<code>fmt</code>的日志库，可以很方便的以<code>fmt</code>的方式格式化日志输出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/MengRao/fmtlog.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> fmtlog</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line">./build.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># g++ test.cpp -o debug -lfmt -lfmtlog-static # 好像只能使用静态库</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/MengRao/fmtlog">官方仓库，也只有这里的README作为官方文档</a></p></blockquote><h2 id="spdlog"><a href="#spdlog" class="headerlink" title="spdlog"></a>spdlog</h2><p>同样支持<code>fmt</code>格式输出的日志库，相对更成熟一点。</p><p><a href="https://zhuanlan.zhihu.com/p/427038912">https://zhuanlan.zhihu.com/p/427038912</a></p><p><a href="https://www.modb.pro/db/251872">https://www.modb.pro/db/251872</a></p><h2 id="hiredis"><a href="#hiredis" class="headerlink" title="hiredis"></a>hiredis</h2><p><code>C</code>语言版本的<code>Redis Client</code>！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/redis/hiredis.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> hiredis</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">sudo make install</span><br><span class="line"><span class="comment"># g++ test.cpp -o debug -lhiredis</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/redis/hiredis">官方仓库，也只有这里的README作为官方文档</a></p><p><a href="https://github.com/redis/hiredis/blob/79ae5ffc693b57688b4c76141fd2c94868ebdbff/hiredis.h#L305">hiredis.h 头文件，可以看 redis 的API</a></p><p><a href="https://tangming.github.io/2019/10/14/redis-hiredis-introduction/">别人翻译的官方文档，供参考</a></p></blockquote><p>Hiredis提供了同步、异步以及回复解析三种API。</p><h3 id="同步API"><a href="#同步API" class="headerlink" title="同步API"></a>同步API</h3><p>要使用同步 API，只需要引入几个函数调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 两个重要结构体 */</span></span><br><span class="line">redisContext *ctx;  <span class="comment">// 连接上下文，建立连接时创建</span></span><br><span class="line">redisReply *reply;  <span class="comment">// redisCommand返回值，注意释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 和redis服务器建立TCP连接 */</span></span><br><span class="line">redisContext *<span class="title function_">redisConnect</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">int</span> port)</span>;</span><br><span class="line">redisContext *<span class="title function_">redisConnectWithTimeout</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">int</span> port, <span class="type">const</span> <span class="keyword">struct</span> timeval tv)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 发送指令到redis服务器，并取得结果 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">redisCommand</span><span class="params">(redisContext *c, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">redisCommandArgv</span><span class="params">(redisContext *c, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">size_t</span> *argvlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放内存 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">freeReplyObject</span><span class="params">(<span class="type">void</span> *reply)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">redisFree</span><span class="params">(redisContext *c)</span>;    <span class="comment">// 断开连接，关闭套接字</span></span><br></pre></td></tr></table></figure><h4 id="redisConnect"><a href="#redisConnect" class="headerlink" title="redisConnect"></a>redisConnect</h4><p><code>Hiredis</code>通过<code>redisConnect</code>创建一个<code>redisContext</code>来实现与<code>Redis</code>进行连接，<code>context</code>中包含了连接的信息。<code>redisContext</code>中包含有一个整形的<code>err</code>变量和一个字符类型的<code>errstr</code>变量，当创建连接失败，<code>err</code>为非零值，<code>errstr</code>为错误的表述。<strong>当使用<code>redisConnect</code>创建连接后，应该检查<code>err</code>参数以判断连接是否成功</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">redisContext *c = redisConnect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">NULL</span> || c-&gt;err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: %s\n&quot;</span>, c-&gt;errstr);</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t allocate redis context\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用 timeout */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span> =</span> &#123;<span class="number">2</span>, <span class="number">0</span>&#125;;    <span class="comment">// &#123;s, us&#125;;</span></span><br><span class="line">redisContext *c = redisConnectWithTimeout(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, timeout);</span><br></pre></td></tr></table></figure><h4 id="redisCommand"><a href="#redisCommand" class="headerlink" title="redisCommand"></a>redisCommand</h4><p>给数据库发送指令，指令与通过<code>redis-cli</code>使用时一致~</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reply = redisCommand(context, <span class="string">&quot;SET foo bar&quot;</span>);</span><br><span class="line">reply = redisCommand(context, <span class="string">&quot;SET foo %s&quot;</span>, value)</span><br><span class="line">reply = redisCommand(context, <span class="string">&quot;SET foo:%s %s&quot;</span>, key, value);</span><br><span class="line">reply = redisCommand(context, <span class="string">&quot;GET key&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注意每次调用 redisCommand 都需要 free(reply) */</span></span><br><span class="line">freeReplyObject(reply);</span><br></pre></td></tr></table></figure><h4 id="redisCommandArgv"><a href="#redisCommandArgv" class="headerlink" title="redisCommandArgv"></a>redisCommandArgv</h4><p>批量执行命令！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// argv: 命令字符串数组， &#123;&quot;SET FOO 1&quot;, &quot;GET FOO&quot;, &quot;SET FOO 2&quot;, &quot;GET FOO&quot;&#125;;</span></span><br><span class="line"><span class="comment">// argc: 命令argv的数量</span></span><br><span class="line"><span class="comment">// argvlen: agrv中每个字符串的长度数组 &#123;9, 7, 9, 7&#125;。argvlen为NULL时，则调用strlen计算长度</span></span><br><span class="line"><span class="comment">// 返回值：reply 指针，和redisCommand一致。注意此时reply中包含多个返回值，位于reply-&gt;element数组中</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">redisCommandArgv</span><span class="params">(redisContext *c, <span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">size_t</span> *argvlen)</span>;</span><br></pre></td></tr></table></figure><h2 id="redis-plus-plus"><a href="#redis-plus-plus" class="headerlink" title="redis-plus-plus"></a>redis-plus-plus</h2><p>基于<code>hiredis</code>实现的<code>c++</code>版本的<code>redis</code>客户端~</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/sewenew/redis-plus-plus.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> redis-plus-plus</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DREDIS_PLUS_PLUS_CXX_STANDARD=17 ..</span><br><span class="line">make</span><br><span class="line"></span><br><span class="line">sudo make install</span><br><span class="line"><span class="comment"># g++ test.cpp -o debug -lhiredis -lredis++</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/sewenew/redis-plus-plus">github 仓库，其README中有较详细的文档</a></p></blockquote><h2 id="cpp-httplib"><a href="#cpp-httplib" class="headerlink" title="cpp-httplib"></a>cpp-httplib</h2><p>可创建<code>HTTP Server</code>，也可创建<code>HTTP Client</code>用于发送<code>get/post</code>等请求。</p><p>相关方法好像都在<code>httplib.h</code>这个头文件中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/yhirose/cpp-httplib.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> cpp-httplib</span><br><span class="line"><span class="built_in">mkdir</span> -p build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">sudo cmake --build . --target install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 好像只需要将httplib.h拷贝到include目录下就行</span></span><br><span class="line">s@ys:build$ sudo cmake --build . --target install</span><br><span class="line">Install the project...</span><br><span class="line">-- Install configuration: <span class="string">&quot;Release&quot;</span></span><br><span class="line">-- Installing: /usr/local/include/httplib.h</span><br><span class="line">-- Installing: /usr/local/lib/cmake/httplib/httplibConfig.cmake</span><br><span class="line">-- Installing: /usr/local/lib/cmake/httplib/httplibConfigVersion.cmake</span><br><span class="line">-- Installing: /usr/local/lib/cmake/httplib/FindBrotli.cmake</span><br><span class="line">-- Installing: /usr/local/lib/cmake/httplib/httplibTargets.cmake</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/yhirose/cpp-httplib/blob/master/httplib.h">httplib.h 直接看该文件找API</a></p><p><a href="https://segmentfault.com/a/1190000022419921">一点解读</a></p></blockquote><p>常用类和一些结构：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span>;       <span class="comment">// 服务端类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadPool</span>;   <span class="comment">// 线程池类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Client</span>;       <span class="comment">// 客户端类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Request</span>;     <span class="comment">// 请求数据类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Result</span>;       <span class="comment">// 请求返回类，包含 Response</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Response</span>;    <span class="comment">// 响应数据类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    std::unique_ptr&lt;Response&gt; res_;</span><br><span class="line">    Error err_;</span><br><span class="line">    Headers request_headers_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Response</span> &#123;</span><br><span class="line">    std::string version;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">-1</span>;        <span class="comment">// 状态位，200/403...</span></span><br><span class="line">    std::string reason;</span><br><span class="line">    Headers headers;</span><br><span class="line">    std::string body;       <span class="comment">// 响应 body</span></span><br><span class="line">    std::string location;   <span class="comment">// Redirect location</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;httplib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建Client对象 */</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Client</span><span class="params">(<span class="type">const</span> std::string &amp;scheme_host_port)</span></span>;</span><br><span class="line"><span class="function">httplib::Client <span class="title">cli</span><span class="params">(<span class="string">&quot;http://192.168.1.147:18181&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Client</span><span class="params">(<span class="type">const</span> std::string &amp;host, <span class="type">int</span> port)</span></span>;</span><br><span class="line"><span class="function">httplib::Client <span class="title">cli</span><span class="params">(<span class="string">&quot;http://192.168.1.147&quot;</span>, <span class="number">18181</span>)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* get 请求 */</span></span><br><span class="line">httplib::Headers headers = &#123;&#123; <span class="string">&quot;Authorization&quot;</span>, <span class="string">&quot;Basic b25vczpyb2Nrcw==&quot;</span> &#125;&#125;;</span><br><span class="line"></span><br><span class="line">Result <span class="title function_">Get</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span>;</span><br><span class="line">Result <span class="title function_">Get</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path, <span class="type">const</span> Headers &amp;headers)</span>;</span><br><span class="line">Result res = cli.Get(<span class="string">&quot;/onos/v1/flows/of:0000000000001111&quot;</span>, headers);</span><br><span class="line"></span><br><span class="line">cli.set_default_headers(headers);   <span class="comment">// 设置默认Header</span></span><br><span class="line">Result res = cli.Get(<span class="string">&quot;/onos/v1/flows/of:0000000000001111&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Result res = cli.Get(<span class="string">&quot;/onos/v1/flows/of:0000000000001111&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Result重载了 bool() 和 -&gt;，可直接使用-&gt;访问Response的值 */</span></span><br><span class="line"><span class="keyword">if</span> (res) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res-&gt;status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res-&gt;get_header_value(<span class="string">&quot;Content-Type&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res-&gt;body &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res.error() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">auto</span> err = res.error();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;HTTP error: &quot;</span> &lt;&lt; httplib::to_string(err) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Result <span class="title function_">Post</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path)</span>;</span><br><span class="line">Result <span class="title function_">Post</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;body,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;content_type)</span>;</span><br><span class="line">Result <span class="title function_">Post</span><span class="params">(<span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;path, <span class="type">const</span> Headers &amp;headers,</span></span><br><span class="line"><span class="params">            <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;body, <span class="type">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;content_type)</span>;</span><br></pre></td></tr></table></figure><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>解析json字符串，返回json对象。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/nlohmann/json.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> json/</span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make -j</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://json.nlohmann.me/api/basic_json/">文档 API</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> C++ </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程-并发服务器</title>
      <link href="/2022/08/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>/2022/08/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>前面<code>socket</code>中创建的<code>server</code>只有一个主线程，只能连接一个客户端。要实现可同时连接多个客户端，有几种方法：</p><ul><li>为每一个连接创建一个<strong>子进程</strong>处理。</li><li>为每一个连接创建一个<strong>子线程</strong>处理。</li><li>单线程，但使用<code>select, poll, epoll</code>等 <strong><code>IO</code> 复用</strong>算法。</li></ul><h2 id="多进程并发"><a href="#多进程并发" class="headerlink" title="多进程并发"></a>多进程并发</h2><p>每产生一个连接时，就创建一个子进程去处理，父进程只负责监听以及<strong>回收子进程</strong>！</p><p>回收子进程不能放在父进程的循环逻辑中，一种办法是通过注册信号<code>SIGCHLD</code>捕捉函数，在信号处理函数中完成子进程回收。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> socket()             <span class="comment">// 创建监听套接字 lfd</span></span><br><span class="line"><span class="number">2.</span> bind()</span><br><span class="line"><span class="number">3.</span> listen()</span><br><span class="line"><span class="number">4.</span> <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    cfd = accept()      <span class="comment">// 与客户端通信的 socket fd</span></span><br><span class="line">    pid = fork()        <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;     <span class="comment">// 子进程</span></span><br><span class="line">        close(lfd)      <span class="comment">// 关闭用于建立连接的套接字 lfd</span></span><br><span class="line">        read()          <span class="comment">// 读数据，并处理</span></span><br><span class="line">        ....</span><br><span class="line">        write()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;   <span class="comment">// 父进程</span></span><br><span class="line">        close(cfd)      <span class="comment">// 父进程中不需要 真连接 的 fd</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> <span class="keyword">while</span>(waitpid());    <span class="comment">// 父进程回收子进程，通过信号捕捉函数：`SIGCHLD`</span></span><br></pre></td></tr></table></figure><h2 id="多线程并发"><a href="#多线程并发" class="headerlink" title="多线程并发"></a>多线程并发</h2><p>与多进程并发类似，只是为每一个连接创建一个线程。与多进程相比，回收子线程更简单：</p><ul><li>可直接使用<code>pthread_detach</code>分离子线程，自动回收，该方案无法接收线程返回值。</li><li>也可创建一个子线程，专门用于回收用于处理连接的子线程（兄弟线程可互相回收）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> socket()             <span class="comment">// 创建监听套接字 lfd</span></span><br><span class="line"><span class="number">2.</span> bind()</span><br><span class="line"><span class="number">3.</span> listen()</span><br><span class="line"><span class="number">4.</span> <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    cfd = accept()      <span class="comment">// 与客户端通信的 socket fd</span></span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_main, <span class="literal">NULL</span>)   <span class="comment">// 创建子进程</span></span><br><span class="line">    pthread_detach(tid)    <span class="comment">// 分离子线程，自动回收</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> thread_main() &#123;      <span class="comment">// 子线程处理函数</span></span><br><span class="line">    close(lfd)          <span class="comment">// 关闭用于建立连接的套接字 lfd</span></span><br><span class="line">    read()              <span class="comment">// 读数据，并处理</span></span><br><span class="line">    ....</span><br><span class="line">    write()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多路IO复用"><a href="#多路IO复用" class="headerlink" title="多路IO复用"></a>多路IO复用</h2><p>在上面的多进程或多线程并发服务器中，父进程总是阻塞等待连接（阻塞在<code>lfd</code>）、子进程大部分时间阻塞等待消息（阻塞在<code>cfd</code>），无法做其他事情。多路IO转接服务器也叫做多任务IO服务器，该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之<strong>由内核替应用程序监视文件</strong>。</p><p>与多进程和多线程技术相比，<code>I/O</code>多路复用技术的<strong>最大优势是系统开销小</strong>，系统不必创建进程&#x2F;线程，也不必维护这些进程&#x2F;线程，从而大大减小了系统的开销。</p><p><code>select, poll, epoll</code>都是监听<strong>文件描述符</strong>，传递给这些监听函数的参数都是需要监听的文件描述符列表，返回值为有对应监听事件的文件描述符列表。<strong>这些函数监听文件描述符，没有限制必须是<code>socket</code>建立的文件描述符，普通文件、管道等所有文件描述符都可以被监听</strong>。</p><h2 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h2><p>如下图所示，<code>select</code>监听对应的<code>socket fd</code>，连接请求也就是<code>lfd</code>上有消息到达，其他客户端的请求也就是对应的<code>cfd</code>上有消息到达。</p><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220802151005095.png" alt="image-20220802151005095"></p><p><code>select</code>函数中，有三个传入传出参数，<strong>传入</strong>表示要监听的读、写、异常文件描述符，<strong>传出</strong>表示有对应事件的文件描述符。</p><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/v2-320be0c91e2a376199b1d5eef626758e_b.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds,</span></span><br><span class="line"><span class="params">            fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>nfds</code>：要监听的最大文件描述符<code>+1</code></li><li><code>readfds</code>：<strong>传入传出参数</strong>，要监听的读集合</li><li><code>writefds</code>：<strong>传入传出参数</strong>，要监听的写集合，一般传 NULL</li><li><code>exceptfds</code>：<strong>传入传出参数</strong>，要监听的异常集合，一般传 NULL</li><li><code>timeout</code>：<ul><li><code>&gt;0</code> 设置监听超时时长</li><li><code>NULL</code> 阻塞监听</li><li><code>0</code> 非阻塞监听，轮询</li></ul></li><li>返回值：<ul><li><code>&gt;=0</code> 所有监听集合（3个）中，满足对应事件的总数</li><li><code>-1</code> 异常，<code>errno</code></li></ul></li></ul><p><code>fd_set</code> 是一个二进制集合，在c标准库中其长度是固定的（1024），每一位表示对应位的文件描述符，相关的修改只能通过提供的操作函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FD_CLR</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;   <span class="comment">// 将一个描述符移出监听集合</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">FD_ISSET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>; <span class="comment">// 判断描述符是否在监听集合中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_SET</span><span class="params">(<span class="type">int</span> fd, fd_set *<span class="built_in">set</span>)</span>;   <span class="comment">// 将一个描述符加入监听集合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span>;          <span class="comment">// 清零监听集合</span></span><br></pre></td></tr></table></figure><h3 id="Select-基本流程"><a href="#Select-基本流程" class="headerlink" title="Select 基本流程"></a>Select 基本流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lfd = socket();     <span class="comment">// 创建监听套接字 lfd</span></span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line">fd_set rset;        <span class="comment">// 创建读监听集合</span></span><br><span class="line">fd_set allset;      <span class="comment">// 由于作为select参数的rset每次调用都会被修改，用allset作为监听集合</span></span><br><span class="line">FD_ZERO(&amp;allset);   <span class="comment">// 清空</span></span><br><span class="line">FD_SET(lfd, allset) <span class="comment">// 将 lfd 加入监听集合</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    rset = allset;  <span class="comment">// 保存监听集合</span></span><br><span class="line">    ret = select(lfd+<span class="number">1</span>, &amp;rset, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);   <span class="comment">// 监听对应集合</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(lfd, &amp;rset)) &#123;</span><br><span class="line">            cfd = accept();</span><br><span class="line">            FD_SET(cfd, &amp;allset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = lfd+<span class="number">1</span>; i &lt;= maxfd; i++) &#123;  <span class="comment">// 遍历集合，处理对应事件</span></span><br><span class="line">            <span class="keyword">if</span> (FD_ISSET(lfd, &amp;rset)) &#123;</span><br><span class="line">                read()</span><br><span class="line">                ....    <span class="comment">// 处理数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Select-优缺点"><a href="#Select-优缺点" class="headerlink" title="Select 优缺点"></a>Select 优缺点</h3><p><strong>优点</strong>：跨平台！</p><p><strong>缺点</strong>：</p><ul><li>监听上限受文件描述符限制，最大1024（不是数量最大1024，而是文件描述符的大小不能超过1024）。</li><li>检测满足条件的<code>fd</code>比较麻烦，提高了编码难度！<strong>但检测逻辑写好了，性能并不比后面的<code>poll, epoll</code>低</strong>。</li></ul><p>检测条件这里，如果文件描述符很分散，比如 3 和 1023，如果遍历<code>fd_set</code>，效率很低，最好的办法是用一个数组来记录需要监听的文件描述符，只不过需要自己实现，比较麻烦。</p><h2 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h2><p><code>Poll</code>只是一个半成品，对上面的<code>Select</code>进行了一点优化：</p><ul><li>它本身就用数组来记录文件描述符，方便处理很分散的文件描述符。</li><li>不在受限与文件描述符的大小，监听文件描述符的大小不受限。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">nfds_t</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>   fd;         <span class="comment">// 待监听的文件描述符</span></span><br><span class="line">    <span class="type">short</span> events;     <span class="comment">// 待监听的文件描述符对应的监听时间：POLLIN, POLLOUT, POLLERR</span></span><br><span class="line">    <span class="type">short</span> revents;    <span class="comment">// 传入时给0。如果满足对应时间，返回非0：POLLIN, POLLOUT, POLLERR</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>fds</code>：监听的文件描述符【数组】</li><li><code>nfds</code>：监听数组的，实际有效监听个数</li><li><code>timeout</code>：单位 <code>ms</code><ul><li><code>&gt;0</code> 设置监听超时时长</li><li><code>-1</code> 阻塞监听</li><li><code>0</code> 非阻塞监听</li></ul></li><li>返回值：- 返回值：<ul><li><code>&gt;=0</code> 满足对应监听事件的总数。</li><li><code>-1</code> 异常，<code>errno</code></li></ul></li></ul><h3 id="Poll-基本流程"><a href="#Poll-基本流程" class="headerlink" title="Poll 基本流程"></a>Poll 基本流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lfd = socket();     <span class="comment">// 创建监听套接字 lfd</span></span><br><span class="line">bind();</span><br><span class="line">listen();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">fds</span>[1024];</span>    <span class="comment">// 监听数组</span></span><br><span class="line">fds[<span class="number">0</span>].fd = lfd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    ret = poll(fds, maxi+<span class="number">1</span>, <span class="number">-1</span>);   <span class="comment">// 监听对应集合</span></span><br><span class="line">    <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= maxi; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历数组，依次判断是否有对应事件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Poll-优缺点"><a href="#Poll-优缺点" class="headerlink" title="Poll 优缺点"></a>Poll 优缺点</h3><p>优点：</p><ul><li>自带数组结构，可将监听事件集合和返回事件集合分离。</li><li>可拓展监听上限，超出1024限制。</li></ul><p>缺点：</p><ul><li>不能跨平台，只能在 <code>Linux / Unix</code> 下使用。</li><li>仍然无法直接定位满足监听事件的文件描述符。</li><li>编码难度较大。</li></ul><h3 id="突破1024限制"><a href="#突破1024限制" class="headerlink" title="突破1024限制"></a>突破1024限制</h3><p>默认情况下，一个进程可打开的文件描述符上限就<code>1024</code>，当服务器连接的客户端超过1024时，就无法再为其分配文件描述符，也就无法建立连接。</p><p><strong>查看限制</strong>：</p><ul><li><code>cat /proc/sys/fs/file-max</code>：当前计算机所能打开的最大文件个数。受硬件影响。</li><li><code>ulimit -a</code>（<code>open files</code>）：当前用户下的进程，默认可打开文件描述符个数。缺省为 1024</li></ul><p><strong>修改限制</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sudo vim /etc/security/limits.conf    # 在文件末尾加入一下内容</span></span><br><span class="line">*               soft    nofile          65536   <span class="comment"># 设置默认值，可以直接借助命令ulimit修改。【注销用户，使其生效】</span></span><br><span class="line">*               hard    nofile          100000  <span class="comment"># 设置命令上限</span></span><br></pre></td></tr></table></figure><p>接着就可使用<code>ulimit -n num</code>修改进程可打开的文件描述符上限，受到上面设置的<code>hard</code>限制。</p><h2 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h2><p>在<code>man epoll</code>中对<code>epoll</code>有较详细的描述。其在内核中的实现采用了两种数据结构：</p><ul><li><strong>监听红黑树</strong>，用于维护监听的描述符列表。</li><li><strong>就绪链表</strong>，维护一个有监听事件响应的描述符列表。</li></ul><p>如下图所示，使用<code>epoll_ctl()</code>向监听红黑树中添加、删除文件描述符。有数据到达时，通过回调函数，将对应的文件描述符插入到就绪链表中；当使用<code>epoll_wait()</code>时，只判断该<strong>就绪链表</strong>是否为空，不为空就返回就绪链表。</p><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/v2-70f8e9bc1a028d252c01c32329e49341_b.gif" alt="img"></p><p>使用红黑树只是为了管理需要监听的文件描述符，原理上来讲，使用普通的数组也可以记录需要监听的文件描述符，比如方案一：添加监听的描述符通过遍历数组找到第一个空位，删除操作符也需要遍历数组确定位置（而且会留下空位）。这种方式使用的空间复杂度低，但时间复杂度高。方案二：直接使用一个足够长的数组，用文件描述符下标做映射。添加、删除的时间复杂度都是<code>O(1)</code>，单空间复杂度很高，因为并不仅仅是记录文件描述符<code>int</code>，还需要记录需要监听的事件等信息。而红黑树就是对时间、空间复杂度折中的一个方案，空间复杂度低，时间复杂度<code>O(\log n)</code>。</p><p>还有一种方案：用哈希表来管理需要监听的文件描述符，但哈希表有个致命缺陷，没有人知道哈希表增删的时候会在什么时候扩容&#x2F;缩容，这可能会导致某个 <code>epoll_ctl</code> 操作增删文件描述符的时候，会比其它操作长几百倍。而为了保证对外提供的服务的质量，每次 <code>epoll_ctl</code> 的时间应该至少是平均的。</p><h3 id="epoll-create-函数"><a href="#epoll-create-函数" class="headerlink" title="epoll_create 函数"></a>epoll_create 函数</h3><p>创建一棵监听红黑树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>size</code>：创建的红黑树的监听节点数量，仅供内核参考。</li><li>返回值：<ul><li><code>&gt;0</code> 指向新创建的红黑树的根节点的 <code>fd</code>。</li><li><code>-1</code> 失败，<code>errno</code>。</li></ul></li></ul><h3 id="epoll-ctl-函数"><a href="#epoll-ctl-函数" class="headerlink" title="epoll_ctl 函数"></a>epoll_ctl 函数</h3><p>操作监听红黑树。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>epfd</code>：<code>epoll_create</code>函数的返回值，红黑树的根节点</li><li><code>op</code>：对该监听红黑数所做的操作：<ul><li><code>EPOLL_CTL_ADD</code> 添加<code>fd</code>到 监听红黑树；</li><li><code>EPOLL_CTL_MOD</code> 修改<code>fd</code>在 监听红黑树上的监听事件；</li><li><code>EPOLL_CTL_DEL</code> 将一个<code>fd</code>从 监听红黑树上摘下（取消监听）。</li></ul></li><li><code>fd</code>：待监听的 <code>fd</code>。</li><li><code>event</code>：本质 <code>struct epoll_event</code> 结构体 变量地址</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span>  <span class="comment">// union 联合体</span></span><br><span class="line">    <span class="type">void</span>        *ptr;</span><br><span class="line">    <span class="type">int</span>          fd;    <span class="comment">// 传出参数，对应监听时间的 fd</span></span><br><span class="line">    <span class="type">uint32_t</span>     u32;   <span class="comment">// 无用</span></span><br><span class="line">    <span class="type">uint64_t</span>     u64;   <span class="comment">// 无用</span></span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>     events;    <span class="comment">// 监听事件类型 EPOLLIN/ EPOLLOUT/ EPOLL</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="epoll-wait-函数"><a href="#epoll-wait-函数" class="headerlink" title="epoll_wait 函数"></a>epoll_wait 函数</h3><p>判断该<strong>就绪链表</strong>是否为空，不为空就返回就绪链表，否则阻塞等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(<span class="type">int</span> epfd, <span class="keyword">struct</span> epoll_event *events,</span></span><br><span class="line"><span class="params">                <span class="type">int</span> maxevents, <span class="type">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>epfd</code>：<code>epoll_create</code>函数的返回值，红黑树的根节点。</li><li><code>events</code>：传出参数，<strong>数组</strong>，满足监听条件的那些 <code>fd</code> 结构体。数组大小预先就给定<code>LEN</code>！</li><li><code>maxevents</code>：<code>events</code>数组 元素的总个数，也就是上面的<code>LEN</code>。</li><li><code>timeout</code>：单位 <code>ms</code><ul><li><code>&gt;0</code> 设置监听超时时长</li><li><code>-1</code> 阻塞监听</li><li><code>0</code> 非阻塞监听</li></ul></li><li>返回值：<ul><li><code>&gt;=0</code> 满足对应监听事件的总数，也就是<code>events</code>中有效成员的数量。</li><li><code>-1</code> 异常，<code>errno</code></li></ul></li></ul><h3 id="ET和LT模式"><a href="#ET和LT模式" class="headerlink" title="ET和LT模式"></a>ET和LT模式</h3><p><code>epoll</code>是<code>Linux</code>下多路复用IO接口<code>select/poll</code>的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入<code>Ready</code>队列的描述符集合就行了。</p><p><code>epoll</code>事件有两种模型：</p><ul><li><code>Edge Triggered (ET)</code> 边缘触发（上升沿）只有数据到来才触发，不管缓存区中是否还有数据。</li><li><code>Level Triggered (LT)</code> 水平触发（高电平）只要有数据都会触发。</li></ul><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220802175026443.png" alt="image-20220802175026443"></p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/367591714">深入浅出理解select、poll、epoll的实现</a></li><li><a href="https://www.bilibili.com/video/BV1iJ411S7UA?p=75&vd_source=ae9b8ed3bda4e74634d81a57039d0b6e">Linux网络编程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> socket </tag>
            
            <tag> select </tag>
            
            <tag> poll </tag>
            
            <tag> epoll </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程-网卡收包</title>
      <link href="/2022/07/30/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BD%91%E5%8D%A1%E6%94%B6%E5%8C%85/"/>
      <url>/2022/07/30/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BD%91%E5%8D%A1%E6%94%B6%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>在开始之前，我们先用一张图解释 <code>linux</code> 系统接收网络报文的过程。</p><ol><li>首先网络报文通过物理网线发送到网卡，</li><li>网络驱动程序会把网络中的报文读出来放到 <code>ring buffer</code> 中，这个过程使用 DMA（Direct Memory Access），不需要 <code>CPU</code> 参与</li><li><strong>内核</strong>从 <code>ring buffer</code> 中读取报文进行处理，执行 <code>IP</code> 和 <code>TCP/UDP</code> 层的逻辑，最后把报文放到应用程序的 <code>socket buffer</code> 中</li><li>应用程序从 <code>socket buffer</code> 中读取报文进行处理</li></ol><p>注意图中的几个 <code>buffer</code> 缓冲区！</p><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BD%91%E5%8D%A1%E6%94%B6%E5%8C%85/006tKfTcgy1fnf8b0c64xj31hc0u0goa.jpg" alt="img"></p><h2 id="step1：网卡到ringbuffer"><a href="#step1：网卡到ringbuffer" class="headerlink" title="step1：网卡到ringbuffer"></a>step1：网卡到<code>ringbuffer</code></h2><p><code>NIC</code> 在接收到数据包之后，首先需要将数据同步到内核中，这中间的桥梁是 <code>rx ring buffer</code>。它是由 <code>NIC</code> 和驱动程序（内核）共享的一片区域，事实上，<code>rx ring buffer</code> 存储的并不是实际的 <code>packet</code> 数据，而是一个描述符，这个描述符指向了它真正的存储地址，具体流程如下：</p><ol><li>驱动在<strong>内存中分配</strong>一片缓冲区用来接收数据包，叫做 <code>sk_buffer</code>；</li><li>将上述<strong>缓冲区的地址和大小</strong>（即接收描述符），加入到 <code>rx ring buffer</code>。描述符中的缓冲区地址是 <code>DMA</code> 使用的物理地址；</li><li>驱动通知网卡有一个新的描述符；</li><li>网卡从 <code>rx ring buffer</code> 中取出描述符，从而获知缓冲区的地址和大小；</li><li>网卡收到新的数据包；</li><li>网卡将新数据包通过 <code>DMA</code> 直接写到 <code>sk_buffer</code> 中。</li></ol><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BD%91%E5%8D%A1%E6%94%B6%E5%8C%85/20201031120523515.png" alt="img"></p><h3 id="硬中断与软中断"><a href="#硬中断与软中断" class="headerlink" title="硬中断与软中断"></a>硬中断与软中断</h3><p>内核和网络设备驱动是通过<strong>中断</strong>的方式来处理的。当设备上有数据到达的时候，会给CPU的相关引脚上触发一个电压变化，以通知CPU来处理数据。对于网络模块来说，由于处理过程比较复杂和耗时，如果在中断函数中完成所有的处理，将会导致中断处理函数（优先级过高）将过度占据CPU，将导致CPU无法响应其它设备，例如鼠标和键盘的消息。因此Linux中断处理函数是<strong>分上半部和下半部的</strong>。</p><p>上半部通过<strong>硬中断</strong>只进行最简单的工作，快速处理然后释放CPU，接着CPU就可以允许其它中断进来。剩下将绝大部分的工作都放到下半部中，可以慢慢从容处理。</p><p>下半部实现方式是<strong>软中断</strong>，由<code>ksoftirqd</code>内核线程全权处理。和硬中断不同的是，<strong>硬中断是通过给CPU物理引脚施加电压变化</strong>，而<strong>软中断是通过给内存中的一个变量的二进制值以通知软中断处理程序</strong>。</p><p>当 <code>NIC</code> 把数据包通过 <code>DMA</code> 复制到内核缓冲区 <code>sk_buffer</code> 后，<code>NIC</code> 立即发起一个硬件中断。<code>CPU</code> 接收后，首先进入上半部分，<strong>网卡中断对应的中断处理程序是网卡驱动程序的一部分</strong>，之后由它发起软中断，进入下半部分，开始消费 <code>sk_buffer</code> 中的数据，交给内核协议栈处理。</p><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BD%91%E5%8D%A1%E6%94%B6%E5%8C%85/20201031120547192.png" alt="img"></p><p>Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部：</p><ul><li><strong>上半部用来快速处理中断</strong>，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。特点快速执行；</li><li><strong>下半部用来延迟处理上半部未完成的工作</strong>，通常以内核线程的方式运行。特点延迟执行；</li></ul><p>上半部分硬件中断会打断 <code>CPU</code> 正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行，并且每个 <code>CPU</code> 都对应一个软中断内核线程，名字为 <strong>ksoftirqd&#x2F;CPU 编号</strong>，比如说， 0 号 <code>CPU</code> 对应的软中断内核线程的名字就是 <code>ksoftirqd/0</code>。</p><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BD%91%E5%8D%A1%E6%94%B6%E5%8C%85/640.png" alt="图片"></p><p>中断，<code>CPU</code> 能快速响应网卡的请求，但是大量数据包需要接收时，中断处理会降低 CPU 效率。</p><p>为了解决这个问题，现在的内核及驱动都采用一种叫 NAPI（new API）的方式进行数据处理，其原理可以简单理解为 中断 + 轮询，在数据量大时，一次中断后通过轮询接收一定数量包再返回，避免产生多次中断。</p><h2 id="网卡驱动"><a href="#网卡驱动" class="headerlink" title="网卡驱动"></a>网卡驱动</h2><p>在Linux的源代码中，网络设备驱动对应的逻辑位于<code>driver/net/ethernet</code>, 其中<code>intel</code>系列网卡的驱动在<code>driver/net/ethernet/intel</code>目录下。协议栈模块代码位于<code>kernel</code>和<code>net</code>目录。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247484058&idx=1&sn=a2621bc27c74b313528eefbc81ee8c0f&chksm=a6e303a191948ab7d06e574661a905ddb1fae4a5d9eb1d2be9f1c44491c19a82d95957a0ffb6&mpshare=1&scene=1&srcid=0801EnmPgBQZzVQEFjKyk7Kf&sharer_sharetime=1659361715354&sharer_shareid=79e6c1a7d49dcf7edce97768c5697437&exportkey=A547iSBR/stoMtY7WMXZFeY=&acctmode=0&pass_ticket=R9O4qICOXJkDEx0M/33HtH07gcJjvMuCt3NQ8MdRXsskdX0VpO4g9c0oKimWlRqQ&wx_header=0#rd">图解Linux网络包接收过程</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MjM5Njg5NDgwNA==&mid=2247485146&idx=1&sn=e5bfc79ba915df1f6a8b32b87ef0ef78&chksm=a6e307e191948ef748dc73a4b9a862a22ce1db806a486afce57475d4331d905827d6ca161711&mpshare=1&scene=1&srcid=0801OygzsBuKUWkHSLS3Paez&sharer_sharetime=1659361696355&sharer_shareid=79e6c1a7d49dcf7edce97768c5697437&exportkey=A+NSOu0RlBer2zr5GcM2j8k=&acctmode=0&pass_ticket=R9O4qICOXJkDEx0M/33HtH07gcJjvMuCt3NQ8MdRXsskdX0VpO4g9c0oKimWlRqQ&wx_header=0#rd">拆解 Linux 网络包发送过程</a></p></li><li><p>《Linux 设备驱动 Edition 3》</p></li><li><p><a href="https://cizixs.com/2018/01/13/linux-udp-packet-drop-debug/">linux 系统 UDP 丢包问题分析思路</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/JR-qqjNG9ClHCYoRiFg-CQ">深入理解Linux网络之网络性能优化建议</a></p></li><li><p><a href="https://www.codenong.com/cs109400686/">DPDK 网卡收包流程</a></p></li><li><p><a href="https://xiaolincoding.com/network/1_base/how_os_deal_network_package.html#linux-%E6%8E%A5%E6%94%B6%E7%BD%91%E7%BB%9C%E5%8C%85%E7%9A%84%E6%B5%81%E7%A8%8B">Linux 接收网络包的流程</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenVSwitch-测试拓扑</title>
      <link href="/2022/07/18/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/"/>
      <url>/2022/07/18/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="center">topo1</th></tr></thead><tbody><tr><td align="center"><img src="/../images/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/PKTGEN-OVS-DPDK-TESTPMD.png"></td></tr><tr><td align="center"><strong>topo2</strong></td></tr><tr><td align="center"><img src="/../images/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/QEMU-OVS-QEMU.png" alt="ovs-ovs"></td></tr><tr><td align="center"><strong>topo3</strong></td></tr><tr><td align="center"><img src="/../images/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/ovs-ovs.png" alt="ovs-ovs"></td></tr><tr><td align="center"><strong>topo4</strong></td></tr><tr><td align="center"><img src="/../images/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/ovs-ovs-ovs.png" alt="ovs-ovs-ovs"></td></tr><tr><td align="center"><strong>topo5</strong></td></tr><tr><td align="center"><img src="/../images/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/ovs-ovs-ovs2.png" alt="ovs-ovs-ovs2"></td></tr></tbody></table><h2 id="topo1"><a href="#topo1" class="headerlink" title="topo1"></a>topo1</h2><p><img src="/../images/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/PKTGEN-OVS-DPDK-TESTPMD.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 删除之前的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> /usr/local/etc/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/run/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/log/openvswitch/*</span><br><span class="line"></span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=random</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x02</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line">ovs-vsctl add-port br0 vhost-user1 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user1 <span class="built_in">type</span>=dpdkvhostuser ofport_request=1</span><br><span class="line">ovs-vsctl add-port br0 vhost-user2 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user2 <span class="built_in">type</span>=dpdkvhostuser ofport_request=2</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pktgen</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --privileged --name=app-pktgen \</span><br><span class="line">    -v /dev/hugepages:/dev/hugepages \</span><br><span class="line">    -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">    pktgen20:latest /bin/bash</span><br><span class="line"></span><br><span class="line">pktgen -c 0x19 --main-lcore 3 -n 1 --socket-mem 1024 --file-prefix pktgen --no-pci  \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user1,mac=00:00:00:00:00:01,path=/var/run/openvswitch/vhost-user1&#x27;</span> \</span><br><span class="line">-- -T -P -m <span class="string">&quot;0.0&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># testpmd</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --privileged --name=app-testpmd \</span><br><span class="line">    -v /dev/hugepages:/dev/hugepages \</span><br><span class="line">    -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">    pktgen20:latest /bin/bash</span><br><span class="line"></span><br><span class="line">dpdk-testpmd -c 0xE0 -n 1 --socket-mem 1024 --file-prefix testpmd --no-pci \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user2,mac=00:00:00:00:00:02,path=/var/run/openvswitch/vhost-user2&#x27;</span> \</span><br><span class="line">-- -i -a --coremask=0xc0 --forward-mode=rxonly</span><br></pre></td></tr></table></figure><h2 id="topo2"><a href="#topo2" class="headerlink" title="topo2"></a>topo2</h2><p><img src="/../images/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/QEMU-OVS-QEMU.png" alt="ovs-ovs"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 删除之前的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> /usr/local/etc/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/run/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/log/openvswitch/*</span><br><span class="line"></span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=random</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x02</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line">ovs-vsctl add-port br0 vhost-user1 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user1 <span class="built_in">type</span>=dpdkvhostuser ofport_request=1</span><br><span class="line">ovs-vsctl add-port br0 vhost-user2 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user2 <span class="built_in">type</span>=dpdkvhostuser ofport_request=2</span><br></pre></td></tr></table></figure><p>使用QEMU虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于vhost-user1, vhost-user2创建虚拟机</span></span><br><span class="line">qemu-system-x86_64 -enable-kvm -m 2048 -smp 4 \</span><br><span class="line">    -chardev socket,<span class="built_in">id</span>=char0,path=/usr/local/var/run/openvswitch/vhost-user1 \</span><br><span class="line">    -netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=mynet1,chardev=char0,vhostforce \</span><br><span class="line">    -device virtio-net-pci,netdev=mynet1,mac=52:54:00:02:d9:01 \</span><br><span class="line">    -object memory-backend-file,<span class="built_in">id</span>=mem,size=2048M,mem-path=/dev/hugepages,share=on \</span><br><span class="line">    -numa node,memdev=mem -mem-prealloc \</span><br><span class="line">    -net user,hostfwd=tcp::10021-:22 -net nic \</span><br><span class="line">    ./qemu-vm1.img</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 -enable-kvm -m 2048 -smp 4 \</span><br><span class="line">    -chardev socket,<span class="built_in">id</span>=char0,path=/usr/local/var/run/openvswitch/vhost-user2 \</span><br><span class="line">    -netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=mynet1,chardev=char0,vhostforce \</span><br><span class="line">    -device virtio-net-pci,netdev=mynet1,mac=52:54:00:02:d9:02 \</span><br><span class="line">    -object memory-backend-file,<span class="built_in">id</span>=mem,size=2048M,mem-path=/dev/hugepages,share=on \</span><br><span class="line">    -numa node,memdev=mem -mem-prealloc \</span><br><span class="line">    -net user,hostfwd=tcp::10022-:22 -net nic \</span><br><span class="line">    ./qemu-vm2.img &amp;</span><br></pre></td></tr></table></figure><h2 id="topo3"><a href="#topo3" class="headerlink" title="topo3"></a>topo3</h2><p><img src="/../images/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/ovs-ovs.png" alt="ovs-ovs"></p><p><strong>拓扑搭建</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sudo dpdk-hugepages.py -p 1G --setup 4G</span><br><span class="line">sudo modprobe openvswitch</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建容器</span></span><br><span class="line">sudo docker create -it --name=s1 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0</span><br><span class="line">sudo docker create -it --name=s2 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0</span><br><span class="line">sudo docker start s1</span><br><span class="line">sudo docker start s2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 veth-peer</span></span><br><span class="line">sudo ip <span class="built_in">link</span> add p1_2 <span class="built_in">type</span> veth peer name p2_1 &gt; /dev/null</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev p1_2 name p1_2 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s1) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev p2_1 name p2_1 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s2) up</span><br></pre></td></tr></table></figure><p><strong>启动OVS</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ s1 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s1 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1001</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x02</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s1 -- <span class="built_in">set</span> bridge s1 datapath_type=netdev</span><br><span class="line">ifconfig s1 192.168.1.12 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s1 p1_2 -- <span class="built_in">set</span> Interface p1_2 ofport_request=12</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s1 vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ s2 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s2 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1002</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x08</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s2 -- <span class="built_in">set</span> bridge s2 datapath_type=netdev</span><br><span class="line">ifconfig s2 192.168.1.21 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s2 p2_1 -- <span class="built_in">set</span> Interface p2_1 ofport_request=21</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s2 vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br></pre></td></tr></table></figure><h2 id="topo4"><a href="#topo4" class="headerlink" title="topo4"></a>topo4</h2><p><img src="/../images/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/ovs-ovs-ovs.png" alt="ovs-ovs-ovs"></p><p><strong>拓扑搭建</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sdpdk-hugepages.py -p 1G --setup 6G</span><br><span class="line">sudo modprobe openvswitch</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建容器</span></span><br><span class="line">sudo docker create -it --name=s1 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0</span><br><span class="line">sudo docker create -it --name=s2 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0</span><br><span class="line">sudo docker create -it --name=s3 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0</span><br><span class="line">sudo docker start s1 s2 s3</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 veth-peer</span></span><br><span class="line">sudo ip <span class="built_in">link</span> add s1_2 <span class="built_in">type</span> veth peer name s2_1 &gt; /dev/null</span><br><span class="line">sudo ip <span class="built_in">link</span> add s3_2 <span class="built_in">type</span> veth peer name s2_3 &gt; /dev/null</span><br><span class="line">sudo ip <span class="built_in">link</span> add s1_3 <span class="built_in">type</span> veth peer name s3_1 &gt; /dev/null</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s1_2 name s1_2 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s1) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s1_3 name s1_3 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s1) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s2_1 name s2_1 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s2) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s2_3 name s2_3 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s2) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s3_1 name s3_1 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s3) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s3_2 name s3_2 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s3) up</span><br></pre></td></tr></table></figure><p><strong>启动OVS</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ s1 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s1 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1001</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x02</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s1 -- <span class="built_in">set</span> bridge s1 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s1 other_config:hwaddr=<span class="string">&quot;00:00:00:00:10:01&quot;</span></span><br><span class="line">ifconfig s1 192.168.10.1 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s1 s1_2 -- <span class="built_in">set</span> Interface s1_2 ofport_request=12</span><br><span class="line">ovs-vsctl add-port s1 s1_3 -- <span class="built_in">set</span> Interface s1_3 ofport_request=13</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s1 vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ s2 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s2 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1002</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x08</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s2 -- <span class="built_in">set</span> bridge s2 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s2 other_config:hwaddr=<span class="string">&quot;00:00:00:00:10:02&quot;</span></span><br><span class="line">ifconfig s2 192.168.10.2 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s2 s2_1 -- <span class="built_in">set</span> Interface s2_1 ofport_request=21</span><br><span class="line">ovs-vsctl add-port s2 s2_3 -- <span class="built_in">set</span> Interface s2_3 ofport_request=23</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s2 vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ s3 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s3 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1002</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x20</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s3 -- <span class="built_in">set</span> bridge s3 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s3 other_config:hwaddr=<span class="string">&quot;00:00:00:00:10:03&quot;</span></span><br><span class="line">ifconfig s3 192.168.10.3 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s3 s3_1 -- <span class="built_in">set</span> Interface s3_1 ofport_request=31</span><br><span class="line">ovs-vsctl add-port s3 s3_2 -- <span class="built_in">set</span> Interface s3_2 ofport_request=32</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s3vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br></pre></td></tr></table></figure><p><strong>转发流表</strong>：1&lt;-&gt;2 ，2&lt;-&gt;3 ，1&lt;-&gt;3</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s1</span></span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.1,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.2,actions=output:s1_2</span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.3,actions=output:s1_3</span><br><span class="line"><span class="comment"># s2</span></span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.2,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.1,actions=output:s2_1</span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.3,actions=output:s2_3</span><br><span class="line"><span class="comment"># s3</span></span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.3,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.1,actions=output:s3_1</span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.2,actions=output:s3_2</span><br><span class="line"><span class="comment"># arp</span></span><br><span class="line">arp -s 192.168.10.1 00:00:00:00:10:01</span><br><span class="line">arp -s 192.168.10.2 00:00:00:00:10:02</span><br><span class="line">arp -s 192.168.10.3 00:00:00:00:10:03</span><br></pre></td></tr></table></figure><h2 id="topo5"><a href="#topo5" class="headerlink" title="topo5"></a>topo5</h2><p><strong>转发流表2</strong>：1&lt;-&gt;2&lt;-&gt;3 (1与3不直连)</p><p><img src="/../images/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/ovs-ovs-ovs2.png" alt="ovs-ovs-ovs2"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s1</span></span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.1,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.2,actions=output:s1_2</span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.3,actions=output:s1_2</span><br><span class="line"><span class="comment"># s2</span></span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.2,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.1,actions=output:s2_1</span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.3,actions=output:s2_3</span><br><span class="line"><span class="comment"># s3</span></span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.3,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.1,actions=output:s3_2</span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.2,actions=output:s3_2</span><br><span class="line"><span class="comment"># arp</span></span><br><span class="line">arp -s 192.168.10.1 00:00:00:00:10:01</span><br><span class="line">arp -s 192.168.10.2 00:00:00:00:10:02</span><br><span class="line">arp -s 192.168.10.3 00:00:00:00:10:03</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OpenVSwitch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenVSwitch </tag>
            
            <tag> DPDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程-分析工具</title>
      <link href="/2022/07/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/07/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th align="left">名称</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left"><strong>dstat</strong></td><td align="left">查看各种系统资源的统计信息，可保存到文件！</td></tr><tr><td align="left"><strong>iftop</strong></td><td align="left">display bandwidth usage on an interface by host. 可指定TCP&#x2F;UDP端口</td></tr><tr><td align="left"><strong>ip</strong></td><td align="left">show &#x2F; manipulate routing, network devices, interfaces and tunnels</td></tr><tr><td align="left"><strong>ip link</strong></td><td align="left"></td></tr><tr><td align="left"><strong>ip route</strong></td><td align="left"></td></tr><tr><td align="left"><strong>iptables</strong></td><td align="left">administration tool for IPv4&#x2F;IPv6 packet filtering and NAT</td></tr><tr><td align="left"><strong>lsof</strong></td><td align="left">list open files. 查看端口被谁占用</td></tr><tr><td align="left"><strong>nc</strong></td><td align="left">arbitrary TCP and UDP connections and listens.</td></tr><tr><td align="left"><strong>netstat</strong></td><td align="left">打印网络连接、路由表、连接的数据统计、伪装连接以及广播域成员</td></tr><tr><td align="left"><strong>ss</strong></td><td align="left">another utility to investigate sockets.</td></tr><tr><td align="left"><strong>tcpdump</strong></td><td align="left">抓包工具</td></tr><tr><td align="left"><strong>telnet</strong></td><td align="left">user interface to the TELNET protocol.</td></tr><tr><td align="left"><strong>wrk</strong></td><td align="left">http 压测工具</td></tr><tr><td align="left"><strong>top</strong></td><td align="left"></td></tr></tbody></table><h2 id="dstat"><a href="#dstat" class="headerlink" title="dstat"></a>dstat</h2><blockquote><ul><li><a href="https://www.cnblogs.com/zh-dream/p/12081455.html">dstat命令详解</a></li></ul></blockquote><h2 id="iftop"><a href="#iftop" class="headerlink" title="iftop"></a>iftop</h2><blockquote><ul><li><a href="https://www.cnblogs.com/yinzhengjie/p/6223467.html">iftop命令详解</a></li></ul></blockquote><h2 id="ip"><a href="#ip" class="headerlink" title="ip"></a>ip</h2><h2 id="ip-route"><a href="#ip-route" class="headerlink" title="ip route"></a>ip route</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ip route add &lt;your_network_address&gt;/24 dev &lt;your_interface&gt;</span><br></pre></td></tr></table></figure><h2 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h2><blockquote><ul><li><a href="https://wangchujiang.com/linux-command/c/iptables.html">iptables 中文文档</a></li><li><a href="https://linux.die.net/man/8/iptables">iptables - Linux man page</a></li><li><a href="https://blog.51cto.com/yangzhiming/1982814">Ubuntu iptables配置</a></li></ul></blockquote><p><strong>注意：规则的次序非常关键，<code>谁的规则越严格，应该放的越靠前</code>，而检查规则的时候，是按照从上往下的方式进行检查的。</strong></p><p>1、<code>Ubuntu</code> 默认有装<code>iptables</code>，可通过<code>dpkg -l</code>或<code>which iptables</code>确认</p><p>2、<code>Ubuntu</code> 默认没有<code>iptables</code>配置文件，需通过<code>iptables-save &gt; /etc/network/iptables.up.rules</code>生成</p><p>3、<code>iptables</code>配置文件路径及文件名建议为<code>/etc/network/iptables.up.rules</code>，因为执行<code>iptables-apply</code>默认指向该文件，也可以通过-w参数指定文件</p><p>4、<code>Ubuntu</code> 没有重启<code>iptables</code>的命令，执行<code>iptables-apply</code>生效</p><p>5、<code>Ubuntu iptables</code>默认重启服务器后清空，需在<code>/etc/network/interfaces</code>里写入<code>pre-up iptables-restore &lt; /etc/network/iptables.up.rules</code>才会开机生效</p><h2 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h2><blockquote><ul><li><a href="https://wangchujiang.com/linux-command/c/lsof.html">lsof 文档</a></li></ul></blockquote><h2 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h2><blockquote><ul><li><a href="https://www.cnblogs.com/zhaijiahui/p/9028402.html#autoid-3-2-3">nc工具使用</a></li></ul></blockquote><h2 id="ss"><a href="#ss" class="headerlink" title="ss"></a>ss</h2><blockquote><ul><li><a href="https://www.cnblogs.com/machangwei-8/p/10352986.html">ss命令详解</a></li></ul></blockquote><h2 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h2><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20200628111325.png" alt="img"></p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>tcpdump -n</code></td><td>不把IP转化成域名，直接显示 ，<strong>若不加，使用<code>ctrl+c</code>停止时会很慢</strong></td></tr><tr><td><code>tcpdump -nn</code></td><td>不把协议和端口号转化成名字，速度会更快</td></tr><tr><td><code>tcpdump host www.baidu.com</code></td><td>抓取某个网站</td></tr><tr><td><code>tcpdump host 192.168.10.100</code></td><td>基于<strong>IP地址</strong>过滤</td></tr><tr><td><code>tcpdump host src 192.168.10.100</code></td><td>基于<strong>源IP地址</strong>过滤</td></tr><tr><td><code>tcpdump ip dst 192.168.10.100</code></td><td>基于<strong>目的IP地址</strong>过滤</td></tr><tr><td><code>tcpdump net 192.168.10.0/24</code></td><td>基于<strong>网段</strong>进行过滤</td></tr><tr><td><code>tcpdump tcp port 8088</code></td><td>基于<strong>端口</strong>进行过滤</td></tr><tr><td><code>tcpdump -nn tcp src port 10000</code></td><td>基于传输层协议+端口过滤</td></tr><tr><td><code>tcpdump port 80 or port 8088</code></td><td>同时指定两个端口</td></tr><tr><td><code>tcpdump portrange 8000-8080</code></td><td>指定一个端口范围</td></tr><tr><td><code>tcpdump icmp</code></td><td>基于协议进行过滤<code>ip ip6 arp icmp rarp</code></td></tr><tr><td><code>tcpdump ip proto 6</code></td><td>基本IP协议的版本进行过滤</td></tr><tr><td><code>tcpdump -i eth0</code></td><td>过滤指定网卡的数据包</td></tr><tr><td><code>tcpdump -e</code></td><td>每行的打印输出中将包括数据包的<strong>数据链路层头部信息</strong></td></tr><tr><td><code>tcpdump ether host src [mac]</code></td><td>根据 mac 地址进行过滤</td></tr><tr><td><code>tcpdump -c 100</code></td><td><strong>捕获100个包就退出</strong></td></tr><tr><td><code>tcpdump -A</code></td><td><strong>以ASCII码方式显示</strong>每一个数据包(不显示链路层头部信息)</td></tr><tr><td><code>tcpdump -w icmp.pcap</code></td><td>抓到的包数据生成到文件中，以<code>.pcap</code>为后缀</td></tr><tr><td><code>tcpdump -r icmp.pcap</code></td><td>从文件中读取包数据</td></tr></tbody></table><ul><li><p><strong>组合过滤</strong></p><ul><li>and：所有的条件都需要满足，也可以表示为 <code>&amp;&amp;</code></li><li>or：只要有一个条件满足就可以，也可以表示为 <code>||</code></li><li>not：取反，也可以使用 <code>!</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -nn <span class="string">&#x27;ether src 04:42:1a:ea:da:ad &amp;&amp; ip src 192.168.0.3 and udp src port 10000&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>控制详细内容的输出</strong></p><ul><li><code>-v</code>：产生详细的输出. 比如包的TTL，id标识，数据包长度，以及IP包的一些选项。同时它还会打开一些附加的包完整性检测，比如对IP或ICMP包头部的校验和。</li><li><code>-vv</code>：产生比-v更详细的输出. 比如NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码。（摘自网络，目前我还未使用过）</li><li><code>-vvv</code>：产生比-vv更详细的输出。比如 telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面，其相应的图形选项将会以16进制的方式打印出来（摘自网络，目前我还未使用过）</li></ul></li><li><p><strong>控制时间的显示</strong></p><ul><li><code>-t</code>：在每行的输出中不输出时间</li><li><code>-tt</code>：在每行的输出中会输出时间戳</li><li><code>-ttt</code>：输出每两行打印的时间间隔(以毫秒为单位)</li><li><code>-tttt</code>：在每行打印的时间戳之前添加日期的打印（此种选项，输出的时间最直观）</li></ul></li><li><p><strong>显示数据包的头部</strong></p><ul><li><code>-x</code>：以16进制的形式打印每个包的头部数据（但不包括数据链路层的头部）</li><li><code>-xx</code>：以16进制的形式打印每个包的头部数据（包括数据链路层的头部）</li><li><code>-X</code>：以16进制和 ASCII码形式打印出每个包的数据(但不包括连接层的头部)，这在分析一些新协议的数据包很方便。</li><li><code>-XX</code>：以16进制和 ASCII码形式打印出每个包的数据(包括连接层的头部)，这在分析一些新协议的数据包很方便。</li></ul></li></ul><blockquote><ul><li><a href="https://www.cnblogs.com/wongbingming/p/13212306.html">推荐先看这个：全网最详细的 tcpdump 使用指南</a></li><li><a href="https://github.com/mylxsw/growing-up/blob/master/doc/tcpdump%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B.md">tcpdump简明教程</a></li><li><a href="https://colobu.com/2019/07/16/a-tcpdump-tutorial-with-examples/">tcpdump 示例教程</a></li></ul></blockquote><h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>打印网络连接、路由表、连接的数据统计、伪装连接以及广播域成员。</p><blockquote><p><a href="https://wangchujiang.com/reference/docs/netstat.html">Netstat 备忘清单</a></p></blockquote><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>netstat -a</code></td><td>列出 <code>tcp</code>, <code>udp</code> 和 <code>unix</code> 协议下所有套接字的所有连接</td></tr><tr><td><code>netstat -t</code></td><td>只列出 <code>TCP</code> 协议的连接</td></tr><tr><td><code>netstat -u</code></td><td>只列出 <code>UDP</code> 协议的连接</td></tr><tr><td><code>netstat -ant</code></td><td>禁用反向域名解析（不显示主机名），加快查询速度</td></tr><tr><td><code>netstat -tnl</code></td><td>只列出监听中的连接，<code>-l</code></td></tr><tr><td><code>netstat -nlpt</code></td><td>获取进程名、进程号以及用户 ID，<code>-p</code> 进程信息</td></tr><tr><td><code>netstat -ltpe</code></td><td>使用 <code>-ep</code> 选项可以同时查看进程名和用户名。</td></tr><tr><td><code>netstat -s</code></td><td>打印统计数据</td></tr><tr><td><code>netstat -rn</code></td><td>显示内核路由信息</td></tr><tr><td><code>netstat -i</code></td><td>打印网络接口</td></tr><tr><td><code>netstat -ct</code></td><td>使用 <code>netstat</code> 的 <code>-c</code> 选项持续输出信息</td></tr><tr><td><code>netstat -g</code></td><td>显示多播组信息</td></tr></tbody></table><h2 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h2><h2 id="wrk"><a href="#wrk" class="headerlink" title="wrk"></a>wrk</h2><h2 id="top"><a href="#top" class="headerlink" title="top"></a>top</h2><p>Linux 的 top 命令用于实时显示系统中<strong>各个进程</strong>的 CPU 和内存使用情况。</p><blockquote><p><a href="https://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316399.html">top命令详解</a></p></blockquote><p>top 能查看的信息有：</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://linux.cn/article-2434-1.html">netstat 的10个基本用法</a></li><li><a href="https://www.binarytides.com/linux-ss-command/">ss 的10个基本用法</a></li><li><a href="https://linux.cn/article-2493-1.html">如何在Linux下统计高速网络中的流量</a></li><li><a href="https://blog.csdn.net/zqixiao_09/article/details/79165925">Linux下路由配置</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis笔记</title>
      <link href="/2022/06/24/Redis%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/06/24/Redis%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Redis 是一个高性能的、键值对数据库，<strong>数据直接存储在内存中</strong>，只有需要持久化时才写入硬盘。</p><h2 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h2><p>ubuntu 下使用 apt 安装的 redis 版本较老，可采用源码安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.6.tar.gz &amp;&amp; tar xzf redis-6.2.6.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> redis-stable &amp;&amp; make -j</span><br><span class="line">make <span class="built_in">test</span></span><br><span class="line">sudo make install</span><br><span class="line">sudo <span class="built_in">mkdir</span> /etc/redis &amp;&amp; sudo <span class="built_in">cp</span> redis.conf /etc/redis <span class="comment"># 复制配置文件到 /etc</span></span><br></pre></td></tr></table></figure><p>安装完成后，会有以下命令可用：</p><ul><li><strong>redis-cli</strong>: Redis客户端</li><li><strong>redis-server</strong>: Redis服务器启动命令</li><li><strong>redis-benchmark</strong>: 性能测试工具</li><li><strong>redis-check-aof</strong>: 修复有问题的AOF文件</li><li><strong>redis-check-rdb</strong>: 修复有问题的RDB文件</li><li><strong>redis-sentinel</strong>: Redis集群使用</li></ul><p>设置好配置文件后，启动方法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p><code>Redis</code> 启动时有很多配置参数，这些参数设置均在 <code>redis.conf</code> 中，且有注释和分类，<strong>注意：redis 配置文件中注释必须以 # 开头，且必须单独一行</strong>。</p><p><strong>除了在启动前通过修改配置文件的方式修改配置，启动后也可通过<code>CONFIG SET/GET</code>命令修改、查看配置。</strong></p><p><code>Redis</code> 的所有特性和功能都在配置文件中有所体现，建议仔细了解。</p><p><strong>NETWORK</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span> 127.0.0.1 ::1  <span class="comment"># 允许指定地址的host访问server，如果要全部都能访问，注释掉该行</span></span><br><span class="line">                    <span class="comment"># 注意，即使注释掉了bind，但protect-mode启动了的，</span></span><br><span class="line">                    <span class="comment"># 并且没有给server设置密码，外部仍然无法访问</span></span><br><span class="line">protected-mode <span class="built_in">yes</span>  <span class="comment"># 保护模式，禁止其他主机在无密码的方式下访问本机的redis-server</span></span><br><span class="line">port 6379           <span class="comment"># 监听端口号</span></span><br><span class="line">tcp-backlog         <span class="comment"># 连接队列=未完成三次握手队列+已经完成三次握手队列，高并发环境下需要高 backlog 值</span></span><br><span class="line"><span class="built_in">timeout</span> 0           <span class="comment"># 客户端N秒空闲后，关闭连接，0永不关闭</span></span><br><span class="line">tcp-keepalive 300   <span class="comment"># 对访问客户端的一种心跳检测，每个n秒检测一次，建议设60</span></span><br><span class="line">unixsocket /tmp/redis.sock <span class="comment"># 使用unixsocket连接，比 ip+port 效率更高</span></span><br></pre></td></tr></table></figure><p><strong>GENERAL</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span>       <span class="comment"># 设置守护进程（后台启动），关闭当前终端后不会关闭redis</span></span><br><span class="line">loglevel notice     <span class="comment"># 日志级别，总共支持四个级别：debug、verbose、notice、warning</span></span><br><span class="line">logfile <span class="string">&quot;&quot;</span>          <span class="comment"># 指定日志文件名称</span></span><br><span class="line">databases 16        <span class="comment"># 设置库的数量</span></span><br></pre></td></tr></table></figure><p><strong>SNAPSHOTTING</strong> 保存数据到磁盘文件 <strong>RDB</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">save 3600 1 300 100 60 10000</span><br><span class="line">                    <span class="comment"># 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可多个条件配合</span></span><br><span class="line">rdbcompression <span class="built_in">yes</span>  <span class="comment"># 指定存储至本地数据库时是否压缩数据，默认为 yes，Redis 采用 LZF 压缩，</span></span><br><span class="line">                    <span class="comment"># 如果为了节省 CPU 时间，可以关闭该选项，但会导致数据库文件变的巨大</span></span><br><span class="line">dbfilename dump.rdb <span class="comment"># 指定本地数据库文件名</span></span><br><span class="line"><span class="built_in">dir</span> ./              <span class="comment"># 指定本地数据库文件的存放路径</span></span><br></pre></td></tr></table></figure><p><strong>REPLICATION</strong> 同步到从机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">                    <span class="comment"># 设置当本机为 slave 服务时，设置 master 服务的 IP 地址及端口，</span></span><br><span class="line">                    <span class="comment"># 在 Redis 启动时，它会自动从 master 进行数据同步</span></span><br><span class="line">masterauth &lt;master-password&gt;</span><br><span class="line">                    <span class="comment"># 当 master 服务设置了密码保护时，slave 服务连接 master 的密码</span></span><br></pre></td></tr></table></figure><p><strong>SECURITY</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requirepass 123456  <span class="comment"># 设置server密码，默认不带密码！！！</span></span><br></pre></td></tr></table></figure><p><strong>CLIENTS</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxclients 120      <span class="comment"># 最多连接的客户端数目，设置同一时间最大客户端连接数，默认无限制，</span></span><br><span class="line">                    <span class="comment"># Redis 可同时打开的客户端连接数为Redis进程可打开的最大文件描述符数</span></span><br></pre></td></tr></table></figure><p><strong>MEMORY</strong>:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt;   <span class="comment"># 指定 Redis 最大内存限制，Redis 数据都在内存中，达到最大内存后，</span></span><br><span class="line">                    <span class="comment"># Redis 会先尝试清除部分key，清除策略由 maxmemory-policy 指定</span></span><br><span class="line">                    <span class="comment"># 若无法有效清除，将无法再进行写入操作，但仍然可以进行读取操作。</span></span><br><span class="line">                    <span class="comment"># Redis 新的 vm 机制，会把 Key 存放内存，Value 会存放在 swap 区</span></span><br><span class="line">maxmemory-policy noeviction</span><br><span class="line">                    <span class="comment"># volatile-lru：使用 LRU 算法移除 key，只对设置了过期时间的键；</span></span><br><span class="line">                    <span class="comment"># allkeys-lru：在所有集合 key 中，使用 LRU 算法移除 key</span></span><br><span class="line">                    <span class="comment"># LRU是淘汰最长时间没有被使用的，LFU是淘汰一段时间内，使用次数最少的</span></span><br><span class="line">                    <span class="comment"># volatile-lfu：使用 LFU 算法移除 key，只对设置了过期时间的键；</span></span><br><span class="line">                    <span class="comment"># allkeys-lfu：在所有集合 key 中，使用 LFU 算法移除 key</span></span><br><span class="line">                    <span class="comment"># volatile-random：在过期集合中移除随机的 key，只对设置了过期时间的键</span></span><br><span class="line">                    <span class="comment"># allkeys-random：在所有集合 key 中，移除随机的 key</span></span><br><span class="line">                    <span class="comment"># volatile-ttl：移除那些 TTL 值最小的 key，即那些最近要过期的 key</span></span><br><span class="line">                    <span class="comment"># noeviction：不进行移除。针对写操作，只是返回错误信息</span></span><br></pre></td></tr></table></figure><p><strong>APPEND ONLY MODE</strong> 保存写操作到文件 <strong>AOF</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">appendonly no       <span class="comment"># 是否启用AOF，将写操作记录到文件，以便重启时恢复数据</span></span><br><span class="line">appendfilename appendonly.aof</span><br><span class="line">                    <span class="comment"># 指定保存操作信息的文件名</span></span><br><span class="line">appenddirname <span class="string">&quot;&quot;</span>    <span class="comment"># 指定保存操作信息的文件路径</span></span><br><span class="line">appendfsync no      <span class="comment"># 指定更新操作记录的条件：</span></span><br><span class="line">                    <span class="comment"># no：表示不主动进行同步，把同步时机交给操作系统。</span></span><br><span class="line">                    <span class="comment"># always：始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好</span></span><br><span class="line">                    <span class="comment"># everysec：表示每秒同步一次，如果宕机，本秒的数据可能丢失。</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">                    <span class="comment"># AOF 采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,</span></span><br><span class="line">                    <span class="comment"># 当AOF 文件的大小超过所设定的阈值时，Redis 就会启动 AOF 文件的内容压缩，</span></span><br><span class="line">                    <span class="comment"># 只保留可以恢复数据的最小指令集</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line">                    <span class="comment"># 设置重写的基准值，最小文件 64MB。达到这个值开始重写</span></span><br></pre></td></tr></table></figure><h3 id="Docker-运行"><a href="#Docker-运行" class="headerlink" title="Docker 运行"></a>Docker 运行</h3><p><code>Redis</code> 官方有提供镜像，可直接<code>docker pull redis:6.2.6</code>拉取。</p><p>主要是启动时的端口和文件映射，需要根据<code>Redis</code>存储的文件路径和使用的端口确定。下面是一个例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 准备一个空文件夹存放redis相关的数据</span></span><br><span class="line"><span class="built_in">mkdir</span> redisdata &amp;&amp; <span class="built_in">cd</span> redisdata</span><br><span class="line"><span class="comment"># 2. 创建并编辑配置文件，下面给了一个示例</span></span><br><span class="line">vim redis.conf</span><br><span class="line"><span class="comment"># 3. 拉取 redis 镜像</span></span><br><span class="line">docker pull redis:6.2.6</span><br><span class="line"><span class="comment"># 4. 启动容器，下面非后台运行，使用 `-d` 后台运行</span></span><br><span class="line">docker run --name redis -p 6379:6379 -v $(<span class="built_in">pwd</span>):/data \</span><br><span class="line">    redis:6.2.6 redis-server /data/redis.conf</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ol><li><p><strong>配置文件的中设置不对会造成容器启动后又马上</strong><code>Exit</code>，一个简单的示例如下：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bind 127.0.0.1 ::1</span></span><br><span class="line"><span class="comment"># daemonize 必须设置为默认的 no</span></span><br><span class="line">daemonize no</span><br><span class="line"><span class="comment"># 设置RDB备份文件目录</span></span><br><span class="line"><span class="built_in">dir</span> /data/</span><br><span class="line"><span class="comment"># 目录不存在也会导致容器自动停止</span></span><br><span class="line">logfile <span class="string">&quot;/data/redis-server.log&quot;</span></span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">requirepass 123456</span><br></pre></td></tr></table></figure></li><li><p>配置文件中的相关路径要有效。</p></li><li><p>如果在 <code>Docker</code> 中运行 <code>Redis</code> ，并且设置 <code>daemonize</code> 为 <code>yes</code>，即将 <code>Redis</code> 进程守护化时，最终的 <code>Docker exec</code> 进程（启动 <code>Redis</code> 的那个进程）就无事可做了，所以该进程退出，容器也随之结束。<a href="https://stackoverflow.com/questions/50790197/why-redis-in-docker-need-set-daemonize-to-no">来自 stackoverflow 上的回答</a></p></li><li><p>如果希望 <code>redis</code> <strong>后台运行可以使用 <code>-d</code> 选项</strong>，不过这样启动失败时难以查看错误的日志信息，所以可以先不带该选项测试是否可正常启动。无误后再使用<code>-d</code>选项。</p></li><li><p><strong>启动失败后，记得删除掉该容器</strong>，再重新尝试启动，否则名字冲突导致启动失败。</p></li></ol><p>也可以自制镜像，将设置好的配置文件拷贝到容器中。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> redis</span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> redis.conf /etc/redis/redis.conf</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [ <span class="string">&quot;redis-server&quot;</span>, <span class="string">&quot;/etc/redis/redis.conf&quot;</span>]</span></span><br></pre></td></tr></table></figure><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 127.0.0.1 -p 6379 -a password</span><br><span class="line"><span class="comment">#  -h &lt;hostname&gt;      Server hostname (default: 127.0.0.1).</span></span><br><span class="line"><span class="comment">#  -s &lt;socket&gt;        Server socket (overrides hostname and port).</span></span><br><span class="line"><span class="comment">#  -a &lt;password&gt;      Password to use when connecting to the server.</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>auth</strong> passwd</td><td align="left">授权</td></tr><tr><td align="left"><strong>ping</strong></td><td align="left">测试连通性</td></tr><tr><td align="left"><strong>shutdown</strong></td><td align="left">关闭数据库服务进程 <code>redis-server</code></td></tr><tr><td align="left"><strong>select</strong> index</td><td align="left">切换数据库</td></tr><tr><td align="left"><strong>create</strong> index</td><td align="left">创建数据库</td></tr><tr><td align="left"><strong>drop</strong> index</td><td align="left">删除数据库</td></tr></tbody></table><h3 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h3><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>keys</strong> *</td><td align="left">查看当前库的所有key</td></tr><tr><td align="left"><strong>exists</strong> key</td><td align="left">查看key是否存在</td></tr><tr><td align="left"><strong>del</strong> key</td><td align="left">删除key</td></tr><tr><td align="left"><strong>unlink</strong> key</td><td align="left">删除key，只是将key从数据库中删除，真正的删除会在后续异步操作</td></tr><tr><td align="left"><strong>type</strong> key</td><td align="left">查看key的类型</td></tr><tr><td align="left"><strong>expire</strong> key seconds</td><td align="left">设置key的过期时间</td></tr><tr><td align="left"><strong>ttl</strong> key</td><td align="left">查看key的过期时间</td></tr><tr><td align="left"><strong>dbsize</strong></td><td align="left">查看当前库的key数量</td></tr><tr><td align="left"><strong>flushdb</strong></td><td align="left">清空当前库</td></tr><tr><td align="left"><strong>flushall</strong></td><td align="left">清空所有库</td></tr></tbody></table><p>虽然 <code>Redis</code> 是 <code>key-value</code> 的方式存储数据，<code>key</code> 与 <code>key</code> 之间没有关系，但通常可以通过 <code>key</code> 的命名来提供一定的“信息”，<code>Redis</code> 的官方文档推荐使用冒号<code>:</code>作为键名的分隔符，因为它可以提高可读性和维护性，并且可以利用<code>SCAN</code>命令进行模式匹配。并且通常在使用 <code>GUI</code> 工具查看数据时，也会用<code>:</code>来分组。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">set</span> <span class="string">md|dv:label:json</span> <span class="number">0</span></span><br><span class="line"><span class="string">set</span> <span class="string">md|dv:a94de756-b776-496b-bfe1-a6f3edd1d0cd</span> <span class="number">0</span></span><br><span class="line"><span class="string">set</span> <span class="string">md|dv:0f0a1014-43be-4531-95ee-34fdffc0b681</span> <span class="number">0</span></span><br><span class="line"><span class="string">set</span> <span class="string">md|dv:service:name:device-rest</span> <span class="number">0</span></span><br><span class="line"><span class="string">set</span> <span class="string">md|dv:label:float</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><p>上面的几个 <code>key</code> 在 <code>redis-desktop-manager</code> 中显示效果如下：</p><p><img src="/../images/Redis%E7%AC%94%E8%AE%B0/image-20230307231649741.png" alt="image-20230307231649741"></p><p>注意：是以 <code>:</code> 分割，<code>key</code>中的<code>|</code>没有实际意义。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String 是二进制安全的，可以包含任何数据。如jpg图片或者序列化的对象，但最大长度512MB。</p><p>String 的数据结构为动态字符串，当字符串小于1Mb时，加倍扩容；大于1Mb时，一次扩容增加1Mb。</p><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>set</strong> key value</td><td align="left">设置key的值，如果key存在，则覆盖</td></tr><tr><td align="left"><strong>get</strong> key</td><td align="left">查看 key 对应的值</td></tr><tr><td align="left"><strong>append</strong> key value</td><td align="left">在key的值后面追加value</td></tr><tr><td align="left"><strong>strlen</strong> key</td><td align="left">查看key的长度</td></tr><tr><td align="left"><strong>setnx</strong> key value</td><td align="left">只有当key不存在时，才设置key的值，否则不设置</td></tr><tr><td align="left"><strong>incr</strong> key</td><td align="left">将key的值增加1</td></tr><tr><td align="left"><strong>decr</strong> key</td><td align="left">将key的值减少1</td></tr><tr><td align="left"><strong>incrby</strong> key increment</td><td align="left">将key的值增加increment</td></tr><tr><td align="left"><strong>decrby</strong> key decrement</td><td align="left">将key的值减少decrement</td></tr></tbody></table><p><strong>批量操作的命令</strong>：</p><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>mset</strong> key1 value1 … keyN valueN</td><td align="left">设置多个key的值</td></tr><tr><td align="left"><strong>mget</strong> key1 … keyN</td><td align="left">获取多个key的值</td></tr><tr><td align="left"><strong>msetnx</strong> key1 value1 … keyN valueN</td><td align="left">只有当所有key都不存在时，才设置多个key的值，一个失败则全部失败</td></tr><tr><td align="left"><strong>getrange</strong> key start end</td><td align="left">获取key的值的一部分 [start, end], 包含start 和end</td></tr><tr><td align="left"><strong>setrange</strong> key offset value</td><td align="left">设置key的值的一部分 [offset, offset+value.length()], <br />如果offset+value.length()大于key的长度，则扩展key的长度</td></tr><tr><td align="left"><strong>setex</strong> key seconds value</td><td align="left">设置key的值并设置过期时间</td></tr><tr><td align="left"><strong>getset</strong> key value</td><td align="left">设置key的值，并返回key的旧值</td></tr></tbody></table><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>列表是值的结构，多个字符串的集合，底层是一个双向链表，对两端的操作性能很高，对中间的操作性能较差。</p><p>底层：quicklist，将部分数据组合为一个ziplist，多个ziplist通过前后指针组合为双向链表（quicklist），避免对单个小值如 int 分配两个前后指针，节约空间。</p><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>lpush</strong> key value</td><td align="left">在key的左边添加一个值（也可同时插入多个值）</td></tr><tr><td align="left"><strong>rpush</strong> key value</td><td align="left">在key的右边添加一个值</td></tr><tr><td align="left"><strong>lrange</strong> key start stop</td><td align="left">获取key的值的一部分，包含start和stop</td></tr><tr><td align="left"><strong>lpop</strong> key</td><td align="left">删除并返回key的左边的值（值在键在，值空键消）</td></tr><tr><td align="left"><strong>rpop</strong> key</td><td align="left">删除并返回key的右边的值</td></tr><tr><td align="left"><strong>lpoplpush</strong> source destination</td><td align="left">将source的左边的值移动到destination的右边</td></tr><tr><td align="left"><strong>lpoprpush</strong> source destination</td><td align="left">将source的左边的值移动到destination的右边</td></tr><tr><td align="left"><strong>rpoprpush</strong> source destination</td><td align="left">将source的右边的值移动到destination的左边</td></tr><tr><td align="left"><strong>rpoplpush</strong> source destination</td><td align="left">将source的右边的值移动到destination的左边</td></tr><tr><td align="left"><strong>lindex</strong> key index</td><td align="left">获取key的值的第index个元素</td></tr><tr><td align="left"><strong>llen</strong> key</td><td align="left">获取key的值的长度</td></tr><tr><td align="left"><strong>linsert</strong> key before</td><td align="left">after pivot value</td></tr><tr><td align="left"><strong>lrem</strong> key count value</td><td align="left">从左边删除count个值为value的元素</td></tr><tr><td align="left"><strong>lset</strong> key index value</td><td align="left">设置key的值的第index个元素的值</td></tr></tbody></table><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>值部分也是 field-value 结构！</p><p>底层有两种：当数据较少时用zipist，当数据较多时用hashtable。</p><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>hset</strong> key field value</td><td align="left">设置key的值的field的值</td></tr><tr><td align="left"><strong>hget</strong> key field</td><td align="left">获取key的值的field的值</td></tr><tr><td align="left"><strong>hmset</strong> key field1 value1 … fieldN valueN</td><td align="left">设置key的值的多个field的值</td></tr><tr><td align="left"><strong>hexists</strong> key field</td><td align="left">判断key的值是否包含field</td></tr><tr><td align="left"><strong>hkeys</strong> key</td><td align="left">获取key的值的所有field</td></tr><tr><td align="left"><strong>hvals</strong> key</td><td align="left">获取key的值的所有value</td></tr><tr><td align="left"><strong>hlen</strong> key</td><td align="left">获取key的值的长度</td></tr><tr><td align="left"><strong>hdel</strong> key field</td><td align="left">删除key的值的field</td></tr><tr><td align="left"><strong>hincrby</strong> key field increment</td><td align="left">设置key的值的field的值加increment</td></tr><tr><td align="left"><strong>hsetnx</strong> key field value</td><td align="left">只有在key的值的field不存在时，才设置key的值的field的值</td></tr></tbody></table><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>string 类型的无序集合，底层为哈希表，与list类似，但是没有重复的值，每个值都是唯一的。</p><p>底层：字典，用hash实现。</p><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>sadd</strong> key value</td><td align="left">将一个或多个值插入到key的集合中</td></tr><tr><td align="left"><strong>smembers</strong> key</td><td align="left">获取key的值的所有元素</td></tr><tr><td align="left"><strong>sismember</strong> key value</td><td align="left">判断key的值是否包含value</td></tr><tr><td align="left"><strong>scard</strong> key</td><td align="left">获取key的值的长度</td></tr><tr><td align="left"><strong>srem</strong> key value</td><td align="left">删除key的值中的value</td></tr><tr><td align="left"><strong>spop</strong> key</td><td align="left">随机获取并删除key的值中的一个元素</td></tr><tr><td align="left"><strong>srandmember</strong> key</td><td align="left">随机获取key的值中的一个元素，但不删除</td></tr><tr><td align="left"><strong>smove</strong> source destination value</td><td align="left">将source的值中的value移动到destination的值中</td></tr><tr><td align="left"><strong>sinter</strong> source1 … sourceN</td><td align="left">获取所有source的值的交集</td></tr><tr><td align="left"><strong>sunion</strong> source1 … sourceN</td><td align="left">获取所有source的值的并集</td></tr><tr><td align="left"><strong>sdiff</strong> source1 … sourceN</td><td align="left">获取所有source的值的差集</td></tr></tbody></table><h3 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h3><p>与set类似，但是一个有序集合，每个值都有一个score，score越小，编号越小</p><p>底层：hash + 跳跃表</p><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>zadd</strong> key score value</td><td align="left">将一个或多个值插入到key的有序集合中</td></tr><tr><td align="left"><strong>zrange</strong> key start stop [withscores]</td><td align="left">获取key的值的一部分，包含start和stop</td></tr><tr><td align="left"><strong>zrangebyscore</strong> key min max [withscores]</td><td align="left">获取key的值的一部分，包含min和max</td></tr><tr><td align="left"><strong>zrevrangebyscore</strong> key max min [withscores]</td><td align="left">获取key的值的一部分，包含max和min</td></tr><tr><td align="left"><strong>zincrby</strong> key increment value</td><td align="left">设置key的值的field的值加increment</td></tr><tr><td align="left"><strong>zrem</strong> key value</td><td align="left">删除key指定值的field</td></tr><tr><td align="left"><strong>zcount</strong> key min max</td><td align="left">获取指定区间的元素个数</td></tr><tr><td align="left"><strong>zrank</strong> key value</td><td align="left">获取key的值的field的编号，从0开始</td></tr></tbody></table><h3 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h3><p>bitmaps 本身不是一种数据类型，就是字符串，但可以对位进行操作。可以把bitmaps想象成一个以位为单位的数组，每一位只能存储0或1，数组的下标在bitmaps中叫做偏移量offset。</p><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>setbit</strong> key offset value</td><td align="left">value 只能是 0 或 1</td></tr><tr><td align="left"><strong>getbit</strong> key offset</td><td align="left">获取偏移位上的值</td></tr><tr><td align="left"><strong>bitcount</strong> key [start end]</td><td align="left">获取指定区间（未指定区间则全部）的<code>1</code>元素个数，<strong>区间单位是字节byte 而不是 bit</strong></td></tr><tr><td align="left"><strong>bitop</strong> operation destkey srckey1 … srckeyN</td><td align="left">进行指定操作，操作类型有：and, or, xor, not</td></tr></tbody></table><h3 id="Geo"><a href="#Geo" class="headerlink" title="Geo"></a>Geo</h3><p>就是元素的二维坐标，在地图上就是经纬度。redis提供了经纬度设置、查询、范围查询、距离查询、经纬度Hash等功能。</p><p>有效的经纬度范围是：-180&lt;&#x3D;经度&lt;&#x3D;180, -85&lt;&#x3D;纬度&lt;&#x3D;85，坐标位置超过范围时，返回错误。</p><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>geoadd</strong> key longitude latitude member [longitude latitude member …]</td><td align="left">将一个或多个值插入到key的Geo中</td></tr><tr><td align="left"><strong>geodist</strong> key member1 member2</td><td align="left">获取两个元素之间的距离</td></tr><tr><td align="left"><strong>geopos</strong> key member1 member2</td><td align="left">获取两个元素的坐标</td></tr><tr><td align="left"><strong>geodist</strong> key member1 member2 [m&#x2F;km&#x2F;ft&#x2F;mi]</td><td align="left">获取两个元素之间的距离</td></tr><tr><td align="left"><strong>georadius</strong> key longitude latitude radius [m&#x2F;km&#x2F;ft&#x2F;mi]</td><td align="left">获取指定范围内的元素</td></tr></tbody></table><h2 id="事物"><a href="#事物" class="headerlink" title="事物"></a>事物</h2><p>Redis 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p><strong>Redis 事务的主要作用就是串联多个命令防止别的命令插队。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi           <span class="comment"># 开始记录</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k1 v1   <span class="comment"># 命令入队</span></span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k2 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">set</span> k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; <span class="built_in">exec</span>        <span class="comment"># 执行命令</span></span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">3) OK</span><br><span class="line">127.0.0.1:6379&gt; get k3          <span class="comment"># 查看事物执行情况</span></span><br><span class="line"><span class="string">&quot;v3&quot;</span></span><br></pre></td></tr></table></figure><p>从输入 Multi 命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入 Exec 后，Redis 会将之前的命令队列中的命令依次执行。组队的过程中可以通过 discard 来放弃组队。</p><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><p>错误可能发生在<strong>组队阶段</strong>，或者<strong>执行阶段</strong>。</p><ul><li><strong>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</strong></li><li><strong>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</strong></li></ul><h3 id="事务三特性"><a href="#事务三特性" class="headerlink" title="事务三特性"></a>事务三特性</h3><ol><li><strong>单独的隔离操作</strong><br> 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li><li><strong>没有隔离级别的概念</strong><br> 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li><li><strong>不保证原子性</strong><br> 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ol><h2 id="hiredis-x2F-redis"><a href="#hiredis-x2F-redis" class="headerlink" title="hiredis&#x2F;redis++"></a>hiredis&#x2F;redis++</h2><p>异步操作的命令，或使用了回调函数的操作没有给出例子。</p><h3 id="redis-cli-建立连接"><a href="#redis-cli-建立连接" class="headerlink" title="redis-cli 建立连接"></a>redis-cli 建立连接</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sw/redis++/redis++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">sw::<span class="function">redis::Redis <span class="title">redis</span><span class="params">(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>)</span></span>;</span><br><span class="line">sw::<span class="function">redis::Redis <span class="title">redis</span><span class="params">(<span class="string">&quot;tcp://127.0.0.1:6379&quot;</span>, <span class="string">&quot;password&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="Key-ops"><a href="#Key-ops" class="headerlink" title="Key ops"></a>Key ops</h3><table><thead><tr><th align="left">cmd</th><th align="left"><code>redis++</code></th></tr></thead><tbody><tr><td align="left"><strong>keys</strong> *</td><td align="left"><code>std::vector&lt;std::string&gt; keys = redis.keys(&quot;*&quot;);</code></td></tr><tr><td align="left"><strong>exists</strong> key</td><td align="left"><code>bool exists = redis.exists(&quot;key&quot;);</code></td></tr><tr><td align="left"><strong>del</strong> key</td><td align="left"><code>int deleted = redis.del(&quot;key&quot;);</code></td></tr><tr><td align="left"><strong>unlink</strong> key</td><td align="left"><code>int unlinked = redis.unlink(&quot;key&quot;);</code></td></tr><tr><td align="left"><strong>type</strong> key</td><td align="left"><code>sw::redis::RedisType type = redis.type(&quot;key&quot;);</code></td></tr><tr><td align="left"><strong>expire</strong> key seconds</td><td align="left"><code>bool success = redis.expire(&quot;key&quot;, 60);</code></td></tr><tr><td align="left"><strong>ttl</strong> key</td><td align="left"><code>long long ttl = redis.ttl(&quot;key&quot;);</code></td></tr><tr><td align="left"><strong>dbsize</strong></td><td align="left"><code>long long size = redis.dbsize();</code></td></tr><tr><td align="left"><strong>flushdb</strong></td><td align="left"><code>bool success = redis.flushdb();</code></td></tr><tr><td align="left"><strong>flushall</strong></td><td align="left"><code>bool success = redis.flushall();</code></td></tr></tbody></table><h3 id="String-ops"><a href="#String-ops" class="headerlink" title="String ops"></a>String ops</h3><table><thead><tr><th align="left">cmd</th><th align="left"><code>redis++</code></th></tr></thead><tbody><tr><td align="left"><strong>set</strong> key value</td><td align="left"><code>bool success = redis.set(&quot;key&quot;, &quot;value&quot;);</code></td></tr><tr><td align="left"><strong>get</strong> key</td><td align="left"><code>std::string value = redis.get(&quot;key&quot;);</code></td></tr><tr><td align="left"><strong>append</strong> key value</td><td align="left"><code>int length = redis.append(&quot;key&quot;, &quot;value&quot;);</code></td></tr><tr><td align="left"><strong>strlen</strong> key</td><td align="left"><code>int length = redis.strlen(&quot;key&quot;);</code></td></tr><tr><td align="left"><strong>setnx</strong> key value</td><td align="left"><code>bool success = redis.setnx(&quot;key&quot;, &quot;value&quot;);</code></td></tr><tr><td align="left"><strong>incr</strong> key</td><td align="left"><code>long long result = redis.incr(&quot;key&quot;);</code></td></tr><tr><td align="left"><strong>decr</strong> key</td><td align="left"><code>long long result = redis.decr(&quot;key&quot;);</code></td></tr><tr><td align="left"><strong>incrby</strong> key increment</td><td align="left"><code>long long result = redis.incrby(&quot;key&quot;, 10);</code></td></tr><tr><td align="left"><strong>decrby</strong> key decrement</td><td align="left"><code>long long result = redis.decrby(&quot;key&quot;, 10);</code></td></tr></tbody></table><p><strong>批量操作的命令</strong>：</p><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>mset</strong> key1 value1 … keyN valueN</td><td align="left"><code>bool success = redis.mset(&#123;&quot;key1&quot;, &quot;value1&quot;, &quot;key2&quot;, &quot;value2&quot;&#125;);</code></td></tr><tr><td align="left"><strong>mget</strong> key1 … keyN</td><td align="left"><code>std::vector&lt;std::string&gt; values = redis.mget(&#123;&quot;key1&quot;, &quot;key2&quot;&#125;);</code></td></tr><tr><td align="left"><strong>msetnx</strong> key1 value1 … keyN valueN</td><td align="left"><code>bool success = redis.msetnx(&#123;&quot;key1&quot;, &quot;value1&quot;, &quot;key2&quot;, &quot;value2&quot;&#125;);</code></td></tr><tr><td align="left"><strong>getrange</strong> key start end</td><td align="left"><code>std::string sub = redis.getrange(&quot;key&quot;, 1, 3);</code></td></tr><tr><td align="left"><strong>setrange</strong> key offset value</td><td align="left"><code>int length = redis.setrange(&quot;key&quot;, 1, &quot;new&quot;);</code></td></tr><tr><td align="left"><strong>setex</strong> key seconds value</td><td align="left"><code>bool success = redis.setex(&quot;key&quot;, 60, &quot;value&quot;);</code></td></tr><tr><td align="left"><strong>getset</strong> key value</td><td align="left">设置key的值，并返回key的旧值</td></tr></tbody></table><h3 id="List-ops"><a href="#List-ops" class="headerlink" title="List ops"></a>List ops</h3><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>lpush</strong> key value</td><td align="left"><code>int length = redis.lpush(&quot;list&quot;, &quot;element1&quot;, &quot;element2&quot;);</code></td></tr><tr><td align="left"><strong>rpush</strong> key value</td><td align="left"><code>int length = redis.rpush(&quot;list&quot;, &quot;element1&quot;, &quot;element2&quot;);</code></td></tr><tr><td align="left"><strong>lrange</strong> key start stop</td><td align="left"><code>std::vector&lt;std::string&gt; elements = redis.lrange(&quot;list&quot;, 0, -1);</code></td></tr><tr><td align="left"><strong>lpop</strong> key</td><td align="left"><code>std::string element = redis.lpop(&quot;list&quot;);</code></td></tr><tr><td align="left"><strong>rpop</strong> key</td><td align="left"><code>std::string element = redis.rpop(&quot;list&quot;);</code></td></tr><tr><td align="left"><strong>lpoplpush</strong> source destination</td><td align="left"><code>bool success = redis.lpoplpush(&quot;source&quot;, &quot;destination&quot;);</code></td></tr><tr><td align="left"><strong>lpoprpush</strong> source destination</td><td align="left"><code>bool success = redis.lpoprpush(&quot;source&quot;, &quot;destination&quot;);</code></td></tr><tr><td align="left"><strong>rpoprpush</strong> source destination</td><td align="left"><code>bool success = redis.rpoprpush(&quot;source&quot;, &quot;destination&quot;);</code></td></tr><tr><td align="left"><strong>rpoplpush</strong> source destination</td><td align="left"><code>bool success = redis.rpoplpush(&quot;source&quot;, &quot;destination&quot;);</code></td></tr><tr><td align="left"><strong>llen</strong> key</td><td align="left"><code>int64_t len = redis.llen(&quot;mylist&quot;);</code></td></tr><tr><td align="left"><strong>lindex</strong> key index</td><td align="left">获取key的值的第index个元素</td></tr><tr><td align="left"><strong>linsert</strong> key before</td><td align="left">after pivot value</td></tr><tr><td align="left"><strong>lrem</strong> key count value</td><td align="left">从左边删除count个值为value的元素</td></tr><tr><td align="left"><strong>lset</strong> key index value</td><td align="left">设置key的值的第index个元素的值</td></tr></tbody></table><h3 id="Hash-ops"><a href="#Hash-ops" class="headerlink" title="Hash ops"></a>Hash ops</h3><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>hset</strong> key field value</td><td align="left"><code>bool success = redis.hset(&quot;hash&quot;, &quot;field&quot;, &quot;value&quot;);</code></td></tr><tr><td align="left"><strong>hget</strong> key field</td><td align="left"><code>std::string value = redis.hget(&quot;hash&quot;, &quot;field&quot;);</code></td></tr><tr><td align="left"><strong>hmset</strong> key field1 value1 … fieldN valueN</td><td align="left"><code>bool success = redis.hmset(&quot;hash&quot;, &#123;&#123;"field1", "value1"&#125;, &#123;"field2", "value2"&#125;&#125;);</code></td></tr><tr><td align="left"><strong>hexists</strong> key field</td><td align="left"><code>bool exists = redis.hexists(&quot;hash&quot;, &quot;field&quot;);</code></td></tr><tr><td align="left"><strong>hkeys</strong> key</td><td align="left"><code>std::vector&lt;std::string&gt; fields = redis.hkeys(&quot;hash&quot;);</code></td></tr><tr><td align="left"><strong>hvals</strong> key</td><td align="left"><code>std::vector&lt;std::string&gt; values = redis.hvals(&quot;hash&quot;);</code></td></tr><tr><td align="left"><strong>hlen</strong> key</td><td align="left"><code>int count = redis.hlen(&quot;hash&quot;);</code></td></tr><tr><td align="left"><strong>hdel</strong> key field</td><td align="left"><code>bool success = redis.hdel(&quot;hash&quot;, &quot;field&quot;);</code></td></tr><tr><td align="left"><strong>hincrby</strong> key field increment</td><td align="left"><code>int value = redis.hincrby(&quot;hash&quot;, &quot;field&quot;, 1);</code></td></tr><tr><td align="left"><strong>hsetnx</strong> key field value</td><td align="left"><code>bool success = redis.hsetnx(&quot;hash&quot;, &quot;field&quot;, &quot;value&quot;);</code></td></tr></tbody></table><h3 id="Set-ops"><a href="#Set-ops" class="headerlink" title="Set ops"></a>Set ops</h3><table><thead><tr><th align="left">cmd</th><th align="left">explain</th></tr></thead><tbody><tr><td align="left"><strong>sadd</strong> key value</td><td align="left"><code>int count = redis.sadd(&quot;set&quot;, &#123;&quot;elem1&quot;, &quot;elem2&quot;, &quot;elem3&quot;&#125;);</code></td></tr><tr><td align="left"><strong>smembers</strong> key</td><td align="left"><code>std::vector&lt;std::string&gt; members = redis.smembers(&quot;set&quot;);</code></td></tr><tr><td align="left"><strong>sismember</strong> key value</td><td align="left"><code>bool exist = redis.sismember(&quot;set&quot;, &quot;elem&quot;);</code></td></tr><tr><td align="left"><strong>scard</strong> key</td><td align="left"><code>int count = redis.scard(&quot;set&quot;);</code></td></tr><tr><td align="left"><strong>srem</strong> key value</td><td align="left"><code>int count = redis.srem(&quot;set&quot;, &#123;&quot;elem1&quot;, &quot;elem2&quot;&#125;);</code></td></tr><tr><td align="left"><strong>spop</strong> key</td><td align="left"><code>std::string elem = redis.spop(&quot;set&quot;);</code></td></tr><tr><td align="left"><strong>srandmember</strong> key</td><td align="left"><code>std::vector&lt;std::string&gt; elems = redis.srandmember(&quot;set&quot;, 2);</code></td></tr><tr><td align="left"><strong>smove</strong> source destination value</td><td align="left"><code>bool success = redis.smove(&quot;set1&quot;, &quot;set2&quot;, &quot;elem&quot;);</code></td></tr><tr><td align="left"><strong>sinter</strong> source1 … sourceN</td><td align="left"><code>std::vector&lt;std::string&gt; elems = redis.sinter(&#123;&quot;set1&quot;, &quot;set2&quot;&#125;);</code></td></tr></tbody></table><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.runoob.com/redis/redis-tutorial.html">redis 菜鸟教程</a></li><li><a href="https://redis.io/commands/">官方命令文档查询</a></li><li><a href="https://redis.io/docs/clients/">Redis官方推荐的各语言的client库</a></li><li><a href="https://www.runoob.com/w3cnote/python-redis-intro.html">python 中通过redis-py使用redis</a></li><li><a href="https://www.bilibili.com/video/BV1Rv41177Af">【尚硅谷】Redis 6 入门到精通</a> 有讲义</li></ul>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Redis </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenVSwitch-控制器ONOS</title>
      <link href="/2022/06/03/OpenVSwitch-%E6%8E%A7%E5%88%B6%E5%99%A8ONOS/"/>
      <url>/2022/06/03/OpenVSwitch-%E6%8E%A7%E5%88%B6%E5%99%A8ONOS/</url>
      
        <content type="html"><![CDATA[<h2 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h2><p>直接使用 <code>docker</code> 安装最方便！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull onosproject/onos</span><br></pre></td></tr></table></figure><p>启动，做端口映射，不需要的可以去掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -d -p 8181:8181 -p 8101:8101 -p 6653:6653 -p 6640:6640 --name onos onosproject/onos</span><br></pre></td></tr></table></figure><ul><li>8181 - REST API 和 GUI</li><li>8101 - ONOS CLI</li><li>9876 - 集群内通信</li><li>6653 - Openflow 通信，OVS 连接控制器使用此端口（流表相关操作）</li><li>6640 - OVSDB，OVS 网桥、端口相关的配置</li></ul><p>启用应用，用于控制OVS时，打开下面的应用，可通过<code>UI</code> 界面操作，也可在容器中用命令行方式启用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it onos bash</span><br><span class="line"><span class="built_in">cd</span> bin</span><br><span class="line">./onos-app localhost activate org.onosproject.openflow-base</span><br><span class="line">./onos-app localhost activate org.onosproject.ofagent</span><br><span class="line">./onos-app localhost activate org.onosproject.fwd</span><br><span class="line">./onos-app localhost activate org.onosproject.drivers.ovsdb</span><br><span class="line">./onos-app localhost activate org.onosproject.proxyarp</span><br><span class="line">./onos-app localhost activate org.onosproject.lldpprovider</span><br></pre></td></tr></table></figure><p><code>lldpprovider</code> 是用于拓扑发现的，启用该应用后，在 <code>UI/topology</code> 可以看到节点是否有链路直连。</p><h3 id="常用页面"><a href="#常用页面" class="headerlink" title="常用页面"></a>常用页面</h3><ol><li>UI 页面地址：<a href="http://localhost:8181/onos/ui/">http://localhost:8181/onos/ui/</a> 用户名：onos，密码：rocks</li><li>RESTFUL 接口文档：<a href="http://localhost:8181/onos/v1/docs/">http://localhost:8181/onos/v1/docs/</a></li><li>流表组成说明：<a href="https://wiki.onosproject.org/display/ONOS/Flow+Rules">https://wiki.onosproject.org/display/ONOS/Flow+Rules</a></li><li>ONOS wiki，也就是官方文档：<a href="https://wiki.onosproject.org/">https://wiki.onosproject.org</a></li></ol><h3 id="连接ONOS-CLI"><a href="#连接ONOS-CLI" class="headerlink" title="连接ONOS CLI"></a>连接ONOS CLI</h3><ol><li>打开终端并输入以下命令，以连接到ONOS的远程命令行界面：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">phpCopy code</span><br><span class="line">ssh &lt;username&gt;@&lt;onos-ip-address&gt; -p 8101</span><br></pre></td></tr></table></figure><p>其中，<code>&lt;username&gt;</code> 是您连接到ONOS的用户名，<code>&lt;onos-ip-address&gt;</code> 是ONOS的IP地址。</p><ol><li>按回车键执行命令，并输入您的密码（如果需要）。</li><li>连接成功后，您将看到ONOS的CLI界面，类似于以下内容：</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">yamlCopy</span> <span class="string">codeWelcome</span> <span class="string">to</span> <span class="string">ONOS</span></span><br><span class="line">     <span class="string">________</span>  <span class="string">________</span>  <span class="string">________</span>  <span class="string">________</span> </span><br><span class="line">    <span class="string">|\</span>   <span class="string">__</span>  <span class="string">\|\</span>   <span class="string">__</span>  <span class="string">\|\</span>   <span class="string">__</span>  <span class="string">\|\</span>   <span class="string">___</span> <span class="string">\</span> </span><br><span class="line">    <span class="string">\</span> <span class="string">\</span>  <span class="string">\|\</span>  <span class="string">\</span> <span class="string">\</span>  <span class="string">\|\</span>  <span class="string">\</span> <span class="string">\</span>  <span class="string">\|\</span>  <span class="string">\</span> <span class="string">\</span>  <span class="string">\_|\</span> <span class="string">\</span> </span><br><span class="line">     <span class="string">\</span> <span class="string">\</span>   <span class="string">____\</span> <span class="string">\</span>  <span class="string">\\\</span>  <span class="string">\</span> <span class="string">\</span>   <span class="string">__</span>  <span class="string">\</span> <span class="string">\</span>  <span class="string">\</span> <span class="string">\\</span> <span class="string">\</span> </span><br><span class="line">      <span class="string">\</span> <span class="string">\</span>  <span class="string">\___|\</span> <span class="string">\</span>  <span class="string">\\\</span>  <span class="string">\</span> <span class="string">\</span>  <span class="string">\</span> <span class="string">\</span>  <span class="string">\</span> <span class="string">\</span>  <span class="string">\_\\</span> <span class="string">\</span> </span><br><span class="line">       <span class="string">\</span> <span class="string">\__\</span>    <span class="string">\</span> <span class="string">\_______\</span> <span class="string">\__\</span> <span class="string">\__\</span> <span class="string">\_______\</span></span><br><span class="line">        <span class="string">\|__|</span>     <span class="string">\|_______|\|__|\|__|\|_______|</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Documentation:</span> <span class="string">wiki.onosproject.org</span>         </span><br><span class="line"><span class="attr">Tutorials:</span>     <span class="string">tutorials.onosproject.org</span>     </span><br><span class="line"><span class="attr">Mailing lists:</span> <span class="string">lists.onosproject.org</span>         </span><br><span class="line"></span><br><span class="line"><span class="string">Come</span> <span class="string">help</span> <span class="string">out!</span> <span class="attr">Find out how at:</span> <span class="string">contribute.onosproject.org</span></span><br><span class="line"></span><br><span class="line"><span class="string">onos&gt;</span></span><br></pre></td></tr></table></figure><p>现在，您可以在CLI中执行各种ONOS命令以管理和监控ONOS控制器和网络。</p><h3 id="清楚所有配置"><a href="#清楚所有配置" class="headerlink" title="清楚所有配置"></a>清楚所有配置</h3><ol><li>打开终端并连接到ONOS的CLI。</li><li>在CLI中输入以下命令以清除缓存：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onos&gt; clear storage</span><br></pre></td></tr></table></figure><p>按回车键执行命令。</p><p>这将清除ONOS的所有缓存，包括网络拓扑、设备、主机、流表等。请注意，在执行此命令之前，您需要确保ONOS控制器已经停止对网络的控制，以避免数据丢失或网络中断。</p><h2 id="OVS-连接控制器"><a href="#OVS-连接控制器" class="headerlink" title="OVS 连接控制器"></a>OVS 连接控制器</h2><ol><li>要指定OPENFLOW 协议为 <code>OPENFLOW13,OPENFLOW10</code>，<strong>仅指定为<code>OPENFLOW13</code>时，连接控制器后将无法使用<code>ofctl</code>查看流表</strong>。</li><li>将<code>ovs bridge</code> 连接到控制器后的 <code>deviceId</code> 为<code>bridge</code>对应的<code>datapath-id</code>，可以先指定该值，再连接控制器。下发流表时会用到。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ovs-vsctl add-br s1 -- <span class="built_in">set</span> bridge s1 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s1 other_config:datapath-id=0x0000000000000012</span><br><span class="line">ifconfig s1 192.168.1.12 netmask 255.255.255.0 up</span><br><span class="line"></span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s1 protocols=OpenFlow13,OpenFlow10</span><br><span class="line">ovs-vsctl set-controller s1 tcp:172.17.0.2:6653</span><br></pre></td></tr></table></figure><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 创建容器</span></span><br><span class="line">sudo docker create --<span class="built_in">rm</span> -it --name=s1 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk</span><br><span class="line">sudo docker create --<span class="built_in">rm</span> -it --name=s2 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk</span><br><span class="line">sudo docker start s1</span><br><span class="line">sudo docker start s2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 veth-peer，连接两容器</span></span><br><span class="line">sudo ip <span class="built_in">link</span> add p1_2 <span class="built_in">type</span> veth peer name p2_1 &gt; /dev/null</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev p1_2 name p1_2 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s1) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev p2_1 name p2_1 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s2) up</span><br><span class="line">docker <span class="built_in">exec</span> -it s1 tc qdisc add dev p1_2 root netem delay 1</span><br><span class="line">docker <span class="built_in">exec</span> -it s2 tc qdisc add dev p2_1 root netem delay 1</span><br><span class="line"></span><br><span class="line"><span class="comment">############################### s1 中启动OVS ##################################</span></span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1001</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x4</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line">ovs-vsctl add-br s1 -- <span class="built_in">set</span> bridge s1 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s1 other_config:datapath-id=0x0000000000000012</span><br><span class="line">ovs-vsctl add-port s1 p1_2 -- <span class="built_in">set</span> Interface p1_2 ofport_request=12</span><br><span class="line">ifconfig s1 192.168.1.12 netmask 255.255.255.0 up</span><br><span class="line"></span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s1 protocols=OpenFlow13,OpenFlow10</span><br><span class="line">ovs-vsctl set-controller s1 tcp:172.17.0.2:6653</span><br><span class="line"></span><br><span class="line"><span class="comment">############################### s2 中启动OVS ##################################</span></span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1002</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x40</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line">ovs-vsctl add-br s2 -- <span class="built_in">set</span> bridge s2 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s1 other_config:datapath-id=0x0000000000000021</span><br><span class="line">ovs-vsctl add-port s2 p2_1 -- <span class="built_in">set</span> Interface p2_1 ofport_request=21</span><br><span class="line">ifconfig s2 192.168.1.21 netmask 255.255.255.0 up</span><br><span class="line"></span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s2 protocols=OpenFlow13,OpenFlow10</span><br><span class="line">ovs-vsctl set-controller s2 tcp:172.17.0.2:6653</span><br></pre></td></tr></table></figure><h2 id="下发流表"><a href="#下发流表" class="headerlink" title="下发流表"></a>下发流表</h2><p>下发的<code>ARP</code>流表只能匹配<code>MAC</code>地址，但一般不需要手动下发。网络拓扑比较小时，也可以通过<code>arp -s &#123;ip&#125; &#123;mac&#125;</code>手动配置。</p><p><strong>限制</strong>：匹配的以太类型不为IP时，无法匹配目的IP或源IP！即ARP和MPLS类型的，只能和MAC地址一起作为匹配域。实际上这才是正确的，比如MPLS类型的数据包，OVS解析时，并不会解析三层的协议。MPLS是一种隧道协议，并不关心也不会记录下一层的协议类型，因此无法解析。<code>ovs-ofctl</code>并不会提示这种既匹配MPLS标签又匹配IP这种“逻辑”错误。</p><h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2><p><a href="https://gerrit.onosproject.org/plugins/gitiles/onos">https://gerrit.onosproject.org/plugins/gitiles/onos</a></p><p><a href="https://bazel.build/install/ubuntu">https://bazel.build/install/ubuntu</a></p><h3 id="编译-ONOS-镜像"><a href="#编译-ONOS-镜像" class="headerlink" title="编译 ONOS 镜像"></a>编译 ONOS 镜像</h3><p><a href="https://github.com/Yo-gurts/onos/blob/master/Dockerfile">onos</a>仓库中已有写好了的<code>Dockerfile</code>，将整个项目<code>clone</code>到本地后，即可直接编译镜像。该<code>Dockerfile</code>不是从网上下载源码，而是从当前目录<code>COPY</code>，所以修改源码后直接编译就行。</p><p>但是 <code>ONOS</code> 编译过程需要从<code>github</code>或一些外网地址下载相关编译工具，导致编译缓慢或者直接失败。需要配置代理使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --network=host --build-arg http_proxy=http://127.0.0.1:8889 --build-arg https_proxy=http://127.0.0.1:8889  -t onos .</span><br></pre></td></tr></table></figure><p>上面的方式在某些情况下已经够用了，但可能卡在<code>onos-gui-npm-install</code>，需要进一步处理。</p><ul><li>一种方式是修改 <code>Dockerfile</code>，增加 <code>--action_env</code> 指定代理。</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cat</span> WORKSPACE-docker &gt;&gt; WORKSPACE &amp;&amp; bazelisk build onos \</span></span><br><span class="line"><span class="language-bash">+    --action_env=https_proxy=http://127.0.0.1:8889 \</span></span><br><span class="line"><span class="language-bash">     --<span class="built_in">jobs</span> <span class="variable">$&#123;JOBS&#125;</span> \</span></span><br><span class="line"><span class="language-bash">     --verbose_failures \</span></span><br><span class="line"><span class="language-bash">     --java_runtime_version=dockerjdk_11</span></span><br></pre></td></tr></table></figure><ul><li>另一种方式是修改<code>web/gui/BUILD</code>。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> onos/web/gui</span><br><span class="line">sudo vi BUILD</span><br><span class="line"><span class="comment">#修改 onos-gui-npm-install</span></span><br><span class="line">在$<span class="variable">$NPM</span> $<span class="variable">$NPM_ARGS</span> install后面加上</span><br><span class="line">--registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改 onos-gui-npm-build</span></span><br><span class="line">在$<span class="variable">$ROOT</span>/$<span class="variable">$NPM</span> $<span class="variable">$NPM_ARGS</span> run build --no-cache后加上</span><br><span class="line">--registry https://registry.npm.taobao.org</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> onos/web/gui2-fw-lib</span><br><span class="line">sudo vi BUILD</span><br><span class="line"><span class="comment">#修改 onos-gui2-fw-npm-install</span></span><br><span class="line">在npm $<span class="variable">$NPM_ARGS</span> install后面加上</span><br><span class="line">--registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>也可以尝试两种方法都用。此外，也可以先将<code>bazelisk build onos</code>之前的编译为一个镜像（免去安装编译工具的步骤），启动容器，再慢慢编译，通过<code>docker commit</code>将完成编译的容器保存为镜像，再参考<code>Dockerfile</code>进行二阶段的编译过程（此法最可靠）。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://wiki.onosproject.org/display/ONOS/Downloads">onos 官网预编译的下载页面</a></li><li><a href="https://github.com/opennetworkinglab/onos">onos github</a></li><li><a href="https://chentingz.github.io/2019/10/28/%E3%80%8CONOS%20x%20Mininet%E3%80%8D%E4%BB%8E0%E5%BC%80%E5%A7%8B%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83/#0x05-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83">「ONOS x Mininet」从0开始搭建环境</a></li><li><a href="https://feisky.gitbooks.io/sdn/content/sdn/onos.html">ONOS介绍</a></li><li><a href="http://developer.huawei.com/ict/cn/site-sdn-onos/article/onos-paradigm">ONOS架构分析</a></li><li><a href="http://www.sdnlab.com/6371.html">ONOS白皮书上篇之ONOS简介</a></li><li><a href="http://www.sdnlab.com/6800.html">ONOS白皮书中篇之ONOS架构</a></li><li><a href="https://zhuanlan.zhihu.com/p/387616511?utm_id=0">ONOS编译过程的问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenVSwitch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenVSwitch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenVSwitch-DPDK-性能测试</title>
      <link href="/2022/05/23/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
      <url>/2022/05/23/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>OVS基于DPDK的数据通路绕过了内核协议栈，并且做了很多优化，带来了一定的性能提升，但也引入了很多需要配置的参数，而且这些参数和性能密切相关。</p></blockquote><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><blockquote><p><a href="https://man7.org/linux/man-pages/man5/ovs-vswitchd.conf.db.5.html">ovsdb 官方文档</a>，下面的参数表格只是简单翻译了一下作用，仅供参考，具体信息还得看官方文档</p></blockquote><p><code>ovsdb</code>中存储着<code>OVS</code>所有配置信息，并按结构划分为一张张表<code>TABLE</code>，这里只关注其中与<code>dpdk</code>有关的配置参数。</p><h3 id="Open-vSwitch-Table"><a href="#Open-vSwitch-Table" class="headerlink" title="Open_vSwitch Table"></a>Open_vSwitch Table</h3><style>table th:first-of-type {    width: 40%;}table th:nth-of-type(2) {    width: 60%;}</style><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>other_config:dpdk-init=true</code></td><td>是否启用<code>dpdk</code>数据通路</td></tr><tr><td><code>other_config:dpdk-lcore-mask=0x1</code></td><td>指定在哪些<code>core</code>上创建<code>lcore</code>线程，该线程用于<code>dpdk</code>库内部消息处理，如日志等；若没有指定，则默认为<code>cpu affinity list</code>中的第一个。<strong>为达到最佳性能，最好将其设置在单个<code>core</code>上</strong></td></tr><tr><td><code>other_config:pmd-cpu-mask=0x30</code></td><td>设置在哪些<code>core</code>上创建<code>pmd</code>线程；若没有指定，则默认在每个<code>NUMA</code>节点上创建一个<code>pmd</code>线程，并绑定到对应<code>NUMA</code>的<code>core</code>上</td></tr><tr><td><code>other_config:smc-enable=true</code></td><td>是否启用<code>SMC</code>缓存，相对于<code>EMC</code>，内存更高效；当流表的数量超过8192时，<code>SMC</code>尤其有用。<strong>默认为<code>false</code></strong></td></tr><tr><td><code>other_config:per-port-memory=true</code></td><td>是否使用每端口内存模型；默认有相同MTU和CPU socket的设备共享内存池</td></tr><tr><td><code>other_config:dpdk-alloc-mem</code></td><td>指定预先从<code>hugepage</code>上分配的内存大小，单位为<code>MB</code>，与<code>socket(cpu)</code>无关；推荐用<code>dpdk-socket-mem</code>指定</td></tr><tr><td><code>other_config:dpdk-socket-mem=&quot;1024,1024&quot;</code></td><td>指定预先从<code>hugepage</code>上为每个<code>socket(cpu)</code>分配的内存大小；值用逗号分割，如对4个CPU socket的系统，”1024,0,1024”，表示为第0和第3个CPU分配1024Mb。<code>dpdk-alloc-mem</code>和<code>dpdk-socket-mem</code>都没有指定的话，会为每个NUMA用DPDK库中设定的默认值。若同时指定了，则采用<code>dpdk-socket-mem</code>。修改后，需要重启守护进程才生效</td></tr><tr><td><code>other_config:dpdk-socket-limit</code></td><td>限制每一个<code>socket(cpu)</code>最大可用的内存大小（上面的<code>dpdk-socket-mem</code>可动态扩容）。值用逗号分割，如对4个CPU socket的系统，”2048,0,0”，值为0表示不设限制。未指定时，<strong>默认为不设限制</strong></td></tr><tr><td><code>other_config:dpdk-hugepage-dir</code></td><td>指定<code>hugetlbfs</code>挂载点的路径，默认为<code>/dev/hugepages</code></td></tr><tr><td><code>other_config:dpdk-extra</code></td><td>为 <code>DPDK</code> 指定其他 <code>EAL</code> 命令行参数</td></tr><tr><td><code>other_config:vhost-sock-dir</code></td><td>指定为<code>vhost-user</code>生成的<code>socket</code>文件路径，该值为基于<code>external_ids:rundir</code>的相对路径。未指定时，则生成在<code>external_ids:rundir</code>目录下</td></tr><tr><td><code>other_config:tx-flush-interval=0</code></td><td>指定一个数据包在<code>output batch</code>中可等待的最大时间（为了凑足32个批量发送），<strong>单位微秒<code>us</code><strong>；该值可调节吞吐率和网络延迟的平衡，值越小：网络延迟越低，但吞吐率也相对低；</strong>默认值为0</strong></td></tr><tr><td><code>other_config:pmd-perf-metrics=true</code></td><td>是否使能记录<code>PMD</code>的详细性能数据，<strong>默认为false</strong></td></tr><tr><td><code>other_config:pmd-rxq-assign=cycles</code></td><td>指定接受队列如何分配到<code>core</code>；有三种算法：<code>cycles/roundrobin/group</code>。<strong>默认为<code>cycles</code></strong></td></tr><tr><td><code>other_config:pmd-rxq-isolate=true</code></td><td>指定一个<code>core</code>在分配（通过<code>pmd-rxq-affinity</code>）一个接受队列后，是否要 <code>isolate</code>。若该值为<code>false</code>，表示允许OVS再将其他<code>RXQ</code>分配给该<code>core</code>。**默认为 <code>true</code>**。</td></tr><tr><td><code>other_config:emc-insert-inv-prob</code></td><td>配置流表插入到<code>EMC</code>的概率（<code>1 / emc-insert-inv-prob</code>），1表示100%插入</td></tr><tr><td><code>other_config:vhost-postcopy-support=true</code></td><td>没看懂，但实测发现对<code>vhost-user</code>端口<strong>性能有一定提升</strong>！</td></tr></tbody></table><p>对这些参数的修改主要通过以下方式（需要注意某些参数设置后需要重启<code>OVS</code>才会生效）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ovs-vsctl <span class="built_in">set</span> open_vswitch . other_config:vhost-postcopy-support=<span class="literal">true</span></span><br><span class="line">ovs-vsctl <span class="built_in">set</span> open_vswitch . other_config:per-port-memory=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="测试说明"><a href="#测试说明" class="headerlink" title="测试说明"></a>测试说明</h2><blockquote><p><strong>注：此处测试的都是原版<code>OVS</code>，没有经过修改</strong>！未作特殊说明，则表示基于以下平台得到的测试结果</p><ul><li>ovs-2.16.0</li><li>dpdk-20.11.6</li><li>处理器：i7-12700k</li><li>系统：ubuntu:22.04</li><li>内核：5.15.0-52-generic</li></ul></blockquote><p>主要对比<code>OVS</code>内核数据通路与<code>DPDK</code>数据通路的吞吐率情况，以及不同配置参数下对性能的影响。</p><p>除了<code>OVS</code>的配置参数，网卡支持的功能<code>ethtool --show-features &#123;eth0&#125;</code>、收发包工具及其配置参数等都可能影响最终的测试结果！</p><table><thead><tr><th align="center"><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/PKTGEN-OVS-DPDK-TESTPMD.png" alt="pktgen-testpmd"><br />topo1</th><th align="center"><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/QEMU-OVS-QEMU.png" alt="qemu"><br />topo2</th></tr></thead><tbody><tr><td align="center"><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/ovs-dpdk-virtualport.png" alt="ovs-dpdk-virtualport"><br />topo3</td><td align="center"><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/ovs-virtualport.png" alt="ovs-virtualport"><br />topo4</td></tr></tbody></table><p>指标：接收带宽！</p><ol><li><code>Topo1</code>：测试不同配置参数下的性能对比。</li><li><code>Topo2</code>：使用其他发包工具<code>iperf</code>（可在<code>veth</code>类端口上使用）同<code>topo1</code>进行对比测试。</li><li><code>Topo3</code>：使用<code>veth</code>等端口时，不会启动<code>PMD</code>线程，测试此时的性能。</li><li><code>Topo4</code>：不使用<code>DPDK</code>，和<code>topo3</code>测试流程一致，两者对比。</li></ol><hr><p><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/physics-port.png" alt="physics-port"></p><p>在两台主机上启动<code>OVS</code>，分别测试<code>OVS/OVS-DPDK</code>的转发能力。</p><hr><h2 id="base"><a href="#base" class="headerlink" title="base"></a>base</h2><p>首先测试在不使用<code>OVS</code>，单独两个虚拟端口直接连接的情况下，<strong>链路</strong>的带宽。</p><p><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/netns-topo.png" alt="netns"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns add A</span><br><span class="line">sudo ip netns add B</span><br><span class="line"></span><br><span class="line">sudo ip <span class="built_in">link</span> add ethA <span class="built_in">type</span> veth peer name ethB</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev ethA name ethA netns A up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev ethB name ethB netns B up</span><br><span class="line">sudo ip netns <span class="built_in">exec</span> A ifconfig ethA 10.0.0.10/24 up</span><br><span class="line">sudo ip netns <span class="built_in">exec</span> B ifconfig ethB 10.0.0.11/24 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># terminal B: B作为Server</span></span><br><span class="line">sudo ip netns <span class="built_in">exec</span> B iperf -s -i 1</span><br><span class="line"><span class="comment"># terminal A: A作为Client</span></span><br><span class="line">sudo ip netns <span class="built_in">exec</span> B iperf -s -i 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他可能用到的命令</span></span><br><span class="line">ip netns list</span><br><span class="line">ip netns delete A</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th></th><th>测试环境</th><th>iperf-tcp</th></tr></thead><tbody><tr><td>c1</td><td><code>veth-veth</code>直连</td><td>102 Gbps</td></tr><tr><td>c2</td><td>docker 默认交换机<code>docker0</code></td><td>79.7 Gbps</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># terminal A</span></span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> A iperf -c 10.0.0.11</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Client connecting to 10.0.0.11, TCP port 5001</span><br><span class="line">TCP window size: 85.0 KByte (default)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  1] <span class="built_in">local</span> 10.0.0.10 port 44154 connected with 10.0.0.11 port 5001</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  1] 0.0000-10.0099 sec   119 GBytes   102 Gbits/sec</span><br><span class="line"></span><br><span class="line"><span class="comment"># terminal B</span></span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> B iperf -s -i 1</span><br></pre></td></tr></table></figure><blockquote><p>注：<code>iperf</code>也支持打<code>udp</code>流进行测试，但实际测出来的带宽远不如<code>tcp</code>，<a href="https://stackoverflow.com/questions/47035263/iperf-tcp-much-faster-than-udp-why">iperf TCP much faster than UDP, why?</a>，虽然这里说调整发包大小，但并没有用，<code>iperf</code>默认的报文大小就是最大值<code>1470</code>，调大后反而需要切片处理，导致速率更低。</p><p>从测试情况来看，应该是<code>iperf</code>发送端的发送速率不足，导致测出的带宽远小于<code>tcp</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server</span></span><br><span class="line">sudo ip netns <span class="built_in">exec</span> B iperf -s -i 1 -u</span><br><span class="line"></span><br><span class="line"><span class="comment"># client</span></span><br><span class="line">sudo ip netns <span class="built_in">exec</span> A iperf -u -c 10.0.0.11 -b 10g</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">Client connecting to 10.0.0.11, UDP port 5001</span><br><span class="line">Sending 1470 byte datagrams, IPG target: 1.18 us (kalman adjust)</span><br><span class="line">UDP buffer size:  208 KByte (default)</span><br><span class="line">------------------------------------------------------------</span><br><span class="line">[  1] <span class="built_in">local</span> 10.0.0.10 port 50645 connected with 10.0.0.11 port 5001</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth</span><br><span class="line">[  1] 0.0000-10.0047 sec  8.37 GBytes  7.19 Gbits/sec</span><br><span class="line">[  1] Sent 6113230 datagrams</span><br><span class="line">[  1] Server Report:</span><br><span class="line">[ ID] Interval       Transfer     Bandwidth        Jitter   Lost/Total Datagrams</span><br><span class="line">[  1] 0.0000-10.0046 sec  8.26 GBytes  7.09 Gbits/sec   0.001 ms 88036/6123229 (1.4%)</span><br></pre></td></tr></table></figure></blockquote><h2 id="vhost-user"><a href="#vhost-user" class="headerlink" title="vhost-user"></a>vhost-user</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 删除之前的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> /usr/local/etc/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/run/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/log/openvswitch/*</span><br><span class="line"></span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=random</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-lcore-mask=0x1</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x6</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line">ovs-vsctl add-port br0 vhost-user1 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user1 <span class="built_in">type</span>=dpdkvhostuser ofport_request=1</span><br><span class="line">ovs-vsctl add-port br0 vhost-user2 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user2 <span class="built_in">type</span>=dpdkvhostuser ofport_request=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># vhost-user3</span></span><br><span class="line">ovs-vsctl add-port br0 vhost-user3 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user3 <span class="built_in">type</span>=dpdkvhostuser ofport_request=3</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr></thead><tbody><tr><td><code>pmd=0x1</code></td><td>*</td><td>*</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>pktgen=0x30</code></td><td></td><td></td><td></td><td></td><td>*</td><td>*</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>testpmd=0x300</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>*</td><td>*</td><td></td><td></td></tr></tbody></table><p><code>pktgen</code>和<code>testpmd</code>好像也采用了<code>PMD</code>轮询驱动类似的方式运行，会占满某些核，在配置参数时需要将<code>core</code>错开，否则影响性能！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pktgen</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --privileged --name=app-pktgen \</span><br><span class="line">    -v /dev/hugepages:/dev/hugepages \</span><br><span class="line">    -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">    pktgen20:latest /bin/bash</span><br><span class="line"></span><br><span class="line">pktgen -c 0x30 -n 1 --socket-mem 1024 --file-prefix pktgen --no-pci  \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user1,mac=00:00:00:00:00:01,path=/var/run/openvswitch/vhost-user1&#x27;</span> \</span><br><span class="line">-- -T -P -m <span class="string">&quot;5.0&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># testpmd</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --privileged --name=app-testpmd \</span><br><span class="line">    -v /dev/hugepages:/dev/hugepages \</span><br><span class="line">    -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">    pktgen20:latest /bin/bash</span><br><span class="line"></span><br><span class="line">dpdk-testpmd -c 0x300 -n 1 --socket-mem 1024 --file-prefix testpmd --no-pci \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user2,mac=00:00:00:00:00:02,path=/var/run/openvswitch/vhost-user2&#x27;</span> \</span><br><span class="line">-- -i -a --coremask=0x200 --forward-mode=rxonly</span><br></pre></td></tr></table></figure><p><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/image-20220703163105375.png" alt="image-20220703163105375"></p><p>可以看到CPU的占用情况与配置一致！<code>Pktgen</code>占用了两个核。</p><h3 id="测试结果-1"><a href="#测试结果-1" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th></th><th></th><th>pktgen-64byte</th><th>pktgen-1500byte</th></tr></thead><tbody><tr><td>c1</td><td>默认流表 Normal</td><td>3 016 608 216 bps</td><td>42 754 318 664 bps</td></tr><tr><td></td><td></td><td>6 284 600 pps</td><td>3 572 386 pps</td></tr><tr><td>c2</td><td>c1 + 匹配入端口流表</td><td>7 849 813 576 bps</td><td>88 330 499 920 bps</td></tr><tr><td></td><td></td><td>16 353 825 pps</td><td>7 380 556 pps</td></tr><tr><td>c3</td><td>c2 + vhost-postcopy-support</td><td>8 086 507 608 bps</td><td>96 284 271 416 bps</td></tr><tr><td></td><td></td><td>16 846 890 pps</td><td>8 045 142 pps</td></tr><tr><td></td><td>下面的2send,1recv, 2pmd</td><td></td><td>125975200120 bps</td></tr><tr><td></td><td></td><td></td><td>10 525 949 pps</td></tr></tbody></table><p><code>c2</code>：配置匹配入端口的流表；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ovs-ofctl add-flow br0 in_port=vhost-user1,actions=output:vhost-user2</span><br><span class="line">ovs-ofctl add-flow br0 in_port=vhost-user3,actions=output:vhost-user4</span><br><span class="line">ovs-ofctl add-flow br0 in_port=vhost-user5,actions=output:vhost-user6</span><br></pre></td></tr></table></figure><p><code>c3</code>：配置<code>vhost-postcopy-support=true</code>；</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-vsctl <span class="built_in">set</span> open_vswitch . other_config:vhost-postcopy-support=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="2send-1recv"><a href="#2send-1recv" class="headerlink" title="2send-1recv"></a>2send-1recv</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 删除之前的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> /usr/local/etc/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/run/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/log/openvswitch/*</span><br><span class="line"></span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=random</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-lcore-mask=0x1</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0xE</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line">ovs-vsctl add-port br0 vhost-user1 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user1 <span class="built_in">type</span>=dpdkvhostuser ofport_request=1</span><br><span class="line">ovs-vsctl add-port br0 vhost-user2 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user2 <span class="built_in">type</span>=dpdkvhostuser ofport_request=2</span><br><span class="line">ovs-vsctl add-port br0 vhost-user3 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user3 <span class="built_in">type</span>=dpdkvhostuser ofport_request=3</span><br><span class="line">ovs-vsctl add-port br0 vhost-user4 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user4 <span class="built_in">type</span>=dpdkvhostuser ofport_request=4</span><br><span class="line">ovs-vsctl add-port br0 vhost-user5 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user5 <span class="built_in">type</span>=dpdkvhostuser ofport_request=5</span><br><span class="line">ovs-vsctl add-port br0 vhost-user6 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user6 <span class="built_in">type</span>=dpdkvhostuser ofport_request=6</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th><th>11</th><th>12</th></tr></thead><tbody><tr><td><code>pmd=0x6</code></td><td></td><td>*</td><td>*</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>pktgen1=0x30</code></td><td></td><td></td><td></td><td></td><td>*</td><td>*</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><code>pktgen2=0xc0</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td>*</td><td>*</td><td></td><td></td><td></td><td></td></tr><tr><td><code>testpmd=0x300</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>*</td><td>*</td><td></td><td></td></tr><tr><td><code>testpmd=0xc00</code></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td>*</td><td>*</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pktgen</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --privileged --name=app-pktgen3 \</span><br><span class="line">    -v /dev/hugepages:/dev/hugepages \</span><br><span class="line">    -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">    pktgen:20.11.3 /bin/bash</span><br><span class="line"></span><br><span class="line">pktgen -c 0x30 -n 1 --socket-mem 1024 --file-prefix pktgen --no-pci  \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user1,mac=00:00:00:00:00:01,path=/var/run/openvswitch/vhost-user1&#x27;</span> \</span><br><span class="line">-- -T -P -m <span class="string">&quot;5.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pktgen</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --privileged --name=app-pktgen2 \</span><br><span class="line">    -v /dev/hugepages:/dev/hugepages \</span><br><span class="line">    -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">    pktgen20:latest /bin/bash</span><br><span class="line"></span><br><span class="line">pktgen -c 0xc0 -n 1 --socket-mem 1024 --file-prefix pktgen --no-pci  \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user1,mac=00:00:00:00:00:03,path=/var/run/openvswitch/vhost-user3&#x27;</span> \</span><br><span class="line">-- -T -P -m <span class="string">&quot;7.0&quot;</span></span><br><span class="line"></span><br><span class="line">pktgen -c 0xc000 -n 1 --socket-mem 1024 --file-prefix pktgen --no-pci  \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user1,mac=00:00:00:00:00:05,path=/var/run/openvswitch/vhost-user5&#x27;</span> \</span><br><span class="line">-- -T -P -m <span class="string">&quot;15.0&quot;</span></span><br><span class="line"></span><br><span class="line">pktgen -c 0xc00 -n 1 --socket-mem 1024 --file-prefix pktgen --no-pci  \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user1,mac=00:00:00:00:00:04,path=/var/run/openvswitch/vhost-user4&#x27;</span> \</span><br><span class="line">-- -T -P -m <span class="string">&quot;11.0&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sequence &lt;<span class="built_in">seq</span><span class="comment">#&gt; &lt;portlist&gt; dst &lt;Mac&gt; src &lt;Mac&gt; dst &lt;IP&gt; src &lt;IP&gt; sport &lt;val&gt; dport &lt;val&gt; ipv4|ipv6 udp|tcp|icmp vlan &lt;val&gt; size &lt;val&gt; [teid &lt;val&gt;]</span></span><br><span class="line">sequence 0 0 dst 00:00:00:00:11:11 src 00:00:00:00:22:22 dst 192.168.1.1/24 src 192.168.1.3/24 sport 10001 dport 10003 ipv4 udp vlan 3000 size 1500</span><br><span class="line">sequence 2 0 dst 00:00:00:00:11:11 src 00:00:00:00:22:22 dst 192.168.1.1/24 src 192.168.1.4/24 sport 10001 dport 10004 ipv4 udp vlan 4000 size 1500</span><br><span class="line"></span><br><span class="line">sequence &lt;<span class="built_in">seq</span><span class="comment">#&gt; &lt;portlist&gt; &lt;dst-Mac&gt; &lt;src-Mac&gt; &lt;dst-IP&gt; &lt;src-IP&gt; &lt;sport&gt; &lt;dport&gt; ipv4|ipv6 udp|tcp|icmp &lt;vlanid&gt; &lt;pktsize&gt; [&lt;teid&gt;]</span></span><br><span class="line">sequence 1 0 dst-Mac 00:00:00:00:11:11 src-Mac 00:00:00:00:22:22 dst-IP 192.168.1.1 src-IP 192.168.1.3/24</span><br><span class="line"></span><br><span class="line"><span class="comment"># range</span></span><br><span class="line"><span class="built_in">set</span> 0 dst ip min 192.168.1.1</span><br><span class="line"><span class="built_in">set</span> 0 dst ip max 192.168.1.2</span><br><span class="line">ovs-ofctl add-flow br0 ip,nw_dst=192.168.1.1,actions=output:vhost-user2</span><br><span class="line">ovs-ofctl add-flow br0 ip,nw_dst=192.168.1.2,actions=output:vhost-user4</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> --privileged --name=app-testpmd2 \</span><br><span class="line">    -v /dev/hugepages:/dev/hugepages \</span><br><span class="line">    -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">    pktgen:20.11.3 /bin/bash</span><br><span class="line"></span><br><span class="line">dpdk-testpmd -c 0x300 -n 1 --socket-mem 1024 --file-prefix testpmd --no-pci \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user2,mac=00:00:00:00:00:02,path=/var/run/openvswitch/vhost-user2&#x27;</span> \</span><br><span class="line">-- -i -a --coremask=0x200 --forward-mode=rxonly</span><br><span class="line"></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --privileged --name=app-testpmd2 \</span><br><span class="line">    -v /dev/hugepages:/dev/hugepages \</span><br><span class="line">    -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">    pktgen20:latest /bin/bash</span><br><span class="line"></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --privileged --name=pktgen3 \</span><br><span class="line">    -v /dev/hugepages:/dev/hugepages \</span><br><span class="line">    -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">    pktgen:20.11.3 /bin/bash</span><br><span class="line"></span><br><span class="line">dpdk-testpmd -c 0xc00 -n 1 --socket-mem 1024 --file-prefix testpmd --no-pci \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user4,mac=00:00:00:00:00:04,path=/var/run/openvswitch/vhost-user4&#x27;</span> \</span><br><span class="line">-- -i -a --coremask=0x800 --forward-mode=rxonly</span><br><span class="line"></span><br><span class="line">dpdk-testpmd -c 0x30000 -n 1 --socket-mem 1024 --file-prefix testpmd --no-pci \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user6,mac=00:00:00:00:00:06,path=/var/run/openvswitch/vhost-user6&#x27;</span> \</span><br><span class="line">-- -i -a --coremask=0x20000 --forward-mode=rxonly</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ovs-ofctl add-flow br0 in_port=vhost-user1,actions=output:vhost-user2</span><br><span class="line">ovs-ofctl add-flow br0 in_port=vhost-user3,actions=output:vhost-user2</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1-------3</span><br><span class="line">  pmd1</span><br><span class="line">2-------4</span><br><span class="line"></span><br><span class="line">1---pmd1----3</span><br><span class="line">2---pmd2----4</span><br></pre></td></tr></table></figure><table><thead><tr><th>服务器 1500byte，收端测速</th><th>pps</th><th>bps</th></tr></thead><tbody><tr><td>1pmd, 1-&gt;2</td><td>4014497</td><td>48 045502408</td></tr><tr><td>1pmd, 1-&gt;2, 3-&gt;2</td><td>3821682</td><td>45 737967984</td></tr><tr><td>1pmd, 1-&gt;2, 3-&gt;4, (2,4的结果差不多)</td><td>1842978</td><td>22 056772136</td></tr><tr><td>2pmd, 1-&gt;2, 3-&gt;2</td><td>5644703</td><td>67 485371880</td></tr><tr><td>2pmd, 1-&gt;2, 3-&gt;4, (2,4的结果差不多)</td><td>3983405</td><td>47 673395952</td></tr><tr><td>2pmd, 1-&gt;2, 3-&gt;2, 4-&gt;2</td><td>5347450</td><td>63 864672136</td></tr><tr><td>3pmd, 1-&gt;2, 3-&gt;2, 4-&gt;2 (应该是收端处理能力限制)</td><td>5332282</td><td>63 816064880</td></tr><tr><td>3pmd, 1-&gt;2, 3-&gt;4, 5-&gt;6 (2,4,6的结果差不多)</td><td>3733353</td><td>44 680773688</td></tr></tbody></table><h2 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 删除之前的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> /usr/local/etc/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/run/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/log/openvswitch/*</span><br><span class="line"></span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=random</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-lcore-mask=0x1</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x02</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line">ovs-vsctl add-port br0 vhost-user1 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user1 <span class="built_in">type</span>=dpdkvhostuser ofport_request=1</span><br><span class="line">ovs-vsctl add-port br0 vhost-user2 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user2 <span class="built_in">type</span>=dpdkvhostuser ofport_request=2</span><br></pre></td></tr></table></figure><p>使用QEMU虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基于vhost-user1, vhost-user2创建虚拟机</span></span><br><span class="line">qemu-system-x86_64 -enable-kvm -m 2048 -smp 4 \</span><br><span class="line">    -chardev socket,<span class="built_in">id</span>=char0,path=/usr/local/var/run/openvswitch/vhost-user1 \</span><br><span class="line">    -netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=mynet1,chardev=char0,vhostforce \</span><br><span class="line">    -device virtio-net-pci,netdev=mynet1,mac=52:54:00:02:d9:01 \</span><br><span class="line">    -object memory-backend-file,<span class="built_in">id</span>=mem,size=2048M,mem-path=/dev/hugepages,share=on \</span><br><span class="line">    -numa node,memdev=mem -mem-prealloc \</span><br><span class="line">    -net user,hostfwd=tcp::10021-:22 -net nic \</span><br><span class="line">    ./qemu-vm1.img</span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 -enable-kvm -m 2048 -smp 4 \</span><br><span class="line">    -chardev socket,<span class="built_in">id</span>=char0,path=/usr/local/var/run/openvswitch/vhost-user2 \</span><br><span class="line">    -netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=mynet1,chardev=char0,vhostforce \</span><br><span class="line">    -device virtio-net-pci,netdev=mynet1,mac=52:54:00:02:d9:02 \</span><br><span class="line">    -object memory-backend-file,<span class="built_in">id</span>=mem,size=2048M,mem-path=/dev/hugepages,share=on \</span><br><span class="line">    -numa node,memdev=mem -mem-prealloc \</span><br><span class="line">    -net user,hostfwd=tcp::10022-:22 -net nic \</span><br><span class="line">    ./qemu-vm2.img &amp;</span><br></pre></td></tr></table></figure><h3 id="测试结果-2"><a href="#测试结果-2" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th></th><th></th><th>iperf-tcp</th></tr></thead><tbody><tr><td>c1</td><td>默认流表 Normal</td><td>22.3 Gbps</td></tr><tr><td>c2</td><td>c1 + 匹配入端口流表</td><td>22.4 Gbps</td></tr><tr><td>c3</td><td>c2 + vhost-postcopy-support</td><td>22.3 Gbps</td></tr></tbody></table><blockquote><p>这三种情况下，速率几乎一致！而且使用<code>iperf-udp</code>测试时，指定带宽小于<code>5Gbps</code>时，测试速率比较正常。但若指定的带宽大于<code>5g</code>，会导致速率严重下降，为<code>1.5Gbps</code>左右。</p><p>不过这里也涉及到配置<code>qemu</code>虚拟机的相关参数，没进一步调试。</p></blockquote><h2 id="物理网卡"><a href="#物理网卡" class="headerlink" title="物理网卡"></a>物理网卡</h2><blockquote><p>这里为在两台物理服务器上做测试，每台服务器用两张网卡，每张网卡两个端口，一张网卡为光口，另一张则是正常的RJ45接口。除一个RJ45口接入网络外，其余端口都两两直连。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ lspci | grep Eth</span><br><span class="line">3d:00.0 Ethernet controller: Intel Corporation Ethernet Connection X722 <span class="keyword">for</span> 10GBASE-T (rev 09)</span><br><span class="line">3d:00.1 Ethernet controller: Intel Corporation Ethernet Connection X722 <span class="keyword">for</span> 10GBASE-T (rev 09)</span><br><span class="line">af:00.0 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ Network Connection (rev 01)</span><br><span class="line">af:00.1 Ethernet controller: Intel Corporation 82599ES 10-Gigabit SFI/SFP+ Network Connection (rev 01)</span><br><span class="line">$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux uestc 5.15.0-52-generic <span class="comment">#58~20.04.1-Ubuntu SMP</span></span><br><span class="line"></span><br><span class="line">$ lscpu <span class="comment"># 两台服务器CPU 频率稍有差别</span></span><br><span class="line">Model name:                      Intel(R) Xeon(R) Gold 6133 CPU @ 2.50GHz</span><br><span class="line">Stepping:                        4</span><br><span class="line">CPU MHz:                         1000.000</span><br><span class="line">CPU max MHz:                     3000.0000</span><br><span class="line">CPU min MHz:                     1000.0000</span><br><span class="line">BogoMIPS:                        5000.00</span><br><span class="line">-----------------------------------------------</span><br><span class="line">Model name:                      Intel(R) Xeon(R) Gold 6145 CPU @ 2.00GHz</span><br><span class="line">Stepping:                        4</span><br><span class="line">CPU MHz:                         1000.120</span><br><span class="line">CPU max MHz:                     3700.0000</span><br><span class="line">CPU min MHz:                     1000.0000</span><br><span class="line">BogoMIPS:                        4000.00</span><br></pre></td></tr></table></figure></blockquote><h3 id="ovs"><a href="#ovs" class="headerlink" title="ovs"></a>ovs</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 删除之前的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> /usr/local/etc/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/run/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/log/openvswitch/*</span><br><span class="line"></span><br><span class="line">ovs-ctl start</span><br><span class="line">ovs-vsctl add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=system</span><br><span class="line"></span><br><span class="line"><span class="comment"># Server A</span></span><br><span class="line">ifconfig br0 192.168.5.80</span><br><span class="line">ovs-vsctl add-port br0 eno0</span><br><span class="line">ovs-ofctl add-flow br0 ip,nw_dst=192.168.5.40,actions=output:eno0</span><br><span class="line">ovs-ofctl add-flow br0 ip,nw_dst=192.168.5.80,actions=output:LOCAL</span><br><span class="line"></span><br><span class="line"><span class="comment"># Server B</span></span><br><span class="line">ifconfig br0 192.168.5.40</span><br><span class="line">ovs-vsctl add-port br0 eno1</span><br><span class="line">ovs-ofctl add-flow br0 ip,nw_dst=192.168.5.80,actions=output:eno1</span><br><span class="line">ovs-ofctl add-flow br0 ip,nw_dst=192.168.5.40,actions=output:LOCAL</span><br></pre></td></tr></table></figure><h3 id="ovs-dpdk"><a href="#ovs-dpdk" class="headerlink" title="ovs-dpdk"></a>ovs-dpdk</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 删除之前的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> /usr/local/etc/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/run/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/log/openvswitch/*</span><br><span class="line"></span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=random</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-lcore-mask=0x1</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x2</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line">ovs-vsctl add-br br1 -- <span class="built_in">set</span> bridge br1 datapath_type=netdev</span><br><span class="line"></span><br><span class="line"><span class="comment"># server A</span></span><br><span class="line">ifconfig br1 192.168.6.80</span><br><span class="line">modprobe vfio enable_unsafe_noiommu_mode=1</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/module/vfio/parameters/enable_unsafe_noiommu_mode</span><br><span class="line">ifconfig eno0 down</span><br><span class="line">ifconfig ens1f0 down</span><br><span class="line">ifconfig ens1f1 down</span><br><span class="line">dpdk-devbind.py --<span class="built_in">bind</span>=vfio-pci 0000:60:00.0</span><br><span class="line">dpdk-devbind.py --<span class="built_in">bind</span>=vfio-pci 0000:18:00.0</span><br><span class="line">dpdk-devbind.py --<span class="built_in">bind</span>=vfio-pci 0000:18:00.1</span><br><span class="line">ovs-vsctl add-port br1 rj45 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface rj45 <span class="built_in">type</span>=dpdk options:dpdk-devargs=0000:60:00.0</span><br><span class="line">ovs-ofctl add-flow br1 ip,nw_dst=192.168.6.40,actions=output:rj45</span><br><span class="line">ovs-ofctl add-flow br1 ip,nw_dst=192.168.6.80,actions=output:LOCAL</span><br><span class="line"></span><br><span class="line"><span class="comment"># server B</span></span><br><span class="line">ifconfig br1 192.168.4.80</span><br><span class="line">modprobe vfio enable_unsafe_noiommu_mode=1</span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/module/vfio/parameters/enable_unsafe_noiommu_mode</span><br><span class="line">ifconfig eno1 down</span><br><span class="line">ifconfig ens802f0 down</span><br><span class="line">ifconfig ens802f1 down</span><br><span class="line">dpdk-devbind.py --<span class="built_in">bind</span>=vfio-pci 0000:3d:00.0</span><br><span class="line">dpdk-devbind.py --<span class="built_in">bind</span>=vfio-pci 0000:af:00.0</span><br><span class="line">dpdk-devbind.py --<span class="built_in">bind</span>=vfio-pci 0000:af:00.1</span><br><span class="line"></span><br><span class="line">ovs-vsctl add-port br1 rj45 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface rj45 <span class="built_in">type</span>=dpdk options:dpdk-devargs=0000:3d:00.0</span><br><span class="line">ovs-ofctl add-flow br1 ip,nw_dst=192.168.6.80,actions=output:rj45</span><br><span class="line">ovs-ofctl add-flow br1 ip,nw_dst=192.168.6.40,actions=output:LOCAL</span><br></pre></td></tr></table></figure><h3 id="测试结果-3"><a href="#测试结果-3" class="headerlink" title="测试结果"></a>测试结果</h3><table><thead><tr><th></th><th></th><th>iperf-tcp</th></tr></thead><tbody><tr><td>c1</td><td>无OVS，网口直连（RJ45与光口差不多）</td><td>9.38 Gbps</td></tr><tr><td>c2</td><td>OVS，RJ45与光口同样差不多</td><td>9.41 Gbps</td></tr><tr><td>c3</td><td>OVS-DPDK，(不知道为什么这么慢)</td><td>3.89 Gbps</td></tr><tr><td>c4</td><td>OVS-DPDK-pktgen</td><td>9.8 Gbps</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server A: pktgen</span></span><br><span class="line">ovs-ofctl add-flow br1 in_port=vhost-user1,actions=output:g1</span><br><span class="line"></span><br><span class="line"><span class="comment"># server B: testpmd</span></span><br><span class="line">ovs-ofctl add-flow br1 in_port=g1,actions=output:vhost-user1</span><br></pre></td></tr></table></figure><h3 id="vhost-user-1"><a href="#vhost-user-1" class="headerlink" title="vhost-user"></a>vhost-user</h3><h3 id="OVS-OVS"><a href="#OVS-OVS" class="headerlink" title="OVS-OVS"></a>OVS-OVS</h3><p>补：该方案使用<code>veth pair</code>连接两容器，本想借此测试OVS-DPDK的转发性能，但<a href="https://www.cnblogs.com/dream397/p/13964154.html#%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E5%8D%8F%E8%AE%AE%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8">使用<code>veth</code>端口会让OVS回落到system datapath</a>，而且搭建下面的拓扑并启动OVS后，会发现没有核被占满（PMD运行时不会休眠）。当添加了<code>vhost-user</code>端口后，才会看到有个核跑满了。</p><p><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/OVS%20%E6%B5%81%E7%A8%8B%E5%9B%BE-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.drawio-16567289755781.png" alt="OVS 流程图-性能测试.drawio"></p><p><strong>拓扑搭建</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dpdk-hugepages.py -p 1G --setup 4G</span><br><span class="line">modprobe openvswitch</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建容器</span></span><br><span class="line">sudo docker create -it --name=s1 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0-qdisc</span><br><span class="line">sudo docker create -it --name=s2 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0-qdisc</span><br><span class="line">sudo docker start s1</span><br><span class="line">sudo docker start s2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 veth-peer</span></span><br><span class="line">sudo ip <span class="built_in">link</span> add p1_2 <span class="built_in">type</span> veth peer name p2_1 &gt; /dev/null</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev p1_2 name p1_2 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s1) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev p2_1 name p2_1 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s2) up</span><br></pre></td></tr></table></figure><p><strong>启动OVS</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ s1 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s1 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1001</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x02</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s1 -- <span class="built_in">set</span> bridge s1 datapath_type=netdev</span><br><span class="line">ifconfig s1 192.168.1.12 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s1 p1_2 -- <span class="built_in">set</span> Interface p1_2 ofport_request=12</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s1 vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ s2 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s2 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1002</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x08</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s2 -- <span class="built_in">set</span> bridge s2 datapath_type=netdev</span><br><span class="line">ifconfig s2 192.168.1.21 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s2 p2_1 -- <span class="built_in">set</span> Interface p2_1 ofport_request=21</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s2 vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br></pre></td></tr></table></figure><h3 id="OVS-OVS-OVS"><a href="#OVS-OVS-OVS" class="headerlink" title="OVS-OVS-OVS"></a>OVS-OVS-OVS</h3><p><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/OVS%20%E6%B5%81%E7%A8%8B%E5%9B%BE-ovs-ovs-ovs.png" alt="OVS 流程图-ovs-ovs-ovs"></p><p><strong>拓扑搭建</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">dpdk-hugepages.py -p 1G --setup 6G</span><br><span class="line">modprobe openvswitch</span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建容器</span></span><br><span class="line">sudo docker create -it --name=s1 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0-vlog</span><br><span class="line">sudo docker create -it --name=s2 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0-vlog</span><br><span class="line">sudo docker create -it --name=s3 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0-vlog</span><br><span class="line">sudo docker start s1 s2 s3</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 veth-peer</span></span><br><span class="line">sudo ip <span class="built_in">link</span> add s1_2 <span class="built_in">type</span> veth peer name s2_1 &gt; /dev/null</span><br><span class="line">sudo ip <span class="built_in">link</span> add s3_2 <span class="built_in">type</span> veth peer name s2_3 &gt; /dev/null</span><br><span class="line">sudo ip <span class="built_in">link</span> add s1_3 <span class="built_in">type</span> veth peer name s3_1 &gt; /dev/null</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s1_2 name s1_2 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s1) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s1_3 name s1_3 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s1) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s2_1 name s2_1 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s2) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s2_3 name s2_3 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s2) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s3_1 name s3_1 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s3) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s3_2 name s3_2 netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s3) up</span><br></pre></td></tr></table></figure><p><strong>启动OVS</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ s1 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s1 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1001</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x02</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s1 -- <span class="built_in">set</span> bridge s1 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s1 other_config:hwaddr=<span class="string">&quot;00:00:00:00:10:01&quot;</span></span><br><span class="line">ifconfig s1 192.168.10.1 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s1 s1_2 -- <span class="built_in">set</span> Interface s1_2 ofport_request=12</span><br><span class="line">ovs-vsctl add-port s1 s1_3 -- <span class="built_in">set</span> Interface s1_3 ofport_request=13</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s1 vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ s2 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s2 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1002</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x08</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s2 -- <span class="built_in">set</span> bridge s2 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s2 other_config:hwaddr=<span class="string">&quot;00:00:00:00:10:02&quot;</span></span><br><span class="line">ifconfig s2 192.168.10.2 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s2 s2_1 -- <span class="built_in">set</span> Interface s2_1 ofport_request=21</span><br><span class="line">ovs-vsctl add-port s2 s2_3 -- <span class="built_in">set</span> Interface s2_3 ofport_request=23</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s2 vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ s3 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s3 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1002</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x20</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s3 -- <span class="built_in">set</span> bridge s3 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s3 other_config:hwaddr=<span class="string">&quot;00:00:00:00:10:03&quot;</span></span><br><span class="line">ifconfig s3 192.168.10.3 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s3 s3_1 -- <span class="built_in">set</span> Interface s3_1 ofport_request=31</span><br><span class="line">ovs-vsctl add-port s3 s3_2 -- <span class="built_in">set</span> Interface s3_2 ofport_request=32</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s3vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br></pre></td></tr></table></figure><p><strong>转发流表</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s1</span></span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.1,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.2,actions=output:s1_2</span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.3,actions=output:s1_3</span><br><span class="line"><span class="comment"># s2</span></span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.2,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.1,actions=output:s2_1</span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.3,actions=output:s2_3</span><br><span class="line"><span class="comment"># s3</span></span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.3,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.1,actions=output:s3_1</span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.2,actions=output:s3_2</span><br><span class="line"><span class="comment"># arp</span></span><br><span class="line">arp -s 192.168.10.1 00:00:00:00:10:01</span><br><span class="line">arp -s 192.168.10.2 00:00:00:00:10:02</span><br><span class="line">arp -s 192.168.10.3 00:00:00:00:10:03</span><br></pre></td></tr></table></figure><p><strong>转发流表2</strong>：1&lt;-&gt;2&lt;-&gt;3 (1与3不直连)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># s1</span></span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.1,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.2,actions=output:s1_2</span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.3,actions=output:s1_2</span><br><span class="line"><span class="comment"># s2</span></span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.2,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.1,actions=output:s2_1</span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.3,actions=output:s2_3</span><br><span class="line"><span class="comment"># s3</span></span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.3,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.1,actions=output:s3_2</span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.2,actions=output:s3_2</span><br></pre></td></tr></table></figure><h4 id="测试ATS"><a href="#测试ATS" class="headerlink" title="测试ATS"></a>测试ATS</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ovs-vsctl <span class="built_in">set</span> interface s1_2 other_config:qdisc-params=<span class="string">&quot;rate:1=10000&quot;</span> <span class="comment"># 10M</span></span><br><span class="line">ovs-appctl vlog/set dpif_qdisc:file:dbg</span><br><span class="line"><span class="comment"># s1</span></span><br><span class="line">ovs-vsctl <span class="built_in">set</span> interface s1_2 other_config:qdisc=ATS</span><br><span class="line"><span class="comment"># s2</span></span><br><span class="line">ovs-vsctl <span class="built_in">set</span> interface s2_3 other_config:qdisc=ATS</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> interface s2_1 other_config:qdisc=ATS</span><br><span class="line"><span class="comment"># s3</span></span><br><span class="line">ovs-vsctl <span class="built_in">set</span> interface s3_2 other_config:qdisc=ATS</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">################################ s1 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s1 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1001</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x02</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s1 -- <span class="built_in">set</span> bridge s1 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s1 other_config:hwaddr=<span class="string">&quot;00:00:00:00:10:01&quot;</span></span><br><span class="line">ifconfig s1 192.168.10.1 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s1 s1_2 -- <span class="built_in">set</span> Interface s1_2 ofport_request=12</span><br><span class="line">ovs-vsctl add-port s1 s1_3 -- <span class="built_in">set</span> Interface s1_3 ofport_request=13</span><br><span class="line">arp -s 192.168.10.1 00:00:00:00:10:01</span><br><span class="line">arp -s 192.168.10.2 00:00:00:00:10:02</span><br><span class="line">arp -s 192.168.10.3 00:00:00:00:10:03</span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.1,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.2,actions=output:s1_2</span><br><span class="line">ovs-ofctl add-flow s1 ip,nw_dst=192.168.10.3,actions=output:s1_2</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s1 vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ s2 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s2 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1002</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x08</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-appctl vlog/set dpif_qdisc:file:dbg</span><br><span class="line">ovs-vsctl add-br s2 -- <span class="built_in">set</span> bridge s2 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s2 other_config:hwaddr=<span class="string">&quot;00:00:00:00:10:02&quot;</span></span><br><span class="line">ifconfig s2 192.168.10.2 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s2 s2_1 -- <span class="built_in">set</span> Interface s2_1 ofport_request=21</span><br><span class="line">ovs-vsctl add-port s2 s2_3 -- <span class="built_in">set</span> Interface s2_3 ofport_request=23</span><br><span class="line">arp -s 192.168.10.1 00:00:00:00:10:01</span><br><span class="line">arp -s 192.168.10.2 00:00:00:00:10:02</span><br><span class="line">arp -s 192.168.10.3 00:00:00:00:10:03</span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.2,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.1,actions=output:s2_1</span><br><span class="line">ovs-ofctl add-flow s2 ip,nw_dst=192.168.10.3,actions=output:s2_3</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s2 vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ s3 ####################################</span></span><br><span class="line">docker <span class="built_in">exec</span> -it s3 bash</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=1002</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x20</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br s3 -- <span class="built_in">set</span> bridge s3 datapath_type=netdev</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge s3 other_config:hwaddr=<span class="string">&quot;00:00:00:00:10:03&quot;</span></span><br><span class="line">ifconfig s3 192.168.10.3 netmask 255.255.255.0 up</span><br><span class="line">ovs-vsctl add-port s3 s3_1 -- <span class="built_in">set</span> Interface s3_1 ofport_request=31</span><br><span class="line">ovs-vsctl add-port s3 s3_2 -- <span class="built_in">set</span> Interface s3_2 ofport_request=32</span><br><span class="line">arp -s 192.168.10.1 00:00:00:00:10:01</span><br><span class="line">arp -s 192.168.10.2 00:00:00:00:10:02</span><br><span class="line">arp -s 192.168.10.3 00:00:00:00:10:03</span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.3,actions=output:LOCAL</span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.1,actions=output:s3_2</span><br><span class="line">ovs-ofctl add-flow s3 ip,nw_dst=192.168.10.2,actions=output:s3_2</span><br><span class="line"><span class="comment"># ovs-vsctl add-port s3vhost-user1 -- set Interface vhost-user1 type=dpdkvhostuser ofport_request=2</span></span><br></pre></td></tr></table></figure><h3 id="veth-OVS-veth"><a href="#veth-OVS-veth" class="headerlink" title="veth-OVS-veth"></a>veth-OVS-veth</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sudo docker create -it --name=s1 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0-vlog</span><br><span class="line">sudo docker create -it --name=s2 --privileged -v /dev/hugepages:/dev/hugepages -v /root/run:/root/run ovs-dpdk:2.16.0-vlog</span><br><span class="line">sudo docker start s1 s2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 veth-peer</span></span><br><span class="line">sudo ip <span class="built_in">link</span> add sh_1 <span class="built_in">type</span> veth peer name s1_h &gt; /dev/null</span><br><span class="line">sudo ip <span class="built_in">link</span> add sh_2 <span class="built_in">type</span> veth peer name s2_h &gt; /dev/null</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s1_h name s1_h netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s1) up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> dev s2_h name s2_h netns $(sudo docker inspect -f <span class="string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> s2) up</span><br><span class="line">ifconfig sh_1 up</span><br><span class="line">ifconfig sh_2 up</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it s1 bash</span><br><span class="line">ifconfig s1_h 192.168.10.1</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev s1_h address 00:00:00:00:10:01</span><br><span class="line">arp -s 192.168.10.2 00:00:00:00:10:02</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it s2 bash</span><br><span class="line">ifconfig s2_h 192.168.10.2</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev s2_h address 00:00:00:00:10:02</span><br><span class="line">arp -s 192.168.10.1 00:00:00:00:10:01</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 删除之前的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> /usr/local/etc/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/run/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/log/openvswitch/*</span><br><span class="line"></span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=random</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x02</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line">ovs-vsctl add-port br0 sh_1 -- <span class="built_in">set</span> Interface sh_1 ofport_request=11</span><br><span class="line">ovs-vsctl add-port br0 sh_2 -- <span class="built_in">set</span> Interface sh_2 ofport_request=12</span><br><span class="line">ovs-ofctl add-flow br0 ip,nw_dst=192.168.10.1,actions=output:sh_1</span><br><span class="line">ovs-ofctl add-flow br0 ip,nw_dst=192.168.10.2,actions=output:sh_2</span><br><span class="line"></span><br><span class="line"><span class="comment">## ATS</span></span><br><span class="line">ovs-vsctl <span class="built_in">set</span> interface sh_1 other_config:qdisc=ATS</span><br><span class="line">ovs-vsctl <span class="built_in">set</span> interface sh_2 other_config:qdisc=ATS</span><br></pre></td></tr></table></figure><h3 id="PKTGEN-OVS-TESTPMD"><a href="#PKTGEN-OVS-TESTPMD" class="headerlink" title="PKTGEN-OVS-TESTPMD"></a>PKTGEN-OVS-TESTPMD</h3><p><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/OVS%20%E6%B5%81%E7%A8%8B%E5%9B%BE-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95.drawio%20(1).png" alt="OVS 流程图-性能测试.drawio (1)"></p><p>由于上面的拓扑存在连接问题，只好用单节点测试OVS的速率与PMD的关系，这里OVS就直接部署在主机上，pktgen和testpmd放置在Docker中运行。</p><p><strong>拓扑搭建</strong>：基本拓扑搭建方法如下，但实际测试时会修改参数！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 删除之前的配置文件</span></span><br><span class="line"><span class="built_in">rm</span> /usr/local/etc/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/run/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/log/openvswitch/*</span><br><span class="line"></span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=random</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x02</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加 bridge</span></span><br><span class="line">ovs-vsctl add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line">ovs-vsctl add-port br0 vhost-user1 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user1 <span class="built_in">type</span>=dpdkvhostuser ofport_request=1</span><br><span class="line">ovs-vsctl add-port br0 vhost-user2 \</span><br><span class="line">    -- <span class="built_in">set</span> Interface vhost-user2 <span class="built_in">type</span>=dpdkvhostuser ofport_request=2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动容器</span></span><br><span class="line"><span class="comment"># pktgen</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --privileged --name=app-pktgen \</span><br><span class="line">    -v /dev/hugepages:/dev/hugepages \</span><br><span class="line">    -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">    pktgen20:latest /bin/bash</span><br><span class="line"></span><br><span class="line">pktgen -c 0x19 --main-lcore 3 -n 1 --socket-mem 1024 --file-prefix pktgen --no-pci  \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user1,mac=00:00:00:00:00:01,path=/var/run/openvswitch/vhost-user1&#x27;</span> \</span><br><span class="line">-- -T -P -m <span class="string">&quot;0.0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># testpmd</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> --privileged --name=app-testpmd \</span><br><span class="line">    -v /dev/hugepages:/dev/hugepages \</span><br><span class="line">    -v /usr/local/var/run/openvswitch:/var/run/openvswitch \</span><br><span class="line">    pktgen20:latest /bin/bash</span><br><span class="line"></span><br><span class="line">dpdk-testpmd -c 0xE0 -n 1 --socket-mem 1024 --file-prefix testpmd --no-pci \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user2,mac=00:00:00:00:00:02,path=/var/run/openvswitch/vhost-user2&#x27;</span> \</span><br><span class="line">-- -i -a --coremask=0xc0 --forward-mode=rxonly</span><br></pre></td></tr></table></figure><p><strong>参数说明</strong>：</p><ul><li><p><code>pmd-cpu-mask</code>：指定在哪些核上面绑定PMD线程，即指定了PMD创建的数量。</p></li><li><p><code>dpdk-lcore-mask</code>：指定在哪些核上创建lcore 线程，该线程用于 dpdk 库内部消息处理，如日志等。</p></li><li><p><code>-c</code>：指定在哪些核上运行Pktgen发包或接收线程。</p></li><li><p><code>-m</code>：指定核与端口的对应关系，注意这里的编号从0开始数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">“1.0, 2.1, 3.2”               - core 1 handles port 0 rx/tx,</span><br><span class="line">                                core 2 handles port 1 rx/tx</span><br><span class="line">                                core 3 handles port 2 rx/tx</span><br><span class="line">1.[0-2], 2.3, ...             - core 1 handle ports 0,1,2 rx/tx,</span><br><span class="line">                                core 2 handle port 3 rx/tx</span><br><span class="line">[1:2].0, [4:6].1, ...         - core 1 handles port 0 rx,</span><br><span class="line">                                core 2 handles port 0 tx,</span><br></pre></td></tr></table></figure></li><li><p><code>--coremask=0xXX</code>：指定在哪些核上运行包转发。</p></li></ul><h4 id="测试1"><a href="#测试1" class="headerlink" title="测试1"></a>测试1</h4><p>CPU为 <code>i7-12700k</code>，系统为 <code>Ubuntu 20.04</code>！</p><p><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/image-20220703165153359.png" alt="image-20220703165153359"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x2</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-lcore-mask=0x1</span><br><span class="line"></span><br><span class="line">pktgen -c 0x30 -n 1 --socket-mem 1024 --file-prefix pktgen --no-pci  \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user1,mac=00:00:00:00:00:01,path=/var/run/openvswitch/vhost-user1&#x27;</span> \</span><br><span class="line">-- -T -P -m <span class="string">&quot;5.0&quot;</span></span><br><span class="line"></span><br><span class="line">dpdk-testpmd -c 0x300 -n 1 --socket-mem 1024 --file-prefix testpmd --no-pci \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user2,mac=00:00:00:00:00:02,path=/var/run/openvswitch/vhost-user2&#x27;</span> \</span><br><span class="line">-- -i -a --coremask=0x200 --forward-mode=rxonly</span><br></pre></td></tr></table></figure><p><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/image-20220703163105375.png" alt="image-20220703163105375"></p><p>可以看到CPU的占用情况与配置一致！<code>Pktgen</code>占用了两个核。</p><p><strong>未配置流表的情况下的速率与配置流表后的速率明显有区别</strong>！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 未配置流表情况下，安装默认的 Normal 转发</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据包大小为 64 BYTE，测得接收速率为 3 Gbps</span></span><br><span class="line">testpmd&gt; show port stats all</span><br><span class="line">  <span class="comment">######################## NIC statistics for port 0  ########################</span></span><br><span class="line">  Throughput (since last show)</span><br><span class="line">  Rx-pps:      6284600          Rx-bps:   3 016 608 216</span><br><span class="line">  Tx-pps:            0          Tx-bps:            0</span><br><span class="line">  <span class="comment">############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据包大小为 1500 BYTE，测得接收速率为 42 Gbps</span></span><br><span class="line">testpmd&gt; show port stats all</span><br><span class="line">  <span class="comment">######################## NIC statistics for port 0  ########################</span></span><br><span class="line">  Throughput (since last show)</span><br><span class="line">  Rx-pps:      3572386          Rx-bps:  42 754 318 664</span><br><span class="line">  Tx-pps:            0          Tx-bps:            0</span><br><span class="line">  <span class="comment">############################################################################</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">############################################################################</span></span><br><span class="line">ovs-ofctl add-flow br0 in_port=vhost-user1,actions=output:vhost-user2</span><br><span class="line"><span class="comment">############################################################################</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据包大小为 64 BYTE，测得接收速率为 7.8 Gbps</span></span><br><span class="line">testpmd&gt; show port stats all</span><br><span class="line">  <span class="comment">######################## NIC statistics for port 0  ########################</span></span><br><span class="line">  Throughput (since last show)</span><br><span class="line">  Rx-pps:     16353825          Rx-bps:   7 849 813 576</span><br><span class="line">  Tx-pps:            0          Tx-bps:            0</span><br><span class="line">  <span class="comment">############################################################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据包大小为 1500 BYTE，测得接收速率为 88 Gbps</span></span><br><span class="line">testpmd&gt; show port stats all</span><br><span class="line">  <span class="comment">######################## NIC statistics for port 0  ########################</span></span><br><span class="line">  Throughput (since last show)</span><br><span class="line">  Rx-pps:      7380556          Rx-bps:  88 330 499 920</span><br><span class="line">  Tx-pps:            0          Tx-bps:            0</span><br><span class="line">  <span class="comment">############################################################################</span></span><br></pre></td></tr></table></figure><h4 id="测试2"><a href="#测试2" class="headerlink" title="测试2"></a>测试2</h4><p><img src="/../images/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/image-20220703171156821.png" alt="image-20220703171156821"></p><p>上面设置流表后，转发速率有了很多提升，但瓶颈在哪一个阶段（发包、转发、收包）还不确定，可能仍然在转发这里，因此先测试启用两个PMD线程后的速率！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x6</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-lcore-mask=0x1</span><br><span class="line"></span><br><span class="line">ovs-vsctl <span class="built_in">set</span> Interface vhost-user1 options:n_rxq=2</span><br><span class="line"></span><br><span class="line">pktgen -c 0x30 -n 1 --socket-mem 1024 --file-prefix pktgen --no-pci  \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user1,mac=00:00:00:00:00:01,path=/var/run/openvswitch/vhost-user1&#x27;</span> \</span><br><span class="line">-- -T -P -m <span class="string">&quot;5.0&quot;</span></span><br><span class="line"></span><br><span class="line">dpdk-testpmd -c 0x300 -n 1 --socket-mem 1024 --file-prefix testpmd --no-pci \</span><br><span class="line">--vdev <span class="string">&#x27;net_virtio_user2,mac=00:00:00:00:00:02,path=/var/run/openvswitch/vhost-user2&#x27;</span> \</span><br><span class="line">-- -i -a --coremask=0x200 --forward-mode=rxonly</span><br></pre></td></tr></table></figure><p>根据日志，确实启用了2个PMD线程，但并没有将<code>vhost-user1</code>设置为双接收队列！按照文档中的描述<a href="http://www.openvswitch.org/support/dist-docs/ovs-vswitchd.conf.db.5.html">n_rxq</a> Not supported by DPDK vHost interfaces. 但是在<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/configure-vhost-user-multiqueue-for-ovs-with-dpdk.html">Intel 的文档</a>中也是用此参数设置的！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2022-07-03T09:32:20.070Z|00075|dpif_netdev|INFO|PMD thread on numa_id: 0, core <span class="built_in">id</span>:  1 created.</span><br><span class="line">2022-07-03T09:32:20.073Z|00076|dpif_netdev|INFO|PMD thread on numa_id: 0, core <span class="built_in">id</span>:  2 created.</span><br><span class="line">2022-07-03T09:32:20.073Z|00077|dpif_netdev|INFO|There are 2 pmd threads on numa node 0</span><br><span class="line">...</span><br><span class="line">2022-07-03T09:32:20.191Z|00086|dpif_netdev|INFO|Core  1 on numa node 0 assigned port <span class="string">&#x27;vhost-user1&#x27;</span> rx queue 0 (measured processing cycles 0).</span><br><span class="line">2022-07-03T09:32:20.191Z|00087|dpif_netdev|INFO|Core  2 on numa node 0 assigned port <span class="string">&#x27;vhost-user2&#x27;</span> rx queue 0 (measured processing cycles 0).</span><br></pre></td></tr></table></figure><p>由于一个接收队列只能交给一个PMD处理，所以这里虽然设置两个PMD，但仍然只有一个PMD在转发包，虽然相比之前，不用去轮询<code>vhost-user2</code>端口上的队列，不过不知道轮询一个空队列的开销大小。</p><p>此情况下，实际测得接收速率仍然为 88 Gbps，故仍然不确定瓶颈在哪！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 数据包大小为 1500 BYTE，测得接收速率为 88 Gbps</span></span><br><span class="line">testpmd&gt; show port stats all</span><br><span class="line">  <span class="comment">######################## NIC statistics for port 0  ########################</span></span><br><span class="line">  Throughput (since last show)</span><br><span class="line">  Rx-pps:      7421329          Rx-bps:  88818467544</span><br><span class="line">  Tx-pps:            0          Tx-bps:            0</span><br><span class="line">  <span class="comment">############################################################################</span></span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><p><a href="https://man7.org/linux/man-pages/man5/ovs-vswitchd.conf.db.5.html#Open_vSwitch_TABLE">Open_vSwitch 守护进程配置</a><br><a href="https://zhuanlan.zhihu.com/p/269782783">CPU socket</a><br><a href="https://bbs.huaweicloud.com/forum/thread-71514-1-1.html">查看网卡归属哪个CPU socket</a><br><a href="https://www.cxyzjd.com/article/sinat_20184565/93471205">OVS DPDK设备内存模型</a></p>]]></content>
      
      
      <categories>
          
          <category> OpenVSwitch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenVSwitch </tag>
            
            <tag> DPDK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程-线程池</title>
      <link href="/2022/05/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/05/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>在多任务并发处理的场景下，如果每来一个任务，就新建一个线程来处理，虽然功能上没问题，但由于线程的创建和销毁会带来很大的开销。线程池就是通过预先创建一定数量的线程，当有任务来时，就将任务分配给一个线程去处理！</p><h2 id="线程池模型"><a href="#线程池模型" class="headerlink" title="线程池模型"></a>线程池模型</h2><p>下面是线程池的结构！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> &#123;</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;           <span class="comment">/* 用于锁住本结构体 */</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> thread_counter; <span class="comment">/* 记录忙状态线程个数的锁 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_cond_t</span> queue_not_full;  <span class="comment">/* 当任务队列满时，添加任务任务的线程阻塞，等待此条件变量 */</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> queue_not_empty; <span class="comment">/* 任务队列不为空时，通知等待任务的线程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> *threads;             <span class="comment">/* 存放线程池中每个线程的 tid 数组 */</span></span><br><span class="line">    <span class="type">pthread_t</span> adjust_tid;           <span class="comment">/* 存管理线程tid */</span></span><br><span class="line">    <span class="type">threadpool_task_t</span> *task_queue;  <span class="comment">/* 任务队列，数组首地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min_thr_num;                <span class="comment">/* 线程池最小线程数 */</span></span><br><span class="line">    <span class="type">int</span> max_thr_num;                <span class="comment">/* 线程池最大线程数 */</span></span><br><span class="line">    <span class="type">int</span> live_thr_num;               <span class="comment">/* 当前存活线程个数 */</span></span><br><span class="line">    <span class="type">int</span> busy_thr_num;               <span class="comment">/* 忙状态线程个数 */</span></span><br><span class="line">    <span class="type">int</span> wait_exit_thr_num;          <span class="comment">/* 要销毁的线程个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> queue_front;                <span class="comment">/* task_queue 队头下标 */</span></span><br><span class="line">    <span class="type">int</span> queue_rear;                 <span class="comment">/* task_queue 队尾下标 */</span></span><br><span class="line">    <span class="type">int</span> queue_size;                 <span class="comment">/* task_queue 队中实际任务数 */</span></span><br><span class="line">    <span class="type">int</span> queue_max_size;             <span class="comment">/* task_queue 队中可容纳的任务数上限 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> shutdown;                  <span class="comment">/* 标志位，线程池使用状态，true或false */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="线程数组和任务队列"><a href="#线程数组和任务队列" class="headerlink" title="线程数组和任务队列"></a>线程数组和任务队列</h3><p>线程池的核心也就是线程数组和任务队列！</p><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/threadpool1.png" alt="image"></p><p><strong>1. 线程数组：threads。</strong></p><p>注意此处的实现中，线程的数量不是固定的，可在最小线程数和最大线程数之间动态调整。当突发任务数量大于最小线程数时，线程池会创建新线程以处理突发任务，任务处理完之后，若没有其他任务需要处理，<strong>管理线程</strong>会定时回收空闲的线程，但保证线程池中线程数不会小于最小线程数。</p><p>当突发任务数量大于最大线程数时，线程池创建的线程数会被限制在最大线程数。</p><p>基于上述原理，线程池结构中，以下5个成员变量用于辅助管理线程数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> *threads;     <span class="comment">/* 存放线程池中每个线程的 tid 数组 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> min_thr_num;        <span class="comment">/* 线程池最小线程数 */</span></span><br><span class="line"><span class="type">int</span> max_thr_num;        <span class="comment">/* 线程池最大线程数 */</span></span><br><span class="line"><span class="type">int</span> live_thr_num;       <span class="comment">/* 当前存活线程个数 */</span></span><br><span class="line"><span class="type">int</span> busy_thr_num;       <span class="comment">/* 忙状态线程个数 */</span></span><br><span class="line"><span class="type">int</span> wait_exit_thr_num;  <span class="comment">/* 要销毁的线程个数 */</span></span><br></pre></td></tr></table></figure><p><strong>2. 任务队列：task_queue。</strong></p><p>与线程数组不同，任务队列是一个固定大小的<strong>循环队列</strong>，用于存放待处理的任务，线程池需要处理的<strong>任务类型</strong>和<strong>参数</strong>不一，无法预先定义在线程中，只能通过任务传入。也就是说，任务队列中存储的内容要包括**任务类型<code>（void *(*func)(void*arg)）</code><strong>和</strong>参数<code>（void *arg）</code>**。</p><p>使用线程池时，只需调用函数将任务添加到任务队列尾部即可，线程池会自动为任务分配线程处理。但当任务队列满时，线程池会拒绝添加新任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *(*function)(<span class="type">void</span> *);  <span class="comment">/* 函数指针，回调函数 */</span></span><br><span class="line">    <span class="type">void</span> *arg;                  <span class="comment">/* 上面函数的参数 */</span></span><br><span class="line">&#125; <span class="type">threadpool_task_t</span>;            <span class="comment">/* 各子线程任务结构体 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">threadpool_task_t</span> *task_queue;  <span class="comment">/* 任务队列，数组首地址 */</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> queue_front;                <span class="comment">/* task_queue 队头下标 */</span></span><br><span class="line"><span class="type">int</span> queue_rear;                 <span class="comment">/* task_queue 队尾下标 */</span></span><br><span class="line"><span class="type">int</span> queue_size;                 <span class="comment">/* task_queue 队中实际任务数 */</span></span><br><span class="line"><span class="type">int</span> queue_max_size;             <span class="comment">/* task_queue 队中可容纳的任务数上限 */</span></span><br></pre></td></tr></table></figure><h3 id="线程池管理线程"><a href="#线程池管理线程" class="headerlink" title="线程池管理线程"></a>线程池管理线程</h3><p>线程池中除了专门用于处理任务的线程，还需要有一个<strong>管理线程</strong>，用于管理线程池中的任务线程。线程池的动态扩容和销毁都是通过管理线程来完成的，管理线程<strong>定期</strong>根据当前线程数组和任务数组情况，决定是否需要扩容或销毁线程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_t</span> adjust_tid;           <span class="comment">/* 存管理线程tid */</span></span><br></pre></td></tr></table></figure><h3 id="条件变量与互斥锁"><a href="#条件变量与互斥锁" class="headerlink" title="条件变量与互斥锁"></a>条件变量与互斥锁</h3><p>线程池的任务分配也可看作<strong>生产者消费者模型</strong>，任务队列中的元素是<strong>产品</strong>，线程池中的每一个线程都是<strong>消费者</strong>，向线程池中添加任务的是<strong>生产者</strong>（一般为主线程）。也就是说，线程池可以看作<strong>单生产者、多消费者模型</strong>。</p><p>一个任务只需要也只能分配给一个任务线程处理！因此，需要配合条件变量和互斥锁来实现任务分配。</p><ul><li><p><strong>消费者</strong>：没有任务时，任务线程都阻塞在条件变量<code>queue_not_empty</code>上，等待新任务到来。</p></li><li><p><strong>生产者</strong>：任务队列满时，主线程<code>pthreadpool_add</code>阻塞在条件变量<code>queue_not_full</code>上，等待任务队列空间可用。</p></li><li><p><code>thread_counter</code>：记录忙状态线程个数的锁！</p></li></ul><p><em>此处可以先回顾基于条件变量实现的生产者消费者模型！此处的任务线程处理逻辑与消费者一致！</em></p><h2 id="threadpool-create-函数"><a href="#threadpool-create-函数" class="headerlink" title="threadpool_create 函数"></a>threadpool_create 函数</h2><p>根据输入的参数创建一个线程池，并返回线程池的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">threadpool_t</span> *<span class="title function_">threadpool_create</span><span class="params">(<span class="type">int</span> min_thr_num, <span class="type">int</span> max_thr_num, <span class="type">int</span> queue_max_size)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>min_thr_num</code>：线程池中最少含有线程数</li><li><code>max_thr_num</code>：线程池中最多最多线程数</li><li><code>queue_max_size</code>：线程池中任务队列的最大容量</li><li>返回值：线程池指针，如果创建失败，返回NULL</li></ul><h2 id="threadpool-add-函数"><a href="#threadpool-add-函数" class="headerlink" title="threadpool_add 函数"></a>threadpool_add 函数</h2><p>添加一个任务到线程池的任务队列中，如果线程池任务队列已满，则阻塞等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">threadpool_add</span><span class="params">(<span class="type">threadpool_t</span> *pool, <span class="type">void</span>*(*function)(<span class="type">void</span> *arg), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>pool</code>：线程池指针</li><li><code>function</code>：任务函数</li><li><code>arg</code>：任务函数参数</li><li>返回值：0，添加成功；不会失败，只会阻塞等待！</li></ul><h2 id="threadpool-destroy-函数"><a href="#threadpool-destroy-函数" class="headerlink" title="threadpool_destroy 函数"></a>threadpool_destroy 函数</h2><p>销毁管理线程、通知所有空闲线程结束、等待忙线程结束，释放线程池所占空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">threadpool_destroy</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>pool</code>：线程池指针</li><li>返回值：0，销毁成功；pool 为NULL 时，返回-1。</li></ul><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><p>下面的简单实现可以用来理解线程池的原理，但性能并不理想！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_TIME 10                 <span class="comment">/* 10s检测一次 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_WAIT_TASK_NUM 10            <span class="comment">/* 如果queue_size &gt; MIN_WAIT_TASK_NUM 添加新的线程到线程池 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_THREAD_VARY 10          <span class="comment">/* 每次创建和销毁线程的个数 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *(*function)(<span class="type">void</span> *);          <span class="comment">/* 函数指针，回调函数 */</span></span><br><span class="line">    <span class="type">void</span> *arg;                          <span class="comment">/* 上面函数的参数 */</span></span><br><span class="line">&#125; <span class="type">threadpool_task_t</span>;                    <span class="comment">/* 各子线程任务结构体 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 描述线程池相关信息 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">threadpool_t</span> &#123;</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> lock;           <span class="comment">/* 用于锁住本结构体 */</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> thread_counter; <span class="comment">/* 记录忙状态线程个数的锁 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_cond_t</span> queue_not_full;  <span class="comment">/* 当任务队列满时，添加任务任务的线程阻塞，等待此条件变量 */</span></span><br><span class="line">    <span class="type">pthread_cond_t</span> queue_not_empty; <span class="comment">/* 任务队列不为空时，通知等待任务的线程 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> *threads;             <span class="comment">/* 存放线程池中每个线程的tid 数组 */</span></span><br><span class="line">    <span class="type">pthread_t</span> adjust_tid;           <span class="comment">/* 存管理线程tid */</span></span><br><span class="line">    <span class="type">threadpool_task_t</span> *task_queue;  <span class="comment">/* 任务队列，数组首地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> min_thr_num;                <span class="comment">/* 线程池最小线程数 */</span></span><br><span class="line">    <span class="type">int</span> max_thr_num;                <span class="comment">/* 线程池最大线程数 */</span></span><br><span class="line">    <span class="type">int</span> live_thr_num;               <span class="comment">/* 当前存活线程个数 */</span></span><br><span class="line">    <span class="type">int</span> busy_thr_num;               <span class="comment">/* 忙状态线程个数 */</span></span><br><span class="line">    <span class="type">int</span> wait_exit_thr_num;          <span class="comment">/* 要销毁的线程个数 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> queue_front;                <span class="comment">/* task_queue 队头下标 */</span></span><br><span class="line">    <span class="type">int</span> queue_rear;                 <span class="comment">/* task_queue 队尾下标 */</span></span><br><span class="line">    <span class="type">int</span> queue_size;                 <span class="comment">/* task_queue 队中实际任务数 */</span></span><br><span class="line">    <span class="type">int</span> queue_max_size;             <span class="comment">/* task_queue 队中可容纳的任务数上限 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> shutdown;                  <span class="comment">/* 标志位，线程池使用状态，true或false */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">threadpool_thread</span><span class="params">(<span class="type">void</span> *threadpool)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">adjust_thread</span><span class="params">(<span class="type">void</span> *threadpool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_thread_alive</span><span class="params">(<span class="type">pthread_t</span> tid)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_free</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">threadpool_t</span> *<span class="title function_">threadpool_create</span><span class="params">(<span class="type">int</span> min_thr_num, <span class="type">int</span> max_thr_num, <span class="type">int</span> queue_max_size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">threadpool_t</span> *pool = <span class="literal">NULL</span>;          <span class="comment">/* 线程池 结构体 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pool = (<span class="type">threadpool_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">threadpool_t</span>))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threadpool failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pool-&gt;min_thr_num = min_thr_num;</span><br><span class="line">        pool-&gt;max_thr_num = max_thr_num;</span><br><span class="line">        pool-&gt;busy_thr_num = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;live_thr_num = min_thr_num;               <span class="comment">/* 活着的线程数 初值=最小线程数 */</span></span><br><span class="line">        pool-&gt;wait_exit_thr_num = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queue_size = <span class="number">0</span>;                           <span class="comment">/* 有0个产品 */</span></span><br><span class="line">        pool-&gt;queue_max_size = queue_max_size;          <span class="comment">/* 最大任务队列数 */</span></span><br><span class="line">        pool-&gt;queue_front = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;queue_rear = <span class="number">0</span>;</span><br><span class="line">        pool-&gt;shutdown = <span class="literal">false</span>;                         <span class="comment">/* 不关闭线程池 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 根据最大线程上限数， 给工作线程数组开辟空间, 并清零 */</span></span><br><span class="line">        pool-&gt;threads = (<span class="type">pthread_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">pthread_t</span>)*max_thr_num);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;threads == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc threads failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pool-&gt;threads, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">pthread_t</span>)*max_thr_num);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 给 任务队列 开辟空间 */</span></span><br><span class="line">        pool-&gt;task_queue = (<span class="type">threadpool_task_t</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">threadpool_task_t</span>)*queue_max_size);</span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;task_queue == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;malloc task failed\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 初始化互斥琐、条件变量 */</span></span><br><span class="line">        <span class="keyword">if</span> (pthread_mutex_init(&amp;(pool-&gt;lock), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_mutex_init(&amp;(pool-&gt;thread_counter), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_cond_init(&amp;(pool-&gt;queue_not_empty), <span class="literal">NULL</span>) != <span class="number">0</span></span><br><span class="line">                || pthread_cond_init(&amp;(pool-&gt;queue_not_full), <span class="literal">NULL</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;init lock or cond failed!\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 启动 min_thr_num 个 work thread */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; min_thr_num; i++) &#123;</span><br><span class="line">            pthread_create(&amp;pool-&gt;threads[i], <span class="literal">NULL</span>, threadpool_thread, (<span class="type">void</span> *)pool);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;start thread 0x%x ... \n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pool-&gt;threads[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_create(&amp;(pool-&gt;adjust_tid), <span class="literal">NULL</span>, adjust_thread, (<span class="type">void</span> *)pool);     <span class="comment">/* 创建管理者线程 */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pool;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    threadpool_free(pool);      <span class="comment">/* 前面代码调用失败时，释放poll存储空间 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 向线程池中 添加一个任务 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_add</span><span class="params">(<span class="type">threadpool_t</span> *pool, <span class="type">void</span>*(*function)(<span class="type">void</span> *arg), <span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* == 为真，队列已经满， 调wait阻塞 */</span></span><br><span class="line">    <span class="keyword">while</span> ((pool-&gt;queue_size == pool-&gt;queue_max_size) &amp;&amp; (!pool-&gt;shutdown)) &#123;</span><br><span class="line">        pthread_cond_wait(&amp;(pool-&gt;queue_not_full), &amp;(pool-&gt;lock));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;shutdown) &#123;</span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 清空 工作线程 调用的回调函数 的参数arg */</span></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;task_queue[pool-&gt;queue_rear].arg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        pool-&gt;task_queue[pool-&gt;queue_rear].arg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加任务到任务队列里 */</span></span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].function = function;</span><br><span class="line">    pool-&gt;task_queue[pool-&gt;queue_rear].arg = arg;</span><br><span class="line">    pool-&gt;queue_rear = (pool-&gt;queue_rear + <span class="number">1</span>) % pool-&gt;queue_max_size;       <span class="comment">/* 队尾指针移动, 模拟环形 */</span></span><br><span class="line">    pool-&gt;queue_size++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 添加完任务后，队列不为空，唤醒线程池中 等待处理任务的线程 */</span></span><br><span class="line">    pthread_cond_signal(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 线程池中各个工作线程 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">threadpool_thread</span><span class="params">(<span class="type">void</span> *threadpool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">threadpool_t</span> *pool = (<span class="type">threadpool_t</span> *)threadpool;</span><br><span class="line">    <span class="type">threadpool_task_t</span> task;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/* 刚创建出线程，等待任务队列里有任务，否则阻塞等待任务队列里有任务后再唤醒接收任务 */</span></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* queue_size == 0 说明没有任务，调 wait 阻塞在条件变量上, 若有任务，跳过该while */</span></span><br><span class="line">        <span class="keyword">while</span> ((pool-&gt;queue_size == <span class="number">0</span>) &amp;&amp; (!pool-&gt;shutdown)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is waiting\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">            pthread_cond_wait(&amp;(pool-&gt;queue_not_empty), &amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 清除指定数目的空闲线程，如果要结束的线程个数大小0，结束线程 */</span></span><br><span class="line">            <span class="keyword">if</span> (pool-&gt;wait_exit_thr_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                pool-&gt;wait_exit_thr_num--;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 如果线程池中线程个数大于最小值时，可以结束线程 */</span></span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is exiting\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">                    pool-&gt;live_thr_num--;</span><br><span class="line">                    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">                    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 如果指定了true，要关闭线程池里的每个线程，自行退出处理---销毁线程池 */</span></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;shutdown) &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x is exiting\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">            pthread_detach(pthread_self());</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);     <span class="comment">/* 线程自行结束 */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 从任务队列里获取任务, 是一个出队操作 */</span></span><br><span class="line">        task.function = pool-&gt;task_queue[pool-&gt;queue_front].function;</span><br><span class="line">        task.arg = pool-&gt;task_queue[pool-&gt;queue_front].arg;</span><br><span class="line"></span><br><span class="line">        pool-&gt;queue_front = (pool-&gt;queue_front + <span class="number">1</span>) % pool-&gt;queue_max_size;       <span class="comment">/* 出队，模拟环形队列 */</span></span><br><span class="line">        pool-&gt;queue_size--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 任务取出后，立即将 线程池琐 释放 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 通知可以有新的任务添加进来 */</span></span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_full));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 执行任务 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x start working\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));                            <span class="comment">/* 忙状态线程数变量琐 */</span></span><br><span class="line">        pool-&gt;busy_thr_num++;                                                   <span class="comment">/* 忙状态线程数+1 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line"></span><br><span class="line">        (*(task.function))(task.arg);                                           <span class="comment">/* 执行回调函数任务 */</span></span><br><span class="line">        <span class="comment">//task.function(task.arg);                                              /* 执行回调函数任务 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 任务结束处理 */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread 0x%x end working\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)pthread_self());</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pool-&gt;busy_thr_num--;                                       <span class="comment">/* 处理掉一个任务，忙状态数线程数-1 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 管理线程 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">adjust_thread</span><span class="params">(<span class="type">void</span> *threadpool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">threadpool_t</span> *pool = (<span class="type">threadpool_t</span> *)threadpool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!pool-&gt;shutdown) &#123;</span><br><span class="line">        sleep(DEFAULT_TIME);                        <span class="comment">/* 定时 对线程池管理 */</span></span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">        <span class="type">int</span> queue_size = pool-&gt;queue_size;          <span class="comment">/* 关注 任务数 */</span></span><br><span class="line">        <span class="type">int</span> live_thr_num = pool-&gt;live_thr_num;      <span class="comment">/* 存活 线程数 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        <span class="type">int</span> busy_thr_num = pool-&gt;busy_thr_num;      <span class="comment">/* 忙着的线程数 */</span></span><br><span class="line">        pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 创建新线程 算法： 任务数大于最小线程池个数, 且存活的线程数少于最大线程个数时 如：30&gt;=10 &amp;&amp; 40&lt;100*/</span></span><br><span class="line">        <span class="keyword">if</span> (queue_size &gt;= MIN_WAIT_TASK_NUM &amp;&amp; live_thr_num &lt; pool-&gt;max_thr_num) &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">            <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*一次增加 DEFAULT_THREAD 个线程*/</span></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;max_thr_num &amp;&amp; add &lt; DEFAULT_THREAD_VARY</span><br><span class="line">                    &amp;&amp; pool-&gt;live_thr_num &lt; pool-&gt;max_thr_num; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pool-&gt;threads[i] == <span class="number">0</span> || !is_thread_alive(pool-&gt;threads[i])) &#123;</span><br><span class="line">                    pthread_create(&amp;(pool-&gt;threads[i]), <span class="literal">NULL</span>, threadpool_thread, (<span class="type">void</span> *)pool);</span><br><span class="line">                    add++;</span><br><span class="line">                    pool-&gt;live_thr_num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 销毁多余的空闲线程 算法：忙线程X2 小于 存活的线程数 且 存活的线程数 大于 最小线程数时*/</span></span><br><span class="line">        <span class="keyword">if</span> ((busy_thr_num * <span class="number">2</span>) &lt; live_thr_num  &amp;&amp;  live_thr_num &gt; pool-&gt;min_thr_num) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 一次销毁DEFAULT_THREAD个线程, 隨機10個即可 */</span></span><br><span class="line">            pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">            pool-&gt;wait_exit_thr_num = DEFAULT_THREAD_VARY;      <span class="comment">/* 要销毁的线程数 设置为10 */</span></span><br><span class="line">            pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DEFAULT_THREAD_VARY; i++) &#123;</span><br><span class="line">                <span class="comment">/* 通知处在空闲状态的线程, 他们会自行终止*/</span></span><br><span class="line">                pthread_cond_signal(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_destroy</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pool-&gt;shutdown = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*先销毁管理线程*/</span></span><br><span class="line">    pthread_join(pool-&gt;adjust_tid, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;live_thr_num; i++) &#123;</span><br><span class="line">        <span class="comment">/*通知所有的空闲线程*/</span></span><br><span class="line">        pthread_cond_broadcast(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pool-&gt;live_thr_num; i++) &#123;</span><br><span class="line">        pthread_join(pool-&gt;threads[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    threadpool_free(pool);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_free</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;task_queue) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;task_queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pool-&gt;threads) &#123;</span><br><span class="line">        <span class="built_in">free</span>(pool-&gt;threads);</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">        pthread_mutex_destroy(&amp;(pool-&gt;lock));</span><br><span class="line">        pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pthread_mutex_destroy(&amp;(pool-&gt;thread_counter));</span><br><span class="line">        pthread_cond_destroy(&amp;(pool-&gt;queue_not_empty));</span><br><span class="line">        pthread_cond_destroy(&amp;(pool-&gt;queue_not_full));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pool);</span><br><span class="line">    pool = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_all_threadnum</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> all_threadnum = <span class="number">-1</span>;                 <span class="comment">// 总线程数</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;lock));</span><br><span class="line">    all_threadnum = pool-&gt;live_thr_num;     <span class="comment">// 存活线程数</span></span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;lock));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">threadpool_busy_threadnum</span><span class="params">(<span class="type">threadpool_t</span> *pool)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> busy_threadnum = <span class="number">-1</span>;                <span class="comment">// 忙线程数</span></span><br><span class="line"></span><br><span class="line">    pthread_mutex_lock(&amp;(pool-&gt;thread_counter));</span><br><span class="line">    busy_threadnum = pool-&gt;busy_thr_num;</span><br><span class="line">    pthread_mutex_unlock(&amp;(pool-&gt;thread_counter));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> busy_threadnum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_thread_alive</span><span class="params">(<span class="type">pthread_t</span> tid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> kill_rc = pthread_kill(tid, <span class="number">0</span>);     <span class="comment">//发0号信号，测试线程是否存活</span></span><br><span class="line">    <span class="keyword">if</span> (kill_rc == ESRCH) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.bilibili.com/video/BV1iJ411S7UA?p=91">线程池原理分析</a></li><li><a href="https://github.com/progschj/ThreadPool">A simple C++11 Thread Pool implementation</a></li><li><a href="https://github.com/search?q=threadpool">github threadpool</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 线程 </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenVSwitch-编译及启动</title>
      <link href="/2022/05/12/OpenVSwitch-%E7%BC%96%E8%AF%91%E5%8F%8A%E5%90%AF%E5%8A%A8/"/>
      <url>/2022/05/12/OpenVSwitch-%E7%BC%96%E8%AF%91%E5%8F%8A%E5%90%AF%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="基于内核的OVS"><a href="#基于内核的OVS" class="headerlink" title="基于内核的OVS"></a>基于内核的OVS</h2><p>首先验证内核版本<code>uname -r</code>与你下载的OVS版本是否匹配（必须），目前 ovs-2.16 最高只支持内核5.8！</p><p><a href="https://docs.openvswitch.org/en/latest/faq/releases/">linux内核与ovs版本匹配关系、ovs版本与DPDK版本匹配关系</a></p><p>以 <code>OVS-2.16.0</code> 为例，编译过程如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取源码</span></span><br><span class="line">wget https://github.com/openvswitch/ovs/archive/refs/tags/v2.16.0.zip &amp;&amp; unzip v2.16.0.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">sudo apt install build-essential fakeroot</span><br><span class="line">dpkg-checkbuilddeps <span class="comment"># 检查依赖并手动安装缺少的模块</span></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ovs-2.16.0</span><br><span class="line">./boot.sh</span><br><span class="line">./configure --with-linux=/lib/modules/$(<span class="built_in">uname</span> -r)/build</span><br><span class="line">make -j     <span class="comment"># -j 默认让所有核同时进行编译，也可以指定编译核数</span></span><br><span class="line"></span><br><span class="line">sudo make install   <span class="comment"># 安装ovs</span></span><br><span class="line">sudo insmod datapath/linux/openvswitch.ko <span class="comment"># 安装内核模块，报错处理见下文</span></span><br><span class="line">sudo make modules_install</span><br><span class="line">sudo modprobe openvswitch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错处理，一般是缺失依赖模块，通过modprobe安装就好</span></span><br><span class="line">modinfo ./datapath/linux/openvswitch.ko | grep depends <span class="comment"># 查看缺少依赖模块</span></span><br><span class="line">sudo modprobe nf_conntrack</span><br><span class="line">sudo modprobe nf_nat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动工具 ovs-ctl</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/share/openvswitch/scripts&#x27;</span> | <span class="built_in">tee</span> -a /root/.bashrc \</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export DB_SOCK=/usr/local/var/run/openvswitch/db.sock&#x27;</span> | <span class="built_in">tee</span> -a /root/.bashrc</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u010710985/article/details/119980125">安装内核模块时报错的解决办法</a></p><h2 id="基于DPDK的OVS"><a href="#基于DPDK的OVS" class="headerlink" title="基于DPDK的OVS"></a>基于DPDK的OVS</h2><p><strong>下面的DPDK编译方式都是基于meson，从DPDK 19版本开始才能使用meson进行编译！</strong></p><p>同样注意OVS的版本与DPDK版本是否匹配，ovs-2.16 适配了DPDK-20.11.5，DPDK的版本<code>20.11.n</code>一定要选最新版，这种更新一般是修复了一些 bug。</p><h3 id="编译安装DPDK"><a href="#编译安装DPDK" class="headerlink" title="编译安装DPDK"></a>编译安装DPDK</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取源码</span></span><br><span class="line">wget https://fast.dpdk.org/rel/dpdk-20.11.5.tar.xz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译工具 meson ninja，从v19开始使用meson进行DPDK的编译！</span></span><br><span class="line">sudo pip3 install meson ninja</span><br><span class="line">sudo apt install libnuma-dev libpcap-dev libfdt-dev</span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> dpdk-stable-20.11.3</span><br><span class="line"><span class="comment"># 编译 使用`| tee file`是将日志显示在终端的同时，保存到文件中</span></span><br><span class="line">meson build | <span class="built_in">tee</span> ../meson.build</span><br><span class="line">ninja -C build</span><br><span class="line"><span class="comment"># 安装库 将DPDK的相关库文件复制到根目录下的相关引用目录</span></span><br><span class="line">sudo ninja -C build install</span><br><span class="line"><span class="comment"># 更新缓存 (usually run when a new library is installed)</span></span><br><span class="line">sudo ldconfig</span><br><span class="line"><span class="comment"># 测试一下 libdpdk 是否安装成功</span></span><br><span class="line">pkg-config --modversion libdpdk</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载 dpdk</span></span><br><span class="line">sudo ninja uninstall</span><br></pre></td></tr></table></figure><h3 id="编译安装-OVS-DPDK"><a href="#编译安装-OVS-DPDK" class="headerlink" title="编译安装 OVS-DPDK"></a>编译安装 OVS-DPDK</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># get ovs v2.16.0</span></span><br><span class="line">wget https://github.com/openvswitch/ovs/archive/refs/tags/v2.16.0.zip</span><br><span class="line"><span class="comment"># 安装依赖包</span></span><br><span class="line">sudo apt install build-essential fakeroot</span><br><span class="line">dpkg-checkbuilddeps <span class="comment"># 检查依赖并手动安装缺少的模块</span></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ovs-2.16.0</span><br><span class="line">./boot.sh</span><br><span class="line">./configure --with-dpdk=static CFLAGS=<span class="string">&quot;-Ofast -msse4.2 -mpopcnt&quot;</span></span><br><span class="line">make -j     <span class="comment"># 多线程编译</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单元测试（可以跳过）</span></span><br><span class="line">make check TESTSUITEFLAGS=-j8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 ovs</span></span><br><span class="line">sudo make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动工具 ovs-ctl</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/share/openvswitch/scripts&#x27;</span> | <span class="built_in">tee</span> -a /root/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export DB_SOCK=/usr/local/var/run/openvswitch/db.sock&#x27;</span> | <span class="built_in">tee</span> -a /root/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否启用了 dpdk</span></span><br><span class="line">ovs-vswitchd --version</span><br><span class="line"><span class="comment"># ovs-vswitchd (Open vSwitch) 2.16.0</span></span><br><span class="line"><span class="comment"># DPDK 20.11.5</span></span><br></pre></td></tr></table></figure><p>如果<code>make -j</code>编译时，出现错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  File <span class="string">&quot;/usr/lib/python3/dist-packages/OpenSSL/__init__.py&quot;</span>, line 8, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    from OpenSSL import crypto, SSL</span><br><span class="line">  File <span class="string">&quot;/usr/lib/python3/dist-packages/OpenSSL/crypto.py&quot;</span>, line 3279, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    _lib.OpenSSL_add_all_algorithms()</span><br><span class="line">AttributeError: module <span class="string">&#x27;lib&#x27;</span> has no attribute <span class="string">&#x27;OpenSSL_add_all_algorithms&#x27;</span></span><br><span class="line">make: *** [Makefile:6819: lib/vswitch-idl.ovsidl] Error 1</span><br></pre></td></tr></table></figure><p>根据<a href="https://levelup.gitconnected.com/fix-attributeerror-module-lib-has-no-attribute-openssl-521a35d83769">这篇文章</a>的解决办法：</p><p>Upgrading <code>pip</code> to the latest version will probably fix the issue for you.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade pip</span><br></pre></td></tr></table></figure><p>If this doesn’t seem to be enough, you will then have to upgrade <code>pyOpenSSL</code>. You need to make sure that the install <code>pyopenssl</code> version is greater than <code>v22.1.0</code> therefore,</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install --upgrade openssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># alternatively</span></span><br><span class="line">python3 -m pip install openssl&gt;22.1.0</span><br></pre></td></tr></table></figure><p>If for any reason you can’t upgrade openssl (due to conflicts with other dependencies you have) the last resort (which I wouldn’t recommend otherwise), is to downgrade <code>cryptography</code> module to an older version:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install cryptography==38.0.4</span><br></pre></td></tr></table></figure><h2 id="生成Docker镜像"><a href="#生成Docker镜像" class="headerlink" title="生成Docker镜像"></a>生成Docker镜像</h2><p><strong>前提：主机上先安装好OVS！</strong></p><p>注意：<strong>docker与宿主机是共享内核的！</strong>，即使是在 docker 中使用 OVS，无论是基于内核的还是基于 DPDK 的，都会用到内核模块<code>openvswitch</code>，只有在主机上安装 OVS 后才带有这个模块，并且每次关机、重启后，都需要重新加载<code>modprobe</code>该模块，否则在docker中启动 OVS 时会报下面的错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">root@72a4b64ba608:~<span class="comment"># ovs-ctl start</span></span><br><span class="line"> * /usr/local/etc/openvswitch/conf.db does not exist</span><br><span class="line"> * Creating empty database /usr/local/etc/openvswitch/conf.db</span><br><span class="line"><span class="built_in">nice</span>: cannot <span class="built_in">set</span> niceness: Permission denied</span><br><span class="line"> * Starting ovsdb-server</span><br><span class="line"> * system ID not configured, please use --system-id</span><br><span class="line"> * Configuring Open vSwitch system IDs</span><br><span class="line">/usr/local/share/openvswitch/scripts/ovs-kmod-ctl: 112: modprobe: not found <span class="comment">############# !!!! ################</span></span><br><span class="line"> * Inserting openvswitch module</span><br><span class="line">/usr/local/share/openvswitch/scripts/ovs-kmod-ctl: 112: rmmod: not found</span><br><span class="line"> * removing bridge module</span><br></pre></td></tr></table></figure><p>上述原因是，启动 OVS 时要判断内核中是否有 openvswitch 模块，如果没有，就需要加载（通过命令 modprobe），但 docker 中并没有 modprobe 命令，因此报错，解决办法就是在主机上先加载该模块到内核（前提是主机上安装过OVS）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo modprobe openvswitch</span><br></pre></td></tr></table></figure><h3 id="基于内核的-Dockerfile"><a href="#基于内核的-Dockerfile" class="headerlink" title="基于内核的 Dockerfile"></a>基于内核的 Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span> as build</span><br><span class="line"><span class="keyword">ARG</span> ovs_version=<span class="number">2.16</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get -y install build-essential fakeroot cmake wget unzip \</span></span><br><span class="line"><span class="language-bash">  graphviz autoconf automake debhelper dh-autoreconf libssl-dev libtool python3-all python3-sphinx \</span></span><br><span class="line"><span class="language-bash">  python3-twisted python3-zope.interface libunbound-dev libunwind-dev</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载编译 OVS</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget https://codeload.github.com/openvswitch/ovs/zip/refs/tags/v<span class="variable">$&#123;ovs_version&#125;</span> -O ovs-<span class="variable">$&#123;ovs_version&#125;</span>.zip \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; unzip ovs-<span class="variable">$&#123;ovs_version&#125;</span>.zip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> ovs-<span class="variable">$&#123;ovs_version&#125;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ./boot.sh \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ./configure --with-linux=/lib/modules/$(<span class="built_in">uname</span> -r)/build \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -j \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make install</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制编译后的文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /usr/local /usr/local/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; apt-get -y --no-install-recommends install python3-all iproute2 net-tools \</span></span><br><span class="line"><span class="language-bash">     vim iperf iftop tcpdump \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; ldconfig \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/share/openvswitch/scripts&#x27;</span> | <span class="built_in">tee</span> -a /root/.bashrc \</span></span><br><span class="line"><span class="language-bash">  &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;export DB_SOCK=/usr/local/var/run/openvswitch/db.sock&#x27;</span> | <span class="built_in">tee</span> -a /root/.bashrc</span></span><br></pre></td></tr></table></figure><h3 id="基于-DPDK-的-Dockerfile"><a href="#基于-DPDK-的-Dockerfile" class="headerlink" title="基于 DPDK 的 Dockerfile"></a>基于 DPDK 的 Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span> as build</span><br><span class="line"><span class="keyword">ARG</span> dpdk_version=<span class="number">20.11</span>.<span class="number">5</span></span><br><span class="line"><span class="keyword">ARG</span> ovs_version=<span class="number">2.16</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get -y install build-essential python3-pip liblua5.3-dev \</span></span><br><span class="line"><span class="language-bash">    cmake wget unzip libnuma-dev pciutils libpcap-dev libelf-dev linux-headers-generic \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; pip3 install meson ninja pyelftools</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载编译 DPDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -q https://fast.dpdk.org/rel/dpdk-<span class="variable">$&#123;dpdk_version&#125;</span>.tar.xz \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar xf dpdk-<span class="variable">$&#123;dpdk_version&#125;</span>.tar.xz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> dpdk-stable-<span class="variable">$&#123;dpdk_version&#125;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; meson build \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ninja -C build \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ninja -C build install \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">cp</span> -r build/lib /usr/local/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载编译 OVS</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget https://codeload.github.com/openvswitch/ovs/zip/refs/tags/v<span class="variable">$&#123;ovs_version&#125;</span> -O ovs-<span class="variable">$&#123;ovs_version&#125;</span>.zip \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; unzip ovs-<span class="variable">$&#123;ovs_version&#125;</span>.zip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> ovs-<span class="variable">$&#123;ovs_version&#125;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ./boot.sh \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ./configure --with-dpdk=static CFLAGS=<span class="string">&quot;-Ofast -msse4.2 -mpopcnt&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -j \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make install</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制相关文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /usr/local /usr/local/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get -y --no-install-recommends install liblua5.3 libnuma-dev pciutils \</span></span><br><span class="line"><span class="language-bash">    libpcap-dev python3 iproute2 net-tools iputils-ping vim iperf iftop tcpdump \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ldconfig \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/share/openvswitch/scripts&#x27;</span> | <span class="built_in">tee</span> -a /root/.bashrc \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;export DB_SOCK=/usr/local/var/run/openvswitch/db.sock&#x27;</span> | <span class="built_in">tee</span> -a /root/.bashrc</span></span><br></pre></td></tr></table></figure><h3 id="自定义-OVS-DPDK-的-Dockerfile"><a href="#自定义-OVS-DPDK-的-Dockerfile" class="headerlink" title="自定义 OVS-DPDK 的 Dockerfile"></a>自定义 OVS-DPDK 的 Dockerfile</h3><p>如果对OVS，DPDK有任何修改，需要将源代码拷贝到容器中进行编译，准备一个文件夹，并准备以下文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Dockerfile</span><br><span class="line">dpdk-stable-20.11.5 <span class="comment"># DPDK的源码</span></span><br><span class="line">ovs-2.16.0          <span class="comment"># OVS的源码</span></span><br><span class="line">bin                 <span class="comment"># 其他一些可执行文件</span></span><br></pre></td></tr></table></figure><p><code>Dockerfile</code> 文件中的内容如下：</p><p><em>为了避免重复编译，不要使用<code>COPY . .</code>，并且COPY文件应该分别运行</em></p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span> as build</span><br><span class="line"><span class="keyword">ARG</span> dpdk_version=<span class="number">20.11</span>.<span class="number">5</span></span><br><span class="line"><span class="keyword">ARG</span> ovs_version=<span class="number">2.16</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get -y install build-essential python3-pip liblua5.3-dev \</span></span><br><span class="line"><span class="language-bash">    cmake wget libnuma-dev pciutils libpcap-dev libelf-dev linux-headers-generic \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; pip3 install meson ninja pyelftools</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地文件复制到docker中</span></span><br><span class="line"><span class="comment"># 编译 DPDK，COPY 文件夹时必须指定目的文件夹名！</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> dpdk-stable-<span class="variable">$&#123;dpdk_version&#125;</span> dpdk-stable-<span class="variable">$&#123;dpdk_version&#125;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> dpdk-stable-<span class="variable">$&#123;dpdk_version&#125;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; meson build \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ninja -C build \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ninja -C build install \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">cp</span> -r build/lib /usr/local/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译 OVS</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ovs-<span class="variable">$&#123;ovs_version&#125;</span> ovs-<span class="variable">$&#123;ovs_version&#125;</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> ovs-<span class="variable">$&#123;ovs_version&#125;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; sh boot.sh \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ./configure --with-dpdk=static CFLAGS=<span class="string">&quot;-Ofast -msse4.2 -mpopcnt&quot;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make -j \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; make install</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制编译后的文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /usr/local /usr/local/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get -y --no-install-recommends install liblua5.3 libnuma-dev pciutils \</span></span><br><span class="line"><span class="language-bash">    libpcap-dev python3 iproute2 net-tools iputils-ping vim iperf iftop tcpdump \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ldconfig \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/share/openvswitch/scripts&#x27;</span> | <span class="built_in">tee</span> -a /root/.bashrc \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">echo</span> <span class="string">&#x27;export DB_SOCK=/usr/local/var/run/openvswitch/db.sock&#x27;</span> | <span class="built_in">tee</span> -a /root/.bashrc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制其他可执行文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> bin/* /usr/bin/</span></span><br></pre></td></tr></table></figure><p>若使用 <code>apt-get update</code> 时比较慢，可以在上方更换阿里云源。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get clean</span></span><br></pre></td></tr></table></figure><h3 id="Pktgen-和-testpmd-的-Dockerfile"><a href="#Pktgen-和-testpmd-的-Dockerfile" class="headerlink" title="Pktgen 和 testpmd 的 Dockerfile"></a>Pktgen 和 testpmd 的 Dockerfile</h3><p><code>pktgen</code> 用来生成、发送数据包，<code>testpmd</code> 用来接收数据包，两者都是针对DPDK的。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span> as build</span><br><span class="line"><span class="comment"># 指定使用的DPDK, pktgen 版本</span></span><br><span class="line"><span class="keyword">ARG</span> dpdk_version=<span class="number">20.11</span>.<span class="number">5</span></span><br><span class="line"><span class="keyword">ARG</span> pktgen_version=<span class="number">20.11</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get -y install build-essential python3-pip liblua5.3-dev \</span></span><br><span class="line"><span class="language-bash">    cmake wget libnuma-dev pciutils libpcap-dev libelf-dev linux-headers-generic \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; pip3 install meson ninja pyelftools</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /opt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载编译 DPDK</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -q https://fast.dpdk.org/rel/dpdk-<span class="variable">$&#123;dpdk_version&#125;</span>.tar.xz \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar xf dpdk-<span class="variable">$&#123;dpdk_version&#125;</span>.tar.xz</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> dpdk-stable-<span class="variable">$&#123;dpdk_version&#125;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; meson build \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ninja -C build \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ninja -C build install \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">cp</span> -r build/lib /usr/local/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># patch to make pktgen compile on arm. Got tip from</span></span><br><span class="line"><span class="comment"># https://medium.com/codex/nvidia-mellanox-bluefield-2-smartnic-dpdk-rig-for-dive-part-ii-change-mode-of-operation-a994f0f0e543</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/#  error Platform.*//&#x27;</span> /usr/local/include/rte_spinlock.h</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/#  error Platform.*//&#x27;</span> /usr/local/include/rte_atomic_32.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># downlaod and unpack pktgen</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> wget -q https://git.dpdk.org/apps/pktgen-dpdk/snapshot/pktgen-dpdk-pktgen-<span class="variable">$&#123;pktgen_version&#125;</span>.tar.gz \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tar xf pktgen-dpdk-pktgen-<span class="variable">$&#123;pktgen_version&#125;</span>.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># building pktgen</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> pktgen-dpdk-pktgen-<span class="variable">$&#123;pktgen_version&#125;</span> \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tools/pktgen-build.sh clean \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; tools/pktgen-build.sh buildlua \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">cp</span> -r usr/local /usr/ \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">mkdir</span> -p /usr/local/share/lua/5.3/ \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; <span class="built_in">cp</span> Pktgen.lua /usr/local/share/lua/5.3/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#####################################################</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> --from=build /usr/local /usr/local/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /root</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; apt-get -y --no-install-recommends install liblua5.3 libnuma-dev pciutils libpcap-dev python3 iproute2 \</span></span><br><span class="line"><span class="language-bash">    &amp;&amp; ldconfig</span></span><br></pre></td></tr></table></figure><p>生成镜像：<code>docker build -t pktgen:20.11.3 .</code></p><h2 id="OVS-启动及配置"><a href="#OVS-启动及配置" class="headerlink" title="OVS 启动及配置"></a>OVS 启动及配置</h2><p>基于内核的数据通路时，OVS启动需要配置的内容不多！但基于OVS-DPDK的数据通路，涉及到的参数设置比较麻烦！</p><h3 id="基于内核数据通路"><a href="#基于内核数据通路" class="headerlink" title="基于内核数据通路"></a>基于内核数据通路</h3><p>以默认参数启动可直接使用<code>ovs-ctl</code>命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-ctl start</span><br></pre></td></tr></table></figure><h3 id="基于-DPDK-的数据通路"><a href="#基于-DPDK-的数据通路" class="headerlink" title="基于 DPDK 的数据通路"></a>基于 DPDK 的数据通路</h3><p>DPDK的数据通路需要一些额外的配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除旧的配置信息</span></span><br><span class="line"><span class="built_in">rm</span> /usr/local/etc/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/run/openvswitch/*</span><br><span class="line"><span class="built_in">rm</span> /usr/local/var/log/openvswitch/*</span><br><span class="line"></span><br><span class="line"><span class="comment">## 0. 设置hugepages</span></span><br><span class="line">dpdk-hugepages.py -p 1G --setup 4G</span><br><span class="line"></span><br><span class="line"><span class="comment">## 1. 启动ovsdb，先不启动ovs-vswitchd</span></span><br><span class="line">ovs-ctl --no-ovs-vswitchd start --system-id=random</span><br><span class="line"></span><br><span class="line"><span class="comment">## 2. 配置使用DPDK，可以配置从任何给定 NUMA 节点使用的内存量</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x02</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 3. 启动 ovs-vswitchd （启动完成）</span></span><br><span class="line">ovs-ctl --no-ovsdb-server --db-sock=<span class="string">&quot;<span class="variable">$DB_SOCK</span>&quot;</span> start</span><br></pre></td></tr></table></figure><p>以上面的方式启动时，无法指定相关文件的路径，下面是最原始的启动流程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数据库文件</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/etc/openvswitch</span><br><span class="line">ovsdb-tool create /usr/local/etc/openvswitch/conf.db \</span><br><span class="line">    /usr/local/share/openvswitch/vswitch.ovsschema</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动数据库</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/var/run/openvswitch</span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/var/log/openvswitch</span><br><span class="line">ovsdb-server --remote=punix:/usr/local/var/run/openvswitch/db.sock \</span><br><span class="line">    --remote=db:Open_vSwitch,Open_vSwitch,manager_options \</span><br><span class="line">    --private-key=db:Open_vSwitch,SSL,private_key \</span><br><span class="line">    --certificate=db:Open_vSwitch,SSL,certificate \</span><br><span class="line">    --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \</span><br><span class="line">    --pidfile --detach --log-file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库</span></span><br><span class="line">ovs-vsctl --no-wait init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置使用DPDK, pmd-cpu-mask 要用16进制</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:pmd-cpu-mask=0x6</span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="string">&quot;1024&quot;</span></span><br><span class="line">ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 Open vSwitch 守护进程</span></span><br><span class="line">ovs-vswitchd --pidfile --detach --log-file=/root/logfile/ovs-vswitchd.log</span><br></pre></td></tr></table></figure><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://docs.openvswitch.org/en/latest/faq/releases/">linux内核与ovs版本匹配关系、ovs版本与DPDK版本匹配关系</a></li><li><a href="https://blog.csdn.net/u010710985/article/details/119980125">安装内核模块时报错的解决办法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenVSwitch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenVSwitch </tag>
            
            <tag> DPDK </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程-socket</title>
      <link href="/2022/05/08/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/"/>
      <url>/2022/05/08/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/</url>
      
        <content type="html"><![CDATA[<h2 id="socket-套接字"><a href="#socket-套接字" class="headerlink" title="socket 套接字"></a>socket 套接字</h2><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/image-20220508224718687.png" alt="image-20220508224718687"></p><p>图中两个虚线框表示两个套接字，在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。</p><p>一个socket只有一个文件描述符，即发送缓冲区和接收缓冲区使用同一个文件描述符。</p><p>网络套接字本质：一个文件描述符指向一个套接字（该套接字内部由内核借助两个缓冲区实现）。</p><h2 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h2><h3 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h3><p>由于历史遗留问题，网络数据流采用大端字节序，而 pc 本地一般采用的小段字节序，所以在网络通信中，需要转换字节序。</p><ul><li>小端法：（pc本地存储）高位存高地址，地位存低地址。</li><li>大端法：（网络存储）高位存低地址，地位存高地址。</li></ul><p>字节序只影响不同字节间的顺序，如果只看单字节内部，大小端都一样。<strong>不存在<code>00001111</code>变为<code>11110000</code>！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// h: host, to, n: network, l: long, s: short</span></span><br><span class="line"><span class="comment">// hton也就是主机到网络的转换，ntoh是网络到主机的转换</span></span><br><span class="line"><span class="comment">// l, s 对应 32位和 16位数据，也就是 ipv4 地址 和 端口号</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span>;</span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span>;</span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example1:</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">01</span>;</span><br><span class="line">htonl(a) = <span class="number">0x01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>;</span><br><span class="line"><span class="comment">// example2:</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">0xff</span> f0 <span class="number">00</span> <span class="number">00</span>;</span><br><span class="line">htonl(b) = <span class="number">0x00</span> <span class="number">00</span> f0 ff;</span><br></pre></td></tr></table></figure><h3 id="inet-pton-函数"><a href="#inet-pton-函数" class="headerlink" title="inet_pton 函数"></a>inet_pton 函数</h3><p>将一个点分十进制的 <code>IP</code> 地址（字符串）转换为一个32位的整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">char</span> *ip = <span class="string">&quot;192.168.1.1&quot;</span>;</span><br><span class="line"><span class="type">int</span> ip_int = <span class="number">0</span>;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;ip_int);</span><br></pre></td></tr></table></figure><ul><li>af：地址族，可以是<code>AF_INET(ipv4)</code>、<code>AF_INET6(ipv6)</code></li><li>src：要转换的 <code>IP</code> 地址，如：<code>&quot;192.168.1.1&quot;</code></li><li>dst：转换后的网络字节序的 <code>IP</code> 地址，整数，如：<code>&amp;ipv4_addr</code></li><li>返回值：<ul><li>1，成功</li><li>0，异常，说明 <code>src</code> 不是一个合法的ip地址</li><li>-1，<code>af</code> 不是一个合法的地址族</li></ul></li></ul><h3 id="inet-ntop-函数"><a href="#inet-ntop-函数" class="headerlink" title="inet_ntop 函数"></a>inet_ntop 函数</h3><p>将一个网络字节序的IP地址转换为一个点分十进制的IP地址（字符串）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src,</span></span><br><span class="line"><span class="params">                        <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="type">char</span> ipv4_str[<span class="number">16</span>];</span><br><span class="line">inet_ntop(AF_INET, &amp;client_addr.sin_addr.s_addr, ipv4_str, <span class="keyword">sizeof</span>(ipv4_str));</span><br></pre></td></tr></table></figure><ul><li>af：地址族，可以是<code>AF_INET(ipv4)</code>、<code>AF_INET6(ipv6)</code></li><li>scr：网络字节序的IP地址</li><li>dst：转换后的点分十进制的IP地址，缓冲区，<code>char buf[16]</code></li><li>size：dst 的大小</li><li>返回值：成功返回 dst, 失败返回 NULL</li></ul><h3 id="inet-addr-函数"><a href="#inet-addr-函数" class="headerlink" title="inet_addr 函数"></a>inet_addr 函数</h3><p>将一个点分十进制的IP地址（字符串）转换为一个32位的整数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">in_addr_t</span> <span class="title function_">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span>;</span><br></pre></td></tr></table></figure><ul><li>cp：要转换的IP地址，如：<code>192.168.10.1</code></li><li>返回值：成功返回网络字节序的IP地址，失败返回 <code>INADDR_NONE(-1, 0xffffffff)</code></li></ul><p>使用这个函数可能会出现问题，因为 <code>INADDR_NONE</code> 也是一个有效的IP地址<code>255.255.255.255</code>！</p><h3 id="sockaddr-结构"><a href="#sockaddr-结构" class="headerlink" title="sockaddr 结构"></a>sockaddr 结构</h3><p>同样是历史遗留问题，socket 相关的函数大多都是使用 <code>struct sockaddr</code> 结构，但现在使用的往往是 <code>struct sockaddr_in</code>，因此在传递参数时，要进行强制类型转换。</p><p>可在 <code>man 7 ip</code> 中查看相关说明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span>        sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="type">in_port_t</span>      sin_port;   <span class="comment">/* 16位 网络字节序的端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span>       s_addr;     <span class="comment">/* 网络字节序的 IP地址 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET;</span><br><span class="line">addr.sin_port = htons(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 ip 地址，方法一</span></span><br><span class="line"><span class="type">int</span> ipv4_addr;</span><br><span class="line">inet_pton(AF_INET, <span class="string">&quot;192.168.1.1&quot;</span>, (<span class="type">void</span>*)&amp;ipv4_addr);</span><br><span class="line">addr.sin_addr.s_addr = ipv4_addr;</span><br><span class="line"><span class="comment">// 指定 ip 地址，方法二</span></span><br><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY); <span class="comment">// 表示取出系统中任意有效的IP 地址（二进制类型）</span></span><br></pre></td></tr></table></figure><h2 id="socket-创建流程"><a href="#socket-创建流程" class="headerlink" title="socket 创建流程"></a>socket 创建流程</h2><p><img src="/../images/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/image-20220509201419178.png" alt="image-20220509201419178"></p><p><strong>服务器端</strong>：</p><ol><li><code>socket()</code> 创建一个 socket（socket1）</li><li><code>bind()</code> 绑定 IP + port（设置 socket1）</li><li><code>listen()</code> 设置<strong>同时</strong>监听上限（socket1用于监听）</li><li><code>accept()</code> 阻塞监听客户端连接（传入socket1以建立连接，创建socket2用于通信）</li><li><code>read()/write()</code> 文件处理的系统调用函数，这里就直接像访问正常文件一样访问socket2</li></ol><p><strong>客户端</strong>：</p><ol><li><code>socket()</code> 创建一个 socket（socket3）</li><li><code>connect()</code> 指定服务器的地址结构（IP+port）连接服务器（设置socket3）</li><li><code>read()/write()</code></li></ol><p>注意，在上图的流程中，最终会有3个 socket 结构，服务器端的 socket1 仅用于监听，并不负责实际的与客户端通信，<code>accept()</code> 函数阻塞等待客户端连接，当有客户端连接时，<code>accept()</code> 函数中会新建一个 socket2 与客户端 socket3 绑定，实现客户端与服务器端的通信。</p><h3 id="socket-函数"><a href="#socket-函数" class="headerlink" title="socket 函数"></a>socket 函数</h3><p>创建一个套接字，并返回一个套接字描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);   <span class="comment">// TCP</span></span><br><span class="line"><span class="type">int</span> sockfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);    <span class="comment">// UDP</span></span><br></pre></td></tr></table></figure><ul><li>domain：地址族，常用三个为 <code>AF_INET(ipv4)</code>、<code>AF_INET6(ipv6)</code>、<code>AF_UNIX(本地套接字)</code></li><li>type：套接字类型，常用两个为 <code>SOCK_STREAM(TCP)</code>、<code>SOCK_DGRAM(UDP)</code></li><li>protocol：协议，一般设置为 0</li><li>返回值：成功返回套接字描述符，失败返回 -1，并设置 errno</li></ul><h3 id="bind-函数"><a href="#bind-函数" class="headerlink" title="bind 函数"></a>bind 函数</h3><p>给 socket 绑定一个地址结构（<code>IP + port</code>）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bind</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params">        <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">addr.sin_family = AF_INET; <span class="comment">// 类型要与 socket 创建时的 domain 一致</span></span><br><span class="line">addr.sin_port = htons(<span class="number">80</span>);</span><br><span class="line">addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">bind(socket1, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br></pre></td></tr></table></figure><ul><li>sockfd：套接字文件描述符</li><li>addr：地址结构（传入参数）</li><li>addrlen：地址结构的大小 <code>sizeof(addr)</code></li><li>返回值：成功返回 0，失败返回 -1，并设置 errno</li></ul><h3 id="listen-函数"><a href="#listen-函数" class="headerlink" title="listen 函数"></a>listen 函数</h3><p>设置<strong>同时</strong>与服务器建立连接上限数（同时进行TCP三次握手的客户端数量）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line">listen(sockfd, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><ul><li>sockfd：套接字文件描述符</li><li>backlog：上限数量，最大值为 <code>128</code>！</li><li>返回值：成功返回 0，失败返回 -1，并设置 errno</li></ul><h3 id="accept-函数"><a href="#accept-函数" class="headerlink" title="accept 函数"></a>accept 函数</h3><p>阻塞等待客户端连接，当有客户端连接时，会新建一个 socket2 与客户端 socket3 绑定，实现客户端与服务器端的通信，返回新建的 socket2 的文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">accept</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> sockaddr *addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line"><span class="type">socklen_t</span> client_addrlen = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line"><span class="type">int</span> sockfd2;</span><br><span class="line">again:</span><br><span class="line">    sockfd2 = accept(sockfd1, (<span class="keyword">struct</span> sockaddr *)&amp;client_addr, &amp;client_addrlen);</span><br><span class="line">    <span class="keyword">if</span> (sockfd2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR || errno == ECONNABORTED)</span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            perror(<span class="string">&quot;accept error&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>sockfd：传入的套接字，上面绑定了地址的 socket1</li><li>addr：传出参数，返回成功建立连接的<strong>客户端</strong>的地址结构</li><li>addrlen：传入传出参数，传入为参2 addr 的大小，传出为客户端的 addr 的实际大小</li><li>返回值：成功返回新建的 socket2 文件描述符，失败返回 -1，并设置 errno：<ul><li>EINTR：被信号中断</li><li>ECONNABORTED：连接被拒绝</li></ul></li></ul><h3 id="connect-函数"><a href="#connect-函数" class="headerlink" title="connect 函数"></a>connect 函数</h3><p>客户端连接到服务器！</p><p>客户端 socket 可以不需要手动 bind，系统会自动绑定本地的地址结构！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">connect</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> sockaddr *addr,</span></span><br><span class="line"><span class="params">            <span class="type">socklen_t</span> addrlen)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htons(<span class="number">80</span>);</span><br><span class="line">server_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;192.168.1.1&quot;</span>);</span><br><span class="line">connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr));</span><br></pre></td></tr></table></figure><ul><li>sockfd：套接字文件描述符</li><li>addr：服务器的地址结构</li><li>addrlen：地址结构的大小 <code>sizeof(addr)</code></li><li>返回值：成功返囟 0，失败返囟 -1，并设置 errno</li></ul><h3 id="TCP-example"><a href="#TCP-example" class="headerlink" title="TCP example"></a>TCP example</h3><p>简单的 TCP 收发测试！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 10001</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 socket</span></span><br><span class="line">    <span class="type">int</span> socketfd1 = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定地址(ip, port)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="type">int</span> res = bind(socketfd1, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr,</span><br><span class="line">                    <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 设置监听上限</span></span><br><span class="line">    res = listen(socketfd1, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 阻塞等待连接</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="type">socklen_t</span> len = <span class="keyword">sizeof</span>(client_addr);</span><br><span class="line">    <span class="type">int</span> socketfd2 = accept(socketfd1, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. read 读取数据</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1500</span>];</span><br><span class="line"></span><br><span class="line">    read(socketfd2, buf, <span class="number">1500</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv data: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *data = <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">    write(socketfd2, data, <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    close(socketfd1);</span><br><span class="line">    close(socketfd2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_PORT 10001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SERVER_IP <span class="string">&quot;192.168.0.8&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 socket</span></span><br><span class="line">    <span class="type">int</span> socketfd3 = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 连接到服务器</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_addr</span>;</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons(SERVER_PORT);</span><br><span class="line">    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);</span><br><span class="line">    <span class="type">int</span> res = connect(socketfd3, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr,</span><br><span class="line">                      <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. write 写数据</span></span><br><span class="line">    <span class="type">char</span> *data = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line">    write(socketfd3, data, <span class="built_in">strlen</span>(data));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1500</span>];</span><br><span class="line">    read(socketfd3, buf, <span class="number">1500</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv data: %s\n&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">    close(socketfd3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nc</code> 命令也可以用来做客户端测试！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 192.168.0.8 10001</span><br></pre></td></tr></table></figure><h2 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a>read 函数</h2><p>从指定的文件描述符上最多读取 <code>count</code> 个字节存放到缓冲区 <code>buf</code> 中，返回实际读取的字节数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p>在网络编程中，read 函数的返回值需要仔细区分：</p><ol><li><code>&gt;0</code> 实际读到的字节数；</li><li><code>=0</code> 已经读到结尾，说明<strong>对端socket已关闭</strong>（重点！！）；</li><li><code>-1</code> 应该进下一步判断 <code>errno</code> 的值：<ul><li><code>EAGAIN/ENOULDBLOCK</code> 设置了非阻塞方式读，没有数据到达</li><li><code>EINTR</code> 慢速系统调用被 中断</li><li>其他情况，异常</li></ul></li></ol><h2 id="write-函数"><a href="#write-函数" class="headerlink" title="write 函数"></a>write 函数</h2><p>将缓冲区 <code>buf</code> 中的 <code>count</code> 个字节数据写入到 <code>fd</code> 对应的文件中，返回实际写入的字节数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><h2 id="recv-x2F-recvfrom-函数"><a href="#recv-x2F-recvfrom-函数" class="headerlink" title="recv&#x2F;recvfrom 函数"></a>recv&#x2F;recvfrom 函数</h2><p>从指定的 <code>sockfd</code> 上接收（读取）数据写入到缓冲区 <code>buf</code>中，<code>buf</code>的长度是<code>len</code>，返回实际接收的字节数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recv</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">                 <span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span>;</span><br></pre></td></tr></table></figure><p><code>flags</code> 参数可以用来指定该函数的特殊行为。常用的 <code>flags</code> 参数值有：</p><ul><li><code>0</code>：不设置标志。</li><li><code>MSG_PEEK</code>：该标志会导致 <code>recv</code> 函数返回套接字中的数据，但不会从缓冲区中删除数据。下一次调用 <code>recv</code> 函数会再次返回相同的数据。这个标志对检查接收到的数据而不消耗它很有用。</li><li><code>MSG_WAITALL</code>：该标志导致 <code>recv</code> 函数阻塞，直到接收到请求的字节数或连接关闭。如果在接收到请求的字节数之前连接关闭，<code>recv</code> 函数会返回已接收的字节数。</li><li><code>MSG_OOB</code>：该标志导致 <code>recv</code> 函数返回带外数据，如果有可用的带外数据。带外数据是单独从正常数据流发送的数据，通常用于紧急数据。</li><li><code>MSG_DONTWAIT</code>：该标志等同于 <code>O_NONBLOCK</code> 文件状态标志。当设置该标志时，<code>recv</code> 函数不会阻塞，如果没有数据可用，则返回 <code>-1</code> 并带有错误代码 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code>。</li></ul><p>这些标志可以使用位运算符 <code>|</code> 组合，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = recv(sockfd, buffer, <span class="number">1024</span>, MSG_PEEK | MSG_WAITALL);</span><br></pre></td></tr></table></figure><h2 id="send-x2F-sendto-函数"><a href="#send-x2F-sendto-函数" class="headerlink" title="send&#x2F;sendto 函数"></a>send&#x2F;sendto 函数</h2><p>将缓冲区<code>buf</code>中的<code>len</code>个字节的数据发送到对应的<code>sockfd</code>，返回实际发送的字节数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">send</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span>;</span><br></pre></td></tr></table></figure><blockquote><p><code>send()</code> &#x2F; <code>write()</code> 的一点区别：</p><p>首先，这两者都是系统调用，都是用来向文件描述符（包括<code>Socket</code>文件描述符）写入数据的。区别在于，<code>send()</code> 系统调用可以指定一些可选的参数，例如<code>flags</code>参数用来指定发送数据的方式，如非阻塞方式和带外方式等。<code>send()</code>函数比<code>write()</code>函数更加灵活，因此在网络编程中更常用。</p></blockquote><h2 id="get-x2F-setsockopt-函数"><a href="#get-x2F-setsockopt-函数" class="headerlink" title="get&#x2F;setsockopt 函数"></a>get&#x2F;setsockopt 函数</h2><p>用于设置套接字的一些特殊选项！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span>          <span class="comment">/* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">               <span class="type">void</span> *optval, <span class="type">socklen_t</span> *optlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setsockopt</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> level, <span class="type">int</span> optname,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="type">void</span> *optval, <span class="type">socklen_t</span> optlen)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>socket</code>：表示需要设置选项的套接字的描述符。</li><li><code>level</code>：表示选项的协议层，通常是 <code>SOL_SOCKET</code>，表示套接字选项。</li><li><code>optname</code>：表示选项的名称，根据不同的协议层，选项可能不同。</li><li><code>optval</code>：指向包含选项值的缓冲区的指针。</li><li><code>optlen</code>：缓冲区的大小。</li></ul><h3 id="SO-SNDBUF-x2F-SO-RCVBUF"><a href="#SO-SNDBUF-x2F-SO-RCVBUF" class="headerlink" title="SO_SNDBUF&#x2F;SO_RCVBUF"></a>SO_SNDBUF&#x2F;SO_RCVBUF</h3><p><code>SO_SNDBUF</code> 选项控制发送缓冲区的大小，即从应用程序发送到套接字的数据在内核中的缓冲区大小。如果应用程序发送的数据量大于该缓冲区大小，则必须等待先前发送的数据完成发送才能继续发送数据。</p><p><code>SO_RCVBUF</code> 选项控制接收缓冲区的大小，即从网络接收到的数据在内核中的缓冲区大小。如果从网络接收的数据量大于该缓冲区大小，则新接收到的数据可能会覆盖先前未读取的数据。</p><p>通过使用 <code>setsockopt</code> 函数，可以修改发送缓冲区和接收缓冲区的大小，以适应应用程序的数据传输需求。但是，修改缓冲区大小并不能保证性能提升，因为实际情况可能受到许多因素的影响。</p><h3 id="SO-LINGER"><a href="#SO-LINGER" class="headerlink" title="SO_LINGER"></a>SO_LINGER</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> l_onoff;        <span class="comment">/* Nonzero to linger on close.  */</span></span><br><span class="line">    <span class="type">int</span> l_linger;       <span class="comment">/* Time to linger.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>SO_LINGER</code> 选项是一个套接字选项，用于控制在关闭套接字时是否等待正在发送的数据的完成。</p><p>当关闭套接字时，如果有数据正在发送，那么通常有两种处理方式：</p><ul><li>如果未启用 <code>SO_LINGER</code> 选项，那么套接字会立即关闭，未发送完的数据会被丢弃。</li><li>如果启用了 <code>SO_LINGER</code> 选项，则套接字将等待所有正在发送的数据完成，直到指定的时间到达为止。</li></ul><p>具体的，可以使用 <code>setsockopt</code> 函数启用 <code>SO_LINGER</code> 选项，并使用一个结构体来指定等待的时间，该结构体由两个成员：</p><ul><li><code>l_onoff</code>：用于控制是否启用 <code>SO_LINGER</code> 选项。</li><li><code>l_linger</code>：表示等待时间，单位为秒。</li></ul><p>如果 <code>l_onoff</code> 设置为非零值，则启用 <code>SO_LINGER</code> 选项，并使用 <code>l_linger</code> 指定的等待时间。如果 <code>l_onoff</code> 设置为零，则禁用 <code>SO_LINGER</code> 选项，关闭套接字时不等待数据的完成。</p><h3 id="SO-KEEPALIVE"><a href="#SO-KEEPALIVE" class="headerlink" title="SO_KEEPALIVE"></a>SO_KEEPALIVE</h3><p><code>SO_KEEPALIVE</code> 选项用于控制是否启用 TCP 连接的 keep-alive 检测机制。当启用该选项时，如果两端在一段时间内没有数据交互，TCP 协议会发送 keep-alive 数据包来检测对端是否仍然可用。如果多次尝试后对端仍然无法响应，则可以断开该连接。</p><p>这个选项可以用于防止长时间空闲的连接被网络中断，从而导致不必要的等待和重试。在某些情况下，它也可以用于检测对端的不存在或故障。</p><h3 id="SO-REUSEADDR"><a href="#SO-REUSEADDR" class="headerlink" title="SO_REUSEADDR"></a>SO_REUSEADDR</h3><p><code>SO_REUSEADDR</code> 选项用于控制在同一个主机上是否允许多个套接字绑定到同一端口。</p><p>在默认情况下，如果一个套接字已经绑定到某个端口，那么其他套接字将不能再绑定到该端口。这种限制有助于防止在同一端口上的竞争冲突。</p><p>但是，有时需要多个套接字共享同一端口，例如当同一主机上有多个服务器程序运行时。在这种情况下，可以使用 <code>SO_REUSEADDR</code> 选项来允许多个套接字绑定到同一端口。</p><h3 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a>SO_REUSEPORT</h3><p><code>SO_REUSEPORT</code> 选项是一种扩展的套接字选项，主要用于允许多个套接字绑定到同一端口，从而共享同一个端口。这个选项与 <code>SO_REUSEADDR</code> 选项类似，但是提供了更多的灵活性和更高的性能。</p><p>在默认情况下，如果一个套接字已经绑定到某个端口，那么其他套接字将不能再绑定到该端口。但是，如果多个套接字都启用了 <code>SO_REUSEPORT</code> 选项，那么多个套接字就可以同时绑定到同一端口。</p><p>这个选项对于提高网络服务的性能和可靠性非常重要，因为它可以允许多个进程或线程共享同一端口，从而利用多核处理器的优势。</p><p>使用 <code>setsockopt</code> 函数，可以在套接字创建后启用或禁用 <code>SO_REUSEPORT</code> 选项。请注意，<code>SO_REUSEPORT</code> 选项可能只在某些操作系统上可用，并且可能需要在编译套接字应用程序时启用特定的宏定义才能使用该选项。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.bilibili.com/video/BV1iJ411S7UA?p=18&spm_id_from=pageDriver">listen 和 accpet 函数说明</a></li><li><a href="https://xiaolincoding.com/network/3_tcp/tcp_interview.html">TCP 三次握手与四次挥手</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-同步与锁</title>
      <link href="/2022/05/06/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%94%81/"/>
      <url>/2022/05/06/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。<strong>主旨在协同步调，按预定的先后次序运行</strong></p><p>线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。</p><p>线程同步可以通过锁来实现！与锁相关的部分函数的<code>man page</code>需要单独安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install manpages-posix-dev</span><br></pre></td></tr></table></figure><h2 id="mutex-互斥量（互斥锁）"><a href="#mutex-互斥量（互斥锁）" class="headerlink" title="mutex 互斥量（互斥锁）"></a>mutex 互斥量（互斥锁）</h2><p>每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。</p><p>资源还是共享的，线程间也还是<strong>竞争</strong>的，但通过“锁”就将资源的访问变成互斥操作。</p><p>互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。因此，即使有了 mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。</p><p><strong>尽量保证锁的粒度，越小越好（访问共享数据前，加锁。访问结束立即解锁）</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="type">pthead_mutex_t</span> muetx = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">// 下面几个函数都是 成功返回 0， 失败返回错误号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="comment">// 销毁锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 加锁，若当前锁已被其它线程加锁，则阻塞，直到被其它线程解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// trylock 尝试加锁，成功返回0，失败返回 EBUSY，不会阻塞</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_trylock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br></pre></td></tr></table></figure><h3 id="pthread-mutex-init-函数"><a href="#pthread-mutex-init-函数" class="headerlink" title="pthread_mutex_init 函数"></a>pthread_mutex_init 函数</h3><p>初始化互斥锁。</p><p>如果互斥锁 mutex 是静态分配的（定义在全局，或加了 static 关键字修饰），可以直接使用宏进行初始化。</p><p><code>pthead_mutex_t muetx = PTHREAD_MUTEX_INITIALIZER;</code></p><p>局部变量应采用动态初始化，即使用 <code>pthread_mutex_init(&amp;mutex, NULL);</code> 初始化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br></pre></td></tr></table></figure><ul><li><p>mutex：互斥锁的地址</p></li><li><p>attr：互斥锁的属性，如果为 NULL，则使用默认属性（线程间共享）</p></li><li><p>返回值：0（成功），非 0（失败）</p></li><li><p>restrict：限定该指针不能拷贝到其他指针，<code>*restrict p = &amp;a, *p2 = *p</code>会报错。</p></li></ul><blockquote><p>pthread_mutexattr_t 的选项包括：</p><ol><li>PTHREAD_MUTEX_NORMAL：普通锁。普通锁不允许递归调用，如果线程试图对已经拥有的锁再次加锁，它将阻塞。</li><li>PTHREAD_MUTEX_RECURSIVE：递归锁。递归锁允许线程多次加锁，每次必须解锁一次。</li><li>PTHREAD_MUTEX_ERRORCHECK：检查锁。检查锁与普通锁相似，但它还允许线程检查是否当前已经拥有该锁。</li><li>PTHREAD_MUTEX_DEFAULT：默认锁类型。默认锁类型是普通锁。</li></ol><p>用户可以根据需要使用不同类型的互斥量，例如递归锁用于处理递归函数，检查锁用于检测错误，而普通锁是一般的互斥量。</p></blockquote><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ol><li>线程试图对同一个互斥量 A 加锁两次。</li><li>线程 1 拥有 A 锁，请求获得 B 锁；线程 2 拥有 B 锁，请求获得 A 锁。</li></ol><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><p>测试1：在不加锁的情况下，下面的<code>i++</code>和<code>printf</code>之间可能被另一个线程打断，导致输出的<code>i</code>的大小不连续！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread_func: %d \n&quot;</span>, i);</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main_func: %d \n&quot;</span>, i);</span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// thread_func: 17982</span></span><br><span class="line"><span class="comment">// main_func: 17982</span></span><br><span class="line"><span class="comment">// thread_func: 17984</span></span><br><span class="line"><span class="comment">// main_func: 17984</span></span><br><span class="line"><span class="comment">// thread_func: 17986</span></span><br><span class="line"><span class="comment">// main_func: 17986</span></span><br><span class="line"><span class="comment">// thread_func: 17988</span></span><br><span class="line"><span class="comment">// main_func: 17988</span></span><br><span class="line"><span class="comment">// thread_func: 17990</span></span><br><span class="line"><span class="comment">// main_func: 17990</span></span><br><span class="line"><span class="comment">// thread_func: 17992</span></span><br><span class="line"><span class="comment">// main_func: 17992</span></span><br><span class="line"><span class="comment">// thread_func: 17994</span></span><br></pre></td></tr></table></figure><p>加锁保证数据不被另一个线程修改！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">pthread_mutex_t</span> mutex_i = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *args)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex_i);  <span class="comment">// 上锁</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread_func: %d \n&quot;</span>, i);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_i);  <span class="comment">// 解锁</span></span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex_i);  <span class="comment">// 上锁</span></span><br><span class="line">        i++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;main_func: %d \n&quot;</span>, i);</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex_i);  <span class="comment">// 解锁</span></span><br><span class="line">        usleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// main_func: 19946</span></span><br><span class="line"><span class="comment">// thread_func: 19947</span></span><br><span class="line"><span class="comment">// main_func: 19948</span></span><br><span class="line"><span class="comment">// thread_func: 19949</span></span><br><span class="line"><span class="comment">// main_func: 19950</span></span><br><span class="line"><span class="comment">// thread_func: 19951</span></span><br><span class="line"><span class="comment">// main_func: 19952</span></span><br><span class="line"><span class="comment">// thread_func: 19953</span></span><br><span class="line"><span class="comment">// main_func: 19954</span></span><br><span class="line"><span class="comment">// thread_func: 19955</span></span><br><span class="line"><span class="comment">// main_func: 19956</span></span><br></pre></td></tr></table></figure><h2 id="rwlock-读写锁"><a href="#rwlock-读写锁" class="headerlink" title="rwlock 读写锁"></a>rwlock 读写锁</h2><ul><li>读共享，写独占。</li><li>写锁优先级高于读锁（读锁写锁同时来，优先处理写锁。读锁加锁成功后，写锁也必须等待读锁释放）。</li><li>锁还是只有一把，但分<strong>以读模式加锁</strong>和<strong>以写模式加锁</strong>两种。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="type">pthread_rwlock_t</span> rwlock = PTHREAD_RWLOCK_INITIALIZER;</span><br><span class="line"><span class="comment">// 初始化读写锁</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_init</span><span class="params">(<span class="type">pthread_rwlock_t</span> *<span class="keyword">restrict</span> rwlock,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">pthread_rwlockattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_destroy</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="comment">// 加读锁，</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_wrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_rdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_trywrlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_tryrdlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_rwlock_unlock</span><span class="params">(<span class="type">pthread_rwlock_t</span> *rwlock)</span>;</span><br></pre></td></tr></table></figure><h2 id="cond-条件变量"><a href="#cond-条件变量" class="headerlink" title="cond 条件变量"></a>cond 条件变量</h2><p>条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line"><span class="type">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="comment">// 初始化条件变量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_init</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="type">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_destroy</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞等待条件变量满足</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">        <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br><span class="line"><span class="comment">// 阻塞等待条件变量满足，最长等待到 abstime 时刻</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">        <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br><span class="line"><span class="comment">// 唤醒（至少）一个阻塞在该条件变量上的线程，一般就理解为唤醒一个线程。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br><span class="line"><span class="comment">// 唤醒所有阻塞在该条件变量上的线程</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_broadcast</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;</span><br></pre></td></tr></table></figure><h3 id="pthread-cond-wait-函数"><a href="#pthread-cond-wait-函数" class="headerlink" title="pthread_cond_wait 函数"></a>pthread_cond_wait 函数</h3><p>阻塞等待一个条件变量！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">        <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span>;</span><br></pre></td></tr></table></figure><ul><li>cond：条件变量的地址</li><li>mutex：互斥锁的地址</li><li>返回值：0（成功），非 0（失败）</li></ul><p>函数作用：</p><ol><li>阻塞等待条件变量 <code>cond</code> 满足</li><li>释放已掌握的互斥锁（解锁互斥量）相当于 <code>pthread_mutex_unlock(&amp;mutex)</code>; <strong>1.2.两步为一个原子操作</strong>。</li><li>当被唤醒，<code>pthread_cond_wait</code> 函数返回时，<strong>解除阻塞并重新申请获取互斥锁</strong> <code>pthread_mutex_lock(&amp;mutex)</code>;</li></ol><p><strong>注意：<code>pthread_cond_broadcast</code>会唤醒所有阻塞在该条件变量上的线程，但并不意味这所有线程会同时收到<code>pthread_cond_wait</code>函数返回，因为该函数返回前还有获取互斥锁这一步，任意一个线程获取锁后，其他线程都会阻塞等待！所以，实际上线程的唤醒任然有先后顺序！</strong></p><p>此函数的原理不太好理解，建议看视频介绍<a href="https://www.bilibili.com/video/BV1KE411q7ee?p=176&t=290.8">条件变量原理</a>！</p><h3 id="pthread-cond-timedwait-函数"><a href="#pthread-cond-timedwait-函数" class="headerlink" title="pthread_cond_timedwait 函数"></a>pthread_cond_timedwait 函数</h3><p>阻塞等待一个条件变量，最长等待到 abstime 时刻。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_timedwait</span><span class="params">(<span class="type">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span><br><span class="line"><span class="params">        <span class="type">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span><br><span class="line"><span class="params">        <span class="type">const</span> <span class="keyword">struct</span> timespec *<span class="keyword">restrict</span> abstime)</span>;</span><br></pre></td></tr></table></figure><ul><li>cond：条件变量的地址</li><li>mutex：互斥锁的地址</li><li>abstime：等待的时间，绝对时间（即从1970年1月1日零时起的纳秒数）</li><li>返回值：0（成功），非 0（失败）</li></ul><h3 id="生产者消费者实现"><a href="#生产者消费者实现" class="headerlink" title="生产者消费者实现"></a>生产者消费者实现</h3><p>条件变量和互斥量是对产品列表加锁，无论是生产者还是消费者，想要生产或消费产品，都需要先获得锁，才能对产品列表进行操作！</p><p>这里用到的核心函数就是[pthread_cond_wait](#pthread_cond_wait 函数)，只要理解该函数的逻辑，就容易理解下面的模型！</p><p>此处实现的产品是后生产的产品先被消费（栈）！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">product</span>;</span></span><br><span class="line"><span class="type">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;lock);  <span class="comment">// 加锁防止其他消费者抢占</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 多消费者时，这里必须用while，因为通过broadcast方式唤醒所有阻塞线程时（唤醒时所有线程要去争锁），</span></span><br><span class="line"><span class="comment">           有可能其他线程先获得锁，也就先消费了产品，到本线程时，可能已经没有产品了，因此还要先判断是否有产品！ */</span></span><br><span class="line">        <span class="keyword">while</span>(product == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 注意理解此函数会进行的操作（解锁+阻塞，收到唤醒解除阻塞+加锁）</span></span><br><span class="line">            pthread_cond_wait(&amp;has_product, &amp;lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = product;</span><br><span class="line">        product = product-&gt;next;    <span class="comment">// 模拟消费一个产品</span></span><br><span class="line">        <span class="comment">// 将 printf 也放在锁的范围，这样才能观察到产品是后生产先被消费</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;consumer %lu --- product %d\n&quot;</span>, pthread_self(), p-&gt;num);</span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">        sleep(rand() % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));</span><br><span class="line">        p-&gt;num = rand() % <span class="number">1000</span> + <span class="number">1</span>;    <span class="comment">// 模拟生产一个产品</span></span><br><span class="line"></span><br><span class="line">        pthread_mutex_lock(&amp;lock);</span><br><span class="line">        <span class="comment">// 将 printf 也放在锁的范围，这样才能观察到产品是后生产先被消费</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;producer %lu --- product %d\n&quot;</span>, pthread_self(), p-&gt;num);</span><br><span class="line">        p-&gt;next = product;</span><br><span class="line">        product = p;    <span class="comment">// 这种实现是栈的方式，后生产的产品先出</span></span><br><span class="line">        pthread_mutex_unlock(&amp;lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将一个阻塞在该条件变量上的线程唤醒</span></span><br><span class="line">        <span class="comment">// pthread_cond_signal(&amp;has_product);</span></span><br><span class="line">        pthread_cond_broadcast(&amp;has_product);</span><br><span class="line">        sleep(rand() % <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> cons, prod;</span><br><span class="line">    pthread_create(&amp;prod, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cons, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> cons1, cons2; <span class="comment">// 模拟多消费者</span></span><br><span class="line">    pthread_create(&amp;cons1, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cons2, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cons1, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cons2, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(prod, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cons, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sem-信号量"><a href="#sem-信号量" class="headerlink" title="sem 信号量"></a>sem 信号量</h2><p>进化版的互斥锁，加锁的线程数量 N 可以自定义，即同时访问数据的线程数量可以为 N。</p><p><strong>初值为N，并不是最大值为N，但若调用sem_post，N值还会变大！</strong></p><p>同样是建议锁，虽然支持多次加锁，但信号量本身并不能保证数据不紊乱，而是需要底层数据结构支持并发操作。</p><p><strong>信号和信号量毫无关系！！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destroy</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_trywait</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_timedwait</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> *sem)</span>;</span><br></pre></td></tr></table></figure><p>信号量可以应用与线程、<strong>进程</strong>之间的同步！</p><h3 id="sem-init-函数"><a href="#sem-init-函数" class="headerlink" title="sem_init 函数"></a>sem_init 函数</h3><p>初始化信号量，可以设置是否共享，以及初始值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> *sem, <span class="type">int</span> pshared, <span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>sem</code>：信号量的地址</li><li><code>pshared</code>：是否共享，<code>0</code>（用于线程间同步），<code>1</code>（<strong>用于进程间同步，在进程间共享</strong>）</li><li><code>value</code>：N 值，可同时访问数据的线程数量.</li><li>返回值：0（成功），-1（失败）</li></ul><h3 id="3类信号量"><a href="#3类信号量" class="headerlink" title="3类信号量"></a>3类信号量</h3><p>信号量有三种类型：</p><ul><li><strong>Posⅸ 有名信号量</strong>：可用于进程或线程间的同步。</li><li><strong>Posix 无名信号量</strong>：基于内存的信号量，存放在内存区中，可用于进程或线程间的同步。<strong>常用于多线程间同步</strong>。</li><li><strong>System V信号量（IPC机制）</strong>：<strong>在内核中维护</strong>，可用于进程或线程间的同步。常用于进程间同步。</li></ul><p>在多线程下，全局变量可在线程间共享，因此将信号量设置为全局变量即可。但在多进程环境下，每个进程间并不共享变量！这三类信号量的共享机制为：</p><ul><li><strong>有名信号量</strong>通过文件系统中的<strong>路径名对应的文件名</strong>进行维护（<strong>信号量只是通过文件名进行标识</strong>，信号量的值并不存放到这个文件中，除非信号量存放在空间映射到这个文件上）。</li><li><strong>无名信号量</strong>通过用户空间内存进行维护，无名信号量要想在进程间通信，<strong>该内存必须为共享内存区</strong>*。如上面的<code>pshared</code>参数！</li><li><strong>System V信号量（IPC机制）</strong>并不在用户空间创建，它由内核维护。它的标识是使用<code>IPC Key</code>！</li></ul><h3 id="生产者消费者实现2"><a href="#生产者消费者实现2" class="headerlink" title="生产者消费者实现2"></a>生产者消费者实现2</h3><p>这个与上面基于条件变量的实现逻辑不同，建议先看视频<a href="https://www.bilibili.com/video/BV1KE411q7ee?p=183&spm_id_from=pageDriver">基于信号量实现生产者消费者模型</a>理解实现的原理，再看具体实现代码。</p><p>注意，对信号量初始化时，将 <code>product_num</code> 初始化为0，但仍然可以调用<code>sem_post</code>, <code>sem_wait</code>等函数，这与上面所说的最多只能有 N (这里为0) 是不是矛盾?怎么实现多个消费者？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 10</span></span><br><span class="line"></span><br><span class="line"><span class="type">sem_t</span> blank_num;</span><br><span class="line"><span class="type">sem_t</span> product_num;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> products[NUM];</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;blank_num);   <span class="comment">// 空格为空时阻塞 blank_num--</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生产一个产品</span></span><br><span class="line">        products[i] = rand() % <span class="number">1000</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;produce product: %d in index: %d\n&quot;</span>, products[i], i);</span><br><span class="line">        sem_post(&amp;product_num); <span class="comment">// product_num++</span></span><br><span class="line"></span><br><span class="line">        i = (i+<span class="number">1</span>) % NUM;    <span class="comment">// 环形队列</span></span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sem_wait(&amp;product_num); <span class="comment">// 当产品为空时阻塞 product_num--</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费产品</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;consume product: %d in index: %d\n&quot;</span>, products[i], i);</span><br><span class="line">        sem_post(&amp;blank_num);   <span class="comment">// blank_num++</span></span><br><span class="line"></span><br><span class="line">        i = (i+<span class="number">1</span>) % NUM;</span><br><span class="line">        sleep(rand() % <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> prod, cons;</span><br><span class="line"></span><br><span class="line">    sem_init(&amp;product_num, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;blank_num, <span class="number">0</span>, NUM);</span><br><span class="line"></span><br><span class="line">    pthread_create(&amp;prod, <span class="literal">NULL</span>, producer, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;cons, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_join(prod, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(cons, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h2><table><thead><tr><th>pthread_mutex_t</th><th>pthread_rwlock_t</th><th>pthread_cond_t</th><th>sem_t</th></tr></thead><tbody><tr><td>pthread_mutex_init</td><td>pthread_rwlock_init</td><td>pthread_cond_init</td><td>sem_init</td></tr><tr><td>pthread_mutex_lock</td><td>pthread_rwlock_wrlock<br />pthread_rwlock_rdlock</td><td>pthread_cond_wait</td><td>sem_wait</td></tr><tr><td>pthread_mutex_trylock</td><td>pthread_rwlock_trywrlock<br />pthread_rwlock_tryrdlock</td><td></td><td>sem_trywait</td></tr><tr><td></td><td></td><td>pthread_cond_timedwait</td><td>sem_timedwait</td></tr><tr><td>pthread_mutex_unlock</td><td>pthread_rwlock_unlock</td><td>pthread_cond_signal<br />pthread_cond_broadcast</td><td>sem_post</td></tr><tr><td>pthread_mutex_destroy</td><td>pthread_rwlock_destroy</td><td>pthread_cond_destroy</td><td>sem_destroy</td></tr></tbody></table><p>下面的方法有助于理解其实现原理，但不是真实情况：</p><ul><li><code>mutex</code>可以看作一个整数，且只有两种取值：0和1。<ul><li>init ：将 <code>i</code> 的值设置为1。</li><li>lock ：相当于 <code>i--</code>，将 <code>i</code> 的值从 1 变为 0。如果 <code>i</code> 为0，则阻塞。</li><li>unlock ：相当于 <code>i++</code>，若 i 已经为 1，i 将不会变化。</li></ul></li><li><code>sem</code> 相当于初值为 N 的互斥量<ul><li>init ：初始化 <code>i</code>，初始值为 N。</li><li>wait ：相当于 <code>i--</code>，若 <code>i</code> 为0，则阻塞。</li><li>post ：相当于 <code>i++</code>，若 <code>i</code> 已经达到 N，还是会 <code>++</code>！（注意与 <code>mutex</code> 区分）</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutex</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m;</span><br><span class="line">    pthread_mutex_init(&amp;m, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_mutex_unlock(&amp;m);</span><br><span class="line">    pthread_mutex_lock(&amp;m);     <span class="built_in">printf</span>(<span class="string">&quot;lock 1\n&quot;</span>);</span><br><span class="line">    pthread_mutex_lock(&amp;m);     <span class="built_in">printf</span>(<span class="string">&quot;lock 2\n&quot;</span>); <span class="comment">// 阻塞</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sem</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">sem_t</span> s;</span><br><span class="line">    sem_init(&amp;s, <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">    sem_post(&amp;s);</span><br><span class="line">    sem_wait(&amp;s);   <span class="built_in">printf</span>(<span class="string">&quot;wait 1\n&quot;</span>);</span><br><span class="line">    sem_wait(&amp;s);   <span class="built_in">printf</span>(<span class="string">&quot;wait 2\n&quot;</span>);</span><br><span class="line">    sem_wait(&amp;s);   <span class="built_in">printf</span>(<span class="string">&quot;wait 3\n&quot;</span>);</span><br><span class="line">    sem_wait(&amp;s);   <span class="built_in">printf</span>(<span class="string">&quot;wait 4\n&quot;</span>);</span><br><span class="line">    sem_wait(&amp;s);   <span class="built_in">printf</span>(<span class="string">&quot;wait 5\n&quot;</span>); <span class="comment">// 阻塞</span></span><br><span class="line">    sem_destroy(&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内核锁"><a href="#内核锁" class="headerlink" title="内核锁"></a>内核锁</h2><p>上面几种锁都是在用户态使用，在内核中，也有类似的实现。</p><table><thead><tr><th>头文件</th><th>结构</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;asm/semaphore.h&gt;</code></td><td><code>struct semaphore</code></td><td>信号量&#x2F;互斥量</td></tr><tr><td><code>&lt;linux/rwsem.h&gt;</code></td><td><code>struct rw_semaphore</code></td><td>读写锁</td></tr><tr><td><code>&lt;linux/completion.h&gt;</code></td><td><code>struct completion</code></td><td>类似条件变量</td></tr><tr><td><code>&lt;linux/spinlock.h&gt;</code></td><td><code>spinlock_t</code></td><td>自旋锁</td></tr><tr><td><code>&lt;linux/spinlock.h&gt;</code></td><td><code>rwlock_t</code></td><td>自旋读写锁</td></tr></tbody></table><p>加锁总会影响系统的性能，在一些场景下可以考虑不加锁的算法！如：环形队列、原子变量、位操作、顺序锁<code>seqlock</code>、读取-拷贝-更新(RCU)。</p><h2 id="锁陷阱"><a href="#锁陷阱" class="headerlink" title="锁陷阱"></a>锁陷阱</h2><ol><li>不允许一个持锁者第 2 次请求锁！</li><li>获得多个锁可能是危险的，当多个锁必须获得时，它们应当一直以同样顺序获得！</li><li>尽量保证锁的粒度，越小越好（访问共享数据前，加锁，访问结束立即解锁）。</li></ol><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.bilibili.com/video/BV1KE411q7ee?p=172&spm_id_from=pageDriver">读写锁优先级</a></li><li><a href="https://www.bilibili.com/video/BV1KE411q7ee?p=176&t=290.8">条件变量原理</a></li><li><a href="https://www.bilibili.com/video/BV1KE411q7ee?p=180&t=471.6">生产者-多个消费者</a></li><li><a href="https://www.bilibili.com/video/BV1KE411q7ee?p=183&spm_id_from=pageDriver">基于信号量实现生产者消费者模型</a></li><li>《Linux 设备驱动程序》</li><li><a href="https://blog.csdn.net/qq_28812525/article/details/105229968">信号量类型</a></li><li>《Linux&#x2F;UNIX系统编程手册–45.2&#x2F;47》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 同步 </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-线程</title>
      <link href="/2022/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><blockquote><p>虽然可以使用诸多进程来相互协作实现需要并发才能完成的功能，但进程间的协作有着重要的限制：<strong>每个进程有自己的独立空间</strong>。这种限制导致进程之间的协作存在明显缺陷：如果相互协作的进程需要动态共享大量的数据，则操作起来十分麻烦。就像一群人之间的协作一样，由于每个人都是独立的个体，各有不同的喜好和习惯，协作难免产生误解和沟通困难。如果一件事情让一个人来处理，协作上就不会发生问题。因此，如果能够让一个进程内部实现并发来完成一个复杂的任务，协作上的难度就会少很多。</p><p>在进程内部实现并发就是进程出现的动机，如下图所示：</p><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/image-20221128233112246.png" alt="image-20221128233112246"></p></blockquote><p>Linux 下，线程又称为<code>LWP: light weight process</code>，轻量级进程。</p><table><thead><tr><th>进程</th><th>线程</th></tr></thead><tbody><tr><td><strong>有独立的进程地址空间</strong></td><td>没有独立的地址空间，多个线程共享</td></tr><tr><td>有独立的 PCB</td><td>有独立的 PCB （但PCB中指向内存资源的三级页表相同）</td></tr><tr><td>分配资源的最小单位</td><td>CPU 执行的最小单位</td></tr><tr><td>查看 <code>ps aux / ps ajx</code></td><td>查看线程号 <code>ps -Lf 进程id</code></td></tr></tbody></table><p><strong>传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程。</strong></p><p>进程中创建线程后，原进程也降为线程了！进程相当于独居，创建线程后就变成合租（共享地址空间）。</p><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/image-20220504212829735.png" alt="image-20220504212829735"></p><p>线程是 CPU 执行的最小单位，以下图为例，A分配的CPU时间为<code>3/5</code>，而 B, C 各只有 <code>1/5</code>。但也不是说线程越多越好，如下图右为的曲线。</p><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/image-20220504213809444.png" alt="image-20220504213809444"></p><h3 id="线程共享资源"><a href="#线程共享资源" class="headerlink" title="线程共享资源"></a>线程共享资源</h3><ol><li>文件描述符表</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户 ID 和组 ID</li><li>内存地址空间 (text&#x2F;data&#x2F;bss&#x2F;heap&#x2F;共享库 <strong>全局变量</strong>)，不包括栈。</li></ol><h3 id="线程非共享资源"><a href="#线程非共享资源" class="headerlink" title="线程非共享资源"></a>线程非共享资源</h3><ol><li>线程 ID</li><li>处理器现场和栈指针（内核栈）</li><li>独立的栈空间（用户空间栈）</li><li>errno 变量</li><li>信号屏蔽字</li><li>调度优先级</li></ol><h3 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h3><p>优点：</p><ol><li>提高程序并发性</li><li>开销小</li><li>数据通信、共享数据方便。只需将数据复制到共享（全局或堆）变量中即可。</li></ol><p>缺点：</p><ol><li>库函数，不稳定</li><li>调试、编写困难、gdb 不支持</li><li>对信号支持不好。</li></ol><p>优点相对突出，缺点均不是硬伤。Linux 下由于实现方法导致进程、线程差别不是很大。</p><h2 id="常用-API"><a href="#常用-API" class="headerlink" title="常用 API"></a>常用 API</h2><p>线程相关的函数的<code>man page</code>可能需要额外下载，<code>sudo apt install manpages-posix manpages-posix-dev</code>，也可通过<code>man -k pthread</code>查看相关的函数。</p><blockquote><p>除了上面下载<code>manpage</code>，也可以<a href="https://man7.org/linux/man-pages/index.html">在线查看manpage</a></p><p><code>Pthread</code>相关的源码也可<a href="https://sourceware.org/git/?p=glibc.git;a=tree;f=nptl;h=d0ce23d37e9b77d6ff82ffdee0f7a1f8f137aa41;hb=HEAD">在线查看</a></p><p><a href="https://elixir.bootlin.com/glibc/glibc-2.36/source">glibc source code</a></p></blockquote><h3 id="pthread-self"><a href="#pthread-self" class="headerlink" title="pthread_self"></a>pthread_self</h3><p>获取线程 id，类似与进程中的 <code>getpid()</code>！</p><p>线程 id 是在<strong>进程地址空间内部</strong>，用来标识线程身份的 id。通过 <code>ps -LF 进程id</code> 得到的是线程号<code>LWP</code>，是操作系统用来区分以分配CPU资源标识，与进程ID的功能类似。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_t</span> <span class="title function_">pthread_self</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>返回值：线程 id</li></ul><h3 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h3><p>创建线程，编译和链接时加 <code>-lpthread</code>！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_create</span><span class="params">(<span class="type">pthread_t</span> *thread, <span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                    <span class="type">void</span> *(*start_routine) (<span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><ul><li>thread：线程 id，传出参数</li><li>attr: 线程属性，默认为 NULL</li><li>start_routine：线程入口函数，函数原型要与 <code>void *(*start_routine) (void *arg)</code> 一致</li><li>arg：上一个参数“传入线程入口函数”的参数</li><li>返回值：0 成功，非 0 失败，返回的是 errno</li></ul><p>循环创建多个线程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is %dth thread, pid = %d, tid = %ld\n&quot;</span>, (<span class="type">int</span>)arg, getpid(), pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ret, i;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thread_func, (<span class="type">void</span> *)i);</span><br><span class="line">        <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;main: pid = %d, tid = %ld\n&quot;</span>, getpid(), pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意上面的代码中，线程入口函数的参数是一个整型变量，而不是指针！</p><p>通过值传递，避免与主线程中的变量冲突。若传入的参数是一个指针，因为线程创建需要一定的时间，而这段时间内，主线程可能会改变这个指针的值。导致结果与预期不一致。</p><p>检查线程返回错误号，不能使用 <code>perror()</code>，只能用 <code>strerror()</code>！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br></pre></td></tr></table></figure><h3 id="pthread-exit"><a href="#pthread-exit" class="headerlink" title="pthread_exit"></a>pthread_exit</h3><p>在线程函数函数内部调用，直接结束当前线程，可设置线程退出值。结束之后仍然需要 <code>pthread_join</code> 回收线程资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_exit</span><span class="params">(<span class="type">void</span> *retval)</span>;</span><br></pre></td></tr></table></figure><ul><li>retval：退出值，无则设 NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// exit(0);         // 退出进程（会把所有线程都退出！）</span></span><br><span class="line">        <span class="comment">// return NULL;     // 退出到调用者</span></span><br><span class="line">        pthread_exit(<span class="literal">NULL</span>); <span class="comment">// 退出当前线程</span></span><br><span class="line">        pthread_exit((<span class="type">void</span>*)<span class="number">0</span>); <span class="comment">// 设定线程退出值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is %dth thread, pid = %d, tid = %ld\n&quot;</span>, i, getpid(), pthread_self());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a>pthread_join</h3><p>阻塞回收线程，类似于进程中的 <code>waitpid()</code>！<strong>注意，回收线程不一定是由父线程完成，兄弟线程之间可互相回收！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure><ul><li>retval：线程的返回值，传出参数</li><li>返回值：0 成功，非 0 失败，返回的是 errno</li></ul><h3 id="pthread-cancel"><a href="#pthread-cancel" class="headerlink" title="pthread_cancel"></a>pthread_cancel</h3><p>杀死线程，类似于进程中的 <code>kill()</code>！</p><p>被杀死的线程会调用 <code>pthread_exit()</code>，并且会返回 <code>PTHREAD_CANCELED</code>！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cancel</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul><li>thread：要杀死的线程 id</li><li>返回值：0 成功，非 0 失败，返回的是 errno</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// pthread_testcancel()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的线程函数中，由于没有进入系统调用，无法用 <code>pthread_cancel()</code> 来杀死线程！</p><p><code>pthread_cancel</code> 只有线程进入系统调用后，才能被杀死！如果子线程逻辑上没有调用系统调用，可以在程序中手动添加取消点 <code>pthread_testcancel()</code>。</p><h3 id="pthread-detach"><a href="#pthread-detach" class="headerlink" title="pthread_detach"></a>pthread_detach</h3><p>设置线程分离，这样线程结束时，线程资源 PCB 会被自动释放，而不需要等待主线程回收！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure><ul><li>thread：要分离的线程 id</li><li>返回值：0 成功，非 0 失败，返回的是 errno</li></ul><p>分离后，再次调用 <code>pthread_join()</code> 时，会报错 <code>Invalid argument</code>！</p><h3 id="pthread-cleanup-push-x2F-pop"><a href="#pthread-cleanup-push-x2F-pop" class="headerlink" title="pthread_cleanup_push&#x2F;pop"></a>pthread_cleanup_push&#x2F;pop</h3><p><code>pthread_cleanup_push</code> 和 <code>pthread_cleanup_pop</code> 是 C 语言 POSIX 线程库 (pthreads) 中的函数，它们用于在线程退出时自动执行清理动作。</p><ul><li><code>pthread_cleanup_push</code> 用于注册清理函数，该函数将在线程退出时自动调用。该函数的第一个参数是清理函数的地址，第二个参数是一个指针，该指针用于传递给清理函数的参数。</li><li><code>pthread_cleanup_pop</code> 用于弹出最近注册的清理函数。如果第二个参数为非零值，则立即调用清理函数。如果第二个参数为零，则在线程退出时自动调用清理函数。</li></ul><p>只有在<code>push</code>和<code>pop</code>这两个函数中间线程退出时，才会执行对应的清理函数。退出的原因有：</p><ul><li>其他线程使用 <code>pthread_cancel()</code> 杀死了此线程。</li><li>线程自己调用了 <code>pthread_exit()</code>。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_push</span><span class="params">(<span class="type">void</span> (*routine)(<span class="type">void</span> *),</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *arg)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pthread_cleanup_pop</span><span class="params">(<span class="type">int</span> execute)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* example */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Cleaning up: &quot;</span> &lt;&lt; *(<span class="type">int</span> *)arg &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *i = (<span class="type">int</span> *)arg;</span><br><span class="line"></span><br><span class="line">    pthread_cleanup_push(cleanup, i);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">while</span>(cnt--) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">3</span>)</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_cleanup_pop(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>routine</code>：清理函数指针；</li><li><code>arg</code>：清理函数的传入参数。</li><li><code>execute</code>：第二个参数是一个整数，它控制清理函数是在线程退出时自动调用，还是在该函数被调用时立即调用。<ul><li>如果第二个参数为 0，则在线程退出时自动调用清理函数。</li><li>如果第二个参数非 0，则在该函数被调用时立即调用清理函数。</li></ul></li></ul><h3 id="进程线程对比"><a href="#进程线程对比" class="headerlink" title="进程线程对比"></a>进程线程对比</h3><table><thead><tr><th>进程</th><th>线程</th></tr></thead><tbody><tr><td><code>fork()</code></td><td><code>pthread_create()</code></td></tr><tr><td><code>getpid()</code></td><td><code>pthread_self()</code></td></tr><tr><td><code>exit()</code></td><td><code>pthread_exit()</code></td></tr><tr><td><code>wait()/waitpid()</code></td><td><code>pthread_join()</code></td></tr><tr><td><code>kill()</code></td><td><code>pthread_cancel()</code></td></tr><tr><td></td><td><code>pthread_detach()</code></td></tr></tbody></table><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><blockquote><p><a href="https://elixir.bootlin.com/glibc/glibc-2.36/source/sysdeps/nptl/internaltypes.h#L26">pthread_attr</a></p></blockquote><p>在线程创建时，就可以设置线程的属性，主要有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread_attr</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>  <span class="title">schedparam</span>;</span>     <span class="comment">/* 线程的调度参数：优先级 */</span></span><br><span class="line">    <span class="type">int</span>                 schedpolicy;    <span class="comment">/* 线程调度策略 */</span></span><br><span class="line">    <span class="type">int</span>                 flags;          <span class="comment">/* 线程的分离状态、作用域属性 */</span></span><br><span class="line">    <span class="type">size_t</span>              guardsize;      <span class="comment">/* 线程栈末尾的警戒缓冲区大小 */</span></span><br><span class="line">    <span class="type">void</span> *              stackaddr;      <span class="comment">/* 线程栈的位置（最低地址） */</span></span><br><span class="line">    <span class="type">size_t</span> s            tacksize;       <span class="comment">/* 线程栈的位置（最低地址） */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocated via a call to __pthread_attr_extension once needed.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pthread_attr_extension</span> *<span class="title">extension</span>;</span></span><br><span class="line">    <span class="type">void</span> *unused;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> sched_priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pthread_attr_extension</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Affinity map.  */</span></span><br><span class="line">    <span class="type">cpu_set_t</span> *cpuset;</span><br><span class="line">    <span class="type">size_t</span> cpusetsize;</span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> sigmask;</span><br><span class="line">    <span class="type">bool</span> sigmask_set;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般不直接对线程属性实例进行修改，而是通过提供的函数来设置！<strong>下面介绍的函数都是对线程属性实例进行了修改，也就是说，执行执行函数后也还没有任何一个线程受到这些属性的影响。只有用该实例去创建新线程时才生效</strong>。</p><p>如果想修改当前运行中的线程的属性，往往有对应的不带<code>attr</code>的函数。</p><p><code>man pthread_attr_init</code>中有获取线程属性并打印输出的例子，可以查看线程的默认属性。</p><h3 id="pthread-attr-init-x2F-destroy"><a href="#pthread-attr-init-x2F-destroy" class="headerlink" title="pthread_attr_init&#x2F;destroy"></a>pthread_attr_init&#x2F;destroy</h3><p>对线程属性实例初始化和销毁的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_init</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>;    <span class="comment">// 初始化线程属性</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_destroy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr)</span>; <span class="comment">// 销毁线程属性</span></span><br></pre></td></tr></table></figure><ul><li>attr：线程属性结构体指针</li><li>返回值：0 成功，非 0 失败，返回的是 errno</li></ul><p><code>init</code> 与 <code>destroy</code> 函数要配套使用，类似于 <code>malloc()</code> 与 <code>free()</code>！</p><p>可以看到上面<code>pthread_attr</code>的结构体中有指针成员，就会涉及到动态内存分配<code>malloc</code>和内存释放<code>free</code>，因此每次用完<code>attr</code>后需要调用<code>destroy</code>释放内存，避免内存泄露。</p><h3 id="pthread-attr-setdetachstate-x2F-get"><a href="#pthread-attr-setdetachstate-x2F-get" class="headerlink" title="pthread_attr_setdetachstate&#x2F;get"></a>pthread_attr_setdetachstate&#x2F;get</h3><p>设置线程分离，这样线程结束时，线程资源 PCB 会被自动释放，而不需要等待主线程回收！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setdetachstate</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> detachstate)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getdetachstate</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *detachstate)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>attr</code>：线程属性结构体指针</li><li><code>detachstate</code>：线程分离状态，可以是以下值：<ul><li><code>PTHREAD_CREATE_JOINABLE</code>：线程分离状态为非分离（默认选项）</li><li><code>PTHREAD_CREATE_DETACHED</code>：线程分离状态为分离</li></ul></li><li>返回值：0 成功，非 0 失败，返回的是 <code>errno</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">thread_func</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;thread func. \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">// 设置线程属性为 分离</span></span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = pthread_create(&amp;tid, &amp;attr, thread_func, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread_create error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    ret = pthread_join(tid, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) <span class="comment">// 报错说明设置线程分离状态成功</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pthread join error: %s\n&quot;</span>, strerror(ret));</span><br><span class="line">    <span class="comment">// 主线程结束，子线程也被 结束！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pthread-attr-setschedpolicy-x2F-get"><a href="#pthread-attr-setschedpolicy-x2F-get" class="headerlink" title="pthread_attr_setschedpolicy&#x2F;get"></a>pthread_attr_setschedpolicy&#x2F;get</h3><p>设置线程调度的策略，支持的有：<code>SCHED_FIFO</code>, <code>SCHED_RR</code>, <code>SCHED_OTHER</code>，关于这几种策略的描述见：<a href="https://man7.org/linux/man-pages/man7/sched.7.html#DESCRIPTION">man7 sched</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setschedpolicy</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getschedpolicy</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *policy)</span>;</span><br></pre></td></tr></table></figure><p>返回值：成功返回，失败返回错误号。</p><ul><li><code>SCHED_FIFO</code>：设置了该策略的线程会一直运行，直到它被IO阻塞或被更高优先级的线程抢占，或者它调用<code>sched_yield</code>。</li><li><code>SCHED_RR</code>：基于<code>SCHED_FIFO</code>，但设置了最大执行时间<code>quantum</code>，执行这么长时间后就会中止，并放入该优先级的调度队列末尾。</li><li><code>SCHED_OTHER</code>：<code>Linux</code>的默认策略，是一种相对<em>公平</em>的调度策略，类似与时间片轮转，但高优先级分配的时间会更多。</li></ul><h3 id="pthread-attr-setschedparam-x2F-get"><a href="#pthread-attr-setschedparam-x2F-get" class="headerlink" title="pthread_attr_setschedparam&#x2F;get"></a>pthread_attr_setschedparam&#x2F;get</h3><p><code>SCHED_FIFO</code>是基于优先级抢占的，该函数用于设置线程进行调度时的优先级。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setschedparam</span><span class="params">(<span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getschedparam</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                               <span class="keyword">struct</span> sched_param *param)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> sched_param &#123;</span><br><span class="line">    <span class="type">int</span> sched_priority;     <span class="comment">/* Scheduling priority */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="pthread-attr-setinheritsched-x2F-get"><a href="#pthread-attr-setinheritsched-x2F-get" class="headerlink" title="pthread_attr_setinheritsched&#x2F;get"></a>pthread_attr_setinheritsched&#x2F;get</h3><p>设置线程的继承属性，其实只有<strong>调度属性</strong>可以继承。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setinheritsched</span><span class="params">(<span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> inheritsched)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getinheritsched</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                                 <span class="type">int</span> *inheritsched)</span>;</span><br></pre></td></tr></table></figure><p><code>inheritsched</code>只有两种取值：</p><ul><li><code>PTHREAD_INHERIT_SCHED</code>：新线程将继承调用<code>pthread_create</code>的线程的调度策略。</li><li><code>PTHREAD_EXPLICIT_SCHED</code>：新线程的调度策略以线程属性中指定的为准。</li></ul><p><strong>也就是说，在使用<code>pthread_attr_setschedpolicy</code>时，必须也要设置<code>PTHREAD_EXPLICIT_SCHED</code>，否则调度策略不会生效</strong>。</p><h3 id="pthread-attr-setscope-x2F-get"><a href="#pthread-attr-setscope-x2F-get" class="headerlink" title="pthread_attr_setscope&#x2F;get"></a>pthread_attr_setscope&#x2F;get</h3><p>线程作用域属性描述特定线程将与哪些线程竞争资源。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setscope</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> scope)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getscope</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">int</span> *scope)</span>;</span><br></pre></td></tr></table></figure><p>线程可以在两种竞争域内竞争资源，也是<code>scope</code>的两种取值：</p><ul><li><code>PTHREAD_SCOPE_SYSTEM</code>：系统域，与系统中的所有线程。一个具有系统域的线程将与整个系统中所有具有系统域的线程按照优先级竞争处理器资源，进行调度。</li><li><code>PTHREAD_SCOPE_PROCESS</code>：进程域，与同一进程内的其他线程竞争。</li></ul><h3 id="pthread-attr-setguardsize-x2F-get"><a href="#pthread-attr-setguardsize-x2F-get" class="headerlink" title="pthread_attr_setguardsize&#x2F;get"></a>pthread_attr_setguardsize&#x2F;get</h3><p>设置线程栈保护区的大小，<strong>默认保护大小与系统页面大小相同</strong>。</p><p>在线程栈的末尾分配之一至少<code>guardsize</code>字节的区域作为堆栈保护区，如果一个线程溢出它的堆栈到保护区，在大多数硬架构上，会产生<code>SIGSEGV</code>信号，从而通知它溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setguardsize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> guardsize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getguardsize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *guardsize)</span>;</span><br></pre></td></tr></table></figure><h3 id="pthread-attr-setstackaddr-x2F-get"><a href="#pthread-attr-setstackaddr-x2F-get" class="headerlink" title="pthread_attr_setstackaddr&#x2F;get"></a>pthread_attr_setstackaddr&#x2F;get</h3><p>当进程栈地址空间不够用时，指定新建线程使用由<code>malloc</code>分配的空间作为自己的栈空间。</p><p><a href="https://man7.org/linux/man-pages/man3/pthread_attr_setstackaddr.3.html#NOTES">Do not use these functions!</a></p><h3 id="pthread-attr-setstacksize-x2F-get"><a href="#pthread-attr-setstacksize-x2F-get" class="headerlink" title="pthread_attr_setstacksize&#x2F;get"></a>pthread_attr_setstacksize&#x2F;get</h3><p>设置线程栈的大小，默认线程栈的大小为<code>8M</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setstacksize</span><span class="params">(<span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> stacksize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getstacksize</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr, <span class="type">size_t</span> *stacksize)</span>;</span><br></pre></td></tr></table></figure><p>当进程中有很多线程时，可能需要减小每个线程栈的默认大小，防止进程的地址空间不够用。</p><p>当线程调用的函数会分配很大的局部变量或者函数调用层次很深时，可能需要增大线程栈的默认大小。</p><h3 id="pthread-attr-setaffinity-np-x2F-get"><a href="#pthread-attr-setaffinity-np-x2F-get" class="headerlink" title="pthread_attr_setaffinity_np&#x2F;get"></a>pthread_attr_setaffinity_np&#x2F;get</h3><p>设置线程的CPU亲和性，让线程在指定的某一个核或一组核上运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_setaffinity_np</span><span class="params">(<span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                                <span class="type">size_t</span> cpusetsize, <span class="type">const</span> <span class="type">cpu_set_t</span> *cpuset)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_attr_getaffinity_np</span><span class="params">(<span class="type">const</span> <span class="type">pthread_attr_t</span> *attr,</span></span><br><span class="line"><span class="params">                                <span class="type">size_t</span> cpusetsize, <span class="type">cpu_set_t</span> *cpuset)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>cpusetsize</code>：应该指定 <code>cpuset</code> 参数的字节数，通常设定为<code>sizeof(cpu_set_t)</code>。</li><li><code>cpuset</code>：核的掩码。</li></ul><p>虽然 <code>cpu_set_t</code> 数据类型实现为一个位掩码，但应该将其看成是一个不透明的结构。</p><p>所有对这个结构的操作都应该使用宏来完成，下面是部分常用的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* man CPU_SET */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_ZERO</span><span class="params">(<span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;          <span class="comment">/* 将 set 初始化为空 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_SET</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;  <span class="comment">/* 将 CPU cpu 添加到 set 中 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_CLR</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;  <span class="comment">/* 从 set 中删除 CPU cpu */</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">CPU_ISSET</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;<span class="comment">/* 在 CPU cpu 是 set 的一个成员时返回 true */</span></span><br></pre></td></tr></table></figure><p>注意上面宏参数<code>cpu</code>编号是从0开始。</p><h3 id="pthread-getattr-np"><a href="#pthread-getattr-np" class="headerlink" title="pthread_getattr_np"></a>pthread_getattr_np</h3><p>获取当前线程的属性，写入到<code>attr</code>中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_getattr_np</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">pthread_attr_t</span> *attr)</span>;</span><br></pre></td></tr></table></figure><h3 id="运行时调整线程属性"><a href="#运行时调整线程属性" class="headerlink" title="运行时调整线程属性"></a>运行时调整线程属性</h3><p>除了上面在线程创建时设置属性，部分属性也支持运行时进行调整。</p><table><thead><tr><th>静态设置</th><th>运行时</th></tr></thead><tbody><tr><td><code>pthread_attr_setschedparam</code></td><td><code>pthread_setschedparam</code></td></tr><tr><td><code>pthread_attr_setaffinity_np</code></td><td><code>pthread_setaffinity_np</code></td></tr></tbody></table><h3 id="CPU亲和性"><a href="#CPU亲和性" class="headerlink" title="CPU亲和性"></a>CPU亲和性</h3><p>设置进程在某一个核或一组核上运行，在某些情况下可以提升性能。如果该进程有多个线程，它们都只能在指定的一组核上面运行。也可单独为某一个线程设置亲和性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">cpu_set_t</span> *mask)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize,</span></span><br><span class="line"><span class="params">                        <span class="type">cpu_set_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>pid</code>：要设置的进程号，也可简单的用<code>0</code>来表示调用进程，也可用<code>gettid()</code>传入线程号</li><li><code>cpusetsize</code>：应该指定 <code>mask</code> 参数的字节数，通常设定为<code>sizeof(cpu_set_t)</code></li><li><code>mask</code>：核的掩码。</li><li>返回值：成功返回0，失败返回<code>-1</code>，并设置<code>errno</code><ul><li>如果<code>mask</code>中指定的 CPU 与系统中的所有 CPU 都不匹配，返回<code>EINVAL</code>错误</li></ul></li></ul><p><code>taskset -p PID</code> 可查看当前进程的<code>mask</code>，可通过 <code>taskset -pc $pid</code> 来获取某线程与CPU核心的亲和性。</p><h2 id="线程注意事项"><a href="#线程注意事项" class="headerlink" title="线程注意事项"></a>线程注意事项</h2><ol><li>主线程退出其他线程不退出，主线程应调用 pthread_exit</li><li>避免僵尸线程：<ul><li>pthread_join</li><li>pthread_detach</li><li>pthread_create 指定分离属性</li><li>被 join 线程可能在 join 函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;</li></ul></li><li>malloc 和 mmap 申请的内存可以被其他线程释放</li><li>应避免在多线程模型中调用 fork 除非，马上 exec，子进程中只有调用 fork 的线程存在，其他线程在子进程中均 pthread_exit</li><li>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制 （多线程中，信号由哪个线程处理不确定！每个线程各有信号屏蔽字mask，共享未决信号集，如果想指定某个线程处理特定信号，可通过设置其他线程的信号屏蔽字）</li></ol><h2 id="一次性初始化"><a href="#一次性初始化" class="headerlink" title="一次性初始化"></a>一次性初始化</h2><blockquote><p>Linux-Unix系统编程手册——31.2节</p></blockquote><p>多线程程序有时有这样的需求：不管创建了多少线程，有些初始化动作只能发生一次。如果由主线程来创建新线程，那么这一点易如反掌，可以在创建依赖于该初始化的线程之前进行初始化。不过，对于库函数而言，这样处理就不可行，因为调用者在初次调用库函数之前可能已经创建了这些线程。故而需要这样的库函数：无论首次为任何线程所调用，都会执行初始化动作。</p><h3 id="pthread-once-函数"><a href="#pthread-once-函数" class="headerlink" title="pthread_once 函数"></a>pthread_once 函数</h3><p>保证无论多少线程、无论调用多少次<code>pthread_once</code>，都只会执行一次<code>init_routine</code>初始化函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_once</span><span class="params">(<span class="type">pthread_once_t</span> *once_control,</span></span><br><span class="line"><span class="params">                 <span class="type">void</span> (*init_routine)(<span class="type">void</span>))</span>;</span><br><span class="line"><span class="type">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br></pre></td></tr></table></figure><ul><li><code>once_control</code>：必须是一指针，指向初始化为 <code>PTHREAD_ONCE_INIT</code> 的静态变量。</li><li><code>init_routine</code>：需要执行的函数，该函数没有任何参数。</li><li>成功返回<code>0</code>。</li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://www.bilibili.com/video/BV1KE411q7ee?p=148&spm_id_from=pageDriver">线程原理–三级页表</a></li><li><a href="https://www.bilibili.com/video/BV1KE411q7ee?p=153&spm_id_from=pageDriver">循环创建子线程</a></li><li><a href="https://man7.org/linux/man-pages/index.html">在线查看manpage</a></li><li><a href="https://elixir.bootlin.com/glibc/glibc-2.36/source">glibc source code</a></li><li><a href="https://www.cnblogs.com/FREMONT/p/9480376.html">线程属性</a></li><li><a href="https://blog.csdn.net/qq_38232598/article/details/114263105">线程&#x2F;进程和核绑定（CPU亲和性）</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 线程 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-信号</title>
      <link href="/2022/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/"/>
      <url>/2022/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><ol><li>信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令。</li><li>所有信号的产生及处理全部都是由【内核】完成的。</li><li>简单、不能携带大量信息、满足条件才发送。</li></ol><h3 id="信号的生命周期"><a href="#信号的生命周期" class="headerlink" title="信号的生命周期"></a>信号的生命周期</h3><ol><li>产生：</li><li>未决：产生与递达之间状态。</li><li>递达：产生并且送达到进程。直接被内核处理掉。</li><li>处理：执行默认处理动作、忽略、捕捉（自定义）</li></ol><p>阻塞信号集（信号屏蔽字）：进程控制块PCB中的变量（位图），用来记录信号的屏蔽状态。被屏蔽的信号，在解除屏蔽前，一直处于未决态。</p><p>未决信号集：进程控制块PCB中的变量（位图），用来记录信号的处理状态。</p><ul><li>信号产生时，未决信号集中对应位立刻翻转为1，表示信号处于未决状态。信号被处理后对应位翻转回0，这一过程往往非常短暂。</li><li>信号产生后，由于某些原因（主要是阻塞）不能递达，一直处理未决状态。</li><li>设置阻塞后，同一信号多次产生，也只能记录一次（也只会被处理一次）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* Signal handlers: */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span>    *<span class="title">signal</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span>   *<span class="title">sighand</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span>                blocked;</span><br><span class="line">    <span class="type">sigset_t</span>                real_blocked;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restored if set_restore_sigmask() was used: */</span></span><br><span class="line">    <span class="type">sigset_t</span>                saved_sigmask; <span class="comment">// 信号屏蔽字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span>       <span class="title">pending</span>;</span>    <span class="comment">// 未决信号集</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>           sas_ss_sp;</span><br><span class="line">    <span class="type">size_t</span>                  sas_ss_size;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>            sas_ss_flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="产生信号"><a href="#产生信号" class="headerlink" title="产生信号"></a>产生信号</h3><ol><li>按键产生，如：<code>ctrl+c, ctrl+z, ctrl+\</code></li><li>系统调用产生，如：<code>kill, raise, abort</code></li><li>软件条件产生，如：定时器<code>alarm</code>，或者该进程的某个子进程退出</li><li>硬件异常产生，如：非法访问内存（段错误）、除0（浮点数例外）、内存对齐出错（总线错误）</li><li>命令产生， 如：<code>kill -9</code></li></ol><h3 id="信号四要素"><a href="#信号四要素" class="headerlink" title="信号四要素"></a>信号四要素</h3><p><strong>编号、名称、事件、默认处理动作</strong>！</p><p>总计有64个信号（<strong>可通过<code>kill -l</code>查看信号名称及编号</strong>），<code>man 7 signal</code>也可查看信号。前32个为常规信号，后32个为实时信号。</p><p>信号到达后，进程视具体信号执行如下默认操作之一：</p><ul><li>Term   终止（杀死）进程，这有时是指进程异常终止，而不是进程因调用 <code>exit()</code> 而发生的正常终止。</li><li>Ign    忽略信号，也就是说，内核将信号丢弃，信号对进程没有产生任何影响</li><li>Core   产生核心转储文件，同时进程终止：核心转储文件包含对进程虚拟内存的镜像，可将其加载到调试器中以检查进程终止时的状态</li><li>Stop   停止进程：暂停进程的执行</li><li>Cont   于之前暂停后再度恢复进程的执行</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">名称       编号      动作      事件</span><br><span class="line">Signal   x86/ARM   Action   Comment</span><br><span class="line">────────────────────────────────────────────────────────────────</span><br><span class="line">SIGHUP       1      Term    Hangup detected on controlling terminal</span><br><span class="line">SIGINT       2      Term    Interrupt from keyboard</span><br><span class="line">SIGQUIT      3      Core    Quit from keyboard</span><br><span class="line">SIGILL       4      Core    Illegal Instruction</span><br><span class="line">SIGTRAP      5      Core    Trace/breakpoint <span class="built_in">trap</span></span><br><span class="line">SIGABRT      6      Core    Abort signal from abort(3)</span><br><span class="line">SIGIOT       6      Core    IOT <span class="built_in">trap</span>. A synonym <span class="keyword">for</span> SIGABRT</span><br><span class="line">SIGBUS       7      Core    Bus error (bad memory access)</span><br><span class="line">SIGFPE       8      Core    Floating-point exception</span><br><span class="line">SIGKILL      9      Term    Kill signal</span><br><span class="line">SIGUSR1     10      Term    User-defined signal 1</span><br><span class="line">SIGSEGV     11      Core    Invalid memory reference</span><br><span class="line">SIGUSR2     12      Term    User-defined signal 2</span><br><span class="line">SIGPIPE     13      Term    Broken pipe: write to pipe with no</span><br><span class="line">SIGALRM     14      Term    Timer signal from alarm(2)</span><br><span class="line">SIGTERM     15      Term    Termination signal</span><br><span class="line">SIGSTKFLT   16      Term    Stack fault on coprocessor (unused)</span><br><span class="line">SIGCHLD     17      Ign     Child stopped or terminated</span><br><span class="line">SIGCONT     18      Cont    Continue <span class="keyword">if</span> stopped</span><br><span class="line">SIGSTOP     19      Stop    Stop process</span><br><span class="line">SIGTSTP     20      Stop    Stop typed at terminal see also seccomp(2)</span><br><span class="line">SIGTTIN     21      Stop    Terminal input <span class="keyword">for</span> background process</span><br><span class="line">SIGTTOU     22      Stop    Terminal output <span class="keyword">for</span> background process</span><br><span class="line">SIGURG      23      Ign     Urgent condition on socket (4.2BSD)</span><br><span class="line">SIGXCPU     24      Core    CPU time <span class="built_in">limit</span> exceeded (4.2BSD);</span><br><span class="line">SIGXFSZ     25      Core    File size <span class="built_in">limit</span> exceeded (4.2BSD);</span><br><span class="line">SIGVTALRM   26      Term    Virtual alarm clock (4.2BSD)</span><br><span class="line">SIGPROF     27      Term    Profiling timer expired</span><br><span class="line">SIGWINCH    28      Ign     Window resize signal (4.3BSD, Sun)</span><br><span class="line">SIGIO       29      Term    I/O now possible (4.2BSD)</span><br><span class="line">SIGPWR      30      Term    Power failure (System V)</span><br><span class="line">SIGSYS      31      Core    Bad system call (SVr4);</span><br><span class="line">SIGUNUSED   31      Core    Synonymous with SIGSYS</span><br></pre></td></tr></table></figure><p><code>SIGKILL(9), SIGSTOP(19)</code> 不能被捕捉、阻塞、忽略。</p><p>重点是下面的信号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SIGHUP       1   Term   当用户退出shell时，由该shell启动的所有进程都会收到该信号。</span><br><span class="line">SIGINT       2   Term   用户按下 ctrl+c</span><br><span class="line">SIGQUIT      3   Core   用户按下 ctrl+\</span><br><span class="line">SIGABRT      6   Core   调用 abort() 函数</span><br><span class="line">SIGBUS       7   Core   非法访问内存地址，包括内存对齐出错</span><br><span class="line">SIGFPE       8   Core   浮点数错误、溢出、除数为0等所有运算错误</span><br><span class="line">SIGKILL      9   Term   Kill信号，不能被捕捉、阻塞、忽略</span><br><span class="line">SIGUSR1     10   Term   用户定义的信号1</span><br><span class="line">SIGSEGV     11   Core   进行了无效的内存访问</span><br><span class="line">SIGUSR2     12   Term   用户定义的信号2</span><br><span class="line">SIGPIPE     13   Term   向一个没有读端口的管道写数据</span><br><span class="line">SIGALRM     14   Term   定时器超时</span><br><span class="line">SIGTERM     15   Term   结束信号，<span class="built_in">kill</span>缺省发送此信号，与KILLSIG不同，可以阻塞、忽略</span><br><span class="line">SIGCHLD     17   Ign    子进程状态发生变化时（进程恢复执行也可能发送），默认忽略此信号</span><br></pre></td></tr></table></figure><h3 id="SIGSEGV"><a href="#SIGSEGV" class="headerlink" title="SIGSEGV"></a>SIGSEGV</h3><p>段错误，进行了<strong>非法的内存</strong>访问！什么为非法呢？进程中使用的地址是虚拟地址，虚拟地址是按页划分的，每个虚拟页对应一个实际的物理页，但并不是一开始就为每一个虚拟页分配了一个物理页，而是用到了才分配。申请内存时也同样只申请虚拟内存，只要虚拟内存地址有效，就是合法的。</p><p>以堆内为例，堆是一段长度可变的<strong>连续虚拟内存</strong>，始于进程的<strong>未初始化数据段末尾</strong>，通常将堆的内存边界（堆顶）称为<code>program break</code>，最初，<code>program break</code> 正好位于未初始化数据段末尾之后。在堆上分配内存那首先得扩展堆的大小，也就是抬升堆顶<code>program break</code>，这样程序就可以访问<strong>新分配区域内</strong>的任何内存地址。（试想一下，如果一开始直接访问堆区域外的地址会发生什么？）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;program break: %p\n&quot;</span>, sbrk(<span class="number">0</span>)); <span class="comment">// sbrk(0) 返回堆顶的地址</span></span><br><span class="line">    getchar();  getchar();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;访问堆顶以上的内存: %d\n&quot;</span>, (<span class="type">int</span> *)(sbrk(<span class="number">0</span>) + <span class="number">100</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *t = <span class="built_in">malloc</span>(<span class="number">20000</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 可以看到堆顶提升</span></span><br><span class="line">    t[<span class="number">10000</span>] = <span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;access array t: %p\n&quot;</span>, t);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;access array t[10000]: %d, addr: %p\n&quot;</span>, t[<span class="number">10000</span>], t+<span class="number">10000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;program break: %p\n&quot;</span>, sbrk(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    getchar();  getchar();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超过128k 不会调整program break, 而是使用mmap</span></span><br><span class="line">    <span class="type">int</span> *t2 = <span class="built_in">malloc</span>(<span class="number">50000</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    t2[<span class="number">10000</span>] = <span class="number">10000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;access array t2: %p\n&quot;</span>, t2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;access array t2[10000]: %d, %p\n&quot;</span>, t2[<span class="number">10000</span>], t2+<span class="number">10000</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;program break: %p\n&quot;</span>, sbrk(<span class="number">0</span>));</span><br><span class="line">    getchar();  getchar();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>/proc/pid/maps</code> 文件可以查看进程的内存布局（显示的是虚拟地址）。如果<strong>指针指向的地址不在该文件中任何一个内存段范围内</strong>，就说明该内存地址是“非法的、无效的”。不过即使内存地址合法，如果<strong>没有对应内存段的访问权限</strong>，也会报“非法的内存访问”。使用该地址时，会先通过MMU中查询，如果是出现了页的权限错误，或者是操作系统发现并没有页面可以换入（未分配的），那么它会触发一个“软中断”。在Linux中，所谓的软中断其实就是一个信号(<code>signal</code>)，由于访问非法内存地址导致的错误叫作段错误<code>(segment fault)</code>，它会发射一个<code>SIGSEGV</code>信号，默认的行为就是终止这个程序。</p><p>在上面的测试代码中，在并没有调用任何<code>malloc()</code>时，通过 <code>/proc/pid/maps</code> 文件可以看到堆顶的位置在一个大小为<code>132k</code>的内存端的起始位置，此时哪怕直接访问堆顶以上的数据（只要不超过<code>132k</code>的范围）都不会报段错误！而进行任何大小的<code>malloc(1)</code>调用，使得堆顶提升<code>132k</code>。也就是说虽然堆大小为0，但实际上操作系统已经为该进程分配了<code>132k</code>的堆内存。</p><h2 id="kill-函数"><a href="#kill-函数" class="headerlink" title="kill 函数"></a>kill 函数</h2><p>向指定进程发送指定的信号。默认发送的信号为<code>SIGTERM</code>，该信号可以被捕获，所以不一定能杀死进程，但<code>SIGKILL(9)</code>总能<strong>一击必杀</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kill</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> sig)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;pid:%d, ppid:%d\n&quot;</span>, getpid(), getppid());</span><br><span class="line">    kill(getppid(), SIGBUS); <span class="comment">// 向父进程发送SIGBUS信号</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent\n&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sig：信号编号，不推荐直接使用数字，应使用宏名。</li><li>pid：进程编号<ul><li>pid &gt; 0：指定进程编号</li><li>pid &#x3D; 0：发给与kill调用者属于同一进程组的所有进程，包括调用进程自身</li><li>pid &#x3D; -1：发给进程有权限发送的 所有进程，除去 init（进程 ID 为 1）和调用进程自身。如果特权级进程发起这一调用，那么会发送信号给系统中的所有进程</li><li>pid &lt; -1：发给进程组编号为abs(pid)的进程组中的 所有进程</li></ul></li><li>返回值：成功返回0，失败返回-1</li></ul><p>进程组: 每个进程都属于一个进程组，进程组是一个或多个进程集合，他们相互关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID 与进程组长ID 相同。</p><p>权限保护: super 用户(root)可以发送信号给任意用户，普通用户是不能向系统用户发送信号的。 kill -9 (root 用户的pid) 是不可以的。同样，普通用户也不能向其他普通用户发送信号，终止其进程。 只能向自己创建的进程发送信号。普通用户基本规则是: <strong>发送者实际或有效用户ID &#x3D;&#x3D; 接收者实际或有效用户ID</strong></p><h3 id="SIGQUIT"><a href="#SIGQUIT" class="headerlink" title="SIGQUIT"></a>SIGQUIT</h3><p>当用户在键盘上键入退出字符（通常为 <code>Control-\</code>）时，该信号将发往前台进程组。默认情况下，该信号终止进程，并生成可用于调试的核心转储文件。进程如果陷入无限循环，或者不再响应时，使用 <code>SIGQUIT</code> 信号就很合适。键入 <code>Control-\</code>，再调用 <code>gdb</code> 调试器加载刚才生成的核心转储文件，接着用 <code>backtrace</code> 命令来获取堆栈跟踪信息，就能发现正在执行的是程序的哪部分代码。</p><h2 id="alarm-函数"><a href="#alarm-函数" class="headerlink" title="alarm 函数"></a>alarm 函数</h2><p>设置定时器（闹钟），指定的 seconds 后，内核给进程发送 SIGALRM 信号，默认动作为终止进程。</p><p><strong>每个进程有且只有一个定时器</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure><ul><li>seconds：设置定时器超时时间，单位为秒</li><li>返回值：返回之前设置的定时器剩余的时间，之前没有设置返回0。无失败！</li></ul><p>计时与进程状态无关，自然计时法。</p><h2 id="setitimer-函数"><a href="#setitimer-函数" class="headerlink" title="setitimer 函数"></a>setitimer 函数</h2><p>与 alarm 功能类似，精度为微秒，可以实现周期定时。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getitimer</span><span class="params">(<span class="type">int</span> which, <span class="keyword">struct</span> itimerval *curr_value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setitimer</span><span class="params">(<span class="type">int</span> which, <span class="type">const</span> <span class="keyword">struct</span> itimerval *new_value,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> itimerval *old_value)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* 周期定时 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* 下一次时间 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="type">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 第一次两秒后执行，后续每隔五秒执行一次</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">myfunc</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    signal(SIGALRM, myfunc); <span class="comment">// 注册信号的处理函数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">new_value</span>;</span></span><br><span class="line">    new_value.it_interval.tv_sec = <span class="number">5</span>;</span><br><span class="line">    new_value.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line">    new_value.it_value.tv_sec = <span class="number">2</span>;</span><br><span class="line">    new_value.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    setitimer(ITIMER_REAL, &amp;new_value, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>which：定时器类型<ul><li>ITIMER_REAL：真实时间（自然计时），发送信号 SIGALRM</li><li>ITIMER_VIRTUAL：虚拟空间计时（用户空间），发送信号 SIGVTALRM。进程占用CPU时间</li><li>ITIMER_PROF：运行时计时（用户+内核），发送信号 SIGPROF。进程占用CPU时间及系统调用时间</li></ul></li><li>new_value：设置新的定时器值，如果为 NULL，则不设置新的定时器值，只返回旧的定时器值</li><li>old_value：返回旧的定时器值，如果为 NULL，则不返回旧的定时器值</li><li>返回值：成功返回0，失败返回-1</li></ul><p><code>time</code> 命令查看程序执行时间，real总时间，user用户空间时间，sys系统空间时间。</p><h2 id="raise-函数"><a href="#raise-函数" class="headerlink" title="raise 函数"></a>raise 函数</h2><p>有时，进程需要向自身发送信号。<code>raise()</code>函数就执行了这一任务。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">raise</span><span class="params">(<span class="type">int</span> sig)</span>;</span><br></pre></td></tr></table></figure><p>在单线程程序中，调用 <code>raise()</code>相当于对 <code>kill()</code>的如下调用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill(getpid(), sig);</span><br></pre></td></tr></table></figure><p>支持线程的系统会将 <code>raise(sig)</code> 实现为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_kill(pthread_self(), sig);</span><br></pre></td></tr></table></figure><p>注意，<code>raise()</code>出错将返回非 0 值（不一定为–1）。调用 <code>raise()</code> 唯一可能发生的错误为 EINVAL，即 sig 无效。</p><h2 id="abort-函数"><a href="#abort-函数" class="headerlink" title="abort 函数"></a>abort 函数</h2><p>函数 <code>abort()</code> 终止其调用进程，并生成核心转储。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>函数 abort()通过产生 SIGABRT 信号来终止调用进程。对 SIGABRT 的默认动作是产生核心转储文件并终止进程。调试器可以利用核心转储文件来检测调用 <code>abort()</code> 时的程序状态。</p><p>如果 abort()成功终止了进程，那么还将刷新 stdio 流并将其关闭。</p><h2 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h2><p>信号集<code>sigset_t</code>虽然是位图，但一般不允许直接对PCB中的信号集进行操作，而是先自定义一个信号集，然后操作这个信号集，最后再把信号集通过提供的函数与PCB中的信号集进行运算（与、或、覆盖等）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sigemptyset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;     <span class="comment">// 全部清零</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigfillset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;      <span class="comment">// 全部置1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaddset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>; <span class="comment">// 将 signum 置1</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigdelset</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>; <span class="comment">// 将 signum 置0</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigismember</span><span class="params">(<span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">int</span> signum)</span>; <span class="comment">// 判断 signum 是否为1</span></span><br></pre></td></tr></table></figure><h2 id="sigprocmask-函数"><a href="#sigprocmask-函数" class="headerlink" title="sigprocmask 函数"></a>sigprocmask 函数</h2><p>设置是否屏蔽信号，类似函数：<code>pthread_sigmask</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigprocmask</span><span class="params">(<span class="type">int</span> how, <span class="type">const</span> <span class="type">sigset_t</span> *<span class="built_in">set</span>, <span class="type">sigset_t</span> *oldset)</span>;</span><br></pre></td></tr></table></figure><ul><li>how：操作方式<ul><li>SIG_BLOCK：设置屏蔽，<code>mask = mask | set</code></li><li>SIG_UNBLOCK：解除屏蔽，<code>mask = mask &amp; ~set</code></li><li>SIG_SETMASK：覆盖，不推荐使用，<code>mask = set</code></li></ul></li><li>set：自定义的传入信号集</li><li>oldset：返回旧的信号集</li><li>返回值：成功返回0，失败返回-1</li></ul><h2 id="sigpending-函数"><a href="#sigpending-函数" class="headerlink" title="sigpending 函数"></a>sigpending 函数</h2><p>读取当前进程的未决信号集。并将其置于 set 指向的 sigset_t 结构中。随后可以使用 <code>sigismember()</code>函数来检查 set。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigpending</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">sigpending(&amp;<span class="built_in">set</span>);</span><br></pre></td></tr></table></figure><ul><li>set：传出参数，返回未决信号集</li><li>返回值：成功返回0，失败返回-1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_set</span><span class="params">(<span class="type">sigset_t</span> *<span class="built_in">set</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i &lt; <span class="number">33</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sigismember(<span class="built_in">set</span>, i))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;has : %d\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">sigset_t</span> pend, in;</span><br><span class="line">    sigemptyset(&amp;in);</span><br><span class="line">    sigaddset(&amp;in, SIGINT);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;in, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        sigpending(&amp;pend);</span><br><span class="line">        print_set(&amp;pend);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="signal-函数"><a href="#signal-函数" class="headerlink" title="signal 函数"></a>signal 函数</h2><p>UNIX 系统提供了两种方法来改变信号处置：<code>signal()</code> 和 <code>sigaction()</code>。<code>signal()</code>的行为在不同 UNIX 实现间存在差异，这也意味着对可移植性有所追求的程序绝不能使用此调用来建立信号处理器函数。故此，<code>sigaction()</code>是建立信号处理器的首选 API（强力推）。</p><p>注册一个信号捕捉函数，当收到信号时，调用该函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*<span class="type">sighandler_t</span>)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">sighandler_t</span> <span class="title function_">signal</span><span class="params">(<span class="type">int</span> signum, <span class="type">sighandler_t</span> handler)</span>;</span><br></pre></td></tr></table></figure><ul><li>signum：要注册的信号编号，<strong>该参数可以是除去 <code>SIGKILL</code> 和 <code>SIGSTOP</code> 之外的任何信号</strong>。</li><li>handler：信号处理函数，注意这里是函数指针，函数的参数是信号编号</li><li>返回值：成功返回之前的信号处理函数，失败返回<code>SIG_ERR</code>，并设置errno</li></ul><p>在为 <code>signal()</code>指定 handler 参数时，可以以如下值来代替函数地址：</p><ul><li><strong>SIG_DFL</strong> 将信号处置重置为默认值。这适用于将之前 signal()调用所改变的信号处置还原。</li><li><strong>SIG_IGN</strong> 忽略该信号。如果信号专为此进程而生，那么内核会默默将其丢弃。进程甚至从未知道曾经产生了该信号。</li></ul><h2 id="sigaction-函数"><a href="#sigaction-函数" class="headerlink" title="sigaction 函数"></a>sigaction 函数</h2><p>同 signal 函数，注册一个信号捕捉函数，在建立信号处理器程序时，<code>sigaction()</code>较之 <code>signal()</code>函数可移植性更佳。</p><p><code>sigaction()</code>允许在获取信号处置的同时无需将其改变，并且，还可设置各种属性对调用信号处理器程序时的行为施以更加精准的控制。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span>     (*sa_handler)(<span class="type">int</span>);   <span class="comment">// 信号处理函数</span></span><br><span class="line">    <span class="type">void</span>     (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *); <span class="comment">// 一般不用</span></span><br><span class="line">    <span class="type">sigset_t</span>   sa_mask; <span class="comment">// 信号屏蔽字，只作用于信号捕捉函数执行期间！</span></span><br><span class="line">    <span class="type">int</span>        sa_flags; <span class="comment">// =0 时，信号捕捉函数执行期间屏蔽当前信号</span></span><br><span class="line">    <span class="type">void</span>     (*sa_restorer)(<span class="type">void</span>);  <span class="comment">// 废弃</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_set</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;catch you : %d\n&quot;</span>, signo);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">    act.sa_handler = print_set;</span><br><span class="line">    sigemptyset(&amp;act.sa_mask);</span><br><span class="line">    act.sa_flags = <span class="number">0</span>;</span><br><span class="line">    sigaction(SIGINT, &amp;act, &amp;oldact);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a>信号捕捉特性</h3><ol><li>进程正常运行时，默认 PCB 中有一个信号屏蔽宇，假定为 X，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由X来指定。而是用 sa_mask 来指定。调用完信号处理函数，再恢复为 X。</li><li>XXX 信号捕捉函数执行期间，XXX 信号自动被屏蔽（sa_flags&#x3D;0）。</li><li>阻塞的常规信号不支持排队，产生多次只记录一次。(后 32 个实时信号支持排队)</li><li>XXX 信号捕捉函数执行期间，若信号 B 未被屏蔽，当信号 B 递达时，会从当前的执行函数跳转到 B 信号的处理函数。（信号就像中断，来了就打断当前操作）。</li></ol><h3 id="sa-flags"><a href="#sa-flags" class="headerlink" title="sa_flags"></a>sa_flags</h3><ul><li><strong>SA_RESTART</strong>：当一个系统调用被信号中断时，信号处理结束恢复执行系统调用。（不幸的是，并非所有的系统调用都可以通过指定 SA_RESTART 来达到自动重启的目的。）</li><li><strong>SA_NODEFER</strong>：捕获该信号时，不会在执行处理器程序时将该信号自动添加到进程掩码中（即不屏蔽当前信号）。</li></ul><h3 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h3><p>SUSv3 对可重入函数的定义是：<strong>函数由两条或多条线程调用时，即便是交叉执行，其效果也与各线程以未定义顺序依次调用时一致。</strong></p><p>更新全局变量或静态数据结构的函数可能是不可重入的，在 C 语言标准函数库中，这种可能性非常普遍。只用到本地变量的函数肯定是可重入的。</p><p><code>malloc()</code>和 <code>free()</code>就维护有一个针对已释放内存块的链表，用于从堆中重新分配内存。</p><p>将静态数据结构用于内部记账的函数也是不可重入的。其中最明显的例子就是 <strong>stdio 函数库成员（<code>printf()</code>、<code>scanf()</code>等）</strong>，它们会为缓冲区 I&#x2F;O 更新内部数据结构。如果在信号处理器函数中调用了 printf()，而主程序又在调用 printf()或其他 stdio 函数期间遭到了处理器函数的中断，那么有时就会看到奇怪的输出，甚至导致程序崩溃或者数据的损坏。</p><h3 id="异步信号安全函数"><a href="#异步信号安全函数" class="headerlink" title="异步信号安全函数"></a>异步信号安全函数</h3><p>异步信号安全的函数是指当从信号处理器函数调用时，可以保证其实现是安全的。如果某一函数是可重入的，又或者信号处理器函数无法将其中断时，就称该函数是异步信号安全的。</p><h2 id="pause-函数"><a href="#pause-函数" class="headerlink" title="pause 函数"></a>pause 函数</h2><p>调用 <code>pause()</code>将暂停进程的执行，直至信号处理器函数中断该调用为止（即有信号到达）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pause</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>处理信号时，<code>pause()</code>遭到中断，并总是返回−1，并将 errno 置为 EINTR。</p><h2 id="SIGCHLD-信号"><a href="#SIGCHLD-信号" class="headerlink" title="SIGCHLD 信号"></a>SIGCHLD 信号</h2><p>子进程状态发生变化时，父进程会收到 SIGCHLD 信号。</p><ul><li>子进程终止时。</li><li>子进程接收到 SIGSTOP 信号停止时。</li><li>子进程处在停止态，接受到SIGCONT 后唤醒时</li></ul><p>借助 SIGCHILD 信号回收子进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">catch_chld</span><span class="params">(<span class="type">int</span> signo)</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> wpid;</span><br><span class="line">    <span class="comment">// 注意这里使用的阻塞的方式回收！当不存在待回收的子进程时，返回-1。</span></span><br><span class="line">    <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch child id: %d\n&quot;</span>, wpid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">    <span class="comment">// 先阻塞信号，防止父进程还未注册处理函数，子进程就结束了</span></span><br><span class="line">    sigaddset(&amp;<span class="built_in">set</span>, SIGCHLD);</span><br><span class="line">    sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">15</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>;</span></span><br><span class="line">        act.sa_handler = catch_chld;</span><br><span class="line">        sigemptyset(&amp;act.sa_mask);</span><br><span class="line">        act.sa_flags = <span class="number">0</span>;</span><br><span class="line">        sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 解除阻塞</span></span><br><span class="line">        <span class="comment">// sigdelset(&amp;set, SIGCHLD);</span></span><br><span class="line">        sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i&#x27;m parent, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i&#x27;m child, pid = %d\n&quot;</span>, getpid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>了解信号产生条件，信号默认处理方式，修改信号默认处理方式。</li><li>信号处理函数要简洁！且必须保证为<strong>可重入函数</strong>或<strong>异步信号安全的函数</strong>。</li><li><code>SIGKILL, SIGSTOP</code>无法捕获，无法修改处理方式。</li><li><code>SIGCHLD</code>信号不一定是子进程结束！</li><li><code>SIGABRT</code>信号（<code>control + \</code>）可生成核心转储文件，非常方便调试程序。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://elixir.bootlin.com/linux/v5.4.190/source/include/linux/sched.h#L913">PCB 中信号相关内容 L913~L923</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-进程通信</title>
      <link href="/2022/04/25/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
      <url>/2022/04/25/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>进程之间是存在内存隔离的，所以进程间通信相对于线程间通信比较麻烦，对于两个完全隔离的事物肯定是没办法进行通信的！不过好在进程并不是完全隔离的，每个进程的地址空间中都有一段共用的内核空间，这就相当于在两个进程之间架了一座桥。所以下面介绍的很多通信方法都是基于这座桥（内核）实现的。</p><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/4-%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4.jpg" alt="img"></p><blockquote><p>本文中的部分图片来源于：<a href="https://xiaolincoding.com/os/4_process/process_commu.html#%E7%AE%A1%E9%81%93">小林coding</a></p></blockquote><h3 id="标识"><a href="#标识" class="headerlink" title="标识"></a>标识</h3><p>不过内核地址空间也不能随便给各个进程用，而且空间那么大，进程怎么知道要去哪里读写呢？第一个问题好解决，每当’我’需要和其他进程通信，我就先向内核申请一块“中继内存”，然后就可以向该地址中写数据了。不过第二个问题，其他需要读数据的进程怎么知道去哪里读呢？给读进程指定内存地址？但进程未启动的时候是不可能知道’我’向内核申请的内存地址信息的。唉，圆不了话了，反正就是想一想文件的使用，我同样不知道文件的内存地址，但我只要知道文件的路径，不管开多少个进程去打开该文件，读到的都是相同的内容（虽然文件是存储在磁盘而不是内存上，不过道理类似）。</p><p>这里的“路径+文件名”就构成了这个文件对象的唯一标识，我们在进程通信时，<strong>也需要一个能唯一标识“中继内存”的标识符</strong>，实际上，<code>Unix Socket</code>、<code>fifo</code>就是采用了“路径+文件名”作为标识！而信号量、消息队列、共享内存这三种通信方式在Linux上有两种标准实现，<code>System V</code>和<code>POSIX</code>，前者通过在使用<strong>一个整数</strong><code>key</code>来标识对象，后者使用<strong>对象名</strong>来实现（跟文件很像了）。<code>Socket</code>使用<code>ip+port</code>作为标识。</p><p>虽然大部分进程间通信都需要通过“唯一标识”去获取对应的中继对象，不过也不绝对，由于在<code>fork</code>时，子进程会复制父进程的信息，所以也可以基于此设计，比如管道<code>pipe</code>。</p><table><thead><tr><th>方式</th><th>标识</th><th>限制</th></tr></thead><tbody><tr><td>pipe</td><td>无（只能用于有血缘关系的进程间）</td><td>容量</td></tr><tr><td>fifo</td><td>路径+文件名<code>/tmp/myfifo</code></td><td>容量</td></tr><tr><td>System V 信号量、消息队列、共享内存</td><td>整数</td><td>ipcs -l</td></tr><tr><td>POSIX 消息队列</td><td></td><td>消息大小、数量</td></tr><tr><td>POSIX 信号量、消息队列、共享内存</td><td>对象名<code>/myobject</code></td><td></td></tr><tr><td>文件映射（内存映射）</td><td>路径+文件名<code>/tmp/myfile</code></td><td></td></tr><tr><td>匿名映射（内存映射）</td><td>无（只能用于有血缘关系的进程间）</td><td></td></tr><tr><td>Unix Domain Socket</td><td>路径+文件名 <code>/tmp/mysock.sock</code></td><td></td></tr><tr><td>Socket</td><td>IP + port</td><td></td></tr></tbody></table><h3 id="方式汇总"><a href="#方式汇总" class="headerlink" title="方式汇总"></a>方式汇总</h3><p>Linux 下一切皆文件，用于进程通信的对象也不例外，所以<code>pipe</code>、<code>fifo</code>、<code>socket</code>甚至消息队列，打开后都会分配一个文件描述符，通过文件描述符来读写数据（消息队列有点特殊）。</p><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/processIPC.png" alt="processIPC"></p><h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><blockquote><p>标识：无，通过 fork 时复制文件描述符的原理。</p></blockquote><p><code>Pipe</code> 管道<strong>并不会</strong>在内核或文件系统上产生唯一的标识，它基于<code>fork()</code>调用时，子进程会拷贝父进程的文件描述符列表，达到多个进程共享同一个管道的文件描述符，从而实现进程间通信。也就限制了<code>Pipe</code>管道只能用于有血缘关系的进程间通信。</p><p><code>fork()</code>之前创建管道<code>pipe(fd[2])</code>，这样每个子进程都有读端<code>fd[0]</code>和写端<code>fd[1]</code>。与所有文件描述符一样，可以使用 <code>read()</code>和<code>write()</code>系统调用来在管道上执行 I&#x2F;O。</p><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/7-%E7%AE%A1%E9%81%93-pipe-fork-%E5%8D%95%E5%90%91%E9%80%9A%E4%BF%A1.jpg" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure><ul><li><code>pipefd[0]</code> 读端</li><li><code>pipefd[1]</code> 写端</li><li>返回值：<ul><li>成功返回 <code>0</code></li><li>失败翻译 <code>-1</code> ，并设置 <code>errno</code></li></ul></li></ul><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    pipe(fd);   <span class="comment">// 创建 pipe</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *str = <span class="string">&quot;child write date!\n&quot;</span>;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>];  <span class="comment">// = &quot;&quot;;  // 不设置为空可能会出现异常</span></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// child process</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: %d, %d\n&quot;</span>, fd[<span class="number">0</span>], fd[<span class="number">1</span>]);</span><br><span class="line">        close(fd[<span class="number">0</span>]);   <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="type">int</span> ret = write(fd[<span class="number">1</span>], str, <span class="built_in">strlen</span>(str));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child write bytes ret: %d, len: %ld\n&quot;</span>, ret, <span class="built_in">strlen</span>(str));</span><br><span class="line">        close(fd[<span class="number">1</span>]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent: %d, %d\n&quot;</span>, fd[<span class="number">0</span>], fd[<span class="number">1</span>]);</span><br><span class="line">        close(fd[<span class="number">1</span>]);   <span class="comment">// 关闭写端</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> ret = read(fd[<span class="number">0</span>], buf, <span class="number">18</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent read bytes ret: %d, len: %ld\n&quot;</span>, ret, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read buf: %s&quot;</span>, buf);    <span class="comment">// 对比两种输出方式</span></span><br><span class="line">        write(STDOUT_FILENO, buf, ret);</span><br><span class="line">        close(fd[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="管道的读写行为"><a href="#管道的读写行为" class="headerlink" title="管道的读写行为"></a>管道的读写行为</h3><p><strong>最好同时只有一个读端和一个写端</strong>！</p><ul><li><p>一个管道是一个字节流，不存在消息或消息边界的概念。</p></li><li><p>通过管道传递的数据是顺序的，在管道中无法使用 <code>lseek()</code> 来随机地访问数据。</p></li><li><p><strong>管道的存储容量是有限的</strong>，一般为 <code>64kbytes</code>，容量满之后，写端被阻塞。</p><blockquote><p>虽然管道的容量大小被限制为<code>64kbytes</code>，但如果需要，进程也可通过一定方法<code>fcntl</code>来修改管道的容量。</p></blockquote></li><li><p>读管道：</p><ol><li>管道中有数据，<code>read</code> 返回实际读取的字节数，并将数据写入缓冲区</li><li>管道无数据：<ul><li>无写端：<code>read</code> 返回 0（类似读到文件末尾）</li><li>有写端：<code>read</code> 阻塞等待，直到有数据写入管道</li></ul></li></ol></li><li><p>写管道：</p><ol><li>无读端：异常终止。(<code>SIGPIPE</code> 导致)</li><li>有读端：<ul><li>管道已满，<code>write</code> <strong>阻塞等待，直到管道有空间</strong></li><li>管道未满，<code>write</code> 返回实际写入的字节数</li></ul></li></ol></li></ul><blockquote><p>虽然父进程和子进程都可以从管道中读取和写入数据，但这种做法并不常见。也可以有多个进程向单个管道中写入数据，但通常只存在一个写者。<strong>同时只有一个读端和一个写端，关闭其他不用的端口</strong>。否则可能出现以下情况：</p><ul><li>占用文件描述符；</li><li>多个进程同时读，竞争带来不确定性；</li><li>其他进程都关闭后，如果写入进程没有关闭管道的读取端，它仍然能够写入；</li><li>如果多个进程写入同一个管道，那么如果它们在一个时刻写入的数据量不超过 <code>PIPE_BUF</code> (Linux 下为4096，<code>getconf PIPE_BUF /</code>)字节，那么就可以确保写入的数据不会发生相互混合的情况（即一次原子写入的最大长度为4096 bytes）。当写入管道的数据块的大小超过了 <code>PIPE_BUF</code> 字节，那么内核可能会将数据分割成几个较小的片段来传输，就容易出现数据交叉，导致数据混乱。</li></ul></blockquote><h2 id="fifo"><a href="#fifo" class="headerlink" title="fifo"></a>fifo</h2><blockquote><p>标识：路径+文件名</p></blockquote><p><code>FIFO</code>与管道<code>Pipe</code>类似，但<strong>FIFO 会在文件系统上创建一个管道类型(p)的文件</strong>，其他进程可以通过该文件获取该管道，<code>FIFO</code>也因此可以用于无血缘关系的进程间通信。<strong>注：创建<code>FIFO</code>的进程不一定会使用该管道</strong>，也可以使用<code>mkfifo</code>命令手动创建管道文件供其他进程使用该文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mkfifo</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;/tmp/myfifo&quot;</span>;</span><br><span class="line"><span class="type">int</span> res = mkfifo(pathname, <span class="number">0664</span>);</span><br></pre></td></tr></table></figure><ul><li><code>pathname</code>：管道文件的路径 + 文件名</li><li><code>mode</code>：管道文件的权限，类似<code>0644</code></li><li>返回值：<ul><li>成功返回 <code>0</code></li><li>失败翻译 <code>-1</code> ，并设置 <code>errno</code></li></ul></li></ul><h3 id="FIFO的读写行为"><a href="#FIFO的读写行为" class="headerlink" title="FIFO的读写行为"></a>FIFO的读写行为</h3><p>FIFO也是一种管道，所以上面<strong>管道的读写行为也基本适用于FIFO</strong>！</p><p>打开<code>FIFO</code>文件和普通文件的区别有2点：</p><ol><li><p>第一<strong>不能以<code>O_RDWR</code>模式打开</strong><code>FIFO</code>文件进行读写操作。这样做的行为是未定义的。只能一个进程以<strong>只读方式<code>O_RDONLY</code>打开</strong>，另一个进程以<strong>只写方式<code>O_WRONLY</code>打开</strong>该文件。与管道一样，当所有引用 <code>FIFO</code> 的描述符都被关闭之后，所有未被读取的数据会被丢弃。</p></li><li><p>第二是对标志位的<code>O_NONBLOCK</code>选项的用法，使用这个选项不仅改变<code>open</code>调用的处理方式，还会改变对这次<code>open</code>调用返回的文件描述符进行的读写请求的处理方式。<code>O_RDONLY</code>、<code>O_WRONLY</code>和<code>O_NONBLOCK</code>标志共有四种合法的组合方式：</p><ul><li><code>flags=O_RDONLY</code>：<code>open</code>将会<strong>调用阻塞</strong>，直到另一个进程以<code>O_WRONLY</code>打开同一个<code>FIFO</code>。</li><li><code>flags=O_WRONLY</code>：<code>open</code>将会<strong>调用阻塞</strong>，直到另一个进程以<code>O_RDONLY</code>打开同一个<code>FIFO</code>。</li><li><code>flags=O_RDONLY|O_NONBLOCK</code>：<strong>立即返回</strong>，若此时没有其他进程以<code>O_WRONLY</code>打开，<code>open</code>会成功返回，此时<code>FIFO</code><strong>被读打开</strong>，不会返回错误。</li><li><code>flags=O_WRONLY|O_NONBLOCK</code>：<strong>立即返回</strong>，若此时没有其他进程以<code>O_RDONLY</code>打开，<code>open</code>会失败返回，此时<code>FIFO</code><strong>没有被打开</strong>，返回-1。</li></ul></li></ol><p><strong>当<code>FIFO</code>的其中一端关闭后，另一端也会立刻关闭</strong>，可以通过下面的例子测试：</p><h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// write fifo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;/tmp/myfifo&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(pathname, O_WRONLY);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;hello, fifo!\n&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read fifo</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pathname = <span class="string">&quot;/tmp/myfifo&quot;</span>;</span><br><span class="line">    <span class="type">int</span> fd = open(pathname, O_RDONLY);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">        bytes = read(fd, buf, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read from fifo: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FIFO</code>文件也可以直接使用命令行进行输入输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先用cat命令读取刚才创建的FIFO文件：</span></span><br><span class="line"><span class="comment"># 这个时候，cat命令将一直挂起，直到终端或者有数据发送到FIFO中。</span></span><br><span class="line"><span class="built_in">cat</span> &lt; /tmp/myfifo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后尝试向FIFO中写数据（在另外一个终端执行这个命令）</span></span><br><span class="line"><span class="comment"># 这个时候cat将会输出内容。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;FIFO test&quot;</span> &gt; /tmp/myfifo</span><br></pre></td></tr></table></figure><h2 id="UNIX-Domain-Socket"><a href="#UNIX-Domain-Socket" class="headerlink" title="UNIX Domain Socket"></a>UNIX Domain Socket</h2><blockquote><p>标识：路径+文件名</p></blockquote><p>又称<strong>本地套接字</strong><code>AF_LOCAL</code> 、<code>UNIX Domain Socket(AF_UNIX)</code>，是一种专门用于<strong>同一主机上进程间</strong>相互通信的<code>Socket</code>，同样可使用流<code>Socket</code>和数据报<code>Socket</code>。使用<code>UNIX Domain</code>发送的报文不会经过协议栈，效率更高。</p><p><code>AF_UNIX</code> 与 <code>AF_LOCAL</code> 的主要区别在于，<code>AF_UNIX</code> 是套接字族的官方名称，而 <code>AF_LOCAL</code> 是一个历史原因使用的同义词。两个常量都在 <code>&lt;sys/socket.h&gt;</code> 头文件中定义，在大多数情况下可以互换使用。</p><h3 id="sockaddr-un"><a href="#sockaddr-un" class="headerlink" title="sockaddr_un"></a>sockaddr_un</h3><p>在 <code>UNIX domain</code> 中，<code>socket</code> 地址以<strong>路径名</strong>来表示，而不是传统的<code>IP+PORT</code>。<strong>会在指定的路径上创建一个文件，以便其他进程建立连接</strong>。</p><p>为将一个 <code>UNIX domain socket</code> 绑定到一个地址上，需要初始化一个 <code>sockaddr_un</code> 结构，然后将指向这个结构的一个（转换）指针作为 <code>addr</code> 参数传入 <code>bind()</code>并将 <code>addrlen</code> 指定为这个结构的大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="type">sa_family_t</span> sun_family;   <span class="comment">/* Always AF_UNIX */</span></span><br><span class="line">    <span class="type">char</span> sun_path[<span class="number">108</span>];       <span class="comment">/* socket 对应的路径名字（最好小于92字节） */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *path = <span class="string">&quot;/tmp/test.sock&quot;</span>;</span><br><span class="line"><span class="type">int</span> sfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);    <span class="comment">// 指定domain 为 AF_UNIX</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un)); <span class="comment">// 清零</span></span><br><span class="line">addr.sun_family = AF_UNIX;</span><br><span class="line"><span class="built_in">strncpy</span>(addr.sun_path, path, <span class="keyword">sizeof</span>(addr.sun_path)<span class="number">-1</span>);  <span class="comment">// 最好使用 strncpy</span></span><br><span class="line"></span><br><span class="line">bind(sfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, sizoef(addr));  <span class="comment">// 会在文件系统中创建一个条目</span></span><br><span class="line"></span><br><span class="line">listen(sfd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> client_fd = accept(sfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">// 注意这里传入参数为NULL</span></span><br></pre></td></tr></table></figure><p>在调用<code>bind()</code>时，会依据<code>sun_path</code>创建<code>socket</code>类型的文件，该目录需要可访问可写。此外还需注意：</p><ul><li>无法将一个 <code>socket</code> 绑定到一个既有路径名上（<code>bind()</code>会失败并返回 <code>EADDRINUSE</code> 错误）。</li><li>通常会将一个 <code>socket</code> 绑定到一个<strong>绝对路径名</strong>上。</li><li>一个 <code>socket</code> 只能绑定到一个路径名上，相应地，一个路径名只能被一个 <code>socket</code> 绑定。</li><li>无法使用 <code>open()</code> 打开一个 <code>socket</code>。</li><li>当不再需要一个 <code>socket</code> 时可以使用 <code>unlink()</code>（或 <code>remove()</code>）<strong>删除其路径名条目</strong>（通常也应该这样做）。</li></ul><h3 id="example-2"><a href="#example-2" class="headerlink" title="example"></a>example</h3><p><strong>服务端</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> bytes, res, sfd, cfd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *path = <span class="string">&quot;/tmp/test.sock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    sfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// stream</span></span><br><span class="line">    <span class="keyword">if</span> (sfd == <span class="number">-1</span>) perror(<span class="string">&quot;socket() 调用失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span>    <span class="comment">// 设置地址（文件路径标识）</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un));</span><br><span class="line">    addr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strncpy</span>(addr.sun_path, path, <span class="keyword">sizeof</span>(addr.sun_path)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    res = bind(sfd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span>(addr));  <span class="comment">// 绑定地址（创建文件）</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) perror(<span class="string">&quot;bind() 调用失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    res = listen(sfd, <span class="number">128</span>);     <span class="comment">// 设置监听上限</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) perror(<span class="string">&quot;listen() 调用失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    cfd = accept(sfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);  <span class="comment">// 等待连接，这里只演示了一个连接的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">1024</span>);</span><br><span class="line">        bytes = read(cfd, buf, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span> (bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv msg: %s\n&quot;</span>, buf);</span><br><span class="line">            buf[<span class="number">0</span>] = <span class="string">&#x27;S&#x27;</span>;</span><br><span class="line">            write(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    res = unlink(path);     <span class="comment">// 用完后，就删掉绑定的文件</span></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) perror(<span class="string">&quot;unlink() 调用失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/un.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> res, bytes, cfd;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *path = <span class="string">&quot;/tmp/test.sock&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);  <span class="comment">// stream</span></span><br><span class="line">    <span class="keyword">if</span> (cfd == <span class="number">-1</span>) perror(<span class="string">&quot;socket() 调用失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sockaddr_un));</span><br><span class="line">    addr.sun_family = AF_UNIX;</span><br><span class="line">    <span class="built_in">strncpy</span>(addr.sun_path, path, <span class="keyword">sizeof</span>(addr.sun_path)<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    res = connect(cfd, (<span class="keyword">struct</span> sockaddr*)&amp;addr, <span class="keyword">sizeof</span>(addr));</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="number">-1</span>) perror(<span class="string">&quot;connect() 调用失败&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">        write(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        read(cfd, buf, <span class="number">1024</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;client recv msg: %s\n&quot;</span>, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="System-V-IPC"><a href="#System-V-IPC" class="headerlink" title="System V IPC"></a>System V IPC</h2><blockquote><p>标识：IPC key（一个整数）+ 其他参数 才能唯一标识一个IPC对象。key 可以由 ftok 得到。</p></blockquote><p><code>System V IPC</code> 包含三种方式，消息队列、共享内存、信号量。一般通信流程为：</p><ol><li>基于<code>IPC key</code>创建一个对象（消息队列、共享内存、信号量）。<code>IPC key</code>类似于文件路径，可用于标识对象。</li><li>其他进程基于<code>IPC key</code>打开该对象。<code>1,2</code>步合并在了<code>get</code>系统调用中。</li><li>多个进程操作该对象实现进程通信。</li><li>从系统中删除该对象。（即使没有进程使用，该对象也不会自动删除）</li></ol><table><thead><tr><th>接口</th><th>消息队列</th><th>共享内存</th><th>信号量</th></tr></thead><tbody><tr><td>头文件</td><td><code>&lt;sys/msg.h&gt;</code></td><td><code>&lt;sys/shm.h&gt;</code></td><td><code>&lt;sys/sem.h&gt;</code></td></tr><tr><td>数据结构</td><td><code>msqid_ds</code></td><td><code>shmid_ds</code></td><td><code>semid_ds</code></td></tr><tr><td>创建&#x2F;打开</td><td><code>msgget()</code></td><td><code>shmget()+shmat()</code></td><td><code>semget()</code></td></tr><tr><td>控制</td><td><code>msgctl()</code></td><td><code>semctl()</code></td><td><code>shmctl()</code></td></tr><tr><td>执行IPC</td><td><code>msgsnd()</code> 写入<br /><code>msgrcv()</code> 接受</td><td>访问共享区域中的内存</td><td><code>semop()</code></td></tr></tbody></table><h3 id="get-调用"><a href="#get-调用" class="headerlink" title="get 调用"></a>get 调用</h3><p>每种 <code>System V IPC</code> 机制都有一个相关的 <code>get</code> 系统调用，它<strong>与文件上的 <code>open()</code>系统调用类似</strong>。给定一个整数 <code>key</code>（类似于文件名），<code>get</code> 调用完成下列某个操作：</p><ul><li>使用给定的 key <strong>创建</strong>一个新 IPC 对象并<strong>返回一个唯一的标识符</strong>来标识该对象。</li><li>返回一个拥有给定的 key 的既有 IPC 对象的标识符（就像文件描述符）。</li></ul><p>后续的消息操作收发使用的是<strong>标识符</strong>，<code>key</code>也只是为了获取该<strong>标识符</strong>。其他进程若想使用该 IPC 对象，<strong>要么知道key（通过get取获取标识符）</strong>，<strong>要么知道该标识符</strong>，直接使用。</p><p>IPC <strong>标识符则是对象本身的一个属性并且对系统全局可见</strong>。也就是不同的进程可以通过对应的 key 获得同一个对象，且获得的标识符大小始终相等（这点与文件描述符不同）。</p><blockquote><p>这里容易误解为只要 key 相同的，就能唯一标识一个对象，实际上除了 key ，还需要 get 调用中的其他参数也一致才能唯一标识一个IPC对象，如果使用相同的 key，但其他参数不同，得到的也是不同的标识符。</p></blockquote><h3 id="IPC-Key"><a href="#IPC-Key" class="headerlink" title="IPC Key"></a>IPC Key</h3><p>消息队列、信号量、共享内存分别有一个数据结构管理其 key，或者说 shmget(100) 和 msgget(100) 返回的是不同的对象。</p><p>对于每种 IPC 机制（共享内存、消息队列、或信号量），内核都会维护一个关联的 ipc_ids 结构，它记录着该 IPC 机制的所有实例的各种全局信息，包括一个大小会动态变化的指针数组 entries，数组中的每个元素指向一个对象实例的关联数据结构（在信号量中是 semid_ds 结构）。</p><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/image-20221217105737164.png" alt="image-20221217105737164"></p><p>在执行一个 IPC get 调用时，Linux 所采用的算法近似如下：</p><ol><li>在关联数据结构列表（entries 数组中的元素指向的结构）中搜索 key 字段与 get 调用中指定的参数匹配的结构。<ol><li>没有找到，且没有指定 IPC_CREAT，返回 ENOENT 错误</li><li>找到了，但指定了 IPC_CREAT | IPC_EXCL ，返回 EEXIST 错误</li><li>否则在找到一个匹配的结构的情况下跳过下面的步骤。</li></ol></li><li>没有找到且指定了 IPC_CREAT ，分配一个新的 IPC 对象并对其初始化，在这个操作中还会更新 ipc_ids 结构中的各个字段，并且可能还会重新设定 entries 数组的大小。</li><li>使用公式计算 IPC 对象的标识符。</li></ol><h3 id="ftok"><a href="#ftok" class="headerlink" title="ftok"></a>ftok</h3><p>如果单纯用数字 key 来标识（当然还有参数），数字不能像字符串那样具备一定含义，不那么方便，而且容易重复。所以也提供了一个函数 ftok 从一个文件 + 数字 来生成 key。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">key_t</span> <span class="title function_">ftok</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> proj_id)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>pathname</code>：一个实际存在的文件路径。</li><li><code>proj_id</code>：一个数字，目的仅仅是允许从同一个文件中生成多个 key 。</li><li>返回值：<ul><li>成功，在 Linux 上，返回的是一个 32 位的值。</li><li>失败返回 -1。</li></ul></li></ul><p>在 Linux 上，返回值是取 proj 参数的最低 8 个有效位、包含该文件所属的文件系统的设备的设备号（即次要设备号）的最低 8 个有效位以及 pathname 所引用的文件的 i-node 号（<strong>并不是基于pathname这个字符串来计算</strong>）的最低 16 个有效位组合而成。</p><h3 id="对象删除"><a href="#对象删除" class="headerlink" title="对象删除"></a>对象删除</h3><p>System V IPC 对象具备内核持久性。一旦被创建之后，一个对象就一直存在直到它被显式地删除或系统被关闭。每种 IPC 都有相关的控制操作，其中 IPC_RMID 控制操作可以实现删除 IPC 对象，<strong>对于消息队列和信号量来讲，IPC 对象的删除是立即生效的，对象中包含的所有信息都会被销毁，不管是否有其他进程仍然在使用该对象</strong>（这带来了一定的缺陷，有时候并不容易确定哪个进程是最后一个退出的）。共享内存对象的删除的操作是不同的。在 shmctl(id,IPC_RMID, NULL)调用之后，只有当所有使用该内存段的进程与该内存段分离之后（使用 shmdt()）才会删除该共享内存段。</p><h3 id="ipcs-ipcrm"><a href="#ipcs-ipcrm" class="headerlink" title="ipcs, ipcrm"></a>ipcs, ipcrm</h3><p>ipcs 和 ipcrm 命令是 System V IPC 领域中类似于 ls 和 rm 文件命令的命令。</p><p>使用 ipcs 能够获取系统上 IPC 对象的信息：</p><blockquote><p>&#x2F;proc&#x2F;sysvipc 目录中的文件也会列出所有 IPC 对象！</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">------ Message Queues --------              队列数据字节数 消息数量</span><br><span class="line">key        标识符      所有者      权限        对象特有信息</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------      区域大小    使用进程数   状态标记</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status</span><br><span class="line"><span class="number">0x510715a7</span> <span class="number">7</span>          yogurt     <span class="number">600</span>        <span class="number">152</span>        <span class="number">1</span></span><br><span class="line"><span class="number">0x00000000</span> <span class="number">12</span>         yogurt     <span class="number">600</span>        <span class="number">1048576</span>    <span class="number">2</span>          dest</span><br><span class="line"><span class="number">0x00000000</span> <span class="number">16</span>         yogurt     <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          dest</span><br><span class="line"><span class="number">0x00000000</span> <span class="number">20</span>         yogurt     <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          dest</span><br><span class="line"><span class="number">0x00000000</span> <span class="number">21</span>         yogurt     <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          dest</span><br><span class="line"><span class="number">0x00000000</span> <span class="number">24</span>         yogurt     <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          dest</span><br><span class="line"><span class="number">0x00000000</span> <span class="number">27</span>         yogurt     <span class="number">600</span>        <span class="number">524288</span>     <span class="number">2</span>          dest</span><br><span class="line"><span class="number">0x00000000</span> <span class="number">30</span>         yogurt     <span class="number">600</span>        <span class="number">1048576</span>    <span class="number">2</span>          dest</span><br><span class="line"><span class="number">0x00000000</span> <span class="number">33</span>         yogurt     <span class="number">600</span>        <span class="number">134217728</span>  <span class="number">2</span>          dest</span><br><span class="line"></span><br><span class="line">------ Semaphore Arrays --------            信号集大小</span><br><span class="line">key        semid      owner      perms      nsems</span><br><span class="line"><span class="number">0x510715a6</span> <span class="number">1</span>          yogurt     <span class="number">600</span>        <span class="number">1</span></span><br></pre></td></tr></table></figure><p>使用 ipcrm 删除对象：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- Delete a shared memory segment by ID:</span><br><span class="line">  ipcrm --shmem-id &#123;&#123;shmem_id&#125;&#125;</span><br><span class="line"></span><br><span class="line">- Delete a shared memory segment by key:</span><br><span class="line">  ipcrm --shmem-key &#123;&#123;shmem_key&#125;&#125;</span><br><span class="line"></span><br><span class="line">- Delete an IPC queue by ID:</span><br><span class="line">  ipcrm --queue-id &#123;&#123;ipc_queue_id&#125;&#125;</span><br><span class="line"></span><br><span class="line">- Delete an IPC queue by key:</span><br><span class="line">  ipcrm --queue-key &#123;&#123;ipc_queue_key&#125;&#125;</span><br><span class="line"></span><br><span class="line">- Delete a semaphore by ID:</span><br><span class="line">  ipcrm --semaphore-id &#123;&#123;semaphore_id&#125;&#125;</span><br><span class="line"></span><br><span class="line">- Delete a semaphore by key:</span><br><span class="line">  ipcrm --semaphore-key &#123;&#123;semaphore_key&#125;&#125;</span><br><span class="line"></span><br><span class="line">- Delete all IPC resources:</span><br><span class="line">  ipcrm --all</span><br></pre></td></tr></table></figure><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>由于 System V IPC 对象会消耗系统资源，因此内核对各种 IPC 对象进行了各式各样的限制以防止资源被耗尽。</p><p>在 Linux 上，ipcs –l 命令可以用来列出各种 IPC 机制上的限制。</p><table><thead><tr><th></th><th>限制</th><th>解释</th></tr></thead><tbody><tr><td></td><td></td><td>部分限制变量位于 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F; ，变量名为文件名</td></tr><tr><td>消息队列</td><td>MSGMNI</td><td>系统级，系统中所能创建的消息队列的数量，32000</td></tr><tr><td></td><td>MSGMAX</td><td>系统级，单条消息中最多可写入的字节数（mtext），8192</td></tr><tr><td></td><td>MSGMNB</td><td>系统级，一个消息队列中一次最多保存的字节数（mtext），16384</td></tr><tr><td></td><td>MSGTQL</td><td>系统级，系统中所有消息队列所能存放的消息总数</td></tr><tr><td></td><td>MSGPOOL</td><td>系统级，用来存放系统中所有消息队列中的数据的缓冲池的大小</td></tr><tr><td>信号量</td><td>SEMMNI</td><td>系统级，限制了所能创建的信号量标识符的数量，32000</td></tr><tr><td></td><td>SEMMSL</td><td>一个信号量集中能分配的信号量的最大数量，32000</td></tr><tr><td></td><td>SEMMNS</td><td>系统级，所有信号量集中的信号量数量，1024000000</td></tr><tr><td></td><td>SEMOPM</td><td>每个 semop()调用能够执行的操作的最大数量，500</td></tr><tr><td></td><td>SEMVMX</td><td>一个信号量能取的最大值</td></tr></tbody></table><h2 id="Sys-消息队列"><a href="#Sys-消息队列" class="headerlink" title="Sys 消息队列"></a>Sys 消息队列</h2><p>System V 消息队列中的消息是以<strong>块</strong>的形式存储的，这些块由<strong>消息类型</strong>和<strong>数据</strong>两部分组成。消息类型是一个整数，可以用来区分不同类型的消息，而数据则是一段二进制数据，可以用来存储消息的具体内容。（<strong>每个块的大小可以是不相同的</strong>！）</p><p>消息队列本身是以<strong>链表</strong>的形式组织的，所有的消息都按照消息类型和发送时间的顺序依次排列。进程可以通过指定消息类型来发送或接收特定类型的消息。</p><p><strong>消息队列本身就具有同步功能</strong>，可以保证在同一时刻只有一个进程能够访问队列。</p><h3 id="msgget"><a href="#msgget" class="headerlink" title="msgget"></a>msgget</h3><p>创建一个新消息队列或取得一个既有队列的标识符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>key</code>：上面的 IPC key。</li><li><code>msgflg</code>：指定施加于新消息队列之上的权限或检查一个既有队列的权限的位掩码，以及 IPC_CREAT | IPC_EXCL。</li><li>返回值：<ul><li>成功返回标识符。</li><li>失败返回 -1。</li></ul></li></ul><h3 id="msgsnd"><a href="#msgsnd" class="headerlink" title="msgsnd"></a>msgsnd</h3><p>消息队列的 IO 函数。msgsnd msgrcv 这两个系统调用接收的第一个参数是消息队列标识符（msqid）。第二个参数 msgp 是一个<strong>由程序员定义的</strong>结构的指针，该结构用于存放被发送或接收的消息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 下面这个结构需要你自己定义！mtext也可以设置为定长 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;       <span class="comment">/* message type, must be &gt; 0 */</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">1</span>];    <span class="comment">/* message data */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>消息的第一个部分包含了消息类型，它用一个类型为 long 的整数来表示，而消息的剩余部分则是由程序员定义的一个结构，其长度和内容可以是任意的，而无需是一个字符数组。因此 mgsp 参数的类型为 void *，这样就允许传入任意结构的指针了。mtext 字段长度可以为零，当对于接收进程来讲所需传递的信息仅通过消息类型就能表示或只需要知道一条消息本身是否存在时，这种做法有时候就变得非常有用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure><p>将 msgp 指向的消息内容复制进内核消息队列链表中，存在内存拷贝。</p><ul><li>msgp ：待发送的消息 msgbuf 地址；其中 mtype 必须指定为 &gt;0 的数。</li><li>msgsz ：指定了 msgbuf.mtext 字段中包含的字节数；不是 msgbuf 的总长度；</li><li>msgflg ：一组标记的位掩码，用于控制 msgsnd()的操作，目前定义了：<ul><li>IPC_NOWAIT，执行非阻塞发送；通常当消息队列满时，msgsnd()会阻塞直到队列中有足够的空间来存放这条消息。但如果指定了这个标记，那么 msgsnd()就会立即返回 EAGAIN 错误。</li></ul></li><li>返回值：<ul><li>成功返回 0；（注意不是返回发送字节数）</li><li>失败返回 -1；阻塞发送时，被信号处理器中断设置 EINTR 错误。</li></ul></li></ul><h3 id="msgrcv"><a href="#msgrcv" class="headerlink" title="msgrcv"></a>msgrcv</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp,</span></span><br><span class="line"><span class="params">               <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure><p>从消息队列中取出并删除一条消息，将其内容复制到 msgp 指向的缓冲区中。</p><ul><li>msgsz ：预分配的缓冲区 msgbuf 中 mtext 字段的大小；如果队列中待删除的消息体的大小超过了msgsz 字节，那么就不会从队列中删除消息，并且 msgrcv() 会返回错误 E2BIG。</li><li>msgtyp ：指定接收的消息类型；<ul><li>如果 &gt;0，则返回并删除指定消息类型的第一条消息。</li><li>如果 &#x3D;0，则删除队列中的第一条消息并将其返回给调用进程。</li><li>如果 &lt;0，则将等待消息当成优先队列来处理！队列中 mtype 最小并且其值小于或等于 msgtyp 的绝对值的第一条消息会被删除并返回给调用进程。</li><li>通过指定不同的 msgtyp 值，多个进程能够从同一个消息队列中读取消息而不会出现竞争读取同一条消息的情况。比较有用的一项技术是让各个进程选取与自己的进程 ID 匹配的消息。</li></ul></li><li>msgflg ：位掩码；<ul><li>IPC_NOWAIT 执行一个非阻塞接收；</li><li>MSG_EXCEPT只有当 msgtyp 大于 0 时这个标记才会起作用，它会强制对常规操作进行补足，即将队列中第一条 mtype 不等于 msgtyp 的消息删除并将其返回给调用者。</li><li>MSG_NOERROR在默认情况下，当消息的 mtext 字段的大小超过了可用空间时（由 maxmsgsz 参数定义），msgrcv()调用会失败。如果指定了 MSG_NOERROR 标记，那么 msgrcv()将会从队列中删除消息并将其 mtext 字段的大小截短为maxmsgsz 字节，然后将消息返回给调用者。被截去的数据将会丢失。</li></ul></li><li>返回值：<ul><li>成功返回接收到的消息中 mtext 字段的大小；</li><li>错误返回 -1；</li></ul></li></ul><h3 id="msgctl"><a href="#msgctl" class="headerlink" title="msgctl"></a>msgctl</h3><p>在标识符为 msqid 的消息队列上执行控制操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 删除消息队列 */</span></span><br><span class="line"><span class="type">int</span> err = msgctl(msqid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>cmd ：指定了在队列上执行的操作：<ul><li>IPC_RMID 立即删除消息队列对象及其关联的 msqid_ds 数据结构。<strong>队列中所有剩余的消息都会丢失</strong>！</li><li>IPC_STAT 将与这个消息队列关联的 msqid_ds 数据结构的副本放到 buf 指向的缓冲区中。</li><li>IPC_SET 使用 buf 指向的缓冲区提供的值更新与这个消息队列关联的 msqid_ds 数据结构中被选中的字段。</li></ul></li><li>buf ：部分控制操作会用到，没有用到的操作传入 NULL 即可。</li><li>返回值：<ul><li>成功执行的返回值与对应的操作有关，IPC_STAT, IPC_SET, IPC_RMID 返回 0。</li><li>失败返回 -1 。</li></ul></li></ul><h3 id="example-3"><a href="#example-3" class="headerlink" title="example"></a>example</h3><p>发送段：在发送过程中可以通过 ipcs 查看消息队列中的消息数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">100</span>, err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;./ipc_sysv_msg_snd.c&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 创建 System V 消息队列 */</span></span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, <span class="number">0664</span> | IPC_CREAT | IPC_EXCL);</span><br><span class="line">    <span class="keyword">if</span> (msgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget error: &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 发送消息 */</span></span><br><span class="line">    buf.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">sprintf</span>(buf.mtext, <span class="string">&quot;%d&quot;</span>, i);</span><br><span class="line">        err = msgsnd(msgid, &amp;buf, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgsnd failed!&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="comment">/* 删除消息队列 */</span></span><br><span class="line">    err = msgctl(msgid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgctl RMID failed!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收端：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">100</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">100</span>, err;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> <span class="title">buf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">key_t</span> key = ftok(<span class="string">&quot;./ipc_sysv_msg_snd.c&quot;</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开 System V 消息队列 */</span></span><br><span class="line">    <span class="type">int</span> msgid = msgget(key, <span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span> (msgid == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msgget error: &quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 接收消息 */</span></span><br><span class="line">    buf.mtype = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i--) &#123;</span><br><span class="line">        err = msgrcv(msgid, &amp;buf, <span class="number">100</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;msgsnd failed!&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg.type: %ld, data: %s\n&quot;</span>, buf.mtype, buf.mtext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Sys-信号量"><a href="#Sys-信号量" class="headerlink" title="Sys 信号量"></a>Sys 信号量</h2><blockquote><p>System V 信号量是一种持久性的数据类型，意味着它们在系统重启之后仍然存在。但是，System V 信号量不会被保存到磁盘上，因此在系统重启之后，所有的信号量都将被初始化为 0。</p></blockquote><p>在多线程中，如果多个线程要访问同一个变量，为了避免多个线程同时写导致数据异常，会采用互斥锁、读写锁、信号量等同步机制，在进程通信时，也会出现两个进程同时访问某段内存的情况，同样需要一种同步机制，而且其实现应该由内核完成，这样才能让多个进程都能访问到。</p><p>在上面介绍的消息队列中，并不需要专门去同步，它本身就具有同步功能。不过下面的共享内存，大多数情况下都得配合信号量使用！</p><p>一个信号量是一个由内核维护的整数，<strong>其值被限制为大于或等于 0</strong>。在一个信号量上可以执行各种操作（即系统调用），包括：</p><ul><li>将信号量设置成一个绝对值；</li><li>在信号量当前值的基础上加上一个数量；</li><li>在信号量当前值的基础上减去一个数量；（试图使信号量降低到 0 之下时<strong>阻塞</strong>）</li><li>等待信号量的值等于 0。（信号量的当前值不为 0 时<strong>阻塞</strong>）</li></ul><blockquote><p>语义上来讲，增加信号量值对应于使一种资源变得可用以便其他进程可以使用它，而减小信号量值则对应于预留（互斥地）进程需使用的资源。在减小一个信号量值时，如果信号量的值太低——即其他一些进程已经预留了这个资源——那么操作就会被阻塞。</p></blockquote><p>使用 System V 信号量的常规步骤如下：</p><ol><li>创建信号量：使用 semget() 函数创建一个新的<strong>信号量集</strong>，或者打开一个现有的信号量集。</li><li>初始化信号量：使用 semctl() 函数初始化信号量的值。</li><li>获取信号量：使用 semop() 函数获取信号量。这会使信号量的值减少 1。</li><li>释放信号量：使用 semop() 函数释放信号量。这会使信号量的值增加 1。</li><li>删除信号量：使用 semctl() 函数 IPC_RMID 删除信号量集。</li></ol><blockquote><p>上面提到的信号量集是什么意思，一个信号量不应该就一个整数值吗？</p><p>(chatgpt) 答：在 System V 信号量中，一个信号量集是一组信号量的集合。每个信号量集都有一个唯一的标识符，称为信号量集标识符。每个信号量集中可以包含多个信号量。每个信号量都有一个整数值，可以用来控制进程的访问。使用信号量集的好处在于，你可以通过一个信号量集管理多个信号量，而不是一个一个地管理。这样，你就可以使用一个函数调用来管理多个信号量，而不是多个函数调用。</p></blockquote><h3 id="semget"><a href="#semget" class="headerlink" title="semget"></a>semget</h3><p>创建一个新信号量集或获取一个既有集合的标识符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br></pre></td></tr></table></figure><ul><li>key ：前面的 IPC key；</li><li>nsems ：指定集合中信号量的数量，并且其值必须大于 0。如果是获取既有集合的标识符，nsems 必须小于等于集合的大小。</li><li>semflg ：位掩码，指定权限 + IPC_CREAT | IPC_EXCL</li><li>返回值：<ul><li>成功返回标识符；</li><li>失败返回 -1；</li></ul></li></ul><h3 id="semctl"><a href="#semctl" class="headerlink" title="semctl"></a>semctl</h3><p>在一个信号量集或集合中的单个信号量上执行各种控制操作。初始化信号量、删除信号量集等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ... <span class="comment">/* union semun arg */</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>              val;    <span class="comment">/* Value for SETVAL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>    <span class="comment">/* Buffer for IPC_STAT, IPC_SET */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span>  *<span class="built_in">array</span>;  <span class="comment">/* Array for GETALL, SETALL */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>  *__<span class="title">buf</span>;</span>  <span class="comment">/* Buffer for IPC_INFO</span></span><br><span class="line"><span class="comment">                                           (Linux-specific) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>semid ：信号量集的标识符；</li><li>semnum ：标识要操作的集合中具体的信号量，不需要该变量的操作会忽略它，可以设置为0。</li><li>cmd ：指定了需执行的操作，某些操作会用到第四个参数 <code>union semun</code>：<ul><li><strong>IPC_RMID</strong> 立即<strong>删除信号量集</strong>及其关联的 semid_ds 数据结构。无需 arg 参数。</li><li>GETVAL 返回由 semid 指定的信号量集中第 semnum 个信号量的值。</li><li><strong>SETVAL</strong> 将由 semid 指定的信号量集中第 semnum 个信号量的值<strong>初始化</strong>为 arg.val。</li><li>GETALL 获取由 semid 指向的信号量集中所有信号量的值并将它们放在 arg.array 指向的数组中。<br>  程序员必须要确保该数组具备足够的空间。</li><li><strong>SETALL</strong> 使用 arg.array 指向的数组中的值<strong>初始化</strong> semid 指向的集合中的所有信号量。</li></ul></li></ul><h3 id="semop"><a href="#semop" class="headerlink" title="semop"></a>semop</h3><p>在 semid 标识的信号量集中的信号量上执行一个或<strong>多个</strong>操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nsops)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">semtimedop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nsops,</span></span><br><span class="line"><span class="params">               <span class="type">const</span> <span class="keyword">struct</span> timespec *timeout)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sem_num;  <span class="comment">/* semaphore number */</span></span><br><span class="line">    <span class="type">short</span>          sem_op;   <span class="comment">/* semaphore operation */</span></span><br><span class="line">    <span class="type">short</span>          sem_flg;  <span class="comment">/* operation flags */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sops ：指向数组的指针，数组中包含了需要执行的操作。<ul><li>sem_num ：指定操作的信号量；</li><li>sem_op ：指定需要执行的操作：<ul><li>如果 sem_op 大于 0，那么就将 sem_op 的值加到信号量值上，其结果是其他等待减小信号量值的进程可能会被唤醒并执行它们的操作。</li><li>如果 sem_op 等于 0，那么就对信号量值进行检查以确定它当前是否等于 0。如果等于 0，那么操作将立即结束，否则 semop()就会阻塞直到信号量值变成 0 为止。</li><li>如果 sem_op 小于 0，那么就将信号量值减去 sem_op。如果信号量的当前值大于或等于 sem_op 的绝对值，那么操作会立即结束。否则 semop()会阻塞直到信号量值增长到在执行操作之后不会导致出现负值的情况为止。</li></ul></li></ul></li><li>nsops ：数组的大小，数组至少需要一个元素！操作将会<strong>按照在数组中的顺序以原子的方式被执行</strong>。</li></ul><h2 id="Sys-共享内存"><a href="#Sys-共享内存" class="headerlink" title="Sys 共享内存"></a>Sys 共享内存</h2><p>todo</p><h2 id="mmap-内存映射"><a href="#mmap-内存映射" class="headerlink" title="mmap 内存映射"></a>mmap 内存映射</h2><p><code>mmap</code>映射方式有两种，一是文件映射，二是匿名映射。映射属性也有两种：私有<code>MAP_PRIVATE</code> 和共享<code>MAP_SHARED</code>。其四种组合如下：</p><ul><li><strong>私有文件</strong>：分配一段内存，其内容用文件的内容初始化，文件的作用也只在于初始化，后续在内存上的修改也不会再同步到文件上。多个进程映射同一个文件同一区域时，一开始会共享同一个物理内存分页，采用<strong>写时复制技术</strong>保证各个进程不共享。</li><li><strong>私有匿名</strong>：分配一段内存，会用0填充内存。每次调用都会创建一个新的映射，不会共享同一个物理页。通过<code>fork()</code>创建子进程时，也会采用<strong>写时复制技术</strong>保证不共享。</li><li><strong>共享文件</strong>：分配一段内存，其内容用文件的内容初始化，对内存的修改内核也会选择合适的时机同步到文件上。多个进程映射同一个文件同一区域时，共享同一个物理内存分页，也就是<strong>共享内存机制</strong>。</li><li><strong>共享匿名</strong>：分配一段内存，会用0填充内存。当通过<code>fork()</code>创建子进程时，父子进程共享同样的物理分页，而不会采用写时复制技术。也就实现了有血缘关系的进程间的共享内存（类似与<code>pipe</code>，只能用于有血缘关系的进程）。</li></ul><p>一个进程在执行 <code>exec()</code> 时映射会丢失，但通过 <code>fork()</code> 创建的子进程会继承映射，映射类型（<code>MAP_PRIVATE</code> 或 <code>MAP_SHARED</code>）也会被继承</p><h3 id="mmap-函数"><a href="#mmap-函数" class="headerlink" title="mmap 函数"></a>mmap 函数</h3><p><code>mmap()</code>系统调用在调用进程的虚拟地址空间中创建一个新映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>addr</code>：指定映射被放置的虚拟地址（仅作内核参考，还涉及分页对齐），一般为<code>NULL</code>，由内核自动选定</li><li><code>length</code>：指定映射的字节数。实际映射大小会向上提升为分页大小的倍数</li><li><code>prot</code>：位掩码，指定施加于映射之上的保护信息，要么是<code>PROT_NONE</code>，要么是其他三个标记的组合<ul><li><code>PROT_NONE</code> 区域无法访问</li><li><code>PROT_READ</code> 区域内容可读取</li><li><code>PROT_WRITE</code> 区域内容可修改</li><li><code>PROT_EXEC</code> 区域内容可执行</li></ul></li><li><code>flag</code>：控制映射操作各个方面的选项的位掩码，这个掩码必须只包含下列值中一个：<ul><li><code>MAP_PRIVATE</code> 创建一个私有映射</li><li><code>MAP_SHARED</code> 创建一个共享映射</li></ul></li><li>剩余的参数 <code>fd</code> 和 <code>offset</code> 是用于文件映射的（匿名映射将忽略它们）</li><li>返回值：<ul><li>成功：映射的起始地址</li><li>失败：返回<code>MAP_FAILED</code></li></ul></li></ul><p>一个文件映射的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="munmap-函数"><a href="#munmap-函数" class="headerlink" title="munmap 函数"></a>munmap 函数</h3><p>与<code>mmap()</code>相反，从进程虚拟地址中删除一个映射。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>addr</code>：需要解除映射的地址范围的起始地址。通常传<code>mmap</code>的返回值。</li><li><code>length</code>：需要解除映射的地址范围的大小，一般与<code>mmap</code>中的大小一致，也会自动页对齐。</li><li>返回值：</li></ul><h2 id="POSIX-IPC"><a href="#POSIX-IPC" class="headerlink" title="POSIX IPC"></a>POSIX IPC</h2><ul><li>消息队列：类似与数据包，每个消息独立。与System V 标准中的消息队列不同，POSIX不区分消息类型，但每个消息有一个优先级，优先级高的消息先被处理。</li><li>信号量：也是由内核维护的整数，其值永远都不会小于0。</li><li>共享内存</li></ul><h3 id="标识-1"><a href="#标识-1" class="headerlink" title="标识"></a>标识</h3><p>在 SUSv3 中规定的唯一一种用来标识 POSIX IPC 对象的可移植的方式是使用<strong>以斜线打头后面跟着一个或多个非斜线字符的名字</strong>，如 &#x2F;myobject，注意<strong>不能</strong>是 <code>/tmp/myobject</code>！</p><p>对象名称看起来像在根目录下的文件名，在某些系统上，也确实会创建该文件，而非特权用户又无法在根目录下创建文件，所以要保证程序的可移植性需要注意对象名的选择。</p><p>在 Linux 上，POSIX 共享内存和消息队列对象的名字的最大长度为 NAME_MAX（255）个字符，而信号量的名字的最大长度要少 4 个字符，这是因为实现会在信号量名字前面加上字符串 sem.</p><table><thead><tr><th>接口</th><th>消息队列</th><th>信号量</th><th>共享内存</th></tr></thead><tbody><tr><td>头文件</td><td>&lt;mqueue.h&gt;</td><td></td><td></td></tr><tr><td>对象句柄</td><td>mqd_t</td><td></td><td></td></tr><tr><td>创建&#x2F;打开</td><td>mq_open()</td><td></td><td></td></tr><tr><td>关闭</td><td>mq_close()</td><td></td><td></td></tr><tr><td>断开链接</td><td>mq_unlink()</td><td></td><td></td></tr><tr><td>执行 IPC</td><td>mq_send()<br />mq_receive()</td><td></td><td></td></tr><tr><td>其他操作</td><td>mq_setattr()<br />mq_getattr()<br />mq_notify()</td><td></td><td></td></tr></tbody></table><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>在 Linux 上，POSIX 消息队列被实现成了虚拟文件系统中的 i-node，并且消息队列描述符也是文件描述符。</p><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/image-20221216152710119.png" alt="image-20221216152710119"></p><p>验证文件描述符与消息队列描述符的关系：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* For O_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> <span class="comment">/* For mode constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ipc_object = <span class="string">&quot;/msgqueue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">    attr.mq_maxmsg = <span class="number">100</span>;</span><br><span class="line">    attr.mq_msgsize = <span class="number">1500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd1, fd2;</span><br><span class="line">    fd1 = open(<span class="string">&quot;./test1&quot;</span>, O_CREAT|O_WRONLY, <span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;随便打开了个文件，其fd = %d\n&quot;</span>, fd1);</span><br><span class="line"></span><br><span class="line">    <span class="type">mqd_t</span> obj = mq_open(ipc_object, O_CREAT|O_EXCL|O_RDWR, <span class="number">0664</span>, &amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (obj &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msg_queue open failed!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;创建并打开了消息队列，其msg_queue id: %d\n&quot;</span>, obj);</span><br><span class="line"></span><br><span class="line">    fd2 = open(<span class="string">&quot;./test2&quot;</span>, O_CREAT|O_WRONLY, <span class="number">0664</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;随便打开了个文件，其fd = %d\n&quot;</span>, fd2);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line">    close(fd2);</span><br><span class="line">    unlink(<span class="string">&quot;./test1&quot;</span>);</span><br><span class="line">    unlink(<span class="string">&quot;./test2&quot;</span>);</span><br><span class="line">    mq_close(obj);</span><br><span class="line">    mq_unlink(ipc_object);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// gcc test.c -o test &amp;&amp; ./test</span></span><br></pre></td></tr></table></figure><h4 id="队列特性"><a href="#队列特性" class="headerlink" title="队列特性"></a>队列特性</h4><p>也可以说是队列参数，先自己思考一下，实现一个队列需要指定哪些参数呢？队列的大小（可以容纳的消息数量）、每个消息的长度、当前队列中有多少消息。</p><p>mq_open()、mq_getattr()以及 mq_setattr()函数都会接收一个参数，它是一个指向 mq_attr 结构的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mq_flags;       <span class="comment">/* Flags (ignored for mq_open()) */</span></span><br><span class="line">    <span class="type">long</span> mq_maxmsg;      <span class="comment">/* Max. # of messages on queue */</span></span><br><span class="line">    <span class="type">long</span> mq_msgsize;     <span class="comment">/* Max. message size (bytes) */</span></span><br><span class="line">    <span class="type">long</span> mq_curmsgs;     <span class="comment">/* # of messages currently in queue</span></span><br><span class="line"><span class="comment">                                       (ignored for mq_open()) */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 查看默认参数：</span></span><br><span class="line"><span class="comment">    mq_flags: 0, O_NONBLOCK: 2048</span></span><br><span class="line"><span class="comment">    mq_maxmsg: 10</span></span><br><span class="line"><span class="comment">    mq_msgsize: 8192</span></span><br><span class="line"><span class="comment">    mq_curmsgs: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_default_attr</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *ipc_key = <span class="string">&quot;/default_attr&quot;</span>;</span><br><span class="line">    <span class="type">mqd_t</span> obj = mq_open(ipc_object, O_CREAT|O_EXCL|O_RDWR, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msg_queue open failed!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">    <span class="type">int</span> err = mq_getattr(obj, &amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (err == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;getattr error!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mq_flags: %lld, O_NONBLOCK: %lld\n&quot;</span>, attr.mq_flags, O_NONBLOCK);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mq_maxmsg: %lld\n&quot;</span>, attr.mq_maxmsg);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mq_msgsize: %lld\n&quot;</span>, attr.mq_msgsize);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;mq_curmsgs: %lld\n&quot;</span>, attr.mq_curmsgs);</span><br><span class="line"></span><br><span class="line">    mq_close(obj);</span><br><span class="line">    mq_unlink(ipc_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mq-open"><a href="#mq-open" class="headerlink" title="mq_open"></a>mq_open</h4><p>创建一个新的消息队列或者打开现有的消息队列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span>           <span class="comment">/* For O_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span>        <span class="comment">/* For mode constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">mqd_t</span> <span class="title function_">mq_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag)</span>;</span><br><span class="line"><span class="type">mqd_t</span> <span class="title function_">mq_open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> oflag, <span class="type">mode_t</span> mode,</span></span><br><span class="line"><span class="params">              <span class="keyword">struct</span> mq_attr *attr)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>name</code>：<code>IPC key</code>，对象标识；</p></li><li><p><code>oflag</code>：和<code>open</code>中的<code>flag</code>类似，控制打开参数，读写、创建、非阻塞等。</p><ul><li>O_CREAT | O_EXCL</li><li>O_RDONLY | O_WRONLY | O_RDWR</li><li>O_NONBLOCK</li></ul></li><li><p>如果<code>oflag</code>中指定的<code>O_CREAT</code>，就还需要<code>mode</code>和<code>attr</code>，分别控制文件权限，和消息队列的特性。</p><ul><li><code>mode</code>：文件权限，<code>0664</code>，类似与<code>chmod</code>修改权限时用的值。</li><li><code>attr</code>：指定消息队列的参数，也可以用<code>NULL</code>使用默认值。</li><li>指定队列参数时，最好使用<code>O_EXCL</code>，否则由于队列已经存在，其参数若与指定的参数不一致，可能会导致后续的<code>mq_receive</code>出错。</li></ul></li><li><p>返回值：</p><ul><li>调用成功，返回一个消息队列描述符（<code>&gt;0</code>），后续用它来引用该消息队列。</li><li>调用失败，返回 <code>-1</code>。</li></ul></li></ul><h4 id="mq-close"><a href="#mq-close" class="headerlink" title="mq_close"></a>mq_close</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mq_close</span><span class="params">(<span class="type">mqd_t</span> mqdes)</span>;</span><br></pre></td></tr></table></figure><p>关闭一个消息队列，进程应该主动关闭不使用的消息队列，避免消息队列描述符耗尽。注意，关闭并不会删除该消息队列。删除需要使用<code>mq_unlink</code>。</p><h4 id="mq-unlink"><a href="#mq-unlink" class="headerlink" title="mq_unlink"></a>mq_unlink</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mq_unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p>删除指定<code>name</code>标识的消息队列，并将队列标记为在所有进程使用完后销毁。</p><h4 id="mq-send"><a href="#mq-send" class="headerlink" title="mq_send"></a>mq_send</h4><p>将位于 msg_ptr 指向的缓冲区中的消息添加到描述符 mqdes 所引用的消息队列中，还需要指定消息的长度、消息的优先级，另外注意该过程存在内存拷贝。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mq_send</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="type">char</span> *msg_ptr,</span></span><br><span class="line"><span class="params">            <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> msg_prio)</span>;</span><br></pre></td></tr></table></figure><ul><li>msg_ptr：指向待发送消息地址；</li><li>msg_len：待发送消息长度；</li><li>msg_prio：待发送消息优先级；</li><li>返回值：<ul><li>成功返回 <code>0</code>；</li><li>失败返回 <code>-1</code>；</li></ul></li></ul><p>每条消息都拥有一个用非负整数表示的优先级，0表示最低优先级，优先级的上限在不同系统上也有差异，SUSv3 要求这个上限至少是 32，这可以通过定义常量 MQ_PRIO_MAX指定，在Linux上，为32768。</p><blockquote><p><code>getconf -a | grep MQ_PRIO_MAX</code></p></blockquote><p>当一条消息被添加到队列中时，它会被放置在队列中具有相同的优先级的所有消息之后。如果无需使用，将其指定为0。</p><p>如果队列满了，<code>mq_send</code>会被阻塞，除非<code>mq_open</code>时设置非阻塞。</p><h4 id="mq-receive"><a href="#mq-receive" class="headerlink" title="mq_receive"></a>mq_receive</h4><p>从 mqdes 引用的消息队列中删除一条优先级最高、存在时间最长的消息并将删除的消息放置在 msg_ptr 指向的缓冲区，该过程同样存在内存拷贝。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mq_receive</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">char</span> *msg_ptr,</span></span><br><span class="line"><span class="params">                   <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> *msg_prio)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>msg_ptr</code>：预分配的内存首地址。</li><li><code>msg_len</code>：调用者使用 msg_len 参数来指定 msg_ptr 指向的缓冲区中的可用字节数，不管消息的实际大小是什么，msg_len（即 msg_ptr 指向的缓冲区的大小）必须要大于或等于队列的 mq_msgsize 特性。</li><li><code>msg_prio</code>：传出参数，接收到的消息的优先级会被复制到 msg_prio 指向的位置处。</li><li>返回值：<ul><li>正常情况返回接收的消息的大小！</li><li>失败返回 <code>-1</code>。</li></ul></li></ul><p>如果消息队列为空，mq_receive 会阻塞直到存在可用的消息。</p><h4 id="收发超时"><a href="#收发超时" class="headerlink" title="收发超时"></a>收发超时</h4><p>与上面的收发函数相同，只是参数多了个超时时间<code>abs_timeout</code>，为调用阻塞的时间指定一个上限。abs_timeout 参数是一个 timespec 结构，它将超时时间描述为自新纪元到现在的一个<strong>绝对值</strong>，其单位为秒数和纳秒数。如果要指定相对值，可用通过获取当前时间，将当前时间+相对值赋值给<code>abs_timeout</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mq_timedsend</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">const</span> <span class="type">char</span> *msg_ptr,</span></span><br><span class="line"><span class="params">                 <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> msg_prio,</span></span><br><span class="line"><span class="params">                 <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">mq_timedreceive</span><span class="params">(<span class="type">mqd_t</span> mqdes, <span class="type">char</span> *msg_ptr,</span></span><br><span class="line"><span class="params">                        <span class="type">size_t</span> msg_len, <span class="type">unsigned</span> <span class="type">int</span> *msg_prio,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="keyword">struct</span> timespec *abs_timeout)</span>;</span><br></pre></td></tr></table></figure><p>因超时而无法完成操作，那么调用就会失败并返回 ETIMEDOUT 错误。</p><h4 id="example-4"><a href="#example-4" class="headerlink" title="example"></a>example</h4><p><strong>send</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* For O_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> <span class="comment">/* For mode constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const char* ipc_object = &quot;/home/yogurt/mymsg&quot;;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ipc_object = <span class="string">&quot;/tmpmyobsdfject2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* send 每秒往消息队列中写入计数值 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mq_attr</span> <span class="title">attr</span>;</span></span><br><span class="line">    attr.mq_maxmsg = <span class="number">100</span>;</span><br><span class="line">    attr.mq_msgsize = <span class="number">1500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 总是报权限不足 */</span></span><br><span class="line">    <span class="type">mqd_t</span> obj = mq_open(ipc_object, O_CREAT|O_RDWR, <span class="number">0666</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (obj &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msg_queue open failed!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;msg_queue id: %d\n&quot;</span>, obj);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> msg[<span class="number">1500</span>];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">sprintf</span>(msg, <span class="string">&quot;%d&quot;</span>, i++);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        mq_send(obj, msg, <span class="built_in">strlen</span>(msg), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mq_close(obj);</span><br><span class="line">    mq_unlink(ipc_object);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>receive</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> <span class="comment">/* For O_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mqueue.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span> <span class="comment">/* For mode constants */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// const char* ipc_object = &quot;/home/yogurt/mymsg&quot;;</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* ipc_object = <span class="string">&quot;/tmpmyobsdfject2&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* send 每秒往消息队列中写入计数值 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">mqd_t</span> obj = mq_open(ipc_object, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;msg_queue open failed!&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;msg_queue id: %u\n&quot;</span>, obj);</span><br><span class="line">    <span class="type">char</span> msg[<span class="number">10000</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> prio;</span><br><span class="line">    <span class="type">int</span> bytes;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        bytes = mq_receive(obj, msg, <span class="number">10000</span>, &amp;prio);</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="number">-1</span>) &#123;</span><br><span class="line">            perror(<span class="string">&quot;receive error! &quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;msg: %s, prio: %u\n&quot;</span>, msg, prio);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mq_close(obj);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><p>与 <code>fifo</code> 行为类似，两个进程分别以只读和只写方式打开文件。理论上可行，但不推荐。效率低下，而且共享偏移量可能导致问题。</p><p>只有通过 <code>write</code> 写入到磁盘文件中的内容才可读取。</p><h2 id="mmap-内存映射-1"><a href="#mmap-内存映射-1" class="headerlink" title="mmap 内存映射"></a>mmap 内存映射</h2><p>内存映射也称<strong>共享内存</strong>，映射的方式分为<strong>文件映射</strong>和<strong>匿名映射</strong>。</p><p>存储映射 I&#x2F;O(Memory-mapped I&#x2F;O) 使一个磁盘文件与存储空间中的一个缓冲区相映射。于是从缓冲区中取数据，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区，则相应的字节就自动写入文件。这样，就可在不使用 <code>read</code> 和 <code>write</code> 函数的情况下，使地址指针完成 I&#x2F;O 操作。</p><p>使用这种方法，首先应该通知内核，将一个指定文件映射到存储区域中。这个映射工作可以通过 <code>mmap</code> 函数来实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags,</span></span><br><span class="line"><span class="params">            <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>addr</code>：映射的起始地址，通常传 NULL，让系统会自动选择一个合适的地址</li><li><code>length</code>：共享内存映射区的大小（要 &lt;&#x3D; 文件的实际大小）</li><li><code>prot</code>：共享内存映射区的读写属性。<code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_READ|PROT_WRITE</code></li><li><code>flags</code>：标注共享内存的共享属性。<code>MAP_SHARED</code>、<code>MAP_PRIVATE</code>（修改不会反应到磁盘上，很少用）</li><li><code>fd</code>：用于创建共享内存映射区的那个文件的 文件描述符。</li><li><code>offset</code>：偏移位置，需是 4k 的整数倍。默认 0，表示映射文件全部。</li><li>返回值：<ul><li>成功：映射区的首地址。</li><li>失败：<code>MAP_FAILED (void*(-1))</code>， errno</li></ul></li></ul><h3 id="munmap-函数-1"><a href="#munmap-函数-1" class="headerlink" title="munmap 函数"></a>munmap 函数</h3><p>释放映射区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>addr</code>：映射区的首地址</li><li><code>length</code>：映射区的大小</li><li>返回值：<ul><li><code>0</code>：成功</li><li><code>-1</code>：失败，errno</li></ul></li></ul><h3 id="mmap-注意事项"><a href="#mmap-注意事项" class="headerlink" title="mmap 注意事项"></a>mmap 注意事项</h3><ol><li>用于创建映射区的文件大小为 0，实际指定非 0 大小创建映射区，出 “总线错误”。</li><li>用于创建映射区的文件大小为 0，实际制定 0 大小创建映射区， 出 “无效参数”。</li><li>用于创建映射区的文件读写属性为，只读。映射区属性为 读、写。 出 “无效参数”。</li><li>创建映射区，需要 read 权限。当访问权限指定为 “共享”MAP_SHARED 时， mmap 的读写权限，应该 &lt;&#x3D;文件的 open 权限。 只写不行。</li><li>文件描述符 fd，在 mmap 创建映射区完成即可关闭。后续访问文件，用 地址访问。</li><li>offset 必须是 4096 的整数倍。（MMU 映射的最小单位 4k ）</li><li>对申请的映射区内存，不能越界访问。</li><li>munmap 用于释放的 地址，必须是 mmap 申请返回的地址。</li><li>映射区访问权限为 “私有”MAP_PRIVATE, 对内存所做的所有修改，只在内存有效，不会反应到物理磁盘上。</li><li>映射区访问权限为 “私有”MA_PRIVATE, 只需要 open 文件时，有读权限，用于创建映射区即可。</li></ol><hr><ol><li>创建映射区的过程中，隐含着一次对映射文件的读操作</li><li>当 MAP_SHARED 时，要求：映射区的权限应该&lt;&#x3D;文件打开的权限（出于对映射区的保护）。而MAP_PRIVATE 则无所谓，因为 mmap 中的权限是对内存的限制</li><li>映射区的释放与文件关闭无关。只要映射建立成功，文件可以立即关闭</li><li>特别注意，当映射文件大小为 0 时，不能创建映射区。所以：用于映射的文件必须要有实际大小！！<br>mmap 使用时常常会出现总线错误，通常是由于共享文件存储空间大小引起的。如，400 字节大小的文件，在简历映射区时，offset4096 字节，则会报出总线错误</li><li>munmap 传入的地址一定是 mmap 返回的地址。坚决杜绝指针++操作</li><li>文件偏移量必须为 4K 的整数倍</li><li>mmap 创建映射区出错概率非常高，一定要检查返回值，确保映射区建立成功再进行后续操作</li></ol><h3 id="example-5"><a href="#example-5" class="headerlink" title="example"></a>example</h3><p>有血缘关系的两个进程间通信的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;mm&quot;</span>, O_RDWR);</span><br><span class="line">    ftruncate(fd, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> *p = mmap(<span class="literal">NULL</span>, <span class="number">100</span>, PROT_READ|PROT_WRITE, MAP_SHARED, fd, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (p == MAP_FAILED) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;mmap error\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);  <span class="comment">// 映射区建立完毕,即可关闭文件</span></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;asdfghjkl\0&quot;</span>;</span><br><span class="line">        <span class="built_in">memcpy</span>(p, str, <span class="built_in">strlen</span>(str)); <span class="comment">// 将内容写入指针地址！而不是让指针指向内容！</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child: %s \n&quot;</span>, p);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent: %s \n&quot;</span>, p);</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        munmap(p, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无血缘关系的进程间通信时，只需要分别做两次 mmap 即可。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><ul><li><a href="https://xiaolincoding.com/os/4_process/process_commu.html">进程通信常用方式</a></li><li><a href="https://blog.csdn.net/xiajun07061225/article/details/8471777">进程间通信-命名管道FIFO</a></li><li><a href="https://blog.51cto.com/momo462/1825852">linux下，pipe的容量的讨论与查看</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-进程</title>
      <link href="/2022/04/25/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/"/>
      <url>/2022/04/25/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>下面的内容如果想要深入、全面地了解，还是建议看书。书上解释得更全面，也可能会有更多例子方便理解，此博客只是为了方便我自己理解以及后续回顾。</p></blockquote><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>进程管理</strong>、内存管理和文件管理是操作系统的三大核心功能。那么什么是进程呢？顾名思义，<strong>进程就是进展中的程序，或者说进程是执行中的程序</strong>。那么什么是程序？程序就是一段机器指令，它规定了计算机要做哪些事。</p><blockquote><p>计算机程序的运行实际上是一件十分复杂的事情，牵扯到方方面面。</p><p>首先，当然得进行编程，而编程需要计算机程序设计语言作为基础。对于绝大多数编写程序的人来说，使用的编程语言称为<strong>高级程序设计语言</strong>，如C、C++、Java等。但由于计算机并不认识高级语言编写的程序，编好的程序需要进行编译变成计算机能够识别的机器语言程序，而这<strong>需要编译器和汇编器的帮助</strong>。其次，机器语言程序需要<strong>加载到内存，形成一个运动中的程序，即进程</strong>，而这需要操作系统的帮助。<strong>进程需要在计算机芯片CPU上执行才算是真正在执行</strong>，而将进程调度到CPU上运行也由操作系统完成。最后，在CPU上执行的机器语言指令需要变成能够在一个个时钟脉冲里执行的基本操作，这<strong>需要指令集结构和计算机硬件的支持</strong>，而整个程序的执行过程还需要操作系统提供的服务和程序语言提供的执行环境（runtime environment）。这样，一个从程序到微指令执行的过程就完成了。</p></blockquote><p>简单而言，一个进程的运行过程为：<strong>程序</strong>（即硬盘上的一个可执行文件）、<strong>运行程序</strong>（将程序中存储的机器语言加载到内存，形成进程，计算机上的多个进程实际上共享了物理内存，容易造成混乱，因此使用了<strong>虚拟内存</strong>对进程的内存地址空间进行隔离）、<strong>在CPU上执行</strong>（对单核的CPU而言，任意时刻只能执行一条指令，因此CPU上任意时刻只能执行一个进程。多个进程通过“时分复用”的方式共享CPU，也就是<strong>进程调度</strong>）。</p><blockquote><p>发明进程的根本动机是什么？</p><p>答：是为了在计算机上同时运行多个程序，提高CPU的利用率。</p></blockquote><h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>程序是包含了一系列信息的文件，这些信息描述了如何在运行时创建一个进程，所包括的内容如下所示：</p><ul><li>二进制格式标识：每个程序文件都包含用于描述可执行文件格式的元信息，现在，大多数 UNIX 实现（包括 Linux）采用可执行连接格式（ELF）。</li><li>机器语言指令：对程序算法进行编码。</li><li><strong>程序入口地址</strong>：标识程序开始执行时的起始指令位置。</li><li>数据：程序文件包含的<strong>变量初始值</strong>和程序使用的<strong>字面常量</strong><code>literal constant</code>值，比如字符串。</li><li><strong>符号表</strong>及重定位表：描述程序中函数和变量的位置及名称。这些表格有多种用途，其中包括<strong>调试和运行时的符号解析</strong>（动态链接）。</li><li><strong>共享库和动态链接信息</strong>：程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及加载共享库的动态链接器的路径名。</li><li>其他信息：程序文件还包含许多其他信息，用以描述如何创建进程。</li></ul><p>可以用一个程序来创建许多进程，或者反过来说，许多进程运行的可以是同一程序。</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>在没有虚拟内存的情况下，各个程序（进程）都直接对物理内存地址进行操作，这样可能会出现多个进程修改同一个内存地址的情况，导致数据混乱，程序崩溃。而解决这个问题的办法就是让进程使用虚拟内存地址，然后再通过<strong>页表</strong>将虚拟内存转换为物理内存地址，在这个过程中，操作系统的内存管理模块就保证了两个进程的虚拟内存地址不会映射到同一个物理内存地址上。</p><p>关于虚拟内存的具体信息可以看：<a href="https://xiaolincoding.com/os/3_memory/vmem.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">虚拟内存</a>。</p><p><strong>页式存储管理</strong>是一种常见而高效的方式，操作系统将内存空间分为若干个固定大小的页，并维护虚拟页地址和物理页地址的映射关系（即页表）。页大小涉及页分配的粒度和页表所占空间，目前的操作系统常用<code>4KB</code>的页。此时，<strong>虚拟内存地址可表示为虚拟页地址和页内偏移两部分</strong>，在进行地址转换时<strong>通过查表的方式</strong>将虚拟页地址替换为物理页地址就可得到对应的物理内存地址。</p><p>任一时刻，每个程序仅有部分页需要驻留在物理内存页帧中。这些页构成了所谓驻留集。程序未使用的拷贝保存在交换区内——这是磁盘空间中的保留区域，作为计算机 RAM 的补充，仅在需要时才会载入物理内存。若进程欲访问的页面目前并未驻留在物理内存中，将会发生页面错误，内核即刻挂起该进程的执行，同时从磁盘中将该页面载入内存。</p><blockquote><p>大多数程序都展现了两种类型的局部性。</p><ul><li><strong>空间局部性</strong>：是指程序倾向于访问在最近访问过的内存地址附近的内存（由于指令是顺序执行的，且有时会按顺序处理数据结构）。</li><li><strong>时间局部性</strong>：是指程序倾向于在不久的将来再次访问最近刚访问过的内存地址（由于循环）。</li></ul></blockquote><p>在 32 位系统中，采用<code>4KB</code>页时，单个完整页表需要<code>1M</code>项，对每个进程维护页表需要相当可观的空间代价，而<code>CPU Cache</code>一般只有数十<code>M</code>，因此页表只能放在内存中。若每次进行地址转换时都需要先查询内存，则会对性能产生明显的影响（内存的访问速度远低于<code>Cache</code>）。为了提高页表访问的速度，现代处理器中通常包含一个<strong>转换后援缓冲器</strong>（Translation Lookaside Buffer，简称 <code>TLB</code>）来<strong>实现快速的虚实地址转换</strong>。<code>TLB</code>也称<strong>页表缓存或快表</strong>，借由<strong>局部性原理</strong>，存储当前处理器中最经常访问页的页表。一般 <code>TLB</code> 访问与 <code>Cache</code> 访问同时进行，而 <code>TLB</code> 也可以被视为页表的 <code>Cache</code> 。</p><blockquote><p>即使是从内存中查找页表，第一次找到后不就会将部分页表信息读入<code>Cache</code>了吗？后续的访问应该也很快，为什么还要专门的<code>TLB</code>模块？</p><p>猜测：<code>Cache</code> 中还存储了许多进程的程序指令、数据等信息，因此 <code>Cache</code> 会频繁地刷新数据。而页表信息会非常高频地进行访问，如果只用 <code>Cache</code> 缓存页表，会导致大量的<code>Cache miss</code>，从而带来很大的性能损耗。而 <code>TLB</code> 只存储页表信息，相对来说刷新频率没有 <code>Cache</code> 那么高，也就是命中率更高，因此相对来说更好、更快。</p><hr><p>假设变量 a 在虚拟内存中的地址为 0x1000，现在需要对它 +1，CPU的流程是在TLB中查询0x1000对应的物理内存地址，找到了0x20000，再查找L1 cache 是否有这个地址的数据，如果有就直接修改，然后写回物理内存？</p><p>chatgpt: 是的，在进程访问虚拟内存时，CPU 的流程通常是这样的：</p><ol><li>CPU 会先在 TLB 中查找虚拟地址 0x1000 对应的物理地址。如果 TLB 中有这个地址的信息，就会直接使用 TLB 中的信息。</li><li>如果 TLB 中没有这个地址的信息，就会从内存中读取页表信息，并将读取的信息存储到 TLB 中，供以后使用。</li><li>然后 CPU 会检查 L1 cache 是否有物理地址 0x20000 的数据。如果有，就直接使用 L1 cache 中的数据。</li><li>如果 L1 cache 中没有这个地址的数据，就会继续检查 L2 cache 和 L3 cache 是否有这个地址的数据。如果有，就直接使用缓存中的数据。</li><li>如果 L2 和 L3 cache 中也没有这个地址的数据，就会从物理内存中读取数据，并将读取的数据存储到 L1 cache 中，供以后使用。</li><li>最后，CPU 会将修改后的数据写回物理内存。</li></ol><p>总之，在进程访问虚拟内存时，CPU 会优先查询 TLB，如果 TLB 中不存在，再查询 cache。如果 cache 中也不存在，最后才会到内存中读取页表信息，这个过程会将页表信息加载到 cache 中。</p><hr><p>虚拟内存带来了哪些优点？</p><p>答：虚拟内存管理使进程的虚拟地址空间与物理内存地址空间隔离开来，优点有：</p><ul><li>进程与进程、进程与内核<strong>相互隔离</strong>，所以一个进程不能读取或修改另一进程或内核的内存。</li><li>适当情况下，两个或者更多进程<strong>能够共享内存</strong>。这是由于内核可以使不同进程的页表条目指向相同的 RAM 页。</li><li><strong>便于实现内存保护机制</strong>；也就是说，可以对页表条目进行标记，以表示相关页面内容是可读、可写、可执行亦或是这些保护措施的组合。多个进程共享 RAM 页面时，允许每个进程对内存采取不同的保护措施。例如，一个进程可能以只读方式访问某页面，而另一进程则以读写方式访问同一页面。</li><li>程序员和编译器、链接器之类的工具无需关注程序在 RAM 中的物理布局。</li><li>因为需要驻留在内存中的仅是程序的一部分，所以<strong>程序的加载和运行都很快</strong>。而且，一个进程所占用的内存（即虚拟内存大小）<strong>能够超出 RAM 容量</strong>。</li><li>由于每个进程使用的 RAM 减少了，RAM 中同时可以<strong>容纳的进程数量就增多</strong>了。进而<strong>提高了CPU的利用率</strong>。</li></ul></blockquote><h3 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h3><p>每个进程所分配的<strong>虚拟内存</strong>由很多部分组成，通常称之为“段（segment）”。</p><blockquote><p><code>size</code>命令可显示二进制可执行文件的文本段、初始化数据段、非初始化数据段(<code>bss</code>)的段大小。</p></blockquote><ul><li><p><strong>文本段</strong>：包含了进程运行的程序机器语言指令。</p></li><li><p><strong>初始化数据段</strong>：包含显式初始化的<strong>全局变量和静态变量</strong>。当程序加载到内存时，从可执行文件中读取这些变量的值。</p></li><li><p><strong>未初始化数据段<code>BSS</code><strong>：包含了</strong>未进行显式初始化</strong>的全局变量和静态变量。程序启动之前，系统将本段内所有内存初始化为0。</p><blockquote><ol><li>BSS 段的内存会被初始化为0，也就意味着未进行显式初始化的<strong>全局变量和静态变量</strong>的初始值为0。但需要注意，未进行显式初始化的<strong>局部变量</strong>，并不在 BSS 段中，也不会被初始化为0！</li><li>将经过初始化的与未经初始化全局变量和静态变量分开存放，其主要原因在于程序在磁盘上存储时，没有必要为未经初始化的变量分配存储空间。相反，可执行文件只需记录未初始化数据段的位置及所需大小，直到运行时再由程序加载器来分配这一空间。</li></ol></blockquote></li><li><p>栈<code>stack</code>：是一个<strong>动态增长和收缩</strong>的段，由栈帧（<code>stack frames</code>）组成。系统会<strong>为每个当前调用的函数分配一个栈帧</strong>。栈帧中存储了函数的局部变量（所谓自动变量）、实参和返回值。此外，<strong>也可使用<code>alloca()</code>在栈上动态分配空间</strong>。</p></li><li><p>堆<code>heap</code>：是可在运行时（为变量）动态<code>malloc()</code>进行内存分配的一块区域。堆顶端称作 <code>program break</code>。</p></li></ul><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/image-20220526222503936.png" alt="image-20220526222503936"></p><h3 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h3><p>就像世界上的人并不平等一样，并不是所有的程序都是平等的。世界上有的人占有资源多，有的人占有资源少，有的人来了，别人得让出资源，有的人则专门为别人让出资源。程序也是这样的，有的程序可以访问计算机的任何资源，有的程序则只能访问少量受限资源。操作系统作为计算机的管理者，自然不能和被管理者享受一样的待遇。它应该享有更多的方便或权限。<strong>为了区分不同的程序的不同权限</strong>，人们发明了内核态和用户态的概念。</p><p>那么什么是内核态，什么又是用户态呢？只要想一想现实生活中处于社会核心的人与处于社会边缘的人有什么区别，就能明白处于核心的人拥有的资源多！因此，<strong>内核态就是拥有资源多的状态，或者说访问资源多的状态，称为特权态</strong>。相对来说，<strong>用户态就是非特权态，在此种状态下访问的资源将受到限制</strong>。例如，如果要访问操作系统的内核数据结构，如进程表，则需要在特权态下才能办到。如果要访问用户程序里的数据，则在用户态就可以了。</p><p>运行在内核态的程序可以访问的资源多，但<strong>可靠性、安全性要求高，维护管理都较复杂</strong>；</p><blockquote><p>那么计算机是如何知道现在正在运转的程序是内核态程序呢？或者说内核态的本质是？</p><p>而正确做出内核态或用户态的判断对系统的正确运行至关重要。显然做出这种判断需要某种标志。<strong>这个标志就是处理器的一个状态位</strong>。这个状态位是CPU状态字里面的一个字位。<strong>也就是说，所谓的用户态、内核态实际上是处理器的一种状态，而不是程序的状态</strong>。我们通过设置该状态字，可以将CPU设置为内核态、用户态或者其他的子态（有的CPU有更多种子态）。<strong>一个程序运行时，CPU是什么态，这个程序就运行在什么态。</strong></p><hr><p>前面说过，内核态是特权态，而用户态是普通态。特权态下运行的程序可以访问任何资源，而用户态下的访问则受到限制。那么这种限制是如何实现的呢？</p><p>显然，要限制一个程序对资源的访问，需要对程序执行的每一条指令进行检查才能完成。而这种检查就是地址翻译。程序发出的每一条指令都要经过这个地址翻译过程。而<strong>通过对翻译的控制，就可以限制程序对资源的访问</strong>。（地址翻译就是将进程的虚拟内存地址翻译为物理内存地址，页表查询的过程。）</p><p>为了赋予内核态程序访问所有资源的权限，<strong>当系统处于内核态时，内核程序可以绕过内存地址翻译而直接执行特权指令</strong>，如停机指令。这种绕过翻译的做法突破了系统对资源的控制。</p></blockquote><p>在 Linux 操作系统中，虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：</p><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/3a6cb4e3f27241d3b09b4766bb0b1124.png" alt="3a6cb4e3f27241d3b09b4766bb0b1124"></p><blockquote><p>为什么内存地址空间被分为内核空间和用户空间？内核空间为什么是共享的？</p><p>todo….</p></blockquote><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程的三种典型状态：</p><ol><li>就绪态：已经具备运行条件，位于进程的就绪队列中，等待进程调度被分配CPU资源。</li><li>运行态：当前占据CPU资源的进程的状态。</li><li>阻塞态：处于运行态的进程因发出某种资源请求，操作系统将其CPU资源剥夺，等待请求的事件满足，再变成就绪态，加入就绪队列。</li></ol><p>这里阐述的进程的3种典型状态并不是唯一的分类方式，事实上，许多商业操作系统的进程状态不止三个。</p><ul><li>创建态：进程正在被创建，操作系统需要为其分配资源、初始化PCB。</li><li>终止态：进程正在从系统中撤销，等待操作系统会回收进程拥有的资源、撤销PCB。</li></ul><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg" alt="七种状态变迁"></p><blockquote><p><strong>那么进程挂起有哪些原因呢</strong>？</p><ol><li>首先是一个进程在运行过程中<strong>执行了某种阻塞操作</strong>，如读写磁盘。由于阻塞操作需要等待结果后才能继续执行，因此操作系统将把这个进程挂起，让其他进程运转。</li><li>另外一种情况是一个<strong>进程执行的时间太长了</strong>，为了公平，操作系统将其挂起，让其他进程也有机会执行。</li></ol></blockquote><h2 id="进程常用-API"><a href="#进程常用-API" class="headerlink" title="进程常用 API"></a>进程常用 API</h2><p>从内核角度看，进程由用户内存空间（user-space memory）和一系列内核数据结构组成，其中用户内存空间包含了程序代码及代码所使用的变量，而内核数据结构则用于维护进程状态信息。记录在内核数据结构中的信息包括许多与进程相关的标识号（IDs）、虚拟内存表、打开文件的描述符表、信号传递及处理的有关信息、进程资源使用及限制、当前工作目录和大量的其他信息。</p><p>对进程的相关操作实际上就是操作内核中记录进程相关信息的结构体。</p><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p>操作系统中，进程是<strong>资源分配的基本单位</strong>，操作系统对进程的管理通过<strong>进程表</strong>来实现，进程表里存放的是关于系统上所有进程的一切信息。实际上，进程表就是一个<code>PCB</code>链表，<strong>每个进程的一切信息都记录在一个进程控制块</strong><code>PCB</code>中，包括进程的状态，进程的资源，进程的输入输出等。在 <code>linux</code> 中，<code>PCB</code> 的实现是 <code>task_struct</code> 结构体。</p><p>具体信息看源码：<a href="https://elixir.bootlin.com/linux/v2.6.39/source/include/linux/sched.h#L1193">linux v2.6.39 task_struct</a>，下面是省略了大部分成员后的结构体，<a href="https://blog.csdn.net/qq_44836294/article/details/108637404">结构体说明</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 进程状态相关 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> state;    <span class="comment">/* -1 unrunnable, 0 runnable, &gt;0 stopped */</span></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">stack</span>;            <span class="comment">/* 指向内核栈 */</span></span><br><span class="line">    <span class="type">int</span> exit_code;          <span class="comment">/* 进程退出码 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进程亲缘关系 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tasks</span>;</span> <span class="comment">/* 用于加入进程表 */</span></span><br><span class="line">    <span class="type">pid_t</span> pid;  <span class="comment">/* 进程号 */</span></span><br><span class="line">    <span class="type">pid_t</span> tgid; <span class="comment">/* 线程组ID */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">real_parent</span>;</span>    <span class="comment">/* 指向创建其的父进程，如果其父进程不存在，则指向init进程 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">parent</span>;</span>         <span class="comment">/* 指向当前的父进程，通常与real_parent一致，接收SIGCHLD信号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">children</span>;</span>          <span class="comment">/* 子进程链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sibling</span>;</span>           <span class="comment">/* 兄弟进程链表 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">group_leader</span>;</span>   <span class="comment">/* threadgroup leader */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_link</span> <span class="title">pids</span>[<span class="title">PIDTYPE_MAX</span>];</span>  <span class="comment">/* PID/PID hash table linkage. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进程下的线程 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">thread_group</span>;</span>  <span class="comment">/* 线程链表 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进程打开的文件信息 */</span></span><br><span class="line">    <span class="type">int</span> link_count, total_link_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span> *<span class="title">fs</span>;</span>       <span class="comment">/* 目录信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">files</span>;</span> <span class="comment">/* 进程所有打开的文件都会在这里面的一个指针数组里，文件描述符就是该数组的下标 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 信号相关信息 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span>;</span></span><br><span class="line">    <span class="type">sigset_t</span> blocked, real_blocked;</span><br><span class="line">    <span class="type">sigset_t</span> saved_sigmask; <span class="comment">/* restored if set_restore_sigmask() was used */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> <span class="title">pending</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 进程调度相关，优先级 */</span></span><br><span class="line">    <span class="type">int</span> prio, static_prio, normal_prio;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rt_priority;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> policy;            <span class="comment">/* 进程的调度策略 SCHED_FIFO, SCHED_RR, SCHED_OTHER, etc */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/* and more */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>进程控制块的主要内容有：</p><ul><li>身份标识（进程号），进程树（父子进程关系）；</li><li>进程的状态信息：就绪、运行、阻塞等；</li><li>进程的调度策略，优先级等；</li><li>进程中存在的线程信息；</li><li>进程打开的文件信息（文件描述符）；</li><li>信号处理相关信息；</li><li>进程的资源：内存、CPU、IO、磁盘等；</li><li>等等。</li></ul><h3 id="fork"><a href="#fork" class="headerlink" title="fork"></a>fork</h3><p>基于当前进程创建一个子进程。在操作系统中，进程是资源分配的基本单位，所以子进程也会重新分配进程控制块<code>PCB</code>，也就是说，父子进程间很多东西都是独享的；不过子进程是当前进程的一个“分身”，或者说<strong>复制</strong>品，因此子进程的<code>PCB</code>与父进程的<code>PCB</code>有很多<strong>相同之处</strong>，比如：环境变量、全局变量、宿主目录位置、进程工作目录位置、文件列表、信号处理方式、文本段、堆、栈。</p><p>不过父子进程仍然存在进程间的内存隔离，因此这里说的相同仅仅是值相同，而且仅仅是刚创建这一时刻，因为后续子进程可以修改这些信息。<strong>或者说父子进程没有内容是“共享的”</strong>更恰当。</p><p>对于一些进程身份信息相关的内容，显然<strong>父子进程是不同的</strong>，包括：进程号、父进程号、进程创建时间等。</p><p>不够由于进程控制块<code>PCB</code>相当大，如果在<code>fork</code>过程中，完全进行内存拷贝会消耗很多时间，因此某些内容采用了<strong>读时共享、写时复制</strong>的策略，如全局变量。而某些内容则直接采用<strong>共享</strong>的方式：文件描述符、<code>mmap</code>映射区等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 1</span></span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// parent process</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2: 循环创建子进程</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// child process</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is parent process\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;this is %dth child process\n&quot;</span>, i);</span><br></pre></td></tr></table></figure><ul><li>返回值：<ul><li>成功，父进程中返回子进程的 <code>PID</code>，子进程返回 <code>0</code>。</li><li>失败，返回 <code>-1</code>，并设置 <code>errno</code> 。</li></ul></li></ul><blockquote><p><a href="https://elixir.bootlin.com/linux/v2.6.39/source/arch/x86/kernel/process.c#L235">系统调用 fork 的源码</a></p></blockquote><h3 id="getpid-x2F-getppid"><a href="#getpid-x2F-getppid" class="headerlink" title="getpid&#x2F;getppid"></a>getpid&#x2F;getppid</h3><blockquote><p><code>PID</code>是一个数字，用于标识一个进程，就像学生的学号一样，每个进程都有一个唯一的编号，保存在进程控制块的 <code>pid</code> 字段中。一般的，在系统运行期间，<code>PID</code> 都是被顺序编号，比如进程A的<code>PID</code>为<code>10</code>，那下个创建的进程的<code>PID</code>则为<code>11</code>。不过<code>PID</code>的值有一个上限，当内核使用的PID达到这个上限后就会循环开始找已闲置的小<code>PID</code>号。</p></blockquote><p>获取当前进程的 <code>PID</code> 和父进程的 <code>PID</code>。使用<code>pstree</code>命令可查看到这一“家族树”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>返回值：<ul><li>成功，返回 <code>PID</code>。</li><li>失败，这些函数总是成功的！</li></ul></li></ul><p><a href="https://elixir.bootlin.com/linux/v2.6.39/source/kernel/timer.c#L1356">getpid 的源码</a>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* kernel/timer.c:1353 */</span></span><br><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> task_tgid_vnr(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* include/linux/sched.h:1600 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">pid_t</span> <span class="title function_">task_tgid_vnr</span><span class="params">(<span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> pid_vnr(task_tgid(tsk));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>getpid()</code>函数返回的值其实是当前进程的<code>tgid</code>而不是<code>pid</code>的值，而由于线程组中领头线程<code>tgid</code>和<code>pid</code>相同，因而<code>getpid()</code>对这类进程所起到的作用和一般进程是一样的。</p></blockquote><h3 id="wait-x2F-waitpid"><a href="#wait-x2F-waitpid" class="headerlink" title="wait&#x2F;waitpid"></a>wait&#x2F;waitpid</h3><p><strong>回收子进程</strong>！</p><blockquote><p>为什么要回收进程？</p><p>正如前面所述，每个进程被分配了一个很大的结构体——进程控制块，该结构体会占用不少的内存空间，如果不回收（释放该结构体），那这些内存就被白白浪费了。此外，每个进程都有一个进程号，如果不回收进程，那它所占用的进程号就不能被再次利用。长时间运行后，必然会有新进程由于无法分配到进程号，而创建失败。<br>如果不回收子进程，这种已经结束但没有被回收的子进程称为<strong>僵尸进程</strong>。</p><hr><p>那操作系统为什么不自动回收进程呢？</p><p>有些时候，父进程希望知道子进程是如何结束的（由于异常错误？还是正常退出），而进程的退出状态就记录在进程控制块的<code>exit_code</code>中，父进程通过子进程的进程号就可以访问到子进程的<code>PCB</code>，进而获知其结束的原因。</p></blockquote><ul><li><code>wait</code>：<strong>阻塞等待</strong>任意一个子进程结束，并回收。参数为传出变量，写入被回收的子进程的结束码。可设置为<code>NULL</code>，表示不接收。</li><li><code>waitpid</code>：回收指定<code>pid</code>的子进程，可以设置是否阻塞。</li></ul><p>这两种系统调用每次只能回收一个子进程，如果父进程需要回收多个子进程，可以多次调用 <code>wait</code> 函数。</p><blockquote><p><strong>注意：进程回收只能由父进程调用该函数，兄弟进程之间无法互相回收，子进程也无法被父进程的父进程回收</strong>！</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* waitpid 回收多个子进程 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123; <span class="comment">// child process</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">pid_t</span> wpid;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123; <span class="comment">/* 父进程执行 */</span></span><br><span class="line">        <span class="comment">// 当前进程不存在子进程时会返回 -1</span></span><br><span class="line">        <span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG)) != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (wpid &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;wait child %d\n&quot;</span>, wpid);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is parent process\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* 子进程执行 */</span></span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;this is %dth child process\n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>wstatus</code> 用来接收子进程的终止状态。可设置为NULL，表示不接收。</li><li><code>pid</code> 参数：<ul><li>如果 <code>pid = 0</code>，则等待任意同组的子进程终止；</li><li>如果 <code>pid = -1</code>，则等待任意子进程终止；</li><li>如果 <code>pid &gt; 0</code>，则等待指定的子进程终止；</li><li>如果 <code>pid &lt; -1</code>，则等待任意进程组 id 为 abs(pid) 的子进程终止。</li></ul></li><li><code>options</code> 参数：<ul><li><code>0</code>：阻塞等待；</li><li><code>WNOHANG</code>：如果没有子进程终止，则立即返回，不阻塞父进程。</li></ul></li><li>返回值：<ul><li><code>&gt;0</code>，成功，返回子进程的 <code>pid</code>；</li><li><code>0</code>，调用时指定了 <code>WNOHANG</code>，并且没有子进程终止；</li><li><code>-1</code>，失败，并设置 <code>errno</code>。<strong>当前进程不存在子进程</strong>或<strong>回收的进程P不是当前进程的子进程</strong>时会返回 <code>-1</code>。</li></ul></li></ul><blockquote><p><strong>孤儿进程</strong>：父进程先于子进终止，子进程沦为“孤儿进程”，会被 <code>init</code> 进程领养。</p><p><strong>僵尸进程</strong>：子进程终止，父进程尚未对子进程进行回收，在此期间，子进程为“僵尸进程”。 <code>kill</code><strong>对其无效</strong>。<strong>每个进程结束后都必然会经历僵尸态</strong>，时间长短的差别而已。回收僵尸进程，得 <code>kill</code> 它的父进程，让孤儿院去回收它。</p><p><strong>杀死父进程并不会导致子进程死亡</strong>，只是子进程的父进程会变为 <code>init</code>。</p></blockquote><h3 id="exec-函数族"><a href="#exec-函数族" class="headerlink" title="exec 函数族"></a>exec 函数族</h3><p><code>fork</code> 创建子进程后执行的是和父进程相同的程序，但有可能执行不同的代码分支，不过这种情况并不多见，因为用线程可以更好更快地达到这个目的。子进程往往要调用一种 <code>exec</code> 函数以执行另一个程序。</p><p>当进程调用一种 <code>exec</code> 函数时，该进程的用户空间<strong>代码和数据完全被新程序替换</strong>，从新程序的启动例程开始执行。<strong>调用 <code>exec</code> 并不创建新进程，所以调用 <code>exec</code> 前后该进程的 <code>id</code> 并未改变</strong>。</p><p><code>exec</code> 函数一旦调用成功，即执行新的程序，<strong>不返回</strong>。只有失败才返回，错误值<code>-1</code>，所以通常我们直接在 <code>exec</code> 函数调用后直接调用 <code>perror()</code>，和 <code>exit()</code>，无需 <code>if</code> 判断。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/* (char  *) NULL */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...</span></span><br><span class="line"><span class="params">                <span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[],</span></span><br><span class="line"><span class="params">                <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><ul><li><code>l</code> 命令行参数列表。</li><li><code>v</code> 使用命令行参数数组。</li><li><code>p</code> 表示要借助环境变量<code>PATH</code>来加载可执行文件。</li><li><code>e</code> 使用环境变量数组，不用进程原有的环境变量，设置新加载程序运行的环境变量。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;/usr/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/tmp&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 指定绝对路径，参数列表以 NULL 结尾。</span></span><br><span class="line">execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/tmp&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 指定程序名，参数列表以 NULL 结尾。</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;/tmp&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execv(<span class="string">&quot;/usr/bin/ls&quot;</span>, argv); <span class="comment">// 指定绝对路径，参数列表以 NULL 结尾。</span></span><br><span class="line">execvp(<span class="string">&quot;ls&quot;</span>, argv); <span class="comment">// 指定程序名，参数列表以 NULL 结尾。</span></span><br></pre></td></tr></table></figure><p>这些函数都是库函数，都是通过系统调用<code>execve</code>实现的。</p><h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>在早期的 BSD 实现中，<code>fork()</code>会对父进程的数据段、堆和栈施行严格的复制。如前所述，这是一种浪费，尤其是在调用 <code>fork()</code>后立即执行 <code>exec()</code>的情况下。出于这一原因，BSD 的后期版本引入了 <code>vfork()</code>系统调用，尽管其运作含义稍微有些不同（实则有些怪异），但效率要远高于 BSD <code>fork()</code>。现代 UNIX 采用写时复制技术来实现 <code>fork()</code>，其效率较之于早期的 <code>fork()</code>实现要高出许多，进而将对 <code>vfork()</code>的需求剔除殆尽。虽然如此，Linux（如同许多其他的 UNIX 实现一样）还是提供了具有 BSD 语义的 <code>vfork()</code>系统调用，以期为程序提供尽可能快的 <code>fork</code> 功能。不过，鉴于 <code>vfork()</code>的怪异语义可能会导致一些难以察觉的程序缺陷（bug），除非能给性能带来重大提升（这种情况发生的概率极小），否则<strong>应当尽量避免使用这一调用</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">vfork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>类似于 <code>fork()</code>，<code>vfork()</code>可以为调用进程创建一个新的子进程。然而，<code>vfork()</code>是为子进程立即执行 <code>exec()</code>的程序而专门设计的。</p><p><code>vfork()</code>因为如下两个特性而更具效率，这也是其与 <code>fork()</code>的区别所在。</p><ul><li>无需为子进程复制虚拟内存页或页表。相反，<strong>子进程共享父进程的内存</strong>，直至其成功执行了 <code>exec()</code>或是调用<code>_exit()</code>退出。</li><li>在子进程调用 <code>exec()</code>或<code>_exit()</code>之前，<strong>将暂停执行父进程。</strong></li></ul><h2 id="进程组与会话"><a href="#进程组与会话" class="headerlink" title="进程组与会话"></a>进程组与会话</h2><p>进程组和会话在进程之间形成了一种两级层次关系：<strong>进程组是一组相关进程的集合，会话是一组相关进程组的集合</strong>。</p><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p><strong>进程组由一个或多个共享同一进程组标识符（<code>PGID</code>）的进程组成</strong>。进程组 ID 是一个数字，其类型与进程 ID 一样（pid_t）。一个进程组拥有一个进程组首进程，该进程是创建该组的进程，其进程 ID 为该进程组的 ID，<strong>新进程会继承其父进程所属的进程组 ID</strong>。</p><p><strong>进程组</strong>拥有一个生命周期，其开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻。一个进程可能会因为终止而退出进程组，也可能会因为加入了另外一个进程组而退出进程组。进程组首进程无需是最后一个离开进程组的成员（<strong>当一个进程组的组长死亡时，只要有其他进程存在，则该进程组存在。并且组ID仍是已故的组长进程ID</strong>）。<strong>会话也类似</strong>。</p><blockquote><p>进程组有什么作用呢？</p><p>一种用处为：可以通过组 ID 同时向该进程组中的所有进程发送信号。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -9 -&#123;&#123;group_id&#125;&#125; <span class="comment"># 组ID前面要加负号`-`，就可以给该进程组中的所有进程发送信号</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="getpgrp-x2F-getpgid"><a href="#getpgrp-x2F-getpgid" class="headerlink" title="getpgrp&#x2F;getpgid"></a>getpgrp&#x2F;getpgid</h4><p>获取一个进程的进程组ID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;   <span class="comment">/* 很少会检索调用者以外的进程的 PGID */</span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpgrp</span><span class="params">(<span class="type">void</span>)</span>;        <span class="comment">/* POSIX.1 version 首选方法 */</span></span><br></pre></td></tr></table></figure><p><code>getpgrp</code>就是返回当前调用进程所属的进程组ID，<strong>首选方法</strong>。</p><p><code>getpgid</code>可以返回指定进程所属的进程组ID，如果<code>pid</code>为<code>0</code>，就是返回当前调用进程所属的进程组ID。</p><h4 id="setpgrp-x2F-setpgid"><a href="#setpgrp-x2F-setpgid" class="headerlink" title="setpgrp&#x2F;setpgid"></a>setpgrp&#x2F;setpgid</h4><p><code>setpgid()</code>系统调用将进程 ID 为 <code>pid</code> 的进程的进程组 ID 修改为 <code>pgid</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">pid_t</span> pgid)</span>;  <span class="comment">/* 首选方法 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">setpgrp</span><span class="params">(<span class="type">void</span>)</span>;                   <span class="comment">/* System V version, 相当于 setpgid(0, 0) */</span></span><br></pre></td></tr></table></figure><p>如果 <code>pid</code> 和 <code>pgid</code> 参数指定了同一个进程（<code>pgid</code>为<code>0</code>或<code>pgid == pid</code>），就会<strong>创建一个新进程组</strong>，并且指定的进程会成为这个新组的首进程。</p><p>如果两个参数的值不同，则会将指定进程从一个进程组中移到另一个进程组中。</p><p>在调用<code>setpgid()</code>时存在以下限制：</p><ul><li><code>pid</code> 参数可以仅指定调用进程或其中一个子进程；</li><li>在组之间移动进程时，调用进程、由 <code>pid</code> 指定的进程以及目标进程组必须要属于同一个会话；</li><li><code>pid</code> 参数所指定的进程不能是会话首进程；</li><li>一个进程在其子进程已经执行 <code>exec()</code> 后就无法修改该子进程的进程组 ID 了。</li></ul><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p><strong>会话是一组进程组的集合</strong>。进程的会话成员关系是由其会话标识符（<code>SID</code>）确定的，会话标识符与进程组 ID 一样，是一个类型为 <code>pid_t</code> 的数字。会话首进程是创建该新会话的进程，其进程 ID 会成为会话 ID。<strong>新进程会继承其父进程的会话 ID</strong>。</p><p><strong>一个会话中的所有进程共享单个控制终端</strong>。控制终端会在会话首进程首次打开一个终端设备时被建立。一个终端最多可能会成为一个会话的控制终端。</p><blockquote><p><strong>前台和后台进程组</strong></p><p>在终端中运行程序时（如<code>ls</code>），该程序产生的输出会显示在终端上，如果需要，也会从终端读入用户键盘输入的信息。<br>有时希望将一个程序A启动后，在当前终端下继续运行程序B，这时一般会通过<code>A &amp;</code>让程序后台运行，此时就还可以继续运行B。</p><p>总的来说，前台和后台的区别在于是否能中终端读入用户输入，或者说运行时是否使用了<code>&amp;</code>。需要注意，后台进程组的输出仍然可以输出到终端，比如<code>sleep 2 &amp;&amp; ls &amp;</code>.</p></blockquote><p>在任一时刻，会话中的其中一个进程组会成为终端的<strong>前台进程组</strong>，其他进程组会成为<strong>后台进程组</strong>。<strong>只有前台进程组中的进程才能从控制终端中读取输入</strong>。当用户在控制终端中输入其中一个信号生成终端字符之后，该信号会被发送到前台进程组中的<strong>所有成员</strong>。</p><blockquote><p>那么会话有什么用呢？</p><p>同样，也可以通过会话<code>SID</code>给会话中的所有进程发送信号！（当然，会话的主要用途不是这个…）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在一个终端中启动多个进程</span></span><br><span class="line">$ <span class="built_in">cat</span> | <span class="built_in">cat</span> | <span class="built_in">cat</span> | <span class="built_in">cat</span>  <span class="comment"># 启动多个进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在另一个终端中运行</span></span><br><span class="line">$ ps aj</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">   5115   54152   54152   54152 pts/3      62248 Ss    1000   0:00 /bin/bash</span><br><span class="line">  54152   62248   62248   54152 pts/3      62248 S+    1000   0:00 <span class="built_in">cat</span></span><br><span class="line">  54152   62249   62248   54152 pts/3      62248 S+    1000   0:00 <span class="built_in">cat</span></span><br><span class="line">  54152   62250   62248   54152 pts/3      62248 S+    1000   0:00 <span class="built_in">cat</span></span><br><span class="line">  54152   62251   62248   54152 pts/3      62248 S+    1000   0:00 <span class="built_in">cat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端中运行的程序其会话 SID 与该终端的进程ID相同，因此下面的命令会将终端也关闭！</span></span><br><span class="line">$ <span class="built_in">kill</span> -9 -54152</span><br></pre></td></tr></table></figure></blockquote><h4 id="getsid"><a href="#getsid" class="headerlink" title="getsid"></a>getsid</h4><p>获取指定进程所属的会话 <code>SID</code> 。<code>pid</code>为0表示获取当前调用进程的会话 <code>SID</code> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getsid</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br></pre></td></tr></table></figure><ul><li>返回值：成功返回调用进程的会话 ID，失败返回<code>-1</code>，设置 <code>errno</code>。</li></ul><h4 id="setsid"><a href="#setsid" class="headerlink" title="setsid"></a>setsid</h4><p>创建一个新会话，并以自己的 <code>PID</code> 设置为进程组 <code>PGID</code>，同时也是新会话的 <code>SID</code> ！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">setsid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>返回值：成功返回调用进程的会话 <code>SID</code>，失败返回 <code>-1</code>，设置 <code>errno</code> 。</li></ul><p><code>setsid()</code>系统调用会按照下列步骤创建一个新会话：</p><ul><li>调用进程成为新会话的首进程和该会话中新进程组的首进程。调用进程的进程组 <code>PGID</code> 和会话 <code>SID</code> 会被设置成该进程的进程 ID。</li><li><strong>调用进程没有控制终端</strong>。所有之前到控制终端的连接都会被断开。</li></ul><p>在调用<code>setsid()</code>时存在一个限制：<strong>调用进程不能是一个进程组的首进程</strong>。避免这个错误发生的最简单的方式是执行一个 <code>fork()</code>并让父进程终止以及让子进程调用 <code>setsid()</code>。进程组中，组长死亡后，不会再自动产生新组长。</p><blockquote><p>为什么不能是进程组的首进程？</p><p>因为如果没有这个约束的话，进程组组长就能够将其自身迁移至另一个（新的）会话中了，而该进程组的其他成员则仍然位于原来的会话中。这会破坏会话和进程组之间严格的两级层次，因为一个进程组的所有成员必须属于同一个会话。</p></blockquote><h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><p>在UNIX系统中，用户通过终端登录系统后得到一个Shell进程，这个终端成为Shell进程的控制终端 (Controlling Terminal)。</p><p>控制终端是保存在<code>PCB</code>中的信息，而我们知道<code>fork</code>会复制<code>PCB</code>中的信息，因此由Shell进程启动的其它进程的控制终端也是这个终端。</p><p>默认情况下（没有重定向），每个进程的标准输入、标准输出和标准错误输出都指向控制终端，进程从标准输入读也就是读用户的键盘输入，进程往标准输出或标准错误输出写也就是输出到显示器上。</p><p>每个进程都可以通过一个特殊的设备文件<code>/dev/tty</code>访问它的控制终端。<code>ttyname</code>函数可以由文件描述符查出对应的文件名，该文件描述符必须指向一个终端设备而不能是任意文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stdin  tty: %s\n&quot;</span>, ttyname(STDIN_FILENO));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stdout tty: %s\n&quot;</span>, ttyname(STDOUT_FILENO));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;stderr tty: %s\n&quot;</span>, ttyname(STDERR_FILENO));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// stdin  tty: /dev/pts/2</span></span><br><span class="line"><span class="comment">// stdout tty: /dev/pts/2</span></span><br><span class="line"><span class="comment">// stderr tty: /dev/pts/2</span></span><br></pre></td></tr></table></figure><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程<code>daemon</code>指的是具有特殊用途的进程，通常采用以<code>d</code>结尾的命名方式，系统创建和处理此类进程的方式与其他进程相同。</p><p>但以下特征是其所独有的：</p><ul><li>长生不老，守护进程通常在系统引导时启动，直至系统关闭前，会一直“健在”，<strong>不受用户登录注销影响</strong>。</li><li>守护进程在后台运行，且无控制终端供其读取或写入数据。周期性的等待某个事件发生或周期性执行某一动作。</li></ul><blockquote><p>很多标准的 <code>daemon</code> 会作为特权进程运行，即有效用户 ID 为 0。</p></blockquote><p><strong>创建守护进程的步骤</strong>：</p><ol><li>执行一个 <code>fork()</code>，之后父进程退出，<strong>子进程</strong>继续执行（子进程被确保不会成为一个进程组首进程）。</li><li>子进程调用 <code>setsid()</code> 开启一个<strong>新会话</strong>并释放它与控制终端之间的所有关联关系。</li><li>清除进程的 <code>umask</code> 以确保当 <code>daemon</code> 创建文件和目录时拥有所需的<strong>权限</strong><code>022 -- 755</code>。</li><li>修改进程的<strong>当前工作目录</strong>，通常会改为根目录<code>/</code>，防止工作目录被卸载，导致进程死亡。</li><li>关闭 <code>daemon</code> 从其父进程继承而来的所有打开着的文件描述符，主要是针对 <code>0, 1, 2</code>，一般是重定向到 <code>/dev/null</code>，防止了后面使用描述符 1 或 2 打开一个文件的情况，因为库函数会将这些描述符当做标准输出和标准错误来写入数据。</li><li>守护进程<strong>业务逻辑</strong><code>while()</code>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">become_daemon</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> maxfd, fd;</span><br><span class="line">    <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>: <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">break</span>;      <span class="comment">/* 1. 子进程继续，也就是守护进程 */</span></span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">exit</span>(EXIT_SUCESS); <span class="comment">/* 父进程退出 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsid() == <span class="number">-1</span>)     <span class="comment">/* 2. 创建新会话 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (umask(<span class="number">0022</span>) == <span class="number">-1</span>)  <span class="comment">/* 3. 重设文件权限掩码 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chdir(<span class="string">&quot;/&quot;</span>) == <span class="number">-1</span>)   <span class="comment">/* 4. 修改进程的当前工作目录 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    close(STDIN_FILENO);    <span class="comment">/* 5. 通常根据需要，关闭/重定向 文件描述符 */</span></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR); <span class="comment">/* fd --&gt; 0 */</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dup2(fd, STDOUT_FILENO); <span class="comment">/* 重定向 stdout 和 stderr */</span></span><br><span class="line">    dup2(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>操作系统上总是会有很多运行中的进程，而CPU却很有限，那么哪个进程能获得CPU的使用权呢？Linux 与大多数其他 UNIX 实现一样，调度进程使用 CPU 的<strong>默认模型是循环时间共享</strong>。在这种模型中，每个进程轮流使用 CPU 一段时间，这段时间被称为<strong>时间片或量子</strong>。</p><p>但进程并不是完全平等的，某些重要进程应该被分配更多的CPU使用权。那么怎么描述进程的重要性呢？进程特性 <code>nice</code> 值允许进程间接地影响内核的调度算法。每个进程都拥有一个 <code>nice</code> 值，其取值范围为（高优先级）<code>−20～19</code>（低优先级），默认值为 0。非特权进程只能降低自己的优先级（不过这个说法已经不正确了），即赋一个大于默认值 0 的 <code>nice</code> 值。这样做之后它们就对其他进程“友好（nice）”了，这个特性的名称也由此而来。</p><p>进程的调度不是严格按照 <code>nice</code> 值的层次进行的，相反，<code>nice</code> 值是一个权重因素，它导致内核调度器倾向于调度拥有高优先级的进程。给一个进程赋一个低优先级（即高 <code>nice</code> 值）并不会导致它完全无法用到 CPU，但会导致它使用 CPU 的时间变少。</p><p>进程控制块<code>PCB</code>中就记录了进程的调度策略和优先级等值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 进程调度相关，优先级 */</span></span><br><span class="line">    <span class="type">int</span> prio, static_prio, normal_prio;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> rt_priority;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="title">sched_class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> <span class="title">se</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_rt_entity</span> <span class="title">rt</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> policy;            <span class="comment">/* 进程的调度策略 SCHED_FIFO, SCHED_RR, SCHED_OTHER, etc */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getpriority-x2F-set"><a href="#getpriority-x2F-set" class="headerlink" title="getpriority&#x2F;set"></a>getpriority&#x2F;set</h3><p><code>getpriority()</code>和 <code>setpriority()</code>系统调用允许一个进程获取和修改自身或其他<strong>进程的 <code>nice</code> 值</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setpriority</span><span class="params">(<span class="type">int</span> which, <span class="type">id_t</span> who, <span class="type">int</span> prio)</span>;</span><br></pre></td></tr></table></figure><p><code>which</code><strong>用于确定<code>who</code>如何被解释</strong>：</p><ul><li><code>PRIO_PROCESS</code>：操作进程 <code>PID</code> 为 who 的进程。如果 who 为 0，那么使用调用者的进程 ID。</li><li><code>PRIO_PGRP</code>：操作进程组 <code>PGID</code> 为 who 的进程组中的所有成员。如果 who 为 0，那么使用调用者的进程组。</li><li><code>PRIO_USER</code>：操作所有真实用户 <code>USRID</code> 为 who 的进程。如果 who 为 0，那么使用调用者的真实用户 ID。</li></ul><p>调用<code>getpriority</code>时，如果有多个进程符合指定的标准，那么将会返回<strong>优先级最高</strong>的进程的 <code>nice</code> 值（即最小的数值）。</p><blockquote><p>由于<code>getpriority</code>可能会在成功时返回<code>−1</code>，因此在调用这个函数之前必须要将 <code>errno</code> 设置为 0，接着在调用之后额外检查<code>errno</code>确认是否发生了错误。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> nice;</span><br><span class="line">    errno = <span class="number">0</span>;</span><br><span class="line">    nice = getpriority(PRIO_PROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nice == <span class="number">-1</span> &amp;&amp; errno != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* 说明调用时发生了错误 */</span></span><br><span class="line">        perror(<span class="string">&quot;getpriority failed!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;current nice: %d\n&quot;</span>, nice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>setpriority</code>时，试图将 <code>nice</code> 值设置为一个超出允许范围的值（<code>-20～+19</code>）时会直接将 <code>nice</code> 值设置为边界值（还存在其他限制）。</p><blockquote><p>需要说明一下，系统调用只能通过<code>syscall</code>直接发起，我们使用的<code>getpriority</code>等其实是<code>c</code>库函数对系统调用进行封装后的函数，库函数的返回结果并不一定是系统调用的直接返回值（虽然这种情况很少见，不过<code>getpriority</code>就是一个特例）。</p><p><code>getpriority()</code>系统调用服务例程不会返回实际的 nice 值，相反，它会返回一个范围在 1（低优先级）～40（高优先级）之间的数字，这个数字是通过公式 <code>unice=20-knice</code> 计算得来的。这样做是为了避免让系统调用服务例程返回一个负值，因为负值一般都表示错误。应用程序是不清楚系统调用服务例程对返回值所做的处理的，因为 C 库函数 <code>getpriority()</code>做了相反的计算操作，它将 <code>20-unice</code> 值返回给了调用程序。</p></blockquote><p>下面简单看一下这两个系统调用的实现：<a href="https://elixir.bootlin.com/linux/v2.6.39/source/kernel/sys.c#L236">linux-2.6.39 getpriority</a>，<a href="https://elixir.bootlin.com/glibc/glibc-2.36/source/sysdeps/unix/sysv/linux/getpriority.c#L35">glibc 库函数 getpriority</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TASK_NICE(p)        PRIO_TO_NICE((p)-&gt;static_prio)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">task_nice</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> task_struct *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> TASK_NICE(p);</span><br><span class="line">&#125;</span><br><span class="line">SYSCALL_DEFINE2(getpriority, <span class="type">int</span>, which, <span class="type">int</span>, who)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (which) &#123;</span><br><span class="line">        <span class="keyword">case</span> PRIO_PROCESS:</span><br><span class="line">            <span class="keyword">if</span> (who)</span><br><span class="line">                p = find_task_by_vpid(who);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = current;</span><br><span class="line">            <span class="keyword">if</span> (p) &#123;</span><br><span class="line">                niceval = <span class="number">20</span> - task_nice(p); <span class="comment">/* 将返回值设置为正数 */</span></span><br><span class="line">                <span class="keyword">if</span> (niceval &gt; retval)</span><br><span class="line">                    retval = niceval;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYSCALL_DEFINE3(setpriority, <span class="type">int</span>, which, <span class="type">int</span>, who, <span class="type">int</span>, niceval)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (niceval &lt; <span class="number">-20</span>) <span class="comment">/* 上下界判断 */</span></span><br><span class="line">        niceval = <span class="number">-20</span>;</span><br><span class="line">    <span class="keyword">if</span> (niceval &gt; <span class="number">19</span>)</span><br><span class="line">        niceval = <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">switch</span> (which) &#123;</span><br><span class="line">        <span class="keyword">case</span> PRIO_PROCESS:</span><br><span class="line">            <span class="keyword">if</span> (who)</span><br><span class="line">                p = find_task_by_vpid(who);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = current;</span><br><span class="line">            <span class="keyword">if</span> (p)</span><br><span class="line">                error = set_one_prio(p, niceval, error);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 库函数 getpriority */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PZERO 20</span></span><br><span class="line"><span class="type">int</span> __getpriority (<span class="keyword">enum</span> __priority_which which, <span class="type">id_t</span> who)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line"></span><br><span class="line">    res = INLINE_SYSCALL (getpriority, <span class="number">2</span>, (<span class="type">int</span>) which, who);</span><br><span class="line">    <span class="keyword">if</span> (res &gt;= <span class="number">0</span>)</span><br><span class="line">        res = PZERO - res; <span class="comment">/* 再次转换 */</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>nice</code>命令可以以指定的<code>nice</code>值运行程序。如<code>nice -3 ./test</code>，指定nice值为3，如果想指定为负数需要再加一个负号<code>nice --3 ./test</code>（需要特权）。</p><p><code>top</code> 中显示的 <code>NI</code> 一栏就是进程的 <code>nice</code> 值！<code>ps -l</code> 也可以查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ top</span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND</span><br><span class="line">275133 yogurt    20   0 8589112   4.5g   4.3g S  45.8  14.3 109:53.85 VirtualBoxVM</span><br><span class="line">  3894 yogurt    20   0 7470576 331140 125048 S   4.3   1.0  13:52.23 gnome-shell</span><br><span class="line">     3 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_gp</span><br><span class="line">     4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 rcu_par_gp</span><br></pre></td></tr></table></figure><p>从版本号为 <code>2.6.12</code> 的内核开始，Linux 提供了 <code>RLIMIT_NICE</code> 资源限制，即允许非特权进程提升 <code>nice</code> 值。非特权进程能够将自己的 <code>nice</code> 值最高提高到公式 <code>20−rlim_cur</code> 指定的值，其中 <code>rlim_cur</code> 是当前的 <code>RLIMIT_NICE</code> 软资源限制。如假设一个进程的 <code>RLIMIT_NICE</code> 软限制是 25，那么其 <code>nice</code>值可以被提高到−5。根据这个公式以及 <code>nice</code> 值的取值范围为（低）<code>+19～−20</code>（高）的事实可以得出 <code>RLIMIT_NICE</code> 的有效范围为（低）<code>1～40</code>（高）的结论。如何修改该值就涉及到下面的进程资源了。</p><h2 id="进程资源"><a href="#进程资源" class="headerlink" title="进程资源"></a>进程资源</h2><p>每个进程都用一组资源限值，它们可以用来限制进程能够消耗的各种系统资源。如在执行任意一个程序之前如果不想让它消耗太多资源，则可以设置该进程的资源限制。</p><h3 id="getrlimit-x2F-set"><a href="#getrlimit-x2F-set" class="headerlink" title="getrlimit&#x2F;set"></a>getrlimit&#x2F;set</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">getrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setrlimit</span><span class="params">(<span class="type">int</span> resource, <span class="type">const</span> <span class="keyword">struct</span> rlimit *rlim)</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_cur;  <span class="comment">/* Soft limit */</span></span><br><span class="line">    <span class="type">rlim_t</span> rlim_max;  <span class="comment">/* Hard limit (ceiling for rlim_cur) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>resource</code> 指定资源，这里有很多选项，查看<code>man page</code>等资料即可，下面只列几项内容：</p><table><thead><tr><th>resource 取值</th><th>说明</th></tr></thead><tbody><tr><td><code>RLIMIT_NICE</code></td><td>能够为进程设置的最大 <code>nice</code> 值</td></tr><tr><td><code>RLIMIT_RTPRIO</code></td><td>能够为进程设置的最高实时优先级</td></tr><tr><td><code>RLIMIT_STACK</code></td><td>进程栈的最大字节数</td></tr></tbody></table><p><strong>软限制</strong>规定了进程能够消耗的资源数量。一个进程可以将软限制调整为从 0 到硬限制之间的值。对于大多数资源来讲，<strong>硬限制的唯一作用是为软限制设定了上限</strong>。特权（<code>CAP_SYS_RESOURCE</code>）进程能够增大和缩小硬限制（只要其值仍然大于软限制），但非特权进程则只能缩小硬限制（这个行为是不可逆的）。取值为 <code>RLIM_INFINITY</code> 表示没有限制。<code>prlimit</code>可以打印出当前的资源限制情况。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ prlimit</span><br><span class="line">RESOURCE   DESCRIPTION                              SOFT       HARD UNITS</span><br><span class="line">AS         address space limit                 unlimited  unlimited bytes</span><br><span class="line">CORE       max core file size                          <span class="number">0</span>  unlimited bytes</span><br><span class="line">CPU        CPU time                            unlimited  unlimited seconds</span><br><span class="line">DATA       max data size                       unlimited  unlimited bytes</span><br><span class="line">FSIZE      max file size                       unlimited  unlimited bytes</span><br><span class="line">LOCKS      max number of file locks held       unlimited  unlimited locks</span><br><span class="line">MEMLOCK    max locked-in-memory address space <span class="number">4173918208</span> <span class="number">4173918208</span> bytes</span><br><span class="line">MSGQUEUE   max bytes in POSIX mqueues             <span class="number">819200</span>     <span class="number">819200</span> bytes</span><br><span class="line">NICE       max nice prio allowed to raise              <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">NOFILE     max number of open files                 <span class="number">1024</span>    <span class="number">1048576</span> files</span><br><span class="line">NPROC      max number of processes                <span class="number">127101</span>     <span class="number">127101</span> processes</span><br><span class="line">RSS        max resident <span class="built_in">set</span> size               unlimited  unlimited bytes</span><br><span class="line">RTPRIO     max real-time priority                      <span class="number">0</span>          <span class="number">0</span></span><br><span class="line">RTTIME     timeout <span class="keyword">for</span> real-time tasks         unlimited  unlimited microsecs</span><br><span class="line">SIGPENDING max number of pending signals          <span class="number">127101</span>     <span class="number">127101</span> signals</span><br><span class="line">STACK      max <span class="built_in">stack</span> size                        <span class="number">8388608</span>  unlimited bytes</span><br></pre></td></tr></table></figure><h2 id="实时进程调度"><a href="#实时进程调度" class="headerlink" title="实时进程调度"></a>实时进程调度</h2><p>在一个系统上一般会同时运行交互式进程和后台进程，标准的内核调度算法一般能够为这些进程提供足够的性能和响应度。但实时应用对调度器有更加严格的要求：</p><ul><li>实时应用必须要为外部输入提供担保最大响应时间。为了满足这种要求，内核必须要提供工具让高优先级进程能快速地取得 CPU 的控制权，<strong>抢占当前运行的所有进程</strong>。</li><li>高优先级进程应该能够保持互斥地访问 CPU <strong>直至它完成</strong>或自动释放 CPU。</li><li>实时应用应该能够精确地控制其组件进程的调度顺序。</li></ul><p>SUSv3 规定的实时进程调度 API 提供了两个实时调度策略：<code>SCHED_RR</code> 和 <code>SCHED_FIFO</code>。使用这两种策略中任意一种策略进行调度的进程的优先级要高于默认的标准循环时间分享<code>SCHED_OTHER</code>策略来调度的进程。</p><p>每个实时策略允许一个优先级范围。在每个调度策略中，拥有高优先级的可运行进程在尝试访问 CPU 时总是优先于优先级较低的进程。Linux 提供了 99 个实时优先级，<strong>其数值从 1（最低）～99（最高）</strong>，并且这个取值范围同时适用于两个实时调度策略。</p><blockquote><p>对于多处理器 Linux 系统（包括超线程系统）来讲，高优先级的可运行进程总是优先于优先级较低的进程的规则并不适用。在多处理器系统中，各个 CPU 拥有独立的运行队列（这种方式比使用一个系统层面的运行队列的性能要好），并且每个 CPU 的运行队列中的进程的优先级都局限于该队列。如假设一个双处理器系统中运行着三个进程，进程 A 的实时优先级为 20，并且它位于 CPU 0 的等待队列中，而该 CPU 当前正在运行优先级为 30 的进程 B，即使 CPU 1 正在运行优先级为 10 的进程 C，进程 A 还是需要等待 CPU 0。</p></blockquote><h3 id="CPU-亲和性"><a href="#CPU-亲和性" class="headerlink" title="CPU 亲和性"></a>CPU 亲和性</h3><p>设置进程的CPU亲和性用于限制进程在指定的CPU上运行，内核尝试了给进程保证<strong>软 CPU 亲和力</strong> — <strong>在条件允许的情况下</strong>进程重新被调度到原来的CPU 上运行。但这并不是强制性的，条件不允许仍然会将进程调度到其他CPU上运行。有时候需要为进程设置<strong>硬 CPU 亲和力</strong>，这样就能显式地将其限制在可用 CPU 中的一个或一组 CPU 上运行，原因如下：</p><ul><li>可以避免由使高速缓冲器中的数据失效所带来的性能影响。</li><li>如果多个线程（或进程）访问同样的数据，那么当将它们限制在同样的 CPU 上的话可能会带来性能提升，因为它们无需竞争数据并且也不存在由此而产生的高速缓冲器未命中。</li><li>对于时间关键的应用程序来讲，可能需要为此应用程序预留一个或更多 CPU，而将系统中大多数进程限制在其他 CPU 上。</li></ul><blockquote><p>使用 isolcpus 内核启动参数能够将一个或更多 CPU 分离出常规的内核调度算法。将一个进程移到或移出被分离出来的 CPU 的唯一方式是使用本节介绍的 CPU 亲和力系统调用。isolcpus启动参数是实现上面列出的最后一种场景的首选方式，具体可参考内核源文件 Documentation&#x2F;kernel-parameters.txt。</p></blockquote><h4 id="sched-setaffinity-x2F-get"><a href="#sched-setaffinity-x2F-get" class="headerlink" title="sched_setaffinity&#x2F;get"></a>sched_setaffinity&#x2F;get</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize,</span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">cpu_set_t</span> *mask)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getaffinity</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">size_t</span> cpusetsize,</span></span><br><span class="line"><span class="params">                        <span class="type">cpu_set_t</span> *mask)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>pid</code>：要设置的进程号，也可简单的用<code>0</code>来表示调用进程，也可用<code>gettid()</code>传入线程号</li><li><code>cpusetsize</code>：应该指定 <code>mask</code> 参数的字节数，通常设定为<code>sizeof(cpu_set_t)</code></li><li><code>mask</code>：核的掩码。</li><li>返回值：成功返回0，失败返回<code>-1</code>，并设置<code>errno</code><ul><li>如果<code>mask</code>中指定的 CPU 与系统中的所有 CPU 都不匹配，返回<code>EINVAL</code>错误</li></ul></li></ul><p><code>taskset -p PID</code> 可查看当前进程的<code>mask</code>，可通过 <code>taskset -pc $pid</code> 来获取某线程与CPU核心的亲和性。</p><p>虽然 <code>cpu_set_t</code> 数据类型实现为一个位掩码，但应该将其看成是一个不透明的结构。</p><p>所有对这个结构的操作都应该使用宏来完成，下面是部分常用的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* man CPU_SET */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_ZERO</span><span class="params">(<span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;          <span class="comment">/* 将 set 初始化为空 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_SET</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;  <span class="comment">/* 将 CPU cpu 添加到 set 中 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CPU_CLR</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;  <span class="comment">/* 从 set 中删除 CPU cpu */</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">CPU_ISSET</span><span class="params">(<span class="type">int</span> cpu, <span class="type">cpu_set_t</span> *<span class="built_in">set</span>)</span>;<span class="comment">/* 在 CPU cpu 是 set 的一个成员时返回 true */</span></span><br></pre></td></tr></table></figure><p>注意上面宏参数<code>cpu</code>编号是从0开始。</p><h2 id="环境列表"><a href="#环境列表" class="headerlink" title="环境列表"></a>环境列表</h2><p>每一个进程都有与其相关的称之为环境列表（environment list）的字符串数组，或简称为环境（environment）。其中每个字符串都以名称&#x3D;值（name&#x3D;value）形式定义。因此，环境是“名称-值”的成对集合，可存储任何信息。常将列表中的名称称为环境变量。</p><p><strong>新进程在创建之时，会继承其父进程的环境副本！</strong>可通过命令<code>printenv</code>查看当前shell环境变量。</p><p>在 C 语言程序中，可以使用全局变量 <code>char **environ</code> 访问环境列表。（C 运行时启动代码定义了该变量并以环境列表位置为其赋值。）<code>environ</code> 与 <code>argv</code> 参数类似，指向一个以 <code>NULL</code> 结尾的指针列表，每个指针又指向一个以空字节终止的字符串。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> **ep;</span><br><span class="line">    <span class="keyword">for</span> (ep = environ; *ep; ep++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, *ep);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getenv"><a href="#getenv" class="headerlink" title="getenv"></a>getenv</h3><p><code>getenv()</code>函数能够从进程环境中检索单个值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *<span class="title function_">getenv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><ul><li>name：指向要检索的环境变量名称的字符串。</li><li>返回值：如果找到该环境变量，则返回该环境变量的值，否则返回 NULL。</li></ul><h3 id="putenv"><a href="#putenv" class="headerlink" title="putenv"></a>putenv</h3><p>有时，对进程来说，修改其环境很有用处。原因之一是这一修改对该进程后续创建的所有子进程均可见。另一个可能的原因在于设定某一变量，以求对于将要载入进程内存的新程序（“execed”）可见。从这个意义上讲，环境不仅是一种进程间通信的形式，还是程序间通信的方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">putenv</span><span class="params">(<span class="type">char</span> *<span class="built_in">string</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>string：参数 string 是一指针，指向 name&#x3D;value 形式的字符串。</li><li>返回值：如果成功，则返回 0，否则返回 非0值，并设置 errno。</li></ul><p>调用 <code>putenv()</code> 函数后，该字符串就成为环境的一部分，换言之，<code>putenv</code> 函数将设定 <code>environ</code> 变量中某一元素的指向与 <code>string</code> 参数的指向位置相同，而非 <code>string</code> 参数所指向字符串的复制副本。</p><h2 id="proc-文件系统"><a href="#proc-文件系统" class="headerlink" title="proc 文件系统"></a>proc 文件系统</h2><p>对于系统中每个进程，内核都提供了相应的目录，命名为<code>/proc/PID</code>，其中 <code>PID</code> 是进程的ID。在此目录中的各种文件和子目录包含了进程的相关信息。</p><p><strong>可通过<code>man 5 proc</code>查看具体介绍</strong>！描述的所有文件的作用以及其内容的含义。</p><table><thead><tr><th>文件</th><th>描述</th></tr></thead><tbody><tr><td>cmdline</td><td>以\0 分隔的命令行参数</td></tr><tr><td>cwd</td><td>指向当前工作目录的符号链接</td></tr><tr><td>Environ</td><td>NAME&#x3D;value 键值对环境列表，以\0 分隔</td></tr><tr><td>exe</td><td>指向正在执行文件的符号链接</td></tr><tr><td>fd</td><td>文件目录，包含了指向由进程打开文件的符号链接</td></tr><tr><td>maps</td><td><strong>内存映射</strong></td></tr><tr><td>mem</td><td>进程虚拟内存（在 I&#x2F;O 操作之前必须调用 <code>lseek()</code>移至有效偏移量）</td></tr><tr><td>mounts</td><td>进程的安装点</td></tr><tr><td>root</td><td>指向根目录的符号链接</td></tr><tr><td>status</td><td>各种信息（比如，进程 ID、凭证、内存使用量、信号）</td></tr><tr><td>task</td><td>为进程中的<strong>每个线程均包含一个子目录</strong>（始自 Linux 2.6）</td></tr></tbody></table><h3 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h3><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>address</code></td><td>部分显示的是该段映射的虚拟地址。</td></tr><tr><td><code>perms</code></td><td>内存块权限 &#96;READ</td></tr><tr><td><code>offset</code></td><td>该段映射在文件&#x2F;其它设备上的偏移量</td></tr><tr><td><code>dev</code></td><td>设备号</td></tr><tr><td><code>inode</code></td><td>文件或者设备的<code>inode</code>节点，0表示没有<code>inode</code>与该段内存关联</td></tr><tr><td><code>pathname</code></td><td>路径名是与该段内存关联的文件路径，若为空，可能是通过<code>mmap</code>创建的匿名映射</td></tr><tr><td><code>[stack]</code></td><td>进程（主线程）的栈空间</td></tr><tr><td><code>[stack:&lt;tid&gt;]</code></td><td>对应线程<code>tid</code>的栈空间</td></tr><tr><td><code>[heap]</code></td><td>进程的堆空间</td></tr><tr><td><code>[vdso]</code></td><td>virtual dynamic shared object，<code>man 7 vdso</code>查看介绍</td></tr></tbody></table><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ ldd debug</span><br><span class="line">linux-vdso.so.1 (0x00007ffc60be6000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4b7c418000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007f4b7c662000)</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> /proc/19898/maps</span><br><span class="line"><span class="comment"># The format of the file is:</span></span><br><span class="line"><span class="comment"># address                 perms offset  dev    inode        pathname</span></span><br><span class="line">562bc9b9e000-562bc9b9f000 r--p 00000000 103:07 3422919      /tmp/debug</span><br><span class="line">562bc9b9f000-562bc9ba0000 r-xp 00001000 103:07 3422919      /tmp/debug</span><br><span class="line">562bc9ba0000-562bc9ba1000 r--p 00002000 103:07 3422919      /tmp/debug</span><br><span class="line">562bc9ba1000-562bc9ba2000 r--p 00002000 103:07 3422919      /tmp/debug</span><br><span class="line">562bc9ba2000-562bc9ba3000 rw-p 00003000 103:07 3422919      /tmp/debug</span><br><span class="line">562bc9cb2000-562bc9cd3000 rw-p 00000000 00:00  0             [heap]</span><br><span class="line">7f94721de000-7f94721e1000 rw-p 00000000 00:00  0</span><br><span class="line">7f94721e1000-7f9472209000 r--p 00000000 103:07 12847599     /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">7f9472209000-7f947239e000 r-xp 00028000 103:07 12847599     /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">7f947239e000-7f94723f6000 r--p 001bd000 103:07 12847599     /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">7f94723f6000-7f94723fa000 r--p 00214000 103:07 12847599     /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">7f94723fa000-7f94723fc000 rw-p 00218000 103:07 12847599     /usr/lib/x86_64-linux-gnu/libc.so.6</span><br><span class="line">7f94723fc000-7f9472409000 rw-p 00000000 00:00  0</span><br><span class="line">7f9472424000-7f9472426000 rw-p 00000000 00:00  0</span><br><span class="line">7f9472426000-7f9472428000 r--p 00000000 103:07 12847231     /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">7f9472428000-7f9472452000 r-xp 00002000 103:07 12847231     /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">7f9472452000-7f947245d000 r--p 0002c000 103:07 12847231     /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line"><span class="comment"># 自己添加的文件映射</span></span><br><span class="line">7f947245d000-7f947245e000 rw-p 00000000 103:07 12066390     /tmp/mmap_file1.c</span><br><span class="line"></span><br><span class="line">7f947245e000-7f9472460000 r--p 00037000 103:07 12847231     /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line">7f9472460000-7f9472462000 rw-p 00039000 103:07 12847231     /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2</span><br><span class="line"></span><br><span class="line">7fff5f37d000-7fff5f39e000 rw-p 00000000 00:00  0             [stack]</span><br><span class="line">7fff5f3df000-7fff5f3e3000 r--p 00000000 00:00  0             [vvar]</span><br><span class="line">7fff5f3e3000-7fff5f3e5000 r-xp 00000000 00:00  0             [vdso]</span><br><span class="line"></span><br><span class="line">ffffffffff600000-ffffffffff601000 --xp 00000000 00:00 0     [vsyscall]</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Linux&#x2F;Unix系统编程手册》</li><li>《操作系统之哲学原理 第二版》</li><li>《计算机体系结构基础》</li><li><a href="https://www.cnblogs.com/yungyu16/p/13024626.html">PCB 进程控制块</a></li><li><a href="https://elixir.bootlin.com/linux/v5.4.190/source/include/linux/sched.h#L624">PCB(task_struct)源码</a></li><li><a href="https://github.com/szza/LearningNote/blob/master/4.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3_%E8%BF%9B%E7%A8%8B.md">操作系统–进程</a></li><li><a href="https://www.bilibili.com/video/BV1KE411q7ee?p=77">物理内存和虚拟内存的映射关系</a></li><li><a href="https://xiaolincoding.com/os/3_memory/vmem.html#linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86">小林coding–为什么要有虚拟内存？</a></li><li><a href="https://xiaolincoding.com/os/4_process/process_base.html">小林coding–进程管理</a></li><li><a href="https://www.cnblogs.com/tolimit/p/4530370.html">linux源码分析 - 进程</a></li><li><a href="https://zhuanlan.zhihu.com/p/266720121">搞懂进程组、会话、控制终端关系，才能明白守护进程如何创建</a></li><li><a href="https://blog.csdn.net/qq_31828515/article/details/73849568">进程间的关系以及终端的概念</a></li><li>《Linux系统编程——6.4虚拟内存管理》</li><li><a href="https://blog.csdn.net/sunao2002002/article/details/84132505">&#x2F;proc&#x2F;pid&#x2F;maps文件格式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-文件</title>
      <link href="/2022/04/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6/"/>
      <url>/2022/04/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>应用程序的系统调用过程：应用程序-&gt;库函数-&gt;系统调用-&gt;驱动-&gt;硬件（磁盘、网卡等）</p><h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><p>现代处理器架构一般允许 CPU 至少在两种不同状态下运行，即：用户态和核心态（有时也称之为监管态 supervisor mode）。执行硬件指令可使 CPU 在两种状态间来回切换。与之对应，<strong>可将虚拟内存区域划分（标记）为用户空间部分或内核空间部分</strong>。<strong>在用户态下运行时，CPU 只能访问被标记为用户空间的内存</strong>，试图访问属于内核空间的内存会引发硬件异常。<strong>当运行于核心态时，CPU 既能访问用户空间内存，也能访问内核空间内存</strong>。</p><p>仅当处理器在核心态运行时，才能执行某些特定操作。这样的例子包括：执行宕机（halt）指令去关闭系统，访问内存管理硬件，以及设备 I&#x2F;O 操作的初始化等。实现者们利用这一硬件设计，将操作系统置于内核空间。这确保了用户进程既不能访问内核指令和数据结构，也无法执行不利于系统运行的操作。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>系统调用是受控的内核入口，借助于这一机制，进程可以请求内核以自己的名义去执行某些动作。以应用程序编程接口（API）的形式，内核提供有一系列服务供程序访问。这包括创建新进程、执行 I&#x2F;O，以及为进程间通信创建管道等。</p><ul><li>系统调用将处理器从用户态切换到核心态，以便 CPU 访问受到保护的内核内存。</li><li>系统调用的组成是固定的，每个系统调用都由一个唯一的数字来标识。（程序通过名称来标识系统调用，对这一编号方案往往一无所知。）</li><li>每个系统调用可辅之以一套参数，对用户空间（亦即进程的虚拟地址空间）与内核空间之间（相互）传递的信息加以规范。</li></ul><p>在探究系统调用时会反复涉及原子操作的概念。<strong>所有系统调用都是以原子操作方式执行的</strong>。之所以这么说，是指内核保证了某系统调用中的所有步骤会作为独立操作而一次性加以执行，其间不会为其他进程或线程所中断。</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><table><thead><tr><th>文件类型标识</th><th>文件类型</th></tr></thead><tbody><tr><td>-</td><td>普通文件</td></tr><tr><td>d</td><td>目录</td></tr><tr><td>l</td><td>符号链接</td></tr><tr><td>s（伪文件）</td><td>套接字</td></tr><tr><td>b（伪文件）</td><td>块设备</td></tr><tr><td>c（伪文件）</td><td>字符设备</td></tr><tr><td>p（伪文件）</td><td>管道</td></tr></tbody></table><p>伪文件不占用磁盘空间。</p><h3 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h3><p>每一个进程对应一个PCB进程控制块（一个记录进程信息的结构体），PCB中包含了一个文件描述符数组0&#x2F;1&#x2F;2…1023，每一个文件描述符对应该进程打开的一个文件。</p><p><em>将文件描述符数组理解为指针数组，文件描述符 fd 就是指针数组的下标！通过它得到指向对应文件的指针。</em></p><p>其中，0,1,2是预定义了的，0是标准输入，1是标准输出，2是标准错误输出。</p><p>进程里面用户打开的文件的文件描述符从3开始编号。</p><p><strong>两个不同的文件描述符，若指向同一打开文件句柄，将共享同一文件偏移量</strong>。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用 <code>read()</code>、<code>write()</code>或 <code>lseek()</code>所致），那么从另一文件描述符中也会观察到这一变化。<strong>无论这两个文件描述符分属于不同进程，还是同属于一个进程</strong>，情况都是如此。</p><h3 id="dentry-和-inode"><a href="#dentry-和-inode" class="headerlink" title="dentry 和 inode"></a>dentry 和 inode</h3><p>一个文件主要由两部分组成，dentry(目录项)和 inode，inode 本质是结构体，存储文件的属性信息，如：权限、类型、大小、时间、用户、盘快位置等。也叫做文件属性管理结构，大多数的 inode 都存储在磁盘上，少量常用、近期使用的 inode 会被缓存到内存中。</p><p>所谓的删除文件，就是删除 inode，但是数据其实还是在硬盘上，以后会覆盖掉。</p><h3 id="硬链接与软链接"><a href="#硬链接与软链接" class="headerlink" title="硬链接与软链接"></a>硬链接与软链接</h3><p>通过硬链接新建的文件与旧文件对应同一个 inode，只是新建了 dentry。</p><ul><li>具有相同 inode 节点号的多个文件互为硬链接文件；</li><li>只有删除了源文件和所有对应的硬链接文件，文件实体才会被删除；</li><li>硬链接文件是文件的另一个入口；</li></ul><p>软链接则类型于windows上的快捷方式，删除软链接文件完全不影响原文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ln</span> oldfile.txt newfile.txt <span class="comment"># 创建硬链接</span></span><br><span class="line"><span class="built_in">ln</span> -s /etc/oldfile.txt newfile.txt <span class="comment"># 软链接文件创建时最好用绝对路径，或者文件移动位置后会失效</span></span><br></pre></td></tr></table></figure><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6/linux-soft-hard-link-diff.png" alt="img"></p><p>冷知识：<code>.</code>、<code>..</code>目录也是通过硬链接创建的。<strong>但不支持用户为目录添加硬连接！</strong></p><p>不能为目录创建硬链接，从而避免出现令诸多系统程序陷于混乱的链接环路。使用绑定挂载（bind mount）可以获得与为目录创建硬链接相似的效果。</p><h2 id="open-函数"><a href="#open-函数" class="headerlink" title="open 函数"></a>open 函数</h2><p>打开文件并返回文件描述符，其返回值为进程未用文件描述符中数值最小者！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/etc/passwd&quot;</span>, O_RDWR|O_CREAT|O_EXCL, <span class="number">0664</span>);</span><br></pre></td></tr></table></figure><ul><li><code>pathname</code>：文件路径</li><li><code>flags</code>：指定文件的打开方式，<code>O_RDONLY, O_WRONLY, or O_RDWR</code><ul><li><code>O_RDONLY</code>：只读</li><li><code>O_WRONLY</code>：只写</li><li><code>O_RDWR</code>：读写。注意 <code>O_RDWR</code> 并不等同于 <code>O_RDONLY | O_WRONLY</code>，后者（或组合）属于逻辑错误。<br>早期的 UNIX 实现中使用数字 0、1、2 表示上述三个打开方式，为了与早期系统兼容，采用了同样的方式！</li><li><code>O_APPEND</code>：若文件有内容，在文件末尾追加</li><li><code>O_TRUNC</code>：若文件存在则清空</li><li><code>O_CREAT</code>：若文件不存在则创建</li><li><code>O_EXCL</code>：若文件存在则报错，配合 <code>O_CREAT</code> 使用</li></ul></li><li><code>mode</code>：flags 指定了 <code>O_CREAT</code> 时才可使用，指定文件权限 <code>mode=0664</code>(八进制数)，文件权限 <code>= mode &amp; ~umask</code>。</li><li>返回值：文件描述符，若失败则返回-1并设置errno，其返回值为进程未用文件描述符中数值最小者！</li></ul><h3 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h3><p>umask值用于设置用户在创建文件时的默认权限，当我们在系统中创建目录或文件时，目录或文件所具有的<strong>默认权限就是由umask值决定的</strong>。</p><p>对于root用户，系统默认的umask值是0022；对于普通用户，系统默认的umask值是0002。执行umask命令可以查看当前用户的umask值。</p><p>umask值一共有4组数字，其中第1组数字用于定义特殊权限，我们一般不予考虑，与一般权限有关的是后3组数字。</p><p>默认情况下，对于目录，用户所能拥有的最大权限是777；对于文件，用户所能拥有的最大权限是目录的最大权限去掉执行权限，即666。因为x执行权限对于目录是必须的，没有执行权限就无法进入目录，而对于文件则不必默认赋予x执行权限。</p><p>对于root用户，他的umask值是022。当root用户创建目录时，默认的权限就是用最大权限777去掉相应位置的umask值权限，即对于所有者不必去掉任何权限，对于所属组要去掉w权限，对于其他用户也要去掉w权限，所以目录的默认权限就是755；当root用户创建文件时，默认的权限则是用最大权限666去掉相应位置的umask值，即文件的默认权限是644。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>系统调用的函数出错时，通常会设置变量<code>errno</code>，可以通过库函数 <code>strerror(errno)</code>和<code>perror(char *msg)</code>来查看报错数字的含义。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">perror</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strerror</span><span class="params">(<span class="type">int</span> errnum)</span>;</span><br><span class="line"></span><br><span class="line">fd = open(pathname，flags，mode);</span><br><span class="line"><span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">    <span class="comment">// printf(&quot;error: %s \n&quot;, strerror(errno));</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FATLURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 <code>perror()</code>会打印出其 msg 参数所指向的字符串，紧跟一条与当前 errno 值相对应的消息。</p><p>函数 <code>strerror()</code>会针对其 errno 参数中所给定的错误号，返回相应的错误字符串。</p><h2 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h2><p><code>close()</code>系统调用关闭一个打开的文件描述符，并将其释放回调用进程，供该进程继续使用。当一进程终止时，将自动关闭其已打开的所有文件描述符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><h2 id="read-函数"><a href="#read-函数" class="headerlink" title="read 函数"></a>read 函数</h2><p>从文件读取数据，返回读取的字节数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/etc/file&quot;</span>, O_RDONLY);</span><br><span class="line"><span class="type">ssize_t</span> n = read(fd, buf, <span class="number">100</span>);</span><br></pre></td></tr></table></figure><ul><li><code>fd</code>：文件描述符</li><li><code>buf</code>：用来存放输入数据的内存缓冲区地址。缓冲区至少应有 count 个字节。</li><li><code>count</code>：指定最多能读取的字节数，size_t 数据类型属于无符号整数类型。</li><li>返回值：ssize_t 数据类型属于有符号的整数类型<ul><li><code>&gt;0</code>，读取的字节数；</li><li><code>=0</code>，读到文件末尾（EOF）；</li><li><code>-1</code>，读取失败，错误码存储在errno中；</li></ul></li></ul><h2 id="write-函数"><a href="#write-函数" class="headerlink" title="write 函数"></a>write 函数</h2><p>向文件写入数据，返回实际写入的字节数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">char</span> buf[<span class="number">100</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/etc/file&quot;</span>, O_RDWR);</span><br><span class="line"><span class="type">ssize_t</span> n = write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br></pre></td></tr></table></figure><ul><li>fd：文件描述符</li><li>buf：要写入的数据的内存地址</li><li>count：欲从 buffer 写入文件的数据字节数</li><li>返回值：<ul><li><code>&gt;0</code>，写入的字节数；</li><li>-1，写入失败，错误码存储在errno中；</li></ul></li></ul><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><p>每调用一次<code>write()</code>，就会进行一次内核态和用户态的切换，如果频繁调用且每次写入的数量不大，可以使用缓冲区，提高性能。</p><p>库函数中的<code>fputc()</code>和<code>fputs()</code>函数，就使用了缓冲区（默认大小4096byte），以提高性能。</p><p><strong>所以系统函数并不是一定比库函数牛逼，能使用库函数的地方就使用库函数。</strong></p><p>注意，将日志写入到文件时，对缓冲区的处理与输出到终端不一样。<strong>当输出到文件时，只有当缓冲区满的时候，才回真正输出缓冲区的内容，并清空缓冲区</strong>。当输出到屏幕时，<em>除了缓冲区满外，遇到’\n’会自动清空缓冲区，另外读入内容也会清空缓冲区</em>。当写入到文件时，往往需要显示调用 <code>fflush()</code>;</p><h2 id="lseek-函数"><a href="#lseek-函数" class="headerlink" title="lseek 函数"></a>lseek 函数</h2><p>对于每个打开的文件，系统内核会记录其文件偏移量，有时也将文件偏移量称为读写偏移量或指针。文件偏移量是指执行下一个 <code>read()</code>或 <code>write()</code>操作的文件起始位置，会以相对于文件头部起始点的文件当前位置来表示。文件第一个字节的偏移量为 0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">off_t</span> <span class="title function_">lseek</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> offset, <span class="type">int</span> whence)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">char</span> msg[<span class="number">100</span>] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;/etc/file&quot;</span>, O_RDWR);</span><br><span class="line"><span class="type">ssize_t</span> n = write(fd, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">lseek(fd, <span class="number">100</span>, SEEK_END); <span class="comment">// 拓展文件大小 100 byte</span></span><br><span class="line">write(fd, <span class="string">&quot;\0&quot;</span>, <span class="number">1</span>); <span class="comment">// 写入一个空字符，不进行操作就无法拓展文件大小</span></span><br><span class="line">lseek(fd, <span class="number">0</span>, SEEK_SET); <span class="comment">// 设置文件指针到文件开头</span></span><br><span class="line">read(fd, msg, n);</span><br></pre></td></tr></table></figure><ul><li><code>fd</code>：文件描述符</li><li><code>offset</code>：偏移量，将读写指针从 whence 指定位置向后偏移 offset 个单位</li><li><code>whence</code>：起始偏移位置，可以是 <code>SEEK_SET</code>（文件开头），<code>SEEK_CUR</code>（当前位置），<code>SEEK_END</code>（文件末尾）</li><li>返回值：文件指针的新位置，若失败则返回-1并设置errno</li></ul><p>获取文件偏移量的当前位置：<code>curr = lseek(fd，0，SEEK_CUR);</code></p><p>应用场景：</p><ol><li>使用 <code>lseek</code> 获取文件大小</li><li>使用 <code>lseek</code> 拓展文件大小，但要想使文件大小真正拓展，必须进行写操作。也可使用 <code>truncate</code> 函数，直接拓展文件</li></ol><h2 id="truncate-x2F-ftruncate-函数"><a href="#truncate-x2F-ftruncate-函数" class="headerlink" title="truncate&#x2F;ftruncate 函数"></a>truncate&#x2F;ftruncate 函数</h2><p>设置文件为指定大小，若文件大小大于指定值时，会截断到指定大小。小于时，会在文件末尾添加空字符。</p><p>文件不存在，或文件没有写权限，返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">truncate</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *path, <span class="type">off_t</span> length)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ftruncate</span><span class="params">(<span class="type">int</span> fd, <span class="type">off_t</span> length)</span>;</span><br></pre></td></tr></table></figure><ul><li><code>path</code>：文件路径</li><li><code>length</code>：指定文件大小，若文件当前长度大于参数 length，调用将丢弃超出部分，若小于参数 length，调用将在文件尾部添加一系列空字节或是一个文件空洞。</li><li>返回值：<ul><li>0，成功；</li><li>-1，失败，错误码存储在errno中；</li></ul></li><li><code>fd</code>：要修改的文件描述符。该系统调用不会修改文件偏移量！</li></ul><p>编译时使用<code>-std=c99</code>会报警告，可以使用<code>-std=gnu99</code>来兼容。</p><h2 id="fcntl-函数"><a href="#fcntl-函数" class="headerlink" title="fcntl 函数"></a>fcntl 函数</h2><p><code>fcntl()</code>系统调用对一个打开的文件描述符执行一系列控制操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure><ul><li><code>cmd</code> 参数所支持的操作范围很广。</li><li>第三个参数以省略号来表示，这意味着可以将其设置为不同的类型，或者加以省略。内核会依据 cmd 参数（如果有的话）的值来确定该参数的数据类型。</li></ul><h2 id="pread-x2F-pwrite-函数"><a href="#pread-x2F-pwrite-函数" class="headerlink" title="pread&#x2F;pwrite 函数"></a>pread&#x2F;pwrite 函数</h2><p>系统调用 <code>pread()</code> 和 <code>pwrite()</code> 完成与 <code>read()</code> 和 <code>write()</code> 相类似的工作，<strong>只是前两者会在 <code>offset</code> 参数所指定的位置</strong>进行文件 I&#x2F;O 操作，而非始于文件的当前偏移量处，且<strong>它们不会改变文件的当前偏移量</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pread</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">pwrite</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count, <span class="type">off_t</span> offset)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pread(O)调用等同于将如下调用纳入同一原子操作:</span></span><br><span class="line"><span class="type">off_t</span> orig;</span><br><span class="line"></span><br><span class="line">orig = lseek(fd，<span class="number">0</span>，SEEK_CUR);   /# Save CUITITent offset *#/</span><br><span class="line">lseek(fd，offset，SEEK_SET);</span><br><span class="line">s = read(fd，buf，len);</span><br><span class="line">lseek(fd，orig，SEEK_SET);       /# Restore original file offset *#/</span><br></pre></td></tr></table></figure><ul><li><code>offset</code>: 在指定的位置进行文件 I&#x2F;O 操作</li></ul><p>该函数在多线程下有用武之地，当调用 <code>pread()</code> 或 <code>pwrite()</code> 时，多个线程可同时对同一文件描述符执行 I&#x2F;O 操作，且不会因其他线程修改文件偏移量而受到影响。</p><h2 id="stat-函数"><a href="#stat-函数" class="headerlink" title="stat 函数"></a>stat 函数</h2><p>获取文件属性，从 inode 结构体中获取。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">stat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fstat</span><span class="params">(<span class="type">int</span> fd, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">lstat</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="keyword">struct</span> stat *statbuf)</span>;</span><br></pre></td></tr></table></figure><ul><li>pathname：文件路径</li><li>statbuf：存储文件属性的结构体，inode 结构体中的属性信息都会被存储到 statbuf 中</li><li>返回值：<ul><li>0，成功；</li><li>-1，失败，错误码存储在errno中；</li></ul></li></ul><p><code>fstat</code>与<code>stat</code>等价，只是传入参数为文件描述符。</p><p><code>lstat</code>与<code>stat</code>等价，只是传入的文件类型为<strong>符号链接</strong>时，返回的文件信息是符号链接本身的信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="type">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">    <span class="type">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">    <span class="type">mode_t</span>    st_mode;        <span class="comment">/* File type and mode */</span></span><br><span class="line">    <span class="type">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">    <span class="type">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">    <span class="type">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">    <span class="type">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">    <span class="type">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">    <span class="type">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">    <span class="type">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>查看文件类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (sb.st_mode &amp; S_IFMT) &#123;</span><br><span class="line">    <span class="keyword">case</span> S_IFBLK:  <span class="built_in">printf</span>(<span class="string">&quot;block device\n&quot;</span>);            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFCHR:  <span class="built_in">printf</span>(<span class="string">&quot;character device\n&quot;</span>);        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFDIR:  <span class="built_in">printf</span>(<span class="string">&quot;directory\n&quot;</span>);               <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFIFO:  <span class="built_in">printf</span>(<span class="string">&quot;FIFO/pipe\n&quot;</span>);               <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFLNK:  <span class="built_in">printf</span>(<span class="string">&quot;symlink\n&quot;</span>);                 <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFREG:  <span class="built_in">printf</span>(<span class="string">&quot;regular file\n&quot;</span>);            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> S_IFSOCK: <span class="built_in">printf</span>(<span class="string">&quot;socket\n&quot;</span>);                  <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:       <span class="built_in">printf</span>(<span class="string">&quot;unknown?\n&quot;</span>);                <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(sb.st_mode)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;directory\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISREG(sb.st_mode)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;regular file\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="link-函数"><a href="#link-函数" class="headerlink" title="link 函数"></a>link 函数</h2><p>硬链接数就是 dentry 数目，link 就是用来创建硬链接的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">link</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *oldpath, <span class="type">const</span> <span class="type">char</span> *newpath)</span>;</span><br></pre></td></tr></table></figure><ul><li>oldpath：旧文件路径</li><li>newpath：新文件路径</li><li>返回值：<ul><li>0，成功；</li><li>-1，失败，错误码存储在errno中；</li></ul></li></ul><h2 id="unlink-函数"><a href="#unlink-函数" class="headerlink" title="unlink 函数"></a>unlink 函数</h2><p>删除一个文件的目录项 dentry，使硬链接数-1。</p><p>清除文件时，如果文件的硬链接数到 0 了，没有 dentry 对应，但该文件仍不会马上被释放，要等到所有打开文件的进程关闭该文件，系统才会挑时间将该文件释放掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">unlink</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname)</span>;</span><br></pre></td></tr></table></figure><ul><li>pathname：文件路径</li><li>返回值：<ul><li><code>0</code>，成功；</li><li><code>-1</code>，失败，错误码存储在errno中；</li></ul></li></ul><h2 id="dup-函数"><a href="#dup-函数" class="headerlink" title="dup 函数"></a>dup 函数</h2><p>复制文件描述符到未使用的最小编号的描述符中。</p><p>复制后，新旧描述符都可使用，并且共享文件指针偏移和文件状态标志等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> oldfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;./test.txt&quot;</span>, O_RDWR|O_CREAT);</span><br><span class="line"><span class="type">int</span> newfd = dup(fd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fd: %d, newfd: %d\n&quot;</span>, fd, newfd); <span class="comment">// fd: 3, newfd: 4</span></span><br></pre></td></tr></table></figure><ul><li><code>oldfd</code>：旧文件描述符</li><li>返回值：<ul><li>新的文件描述符；</li><li>-1，失败，错误码存储在errno中；</li></ul></li></ul><h2 id="dup2-函数"><a href="#dup2-函数" class="headerlink" title="dup2 函数"></a>dup2 函数</h2><p>与dup函数类似，只不过它是将文件描述符复制到指定编号的文件描述符。复制前它会自动调用 <code>close(newfd)</code>。</p><p>同样的，复制后新旧描述符都可使用，并且共享文件指针偏移和文件状态标志等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> oldfd, <span class="type">int</span> newfd)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;./test.txt&quot;</span>, O_RDWR|O_CREAT);</span><br><span class="line"><span class="type">int</span> newfd = dup2(fd, STDOUT_FILENO); <span class="comment">// 将标准输出等重定向到文件</span></span><br></pre></td></tr></table></figure><ul><li>oldfd：旧文件描述符</li><li>newfd：新文件描述符</li><li>返回值：<ul><li>新的文件描述符；</li><li>-1，失败，错误码存储在errno中；</li></ul></li></ul><p>让 newfd 指向 oldfd，也就是说无论写newfd还是oldfd，都会写到oldfd。</p><h2 id="ioctl-函数"><a href="#ioctl-函数" class="headerlink" title="ioctl 函数"></a>ioctl 函数</h2><p>可用于向内核传递任意类型的数据。也是一种内核态和用户态通信的方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内核中的对应函数原型为</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">module_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br></pre></td></tr></table></figure><ul><li><code>fd</code>：与设备驱动通信时，该<code>fd</code>通常表示<code>/dev/</code>目录下的某个文件</li><li><code>request</code>&#x2F;<code>cmd</code>：表示操作类型，也用于判断如何处理后续参数</li><li><code>arg</code>：在内核中 <code>unsigned long</code> 和 <code>void *</code> 是等价的，所以这里既可以表示用户态传入的指针变量，也可以表示普通的整形变量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">attrs</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125; attrs;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="title function_">scull_ioctl</span><span class="params">(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> err = <span class="number">0</span>, tmp;</span><br><span class="line">attrs kdata;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_INT:</span><br><span class="line">            tmp = arg;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_POINTER:</span><br><span class="line">            copy_from_user(&amp;kdata, (attrs *)arg, <span class="keyword">sizeof</span>(attrs));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子中的 <code>IOCTL_INT</code> <code>IOCTL_POINTER</code> 由各个模块自行设计。</p><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><ul><li><a href="https://blog.51cto.com/u_3078781/3287065"><strong>Linux系统调用列表</strong></a></li><li>《LINUX 系统编程手册》</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统编程-静态库动态库</title>
      <link href="/2022/04/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>/2022/04/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>静态库文件名格式为：<code>lib&#123;name&#125;.a</code>，只有 {name} 部分可自定义。</p><p>动态库文件名格式为：<code>lib&#123;name&#125;.so</code>，只有 {name} 部分可自定义。</p><p>静态库和动态库的区别：</p><ul><li>静态库会被链接到程序中，而动态库则只记录了库的名称，程序运行时才去对应的路径中加载库。</li><li>静态库加载速度快，但较消耗内存，动态库则相反。</li></ul><h2 id="gcc-编译流程"><a href="#gcc-编译流程" class="headerlink" title="gcc 编译流程"></a>gcc 编译流程</h2><p><img src="/../images/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93/image-20220331155734904.png" alt="image-20220331155734904"></p><ul><li><code>-I</code> 指定头文件所在目录位置</li><li><code>-c</code> 只做预处理，编译，汇编。得到二进制文件</li><li><code>-g</code> 编译时添加调试文件，用于 gdb 调试</li><li><code>-Wall</code> 显示所有警告信息</li><li><code>-D</code> 向程序中“动态”注册宏定义</li><li><code>-l</code> 指定动态库库名</li><li><code>-L</code> 指定动态库路径</li><li><code>-O0</code> 关闭优化 (默认)</li><li><code>-O1/-O</code> 让可执⾏⽂件更⼩，速度更快</li><li><code>-O2</code> 采⽤⼏乎所有的优化⼿段</li></ul><h2 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h2><p>静态库在生成时应提供一个头文件（包含函数声明），以便其他人知晓库提供的方法，方便使用库。</p><ol><li><p>写好源代码 <code>mymath.c,  mymath.h</code></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mymath.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mymath.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MYMATH_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MYMATH_H_</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mymath.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;add: %d, sub: %d\n&quot;</span>, add(a, b), sub(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将 <code>.c</code> 生成 <code>.o</code> 文件 <code>gcc -c mymath.c -o mymath.o</code></p></li><li><p>使用 <code>ar</code> 工具制作静态库 <code>ar rcs libmymath.a mymath.o</code></p></li></ol><p><strong>使用方法：</strong>有了生成的静态库<code>lib&#123;name&#125;.a</code>，就可以使用该文件，而不需要源文件<code>.c</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c ./lib/libmymath.a -I ./include -o static</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">├── include</span><br><span class="line">│   └── mymath.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libmymath.a</span><br><span class="line">├── main.c</span><br><span class="line">├── mymath.c    <span class="comment"># 已经可以删除了</span></span><br><span class="line">└── static      <span class="comment"># 生成的可执行文件</span></span><br></pre></td></tr></table></figure><p>虽然通过上面的方式，让<code>mymath</code>这个库静态链接到了目标文件中，但用<code>ldd static</code>可以看到还是有一些标准库是动态链接的。**<code>gcc -static</code> 选项可使所有库都通过静态链接。**</p><p>单独像链接 <code>.o</code> 文件那样列出静态库的具体路径，就只是将该静态库使用静态链接，其余库仍然默认使用动态链接。如果要想全部库都使用动态链接，就加上链接参数 <code>-static</code>，它指示编译器对所有库采用静态链接，查找路径与动态库一样，使用 <code>-L</code> 指定库的查找路径。</p><p>要点：</p><ul><li>通过相对或绝对路径指定静态库文件的位置</li><li>通过 <code>-I</code> 指定静态库的头文件所在目录位置</li></ul><h2 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h2><ol><li>将 <code>.c</code> 生成 <code>.o</code> 文件，（生成与位置无关的代码 <code>-fPIC</code>） <code>gcc -c mymath.c -o mymath.o -fPIC</code></li><li>使用 <code>gcc -shared</code> 制作动态库 <code>gcc -shared -o libmymath.so mymath.o</code></li><li>编译可执行文件时，指定所使用的动态库，<code>-l</code> 指定库名（去掉lib前缀与.so后缀），<code>-L</code>指定库路径</li></ol><p><strong>使用方法：</strong>下面就可以指定动态库名称和路径生成可执行文件了，但运行会出错！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gcc main.c -l mymath -L ./lib/ -I ./include/ -o dynamic</span><br><span class="line"></span><br><span class="line">.</span><br><span class="line">├── dynamic    <span class="comment"># 生成的可执行文件</span></span><br><span class="line">├── include</span><br><span class="line">│   └── mymath.h</span><br><span class="line">├── lib</span><br><span class="line">│   └── libmymath.so</span><br><span class="line">├── main.c</span><br><span class="line">└── mymath.c</span><br><span class="line"></span><br><span class="line">$ ./dynamic</span><br><span class="line">./dynamic: error <span class="keyword">while</span> loading shared libraries: libmymath.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p><strong>原因：</strong>编译和运行时的链接器不同！</p><ul><li>链接器：工作于链接阶段，用<code>-l -L</code>指定动态库路径</li><li>动态链接器：工作于程序运行阶段，工作时需要提供动态库所在目录位置，通过环境变量：<code>export LD_LIBRARY_PATH=/path</code></li></ul><p><strong>解决办法：</strong>设置 <code>LD_LIBRARY_PATH</code> 指定动态库的目录（建议使用绝对路径），环境变量是进程的概念，要让动态库地址一直生效：</p><ol><li>通过环境变量 <code>export LD_LIBRARY_PATH=/path</code>，退出该终端后失效</li><li>在<code>.bashrc</code>中添加环境变量，每次打开终端自动加载环境变量</li><li>将库文件复制到 <code>/lib</code> 目录下，标准<code>c</code>库所在目录</li><li>在<code>/etc/ld.so.conf</code>中添加 <code>include /path/lib.so</code>，使用 <code>ldconfig -v</code> 使修改生效</li></ol><p>一个程序运行时，其依赖的动态库的加载过程分为两种方式：<strong>加载时动态链接</strong>和<strong>运行时动态链接</strong>。<br>加载时动态链接是指程序在启动时，由动态链接器根据程序的依赖信息，将所需的动态库文件加载到内存，并进行重定位和初始化。<br>运行时动态链接是指程序在运行过程中，通过调用特定的函数（如dlopen和dlsym），来打开、关闭和使用指定的动态库文件。</p><p><strong>创建动态库的时候，怎么将动态库依赖哪些库的信息打包进去？自动完成吗？</strong></p><blockquote><p>创建动态库时，可以在编译和链接阶段指定该库依赖的其他库。这通常是通过链接器选项完成的，例如使用 GCC 的 <code>-l</code> 选项来链接库。依赖信息会被链接器自动嵌入到生成的动态库中，这样在加载动态库时，动态链接器（如 <code>ld.so</code> 在 Linux 上）可以找到并加载所有必需的依赖库。</p><p>例如，如果你正在创建一个动态库，它依赖于 <code>libm</code> （数学库）和 <code>libpthread</code> （线程库），你可以在链接时使用以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libyourlib.so yourlib.o -lm -lpthread</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>-shared</code> 选项告诉编译器你正在创建一个动态库，<code>-o libyourlib.so</code> 指定输出文件名，<code>yourlib.o</code> 是你的库的编译后的对象文件，而 <code>-lm</code> 和 <code>-lpthread</code> 告诉链接器你的库依赖于数学库和线程库。</p><p>这些依赖关系会被记录在生成的 <code>libyourlib.so</code> 文件中。当你的库被加载时，动态链接器会查看这些依赖信息并加载相应的库。</p><p>如果你想看到你的动态库依赖了哪些其他库，你可以在 Linux 上使用 <code>ldd</code> 命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldd libyourlib.so</span><br></pre></td></tr></table></figure><p>这将列出所有需要的共享库及其路径。有时，你可能需要在非标准路径中查找依赖库。在这种情况下，你可以使用 <code>-L</code> 选项来添加额外的库搜索路径，并用 <code>-Wl,-rpath</code> 选项来设置运行时库搜索路径，这样动态链接器就可以在运行时找到这些库。例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libyourlib.so yourlib.o -L/path/to/libs -lm -lpthread -Wl,-rpath,/path/to/libs</span><br></pre></td></tr></table></figure><p>在这里，<code>-L/path/to/libs</code> 告诉链接器在 <code>/path/to/libs</code> 目录下查找库文件，而 <code>-Wl,-rpath,/path/to/libs</code> 选项将 <code>/path/to/libs</code> 添加到运行时库搜索路径中。这确保了在运行时，即使库不在标准的库路径中，动态链接器也能找到它们。</p></blockquote><p><strong>如果没有用 -l 来指定，是不是 ldd 就看不了依赖关系？</strong></p><blockquote><p>如果在编译动态库时没有使用 <code>-l</code> 选项来链接其他库，那么这些库不会成为动态库的依赖，因此 <code>ldd</code> 命令不会显示这些库作为依赖关系。<code>-l</code> 选项用于链接时期指定链接器需要链接的库。</p><p>但是，如果你的代码调用了其他库的函数，而没有在链接时指定这些库，那么编译过程会因为未解析的符号而失败。这意味着，如果你能成功编译一个动态库而没有使用 <code>-l</code> 选项，那么这个库要么不依赖于任何其他库中的符号，要么仅依赖于那些已经被其他方式（如通过其他链接器标志）链接的库。</p><p>举个例子，如果你的库使用了 C 标准库（libc）中的函数，你通常不需要显式地链接 libc，因为它是编译器默认会链接的库。但是，对于非标准库，如果你的代码中使用了它们，你需要在链接时指定它们，否则会出现链接错误。</p><p>使用 <code>ldd</code> 查看动态库的依赖关系时，只有那些在链接时期被显式指定的库才会被列出。如果库是在运行时动态加载的（例如，使用 <code>dlopen</code>），那么这些库不会出现在 <code>ldd</code> 的输出中，因为它们不是编译时链接的依赖项。</p></blockquote><p><strong>c 编译的时候，跟指定库的顺序 还有关系吗？</strong></p><blockquote><p>是的，指定库的顺序在编译时是有关系的。在链接阶段，编译器会按照指定的库的顺序来查找符号。如果某个符号在前面的库中找到了，则不会去后面的库中再查找，即使后面的库中有同名的符号也不会被使用。</p><p>因此，通常情况下，应该将依赖的库放在被依赖的库之后。例如，如果库 A 依赖于库 B，那么编译时应该将库 B 放在库 A 之后，这样可以确保在链接时先找到库 B 中的符号，然后再找到库 A 中的符号，以确保符号的正确解析和链接。</p><p>举个简单的例子，假设有两个库 libA.a 和 libB.a，其中 libA.a 依赖于 libB.a，如果编译命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">gcc -o program program.c -lA -lB</span><br></pre></td></tr></table></figure><p>这样的话，编译器会先搜索 libA.a，如果在 libA.a 中找不到符号，则会继续搜索 libB.a，以确保能够解析到程序中所需的所有符号。</p></blockquote><p><strong>会存在因为顺序不对，导致编译失败的情况吗？</strong></p><blockquote><p>是的，因为库的顺序不对可能导致编译失败。这通常发生在依赖关系比较复杂的情况下。</p><p>举个例子，假设有三个库：libA.a、libB.a 和 libC.a，它们之间的依赖关系为 libA.a 依赖于 libB.a，libB.a 依赖于 libC.a。如果编译命令的库的顺序为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">gcc -o program program.c -lA -lC -lB</span><br></pre></td></tr></table></figure><p>这样的话，编译器会先搜索 libA.a，然后在 libA.a 中找到对 libB.a 的依赖，接着会搜索 libC.a。但是由于 libC.a 在 libB.a 之后，所以在搜索 libC.a 时，libB.a 的符号还没有被解析，编译器找不到 libB.a 中的符号，因此编译会失败。</p><p>为了避免这种情况，应该按照依赖关系的顺序正确指定库的顺序，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bashCopy code</span><br><span class="line">gcc -o program program.c -lA -lB -lC</span><br></pre></td></tr></table></figure><p>这样的话，编译器会先搜索 libA.a，然后在 libA.a 中找到对 libB.a 的依赖，接着搜索 libB.a，在 libB.a 中找到对 libC.a 的依赖，最终搜索 libC.a，确保能够正确解析和链接所有的符号，避免了编译失败的情况。</p></blockquote><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p><strong>命名</strong>：必须为 <code>Makefile / makefile</code></p><p><strong>缩进</strong>：必须用<code>Tab</code>，不能用空格</p><p><strong>变量</strong>：与<code>bash</code>类似，但用 <code>$()</code> 而不是 <code>$&#123;&#125;</code>，Makefile中的变量的作用相当于c语言里面的宏，使用<code>$(x)</code>就相当于宏展开！</p><p><strong>一个规则</strong>：目标的时间必须晚于依赖条件的时间，否则，更新目标</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标：依赖</span><br><span class="line">（Tab）命令</span><br></pre></td></tr></table></figure><p><strong>两个函数</strong>：匹配函数和替换函数</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配当前工作目录下的所有.c 文件。将文件名组成列表，赋值给变量 src</span></span><br><span class="line"><span class="comment"># src = add.c sub.c div1.c</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span> <span class="comment"># 和上面等价</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./<span class="built_in">dir</span>/*.c)</span>  <span class="comment"># 匹配子目录 src=./dir/add.c ./dir/sub.c</span></span><br></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将参数 3 中，包含参数 1 的部分，替换为参数 2</span></span><br><span class="line"><span class="comment"># obj = add.o sub.o div1.o</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br></pre></td></tr></table></figure><p><strong>三个自动变量</strong>：</p><ul><li><code>$@</code>：表示规则中的目标</li><li><code>$&lt;</code>：表示规则中的第一个依赖条件</li><li><code>$^</code>：表示规则中所有的依赖条件</li></ul><p><strong>模式规则</strong>：自动匹配当前目录下的文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目标：依赖</span></span><br><span class="line"><span class="comment">#（Tab）命令</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    gcc -c <span class="variable">$&lt;</span> -o %@</span><br><span class="line"><span class="comment"># 等价于为每一个 .c 文件写</span></span><br><span class="line"><span class="comment"># a.o:a.c</span></span><br><span class="line"><span class="comment">#   gcc -c a.c -o a.o</span></span><br></pre></td></tr></table></figure><p><strong>静态模式规则</strong>：以指定变量中值为目标，而不是在当前文件夹中搜索</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量：目标：依赖</span></span><br><span class="line"><span class="comment">#（Tab）命令</span></span><br><span class="line"><span class="variable">$(obj)</span>:%.o:%.c</span><br><span class="line">    gcc -c <span class="variable">$&lt;</span> -o %@</span><br></pre></td></tr></table></figure><p><strong>clean</strong>：清理文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean: (没有依赖)</span></span><br><span class="line">    -rm -rf <span class="variable">$(obj)</span></span><br><span class="line"><span class="comment"># “-”：作用是，删除不存在文件时，不报错。顺序执行结束。</span></span><br></pre></td></tr></table></figure><p><strong>目标</strong>：第一个目标为总目标，该目标若不需要更新，就不会检查其他目标</p><p><strong>伪目标：</strong>当前目录若存在文件<code>ALL</code>，<code>clean</code>时，会导致<code>make</code>执行异常，使用伪目标可避免</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean ALL</span></span><br></pre></td></tr></table></figure><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./src/*.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> ./src/*.c ./src/*.o <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">inc_path = ./<span class="keyword">include</span></span><br><span class="line">args = -Wall -std=c99</span><br><span class="line"></span><br><span class="line"><span class="section">ALL: main</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span>:./src/%.o:./src/%.c</span><br><span class="line">    gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(args)</span> -I <span class="variable">$(inc_path)</span></span><br><span class="line"></span><br><span class="line"><span class="section">main:<span class="variable">$(obj)</span></span></span><br><span class="line">    gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(args)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm -rf <span class="variable">$(obj)</span> main</span><br></pre></td></tr></table></figure><h2 id="相关工具"><a href="#相关工具" class="headerlink" title="相关工具"></a>相关工具</h2><h3 id="objdump-查看汇编"><a href="#objdump-查看汇编" class="headerlink" title="objdump 查看汇编"></a>objdump 查看汇编</h3><p>查看可执行文件汇编！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -dS dynamic</span><br></pre></td></tr></table></figure><h3 id="ldd-依赖动态库"><a href="#ldd-依赖动态库" class="headerlink" title="ldd 依赖动态库"></a>ldd 依赖动态库</h3><p>查看程序依赖动态库的路径！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ldd static</span><br><span class="line">    linux-vdso.so.1 (0x00007ffd507e9000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fba762d7000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007fba764ee000)</span><br><span class="line">ldd dynamic</span><br><span class="line">    linux-vdso.so.1 (0x00007ffee615b000)</span><br><span class="line">    libmymath.so =&gt; ./lib/libmymath.so (0x00007f482012c000)</span><br><span class="line">    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f481ff1c000)</span><br><span class="line">    /lib64/ld-linux-x86-64.so.2 (0x00007f4820138000)</span><br></pre></td></tr></table></figure><h3 id="strace-系统调用"><a href="#strace-系统调用" class="headerlink" title="strace 系统调用"></a>strace 系统调用</h3><p>跟踪程序执行时的系统调用！</p><p><code>=</code> 后是该系统调用的返回值！</p><p>第一行是<code>execve</code>，在当前shell的进程中，开了一个子进程，并通过<code>execve</code>执行了另一个程序。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">strace ./static</span><br><span class="line"><span class="comment">#############################################################################</span></span><br><span class="line">execve(<span class="string">&quot;./static&quot;</span>, [<span class="string">&quot;./static&quot;</span>], 0x7ffcdd67dc70 /* 73 vars */) = 0</span><br><span class="line">brk(NULL)                               = 0x56030df70000</span><br><span class="line">arch_prctl(0x3001 /* ARCH_??? */, 0x7fff63567720) = -1 EINVAL (Invalid argument)</span><br><span class="line">access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/etc/ld.so.cache&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0644, st_size=121662, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 121662, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f8755dc8000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">openat(AT_FDCWD, <span class="string">&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;</span>, O_RDONLY|O_CLOEXEC) = 3</span><br><span class="line"><span class="built_in">read</span>(3, <span class="string">&quot;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\360A\2\0\0\0\0\0&quot;</span>..., 832) = 832</span><br><span class="line">pread64(3, <span class="string">&quot;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&quot;</span>..., 784, 64) = 784</span><br><span class="line">pread64(3, <span class="string">&quot;\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0&quot;</span>, 32, 848) = 32</span><br><span class="line">pread64(3, <span class="string">&quot;\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\237\333t\347\262\27\320l\223\27*\202C\370T\177&quot;</span>..., 68, 880) = 68</span><br><span class="line">fstat(3, &#123;st_mode=S_IFREG|0755, st_size=2029560, ...&#125;) = 0</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f8755dc6000</span><br><span class="line">pread64(3, <span class="string">&quot;\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0&quot;</span>..., 784, 64) = 784</span><br><span class="line">pread64(3, <span class="string">&quot;\4\0\0\0\20\0\0\0\5\0\0\0GNU\0\2\0\0\300\4\0\0\0\3\0\0\0\0\0\0\0&quot;</span>, 32, 848) = 32</span><br><span class="line">pread64(3, <span class="string">&quot;\4\0\0\0\24\0\0\0\3\0\0\0GNU\0\237\333t\347\262\27\320l\223\27*\202C\370T\177&quot;</span>..., 68, 880) = 68</span><br><span class="line">mmap(NULL, 2037344, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7f8755bd4000</span><br><span class="line">mmap(0x7f8755bf6000, 1540096, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x22000) = 0x7f8755bf6000</span><br><span class="line">mmap(0x7f8755d6e000, 319488, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x19a000) = 0x7f8755d6e000</span><br><span class="line">mmap(0x7f8755dbc000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e7000) = 0x7f8755dbc000</span><br><span class="line">mmap(0x7f8755dc2000, 13920, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7f8755dc2000</span><br><span class="line">close(3)                                = 0</span><br><span class="line">arch_prctl(ARCH_SET_FS, 0x7f8755dc7540) = 0</span><br><span class="line">mprotect(0x7f8755dbc000, 16384, PROT_READ) = 0</span><br><span class="line">mprotect(0x56030bfe1000, 4096, PROT_READ) = 0</span><br><span class="line">mprotect(0x7f8755e13000, 4096, PROT_READ) = 0</span><br><span class="line">munmap(0x7f8755dc8000, 121662)          = 0</span><br><span class="line">fstat(1, &#123;st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0), ...&#125;) = 0</span><br><span class="line">brk(NULL)                               = 0x56030df70000</span><br><span class="line">brk(0x56030df91000)                     = 0x56030df91000</span><br><span class="line">write(1, <span class="string">&quot;add: 15, sub: 5\n&quot;</span>, 16add: 15, sub: 5</span><br><span class="line">)       = 16    <span class="comment"># 写到标准输出，字符串长度为16</span></span><br><span class="line">exit_group(0)                           = ?</span><br><span class="line">+++ exited with 0 +++</span><br></pre></td></tr></table></figure><h3 id="Valgrind-内存泄露"><a href="#Valgrind-内存泄露" class="headerlink" title="Valgrind 内存泄露"></a>Valgrind 内存泄露</h3><p>Valgrind 是运行在Linux上一套基于仿真技术的程序调试和分析工具，是公认的最接近Purify的产品，它包含一个内核——一个软件合成的CPU，和一系列的小工具，每个工具都可以完成一项任务——调试，分析，或测试等。Valgrind可以<strong>检测内存泄漏和内存越界</strong>，还可以分析cache的使用等，灵活轻巧而又强大。</p><ol><li><code>memcheck</code>：检查程序中的内存问题，如泄漏、越界、非法指针等。</li><li><code>callgrind</code>：检测程序代码覆盖，以及分析程序性能。</li><li><code>cachegrind</code>：分析CPU的cache命中率、丢失率，用于进行代码优化。</li><li><code>helgrind</code>：用于检查多线程程序的竞态条件。</li><li><code>massif</code>：堆栈分析器，指示程序中使用了多少堆内存等信息。</li><li><code>lackey</code>：</li><li><code>nulgrind</code>：</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://www.bilibili.com/video/BV1KE411q7ee">bilibili黑马程序员-Linux系统编程</a><br>参考笔记：<a href="https://github.com/ABottomCoder/Linux-system-programming">https://github.com/ABottomCoder/Linux-system-programming</a><br><a href="https://www.cnblogs.com/wangkangluo1/archive/2011/07/20/2111248.html">Valgrind使用说明</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Makefile </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STL容器</title>
      <link href="/2022/04/23/ProgramBasic_STL/"/>
      <url>/2022/04/23/ProgramBasic_STL/</url>
      
        <content type="html"><![CDATA[<p>线程安全：</p><ul><li>这里列出的<code>C++</code> 标准库中的容器都不是线程安全的！多个线程读时不需要加锁，但有一个线程写时，所有读写线程都需要加锁！</li></ul><p>效率说明：</p><ul><li><code>emplace_back()</code> 是c11新加的，功能与 <code>push_back()</code> 一样，但效率更高，推荐优先使用</li></ul><h2 id="序列式容器"><a href="#序列式容器" class="headerlink" title="序列式容器"></a>序列式容器</h2><blockquote><p><a href="https://hackingcpp.com/cpp/std/sequence_containers.html">序列式容器 hackingcpp</a></p></blockquote><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><p><img src="/../images/ProgramBasic_STL/array_thumb.svg" alt="standard library sequence container &#39;array"></p><p><strong>固定大小的数组</strong>，必须在建立时就指明其大小。</p><ul><li><code>.front()</code>：返回第一元素的<strong>引用</strong>，你可以使用这些操作函数更改元素内容</li><li><code>.back()</code>：返回最末元素的<strong>引用</strong>，<code>c.back() = 10</code></li></ul><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p><img src="/../images/ProgramBasic_STL/vector_thumb.svg" alt="standard library sequence container &#39;vector"></p><p><code>Vector</code> 是一个 <code>dynamic array</code>。</p><p>大小可变，但内存重新分配很耗时间。</p><p><strong>在<code>Vector</code>尾部附加元素或移除元素都很快速</strong>，但是在<code>Vector</code>的中段或起始段安插元素就比较费时</p><ul><li><code>.front()</code>：返回第一元素的<strong>引用</strong> (不检查是否存在第一元素)</li><li><code>.back()</code>：返回最末元素的<strong>引用</strong> (不检查是否存在最末元素)，<code>c.back() = 10</code></li><li><code>.push_back(elem)</code>：尾部附加元素</li><li><code>.pop_back()</code>：移除最后一个元素</li><li><code>.insert(pos, elem)</code>：在iterator 位置 pos 之前方插入一个 elem 拷贝，并返回新元素的位置</li><li><code>.insert(pos, n, elem)</code>：在iterator 位置 pos 之前方插入 n 个 elem 拷贝，并返回第一个新元素的位置</li><li><code>.emplace(pos, args...)</code>：在iterator 位置 pos 之前方插入一个以 args 为初值的元素，并返回新元素的位置</li><li><code>.emplace_back(args...)</code>：附加一个以 args 为初值的元素于未尾，不返回任何东西</li><li><code>.resize(num)</code>：将元素数量改为 num (如果 <code>size()</code> 变大，多出来的新元素都需以 default 构造函数完成初始化)</li><li><code>.resize(num, elem)</code>：将元素数量改为 num (如果 <code>size()</code> 变大，多出来的新元素都是 elem 的拷贝)</li><li><code>.clear()</code>：移除所有元素，将容器清空</li></ul><h3 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h3><p><img src="/../images/ProgramBasic_STL/deque_thumb.svg" alt="standard library sequence container &#39;deque"></p><p>“double-ended queue”的缩写。它是一个dynamic array，可以向两端发展。如图所示，<strong>并不是一段连续的内存</strong>。</p><p>因此<strong>不论在尾部或头部安插元素都十分迅速</strong>。在<strong>中间部分安插元素则比较费时</strong>，因为必须移动其他元素。</p><p>访问元素时deque内部结构会多一个间接过程，所以元素的访问和迭代嚣的动作会稍稍慢一些。</p><p>特别注意，除头尾两端外，在任何地点安插或删除元素都将导致指向deque元素的任何pointer、reference和iterator失效。</p><p>deque的内存重分配优于vector，deque不必在内存重新分配时复制所有元素。</p><ul><li><code>.front()</code>：返回第一元素的<strong>引用</strong> (不检查是否存在第一元素)</li><li><code>.back()</code>：返回最末元素的<strong>引用</strong> (不检查是否存在最末元素)，<code>c.back() = 10</code></li><li><code>.push_back(elem)</code>：尾部附加元素</li><li><code>.pop_back()</code>：移除最后一个元素</li><li><strong><code>.push_front(elem)</code>：头部附加元素</strong></li><li><strong><code>.pop_front()</code>：移除第一个元素</strong></li><li><code>.insert(pos, elem)</code>：在iterator 位置 pos 之前方插入一个 elem 拷贝，并返回新元素的位置</li><li><code>.insert(pos, n, elem)</code>：在iterator 位置 pos 之前方插入 n 个 elem 拷贝，并返回第一个新元素的位置</li><li><code>.emplace(pos, args...)</code>：在iterator 位置 pos 之前方插入一个以 args 为初值的元素，并返回新元素的位置</li><li><code>.emplace_back(args...)</code>：附加一个以 args 为初值的元素于未尾，不返回任何东西</li><li><strong><code>.emplace_front(args...)</code>：附加一个以 args 为初值的元素于起点，不返回任何东西</strong></li><li><code>.resize(num)</code>：将元素数量改为 num (如果 size() 变大，多出来的新元素都需以 default 构造函数完成初始化)</li><li><code>.resize(num, elem)</code>：将元素数量改为 num (如果 size() 变大，多出来的新元素都是 elem 的拷贝)</li><li><code>.clear()</code>：移除所有元素，将容器清空</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p><img src="/../images/ProgramBasic_STL/list_thumb.svg" alt="standard library sequence container &#39;list"></p><p>双向链表，<strong>在任何位置上执行安插或删除动作都非常迅速</strong>。</p><ul><li><code>.front()</code>：返回第一元素的<strong>引用</strong></li><li><code>.back()</code>：返回最末元素的<strong>引用</strong>，<code>c.back() = 10</code></li><li><code>.push_back(elem)</code>：尾部附加元素</li><li><code>.pop_back()</code>：移除最后一个元素</li><li><code>.push_front(elem)</code>：头部附加元素</li><li><code>.pop_front()</code>：移除第一个元素</li><li><code>.insert(pos, elem)</code>：在iterator 位置 pos 之前方插入一个 elem 拷贝，并返回新元素的位置</li><li><code>.insert(pos, n, elem)</code>：在iterator 位置 pos 之前方插入 n 个 elem 拷贝，并返回第一个新元素的位置</li><li><code>.emplace(pos, args...)</code>：在iterator 位置 pos 之前方插入一个以 args 为初值的元素，并返回新元素的位置</li><li><code>.emplace_back(args...)</code>：附加一个以 args 为初值的元素于未尾，不返回任何东西</li><li><code>.emplace_front(args...)</code>：附加一个以 args 为初值的元素于起点，不返回任何东西</li><li><code>.resize(num)</code>：将元素数量改为 num (如果 <code>size()</code> 变大，多出来的新元素都需以 default 构造函数完成初始化)</li><li><code>.resize(num, elem)</code>：将元素数量改为 num (如果 <code>size()</code> 变大，多出来的新元素都是 elem 的拷贝)</li><li><code>.remove(val)</code>：移除所有值为 val 的元素</li><li><code>.remove_if(op)</code>：移除所有造成 <code>op(elem)</code> 返回 true 的元素</li><li><code>.clear()</code>：移除所有元素，将容器清空</li><li><code>.merge(other, comp)</code>：将两个有序 List 合并成一个</li><li><code>.unique()</code>：移除所有重复的元素，重复元素保留第一个</li><li><code>.sort()</code>：对 List 按照升序排序</li></ul><h3 id="Forward-List"><a href="#Forward-List" class="headerlink" title="Forward_List"></a>Forward_List</h3><p><img src="/../images/ProgramBasic_STL/forward_list_thumb.svg" alt="standard library sequence container &#39;forward_list"></p><p>forward list原则上就是一个受限的list，不支持任何“后退移动”或“效率低下”的操作。</p><p>基于这个原因，它不提供成员函数如<code>push_back()</code> 甚至<code>size()</code>。</p><ul><li><code>.front()</code>：返回第一元素的<strong>引用</strong></li><li><code>.push_front(elem)</code>：头部附加元素</li><li><code>.pop_front()</code>：移除第一个元素</li><li><code>.insert_after(pos, args)</code>：在指定的 pos 后插入 args</li><li><code>.emplace_after(pos, args)</code>：在指定的 pos 后插入 args</li><li><code>.emplace_front(args...)</code>：附加一个以 args 为初值的元素于起点</li><li><code>.remove(val)</code>：移除所有值为 val 的元素</li><li><code>.remove_if(op)</code>：移除所有造成 <code>op(elem)</code> 返回 true 的元素</li><li><code>.clear()</code>：移除所有元素，将容器清空</li><li><code>.merge(other, comp)</code>：将两个有序 List 合并成一个</li><li><code>.unique()</code>：移除所有重复的元素，重复元素保留第一个</li><li><code>.sort()</code>：按照升序排序</li></ul><h2 id="关联式容器"><a href="#关联式容器" class="headerlink" title="关联式容器"></a>关联式容器</h2><blockquote><p><a href="https://hackingcpp.com/cpp/std/associative_containers.html">关联式容器 hackingcpp</a></p></blockquote><p>关联式容器依据特定的排序准则，自动为其元素排序。</p><p>自动排序造成的一个重要限制: 你不能直接改变元素值，因为会打乱原本正确的顺序。</p><p><strong>要改变元素值，必须先删除旧元素，再插入新元素。</strong></p><p>通常关联式容器由<strong>红黑树</strong>实现，其值有序，且插入、查找、删除的时间复杂度为<code>O(log n)</code>。</p><h3 id="set、multiset"><a href="#set、multiset" class="headerlink" title="set、multiset"></a>set、multiset</h3><p><img src="/../images/ProgramBasic_STL/set_thumb.svg" alt="internal structure of std::set"></p><p><strong>由于 set 不允许重复值，set 的 insert&#x2F;emplace 返回值为 <code>pair&lt;iterator, bool&gt;</code>，其中 bool 是指是否插入成功。</strong></p><ul><li><code>.count(val)</code>：返回值为val的个数</li><li><code>.find(val)</code>：返回值为val的第一个元素的迭代器，找不到返回 <code>end()</code></li><li><code>.contains(val)</code>：判断是否包含某个元素（c++20）</li><li><code>.lower_bound(val)</code>：返回val的第一个可安插位置，第一个 &gt;&#x3D; val 的位置</li><li><code>.upper_bound(val)</code>：返回val的第一个可安插位置，第一个 &gt; val 的位置</li><li><code>.equal_range(val)</code>：返回val可安插的第一个和最后一个位置</li><li><code>.insert(val)</code>：插入元素，返回插入的元素的迭代器</li><li><code>.insert(pos, val)</code>：插入元素，返回插入的元素的迭代器（pos是提示插入起点）</li><li><code>.emplace(args...)</code>：插入元素，返回插入的元素的迭代器</li><li><code>.emplace_hint(pos, args...)</code>：插入元素，返回插入的元素的迭代器（pos 是提示插入起点）</li><li><code>.merge(other)</code>：将两个 set 合并成一个</li><li><code>.clear()</code>：移除所有元素，将容器清空</li></ul><h3 id="map、multimap"><a href="#map、multimap" class="headerlink" title="map、multimap"></a>map、multimap</h3><p><img src="/../images/ProgramBasic_STL/map_thumb.svg" alt="internal structure of std::map"></p><ul><li><code>.count(val)</code>：返回值为val的个数</li><li><code>.find(val)</code>：返回值为val的第一个元素的迭代器，找不到返回 <code>end()</code></li><li><code>.contains(val)</code>：判断是否包含某个元素（c++20）</li><li><code>.lower_bound(val)</code>：返回val的第一个可安插位置，第一个 <code>&gt;= val</code> 的位置</li><li><code>.upper_bound(val)</code>：返回val的第一个可安插位置，第一个 <code>&gt; val</code> 的位置</li><li><code>.equal_range(val)</code>：返回val可安插的第一个和最后一个位置</li><li><code>.insert(val)</code>：插入元素，返回插入的元素的迭代器</li><li><code>.insert(pos, val)</code>：插入元素，返回插入的元素的迭代器（pos是提示插入起点）</li><li><code>.emplace(args...)</code>：插入元素，返回插入的元素的迭代器</li><li><code>.emplace_hint(pos, args...)</code>：插入元素，返回插入的元素的迭代器（pos 是提示插入起点）</li><li><code>.merge(other)</code>：将两个 map 合并成一个</li><li><code>.clear()</code>：移除所有元素，将容器清空</li></ul><h2 id="无序容器"><a href="#无序容器" class="headerlink" title="无序容器"></a>无序容器</h2><p>通过 hash 实现查找</p><h3 id="unorder-set、unorder-multiset"><a href="#unorder-set、unorder-multiset" class="headerlink" title="unorder_set、unorder_multiset"></a>unorder_set、unorder_multiset</h3><p><img src="/../images/ProgramBasic_STL/unordered_set_thumb.svg" alt="internal structure of std::unordered_set"></p><ul><li><code>.count(val)</code>：返回值为val的个数</li><li><code>.find(val)</code>：返回值为val的第一个元素的迭代器，找不到返回 <code>end()</code></li><li><code>.contains(val)</code>：判断是否包含某个元素（c++20）</li><li><code>.insert(val)</code>：插入元素，返回插入的元素的迭代器</li><li><code>.insert(pos, val)</code>：插入元素，返回插入的元素的迭代器（pos是提示插入起点）</li><li><code>.emplace(args...)</code>：插入元素，返回插入的元素的迭代器</li><li><code>.emplace_hint(pos, args...)</code>：插入元素，返回插入的元素的迭代器（pos 是提示插入起点）</li><li><code>.merge(other)</code>：将两个 set 合并成一个</li><li><code>.clear()</code>：移除所有元素，将容器清空</li></ul><h3 id="unorder-map、unorder-multimap"><a href="#unorder-map、unorder-multimap" class="headerlink" title="unorder_map、unorder_multimap"></a>unorder_map、unorder_multimap</h3><p><img src="/../images/ProgramBasic_STL/unordered_map_thumb.svg" alt="internal structure of std::unordered_map"></p><ul><li><code>.count(val)</code>：返回值为val的个数</li><li><code>.find(val)</code>：返回值为val的第一个元素的迭代器，找不到返回 <code>end()</code></li><li><code>.contains(val)</code>：判断是否包含某个元素（c++20）</li><li><code>.insert(val)</code>：插入元素，返回插入的元素的迭代器</li><li><code>.insert(pos, val)</code>：插入元素，返回插入的元素的迭代器（pos是提示插入起点）</li><li><code>.emplace(args...)</code>：插入元素，返回插入的元素的迭代器</li><li><code>.emplace_hint(pos, args...)</code>：插入元素，返回插入的元素的迭代器（pos 是提示插入起点）</li><li><code>.merge(other)</code>：将两个 set 合并成一个</li><li><code>.clear()</code>：移除所有元素，将容器清空</li></ul><h2 id="特殊容器"><a href="#特殊容器" class="headerlink" title="特殊容器"></a>特殊容器</h2><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><blockquote><p>底层一般用 <code>deque</code> 实现</p><p><code>stack</code> 和 <code>queue</code> 其实是适配器，而不叫容器，因为是对容器的再封装</p></blockquote><ul><li><code>.push()</code>： 将一个元素放入 stack 中</li><li><code>.emplace()</code>： 将一个元素放入 stack 中，效率比 push 更高</li><li><code>.top()</code>： 返回 stack 内的下一个元素</li><li><code>.pop()</code>： 从 stack 内移除一个元素</li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><blockquote><p>底层一般用 <code>deque</code> 实现</p></blockquote><ul><li><code>.front()</code>：返回第一个元素的<strong>引用</strong>，该元素将最先出队</li><li><code>.back()</code>：返回最末元素的<strong>引用</strong>，<code>c.back() = 10</code></li><li><code>.push()</code>： 将一个元素放入 queue 中</li><li><code>.emplace()</code>： 将一个元素放入 queue 中，效率比 push 更高</li><li><code>.pop()</code>： 从 queue 内移除一个元素</li></ul><h3 id="Priority-queue"><a href="#Priority-queue" class="headerlink" title="Priority_queue"></a>Priority_queue</h3><blockquote><p>底层数据结构一般为 <code>vector</code> 为底层容器，堆 <code>heap</code> 为处理规则来管理底层容器实现。</p><ul><li>左子节点 <code>pos = now * 2 + 1</code></li><li>右子节点 <code>pos = now * 2 + 2</code></li><li>父节点 <code>pos = (now - 1) / 2</code></li></ul></blockquote><p>和queue类似，但其元素有优先级，dequeue时并非取最先放入的元素，而是优先级最高的元素！</p><p>如果同时存在若干个优先级最高的元素，我们无法确知究竟哪一个会入选。</p><ul><li><code>.push()</code>： 将一个元素放入priority queue中</li><li><code>.emplace()</code>： 将一个元素放入priority queue中，效率比 push 更高</li><li><code>.top()</code>： 返回priority queue内的下一个元素</li><li><code>.pop()</code>： 从priority queue内移除一个元素</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> priority;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    Node(<span class="type">int</span> p, <span class="type">int</span> v) : priority(p), value(v) &#123;&#125;</span><br><span class="line">    <span class="type">bool</span> operator&lt;(<span class="type">const</span> Node&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> priority &lt; other.priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> <span class="title function_">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Node &amp;a, <span class="type">const</span> Node &amp;b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; pq; // method 1, 正常类型</span></span><br><span class="line">    <span class="comment">// method 2, 自定义类型，不能使用 lambda 或者函数，必须是类型里面重载运算符</span></span><br><span class="line">    <span class="comment">// priority_queue&lt;Node, vector&lt;Node&gt;, cmp&gt; pq;</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;Node&gt; pq;    <span class="comment">// method 3, 重载了 operator&lt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">        pq.push(Node(i, i));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; pq.top().value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bitset"><a href="#Bitset" class="headerlink" title="Bitset"></a>Bitset</h3><p>Bitset造出了一个内含bit或Boolean值上且<strong>大小固定的array</strong>。</p><ul><li><code>bitset&lt;size&gt;(value)</code>：以 value 初始化大小为size 的 bitset</li><li><code>bitset&lt;numeric_limits&lt;unsigned long&gt;::digits&gt;(value)</code></li><li><code>.any()</code>：检查是否有 bit 被设置为1</li><li><code>.all()</code>：检查是否所有 bit 都为1</li><li><code>.none()</code>：检查是否所有 bit 都为0</li><li><code>.set(pos)</code>：设置 pos 位置的 bit 为1</li><li><code>.reset()</code>：设置所有 bit 为0</li><li><code>.reset(pos)</code>：设置 pos 位置的 bit 为0</li><li><code>.flip()</code>：翻转所有 bit</li><li><code>.flip(pos)</code>：翻转 pos 位置的 bit</li><li><code>.to_string()</code>：输出为01字符串</li><li><code>.to_ullong()</code>：输出为 unsigned long long 类型</li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><blockquote><ul><li><a href="https://hackingcpp.com/">hackingcpp</a>：提供了<code>cpp</code>标准库中的容器、算法甚至包括内存管理、调试方法等，值得一看，此文档中的图片就来源于该网站。</li><li><a href="https://hackingcpp.com/cpp/std/algorithms.html">标准库算法可视化</a></li><li><a href="https://hackingcpp.com/cpp/tools/gdb_intro.html">gdb调试</a></li><li><a href="http://www.cplusplus.com/reference/clibrary/">C++ Reference 查找库函数文档</a></li><li><a href="https://gx.jd.com/gx/gx_bookDetail.action?bookId=30656283">京东图书：C++标准库</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构摘要</title>
      <link href="/2022/04/23/DS_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%91%98%E8%A6%81/"/>
      <url>/2022/04/23/DS_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%91%98%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p>只有重点、简洁的介绍，方便查阅！</p><blockquote><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">数据结构可视化网站</a>：部分结构如树，点击后需要手动添加节点，且能看到其变化的过程。<br>另一个可视化数据结构和算法的网站：<a href="https://visualgo.net/zh">visualgo.net&#x2F;zh</a></p></blockquote><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><ul><li>树是由根节点和<strong>若干颗子树</strong>构成。</li><li>每个节点都只有有限个子节点或无子节点。</li><li>没有父节点的节点称为<strong>根节点</strong>。没有子节点的节点称为<strong>叶子节点</strong>。</li><li><strong>树的深度&#x2F;高度：</strong>根节点到最远叶子节点的最长路径上的<strong>节点数</strong>。</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul><li>每个节点最多只有两个子节点的树。</li></ul><h2 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h2><ul><li>树中的每个节点仅包含 0 或 2 个子节点。</li></ul><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><ul><li><strong>除最后一层外</strong>，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。</li><li><strong>重要性质：</strong><ol><li>在二叉树上的第<code>i</code>层上至多有 $2^{i-1}, i&gt;&#x3D;1$个节点。</li><li>深度为<code>k</code>的二叉树至多有 $2^k-1, k &gt;&#x3D; 1$个节点。</li><li>具有<code>n</code>个节点的完全二叉树的深度为 <code>floor&#123; log2(n) &#125; + 1</code> 。</li></ol></li><li>对一颗具有<code>n</code>个节点的完全二叉树中的节点<strong>从<code>0</code>开始按层序编号</strong>，对任意节点<code>i</code>：<ul><li>其父节点编号为：<code>floor&#123; (i-1)/2 &#125;</code></li><li>若<code>2i &lt; n-1</code>，则其左孩子编号为：<code>2i + 1</code></li></ul></li><li>对一颗具有<code>n</code>个节点的完全二叉树中的节点<strong>从<code>1</code>开始按层序编号</strong>，对任意节点<code>i</code>：<ul><li><strong>其父节点编号为：<code>floor&#123; i/2 &#125;</code></strong></li><li><strong>若<code>2i &lt; n</code>，则其左孩子编号为：<code>2i</code></strong></li><li>为便于计算，推荐从1开始（数组的第0位不用）。</li></ul></li></ul><h2 id="完美二叉树"><a href="#完美二叉树" class="headerlink" title="完美二叉树"></a>完美二叉树</h2><ul><li>二叉树中的每个节点（除叶子节点外）都拥有两个子节点，并且具有<strong>相同的高度</strong>。</li></ul><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><ul><li>二叉搜索树又称二叉排序树、二叉查找树，简统称BST。</li><li>一种特殊的二叉树，其任何节点中的值都会<strong>大于等于其左子节点</strong>并且<strong>小于等于其右子节点</strong>。</li></ul><h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><ul><li>它可以是一颗空树，或者具有以下性质的二叉排序树：它的<strong>左子树和右子树的高度之差的绝对值不超过1</strong>且它的左子树和右子树都是一颗平衡二叉树。</li><li>平衡二叉树查询、插入、删除的时间复杂度都是 <code>O(logN)</code>。</li></ul><p>但是平衡二叉树也不是完美的，AVL树最大的缺点就是删除节点时有可能因为失衡，导致需要从删除节点的父节点开始，不断的回溯到根节点，如果这棵AVL树很高的话，那中间就要判断很多个节点，效率就显然变的低下！</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>红黑树是一种含有红黑结点并<strong>能自平衡的</strong>二叉查找树，也是一种<strong>弱</strong>二叉平衡树，<strong>弱</strong>是指红黑树不是严格平衡的。二叉平衡树的左子树和右子树的高度之差的绝对值不超过1，但<strong>红黑树在某些时刻可能会超过1</strong>，只要符合红黑树的五个条件即可。</p><ul><li>性质1：每个节点要么是黑色，要么是红色。</li><li>性质2：根节点是黑色。</li><li>性质3：每个叶子节点（NIL）是黑色。</li><li>性质4：每个红色结点的两个子结点一定都是黑色。</li><li>性质5：任意一结点到每个叶子结点的路径都包含数量相同的黑结点。<ul><li>性质5.1：如果一个结点存在黑子结点，那么该结点肯定有两个子结点。</li></ul></li></ul><p>红黑树和二叉平衡树的区别：</p><ol><li>红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。</li><li>平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</li></ol><h2 id="字典树（Trie树，前缀树）"><a href="#字典树（Trie树，前缀树）" class="headerlink" title="字典树（Trie树，前缀树）"></a>字典树（Trie树，前缀树）</h2><ul><li>从根节点到某一个节点，路过的<strong>字符</strong>连起来就是该节点对应的字符串。</li><li>利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。</li><li>常用于搜索提示。如当输入部分内容，可以自动搜索出可能的选择。</li></ul><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul><li>后进先出</li></ul><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><ul><li>要求是每次入栈的元素必须要有序（<strong>如果新元素入栈不符合要求，则将之前的元素出栈，直到符合要求再入栈</strong>），使之形成<strong>单调递增&#x2F;单调递减</strong>的一个栈。</li><li>单调递增栈：只有比栈顶小的才能入栈，否则就把栈顶出栈后，再入栈。出栈时可能会有一些计算。<strong>适用于求解第一个大于该位置元素的数</strong>。</li><li>单调递减栈：与单调递增栈相反。适用于求解第一个小于该位置元素的数。</li><li><strong>哨兵技巧：</strong>例如在 {1, 3, 4, 5, 2, 9, 6} 末尾添加一个 -1 作为哨兵，变成了 {1, 3, 4, 5, 2, 9, 6, -1} ，这种技巧可以简化代码逻辑。</li></ul><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul><li>先进先出</li></ul><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><ul><li>优先队列一般使用<strong>二叉堆</strong>实现。</li></ul><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p>堆总是一棵<strong>完全二叉树</strong>，<strong>用数组存储</strong>，根据完全二叉树的性质可以很方便地找到某个节点的子节点或父节点的下标。</p></li><li><p>堆中某个结点的值总是<strong>不大于</strong>或<strong>不小于</strong>其父结点的值。</p></li><li><p><strong>堆排序</strong>。</p></li></ul><h2 id="大顶堆（大根堆）"><a href="#大顶堆（大根堆）" class="headerlink" title="大顶堆（大根堆）"></a>大顶堆（大根堆）</h2><ul><li>堆中某个结点的值总是<strong>不大于</strong>其父结点的值；<strong>根节点的值最大！</strong></li></ul><h2 id="小顶堆（小根堆）"><a href="#小顶堆（小根堆）" class="headerlink" title="小顶堆（小根堆）"></a>小顶堆（小根堆）</h2><ul><li>堆中某个结点的值总是<strong>不小于</strong>其父结点的值；<strong>根节点的值最小！</strong></li></ul><h2 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h2><blockquote><ul><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">数据结构可视化网站</a></li><li><a href="https://visualgo.net/en">数据结构与算法可视化</a></li><li><a href="https://www.cnblogs.com/yichunguo/p/12040456.html">二叉平衡树</a></li><li><a href="https://www.jianshu.com/p/e136ec79235c">红黑树</a></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tensorflow-hub</title>
      <link href="/2021/12/27/Tensorflow-hub/"/>
      <url>/2021/12/27/Tensorflow-hub/</url>
      
        <content type="html"><![CDATA[<h2 id="Tensorflow-hub介绍"><a href="#Tensorflow-hub介绍" class="headerlink" title="Tensorflow-hub介绍"></a><code>Tensorflow-hub</code>介绍</h2><p><img src="/../images/Tensorflow-hub/006xUmvuly1gpoths386wj311y0iln04.jpg" alt="scrnli_4_19_2021_9-54-50 AM.png"></p><p><a href="https://tfhub.dev/">tfhub.dev</a>包含一系列模型，根据处理对象<code>Problem domain</code>分成了四类：<code>Image, Text, Video, Audio</code></p><h2 id="模型格式"><a href="#模型格式" class="headerlink" title="模型格式"></a>模型格式</h2><p>模型格式又可分为<code>TF.js, TFLite, Coral</code></p><ul><li><code>TF.js</code> 是用于浏览器的模型。<a href="https://blog.csdn.net/xiangzhihong8/article/details/82597644">ref</a></li><li><code>TFLite</code> 使用的思路主要是从预训练的模型转换为tflite模型文件，拿到移动端部署。<a href="https://blog.csdn.net/yuanlulu/article/details/84063503">ref</a><br><img src="/../images/Tensorflow-hub/006xUmvuly1gpou0gwc06j30lw0cu3zc-168171479005116.jpg" alt="undefined"></li><li><code>Coral</code> 是google发布在一款开发板，类似树莓派，专门用于跑神经网络模型。<a href="https://www.sohu.com/a/299688498_223764">ref</a><br><img src="/../images/Tensorflow-hub/006xUmvuly1gpoud2vi74j30pn0dmjtx.jpg" alt="scrnli_4_19_2021_10-24-56 AM.png"></li></ul><p>上述三类模型都是比较特殊的格式（在电脑上或服务器上运行不使用上述3种格式！），模型列表中的右上角有标出格式。而实际上还有其他格式的模型（<code>TF2.0 Saved Model, Hub module</code>等），只有进入模型页面后才能看见。<br><img src="/../images/Tensorflow-hub/006xUmvuly1gpouy58k3ij30wn08zmyf.jpg" alt="scrnli_4_19_2021_10-44-35 AM.png"><br><img src="/../images/Tensorflow-hub/006xUmvuly1gpouzhx6htj30wr0a875w-168171483639024.jpg" alt="scrnli_4_19_2021_10-46-27 AM.png"></p><p><strong><code>Tensorflow Serving</code> 使用的是<code>TF2.0 Saved Model</code>格式的模型！</strong></p><hr><hr><p><img src="/../images/Tensorflow-hub/006xUmvuly1gpounyjsgdj30ph0dfq4q.jpg" alt="scrnli_4_19_2021_10-35-24 AM.png"><br><code>Collection</code>是处理一类问题的一系列模型的集合，而且在<code>Collection</code>中会展示模型的性能（推理时间等！）在选择模型时非常方便<br><img src="/../images/Tensorflow-hub/006xUmvuly1gpoupu3wqhj311y0ilad3.jpg" alt="scrnli_4_19_2021_10-36-43 AM.png"></p><hr><h2 id="模型使用"><a href="#模型使用" class="headerlink" title="模型使用"></a>模型使用</h2><p>进入模型介绍页面后，如下图：<br><img src="/../images/Tensorflow-hub/006xUmvuly1gpouzhx6htj30wr0a875w.jpg" alt="scrnli_4_19_2021_10-46-27 AM.png"></p><ul><li><code>COPY URL</code> 复制模型链接，在加载模型时，可直接使用<code>hub.load(&quot;model url&quot;)</code>的方式来加载，它会先自动下载模型到本地，再加载模型。但由于网络环境限制，不太好用，一般用下面的方法。</li><li><code>download</code> 下载模型到本地，加载模型时，可直接使用<code>hub.load(&quot;/home/xxx/modlepath&quot;)</code>，指定本地模型的路径。</li><li><strong><code>open colab notebook</code> 在colab中使用此模型，并且提供了模型的使用方法，非常方便！！！！</strong></li></ul><h2 id="image-object-Detective"><a href="#image-object-Detective" class="headerlink" title="image object Detective"></a>image object Detective</h2><p>下面演示如何本地加载目标检测的模型以及用<code>Tensorflow Serving</code>部署模型！</p><ol><li><p>下载模型文件<br> <a href="https://tfhub.dev/tensorflow/collections/object_detection/1">模型集合</a>，随便选择一个模型，<code>output</code>一栏中有<code>Boxes, Boxes/Keypoints</code>表示用方框或方框+关键点表示物体。[选择一个模型]后，将模型文件下载到本地。<em>再点击<code>open colab notebook</code>，查看如何使用</em></p></li><li><p>安装可视化工具<br> 由于模型的输出是物体在图片中的坐标（方框的点的位置），只是数字而不是图片，不利于观察，所以需要将方框画在原图中，所以需要安装相应的包来完成。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Clone the tensorflow models repository</span></span><br><span class="line">git <span class="built_in">clone</span> --depth 1 https://github.com/tensorflow/models</span><br><span class="line">sudo apt install -y protobuf-compiler</span><br><span class="line"><span class="built_in">cd</span> models/research/</span><br><span class="line">protoc object_detection/protos/*.proto --python_out=.</span><br><span class="line"><span class="built_in">cp</span> object_detection/packages/tf2/setup.py .</span><br><span class="line">python -m pip install .</span><br></pre></td></tr></table></figure></li><li><p>本地加载模型并测试，注意修改下面的路径变量</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> six <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"><span class="keyword">from</span> six.moves.urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> tensorflow_hub <span class="keyword">as</span> hub</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> label_map_util</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> visualization_utils <span class="keyword">as</span> viz_utils</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> ops <span class="keyword">as</span> utils_ops</span><br><span class="line"></span><br><span class="line">COCO17_HUMAN_POSE_KEYPOINTS = [(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">    (<span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="number">0</span>, <span class="number">6</span>),</span><br><span class="line">    (<span class="number">5</span>, <span class="number">7</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="number">9</span>),</span><br><span class="line">    (<span class="number">6</span>, <span class="number">8</span>),</span><br><span class="line">    (<span class="number">8</span>, <span class="number">10</span>),</span><br><span class="line">    (<span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">    (<span class="number">5</span>, <span class="number">11</span>),</span><br><span class="line">    (<span class="number">6</span>, <span class="number">12</span>),</span><br><span class="line">    (<span class="number">11</span>, <span class="number">12</span>),</span><br><span class="line">    (<span class="number">11</span>, <span class="number">13</span>),</span><br><span class="line">    (<span class="number">13</span>, <span class="number">15</span>),</span><br><span class="line">    (<span class="number">12</span>, <span class="number">14</span>),</span><br><span class="line">    (<span class="number">14</span>, <span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line">MODEL_PATH = <span class="string">&quot;***/TensorflowServer/Model/centernet_resnet50v2_512x512_1/1&quot;</span></span><br><span class="line">PATH_TO_LABELS = <span class="string">&#x27;***/models/research/object_detection/data/mscoco_label_map.pbtxt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_image_into_numpy_array</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Load an image from file into a numpy array.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Puts image into numpy array to feed into tensorflow graph.</span></span><br><span class="line"><span class="string">    Note that by convention we put it into a numpy array with shape</span></span><br><span class="line"><span class="string">    (height, width, channels), where channels=3 for RGB.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        path: the file path to the image</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">        uint8 numpy array with shape (img_height, img_width, 3)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    image = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span>(path.startswith(<span class="string">&#x27;http&#x27;</span>)):</span><br><span class="line">        response = urlopen(path)</span><br><span class="line">        image_data = response.read()</span><br><span class="line">        image_data = BytesIO(image_data)</span><br><span class="line">        image = Image.<span class="built_in">open</span>(image_data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        image_data = tf.io.gfile.GFile(path, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">        image = Image.<span class="built_in">open</span>(BytesIO(image_data))</span><br><span class="line"></span><br><span class="line">    (im_width, im_height) = image.size</span><br><span class="line">    <span class="keyword">return</span> np.array(image.getdata()).reshape((<span class="number">1</span>, im_height, im_width, <span class="number">3</span>)).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualization</span>(<span class="params">result, image_np</span>):</span><br><span class="line">    category_index = label_map_util.create_category_index_from_labelmap(PATH_TO_LABELS, use_display_name=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    label_id_offset = <span class="number">0</span></span><br><span class="line">    image_np_with_detections = image_np.copy()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use keypoints if available in detections</span></span><br><span class="line">    keypoints, keypoint_scores = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;detection_keypoints&#x27;</span> <span class="keyword">in</span> result:</span><br><span class="line">        keypoints = result[<span class="string">&#x27;detection_keypoints&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        keypoint_scores = result[<span class="string">&#x27;detection_keypoint_scores&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    viz_utils.visualize_boxes_and_labels_on_image_array(</span><br><span class="line">        image_np_with_detections[<span class="number">0</span>],</span><br><span class="line">        result[<span class="string">&#x27;detection_boxes&#x27;</span>][<span class="number">0</span>],</span><br><span class="line">        (result[<span class="string">&#x27;detection_classes&#x27;</span>][<span class="number">0</span>] + label_id_offset).astype(<span class="built_in">int</span>),</span><br><span class="line">        result[<span class="string">&#x27;detection_scores&#x27;</span>][<span class="number">0</span>],</span><br><span class="line">        category_index,</span><br><span class="line">        use_normalized_coordinates=<span class="literal">True</span>,</span><br><span class="line">        max_boxes_to_draw=<span class="number">200</span>,</span><br><span class="line">        min_score_thresh=<span class="number">.30</span>,</span><br><span class="line">        agnostic_mode=<span class="literal">False</span>,</span><br><span class="line">        keypoints=keypoints,</span><br><span class="line">        keypoint_scores=keypoint_scores,</span><br><span class="line">        keypoint_edges=COCO17_HUMAN_POSE_KEYPOINTS)</span><br><span class="line"></span><br><span class="line">    plt.imsave(<span class="string">&quot;output.png&quot;</span>, image_np_with_detections[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    imagePath = sys.argv[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get input picture</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    image_np = load_image_into_numpy_array(imagePath)</span><br><span class="line">    plt.imsave(<span class="string">&quot;input.png&quot;</span>, image_np[<span class="number">0</span>])</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;load image: %s ms&#x27;</span> % ((end - start)*<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># load model</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    detector = hub.load(MODEL_PATH)</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;load model: %s ms&#x27;</span> % ((end - start)*<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># running inference</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    results = detector(image_np)</span><br><span class="line">    result = &#123;key:value.numpy() <span class="keyword">for</span> key,value <span class="keyword">in</span> results.items()&#125;</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;inference time: %s ms&#x27;</span> % ((end - start)*<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># show result in picture</span></span><br><span class="line">    visualization(result, image_np)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li><li><p>使用<code>TensorFlow Serving</code>部署</p></li></ol><p>  部署方式和之前的模型一样，用<code>model.config</code>比较方便，运行下面的命令：<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -t -d --<span class="built_in">rm</span> -p 8501:8501 -p 8111:8500 --name tfserver --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=MODELPATH/Model,target=/models tensorflow/serving --model_config_file=/models/model.config</span><br></pre></td></tr></table></figure></p><p>  测试，使用<code>python</code>发送<code>REST</code>请求：<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> six <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageDraw, ImageFont</span><br><span class="line"><span class="keyword">from</span> six.moves.urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> tensorflow_hub <span class="keyword">as</span> hub</span><br><span class="line"></span><br><span class="line"><span class="comment"># visualization</span></span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> label_map_util</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> visualization_utils <span class="keyword">as</span> viz_utils</span><br><span class="line"><span class="keyword">from</span> object_detection.utils <span class="keyword">import</span> ops <span class="keyword">as</span> utils_ops</span><br><span class="line"></span><br><span class="line">COCO17_HUMAN_POSE_KEYPOINTS = [(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">    (<span class="number">0</span>, <span class="number">2</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="number">3</span>),</span><br><span class="line">    (<span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">    (<span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">    (<span class="number">0</span>, <span class="number">6</span>),</span><br><span class="line">    (<span class="number">5</span>, <span class="number">7</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="number">9</span>),</span><br><span class="line">    (<span class="number">6</span>, <span class="number">8</span>),</span><br><span class="line">    (<span class="number">8</span>, <span class="number">10</span>),</span><br><span class="line">    (<span class="number">5</span>, <span class="number">6</span>),</span><br><span class="line">    (<span class="number">5</span>, <span class="number">11</span>),</span><br><span class="line">    (<span class="number">6</span>, <span class="number">12</span>),</span><br><span class="line">    (<span class="number">11</span>, <span class="number">12</span>),</span><br><span class="line">    (<span class="number">11</span>, <span class="number">13</span>),</span><br><span class="line">    (<span class="number">13</span>, <span class="number">15</span>),</span><br><span class="line">    (<span class="number">12</span>, <span class="number">14</span>),</span><br><span class="line">    (<span class="number">14</span>, <span class="number">16</span>)]</span><br><span class="line"></span><br><span class="line">PATH_TO_LABELS = <span class="string">&#x27;/home/yogurt/Desktop/EdgeX_Tutorial/TensorflowServer/tensorflow-models/research/object_detection/data/mscoco_label_map.pbtxt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_image_into_numpy_array</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Load an image from file into a numpy array.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Puts image into numpy array to feed into tensorflow graph.</span></span><br><span class="line"><span class="string">    Note that by convention we put it into a numpy array with shape</span></span><br><span class="line"><span class="string">    (height, width, channels), where channels=3 for RGB.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        path: the file path to the image</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        Returns:</span></span><br><span class="line"><span class="string">        uint8 numpy array with shape (img_height, img_width, 3)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    image = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span>(path.startswith(<span class="string">&#x27;http&#x27;</span>)):</span><br><span class="line">        response = urlopen(path)</span><br><span class="line">        image_data = response.read()</span><br><span class="line">        image_data = BytesIO(image_data)</span><br><span class="line">        image = Image.<span class="built_in">open</span>(image_data)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        image_data = tf.io.gfile.GFile(path, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">        image = Image.<span class="built_in">open</span>(BytesIO(image_data))</span><br><span class="line"></span><br><span class="line">    (im_width, im_height) = image.size</span><br><span class="line">    <span class="keyword">return</span> np.array(image.getdata()).reshape((<span class="number">1</span>, im_height, im_width, <span class="number">3</span>)).astype(np.uint8)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">visualization</span>(<span class="params">result, image_np</span>):</span><br><span class="line">    category_index = label_map_util.create_category_index_from_labelmap(PATH_TO_LABELS, use_display_name=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    label_id_offset = <span class="number">0</span></span><br><span class="line">    image_np_with_detections = image_np.copy()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use keypoints if available in detections</span></span><br><span class="line">    keypoints, keypoint_scores = <span class="literal">None</span>, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">&#x27;detection_keypoints&#x27;</span> <span class="keyword">in</span> result:</span><br><span class="line">        keypoints = result[<span class="string">&#x27;detection_keypoints&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        keypoint_scores = result[<span class="string">&#x27;detection_keypoint_scores&#x27;</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    viz_utils.visualize_boxes_and_labels_on_image_array(</span><br><span class="line">        image_np_with_detections[<span class="number">0</span>],</span><br><span class="line">        result[<span class="string">&#x27;detection_boxes&#x27;</span>][<span class="number">0</span>],</span><br><span class="line">        (result[<span class="string">&#x27;detection_classes&#x27;</span>][<span class="number">0</span>] + label_id_offset).astype(<span class="built_in">int</span>),</span><br><span class="line">        result[<span class="string">&#x27;detection_scores&#x27;</span>][<span class="number">0</span>],</span><br><span class="line">        category_index,</span><br><span class="line">        use_normalized_coordinates=<span class="literal">True</span>,</span><br><span class="line">        max_boxes_to_draw=<span class="number">200</span>,</span><br><span class="line">        min_score_thresh=<span class="number">.30</span>,</span><br><span class="line">        agnostic_mode=<span class="literal">False</span>,</span><br><span class="line">        keypoints=keypoints,</span><br><span class="line">        keypoint_scores=keypoint_scores,</span><br><span class="line">        keypoint_edges=COCO17_HUMAN_POSE_KEYPOINTS)</span><br><span class="line"></span><br><span class="line">    plt.imsave(<span class="string">&quot;output.png&quot;</span>, image_np_with_detections[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        imagePath = <span class="built_in">input</span>(<span class="string">&quot;please input image url/path:&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># get input picture</span></span><br><span class="line">        start = time.time()</span><br><span class="line">        image_np = load_image_into_numpy_array(imagePath)</span><br><span class="line">        plt.imsave(<span class="string">&quot;input.png&quot;</span>, image_np[<span class="number">0</span>])</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;load image: %s毫秒&#x27;</span> % ((end - start)*<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># request body</span></span><br><span class="line">        data = json.dumps(&#123;<span class="string">&quot;signature_name&quot;</span>: <span class="string">&quot;serving_default&quot;</span>, <span class="string">&quot;instances&quot;</span>: image_np.tolist()&#125;)</span><br><span class="line">        headers = &#123;<span class="string">&quot;content-type&quot;</span>: <span class="string">&quot;application/json&quot;</span>&#125;</span><br><span class="line">        start = time.time()</span><br><span class="line">        json_response = requests.post(<span class="string">&#x27;http://localhost:8501/v1/models/detect2:predict&#x27;</span>, data=data, headers=headers)</span><br><span class="line">        end = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;inference time: %s ms&#x27;</span> % ((end - start)*<span class="number">1000</span>))</span><br><span class="line">        <span class="comment"># print(json_response.text)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># decode result</span></span><br><span class="line">        results = json.loads(json_response.text)[<span class="string">&#x27;predictions&#x27;</span>][<span class="number">0</span>]</span><br><span class="line">        result = &#123;key:np.array([value], dtype=np.float32) <span class="keyword">for</span> key,value <span class="keyword">in</span> results.items()&#125;</span><br><span class="line"></span><br><span class="line">        visualization(result, image_np)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Tensorflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
