---
title: 十大经典排序算法（动图演示）
top_img: transparent
date: 2022-12-18 10:32:21
updated: 2022-12-18 10:32:21
toc_number: false
tags:
  - Sort
  - Algorithm
  - C++
categories: Algorithm
keywords:
description:
---

> 本文来源于 [www.cnblogs.com](https://www.cnblogs.com/onepixel/articles/7674659.html)，将代码实现改为了 `c++`
> 文中的动态图也可以在：[visualgo.net/zh/sorting](https://visualgo.net/zh/sorting) 查看，还有其他算法的可视化！
> 另一个可视化排序过程的网站：[cs.usfca.edu/~galles/visualization/Algorithms.html](https://www.cs.usfca.edu/~galles/visualization/Algorithms.html)，还包括数据结构的可视化

## 0、算法概述

### 0.1 算法分类

十种常见排序算法可以分为两大类：

* **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 `O(nlogn)`，因此也称为非线性时间比较类排序。
* **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

![algorithm](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20190306165258970-1789860540.png)

### 0.2 算法复杂度

![complex](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20180402133438219-1946132192.png)

**相关概念**：

* **稳定**：如果 `a` 原本在 `b` 前面，而 `a=b`，排序之后 `a` 仍然在 `b` 的前面。
* **不稳定**：如果 `a` 原本在 `b` 的前面，而 `a=b`，排序之后 `a` 可能会出现在 `b` 的后面。
* **时间复杂度**：对排序数据的总的操作次数。反映当 `n` 变化时，操作次数呈现什么规律。
* **空间复杂度：**是指算法在计算机内执行时所需存储空间的度量，它也是数据规模 `n` 的函数。

## 1、冒泡排序（Bubble Sort）

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。

### 1.1 算法描述

* 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
* 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；
* 针对所有的元素重复以上的步骤，除了最后一个；
* 重复步骤 1~3，直到排序完成。

### 1.2 动图演示

![bubblesort](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015223238449-2146169197.gif)

### 1.3 代码实现

```cpp
void bubbleSort(vector<int> &arr) {
    int len = arr.size();
    for (int i = 0; i < len-1; i++) {
        for (int j = 0; j < len-1-i; j++) {
            if (arr[j] > arr[j+1])
                swap(arr[j], arr[j+1]);
        }
    }
}
```

## 2、选择排序（Selection Sort）

选择排序 (Selection-sort) 是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

### 2.1 算法描述

`n` 个记录的直接选择排序可经过 `n-1` 趟直接选择排序得到有序结果。具体算法描述如下：

* 初始状态：无序区为 `R[1..n]`，有序区为空；
* 第 `i` 趟排序 (`i=1,2,3…n-1`) 开始时，当前有序区和无序区分别为 `R[1..i-1]`和 `R(i..n)`。该趟排序从当前无序区中 - 选出关键字最小的记录 `R[k]`，将它与无序区的第 `1` 个记录 `R` 交换，使 `R[1..i]`和 `R[i+1..n)`分别变为记录个数增加 `1` 个的新有序区和记录个数减少 `1` 个的新无序区；
* `n-1` 趟结束，数组有序化了。

### 2.2 动图演示

![selectsort](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015224719590-1433219824.gif)　　

### 2.3 代码实现

```cpp
void selectionSort(vector<int> &arr) {
    int len = arr.size();
    int minIdx;
    for (int i = 0; i < len-1; i++) {
        minIdx = i;
        for (int j = i+1; j < len; j++) {
            if (arr[j] < arr[minIdx])
                minIdx = j;
        }

        if (minIdx != i)
            swap(arr[minIdx], arr[i]);
    }
}
```

### 2.4 算法分析

表现最稳定的排序算法之一，因为无论什么数据进去都是 `O(n2)` 的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。

## 3、插入排序（Insertion Sort）

插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

> core: 左边是有序数组，将右边未排序的第一个数插入到左边有序数组中。

### 3.1 算法描述

一般来说，插入排序都采用 `in-place` 在数组上实现。具体算法描述如下：

* 从第一个元素开始，该元素可以认为已经被排序；
* 取出下一个元素，在已经排序的元素序列中从后向前扫描；
* 如果该元素（已排序）大于新元素，将该元素移到下一位置；
* 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；
* 将新元素插入到该位置后；
* 重复步骤 2~5。

### 3.2 动图演示

![insertsort](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015225645277-1151100000.gif)

### 3.3 代码实现

```cpp
void insertionSort(vector<int> &arr) {
    int len = arr.size();
    int currVal, currIdx;
    for (int i = 1; i < len; i++) {
        currIdx = i;
        currVal = arr[i];
        while(currIdx > 0 && currVal < arr[currIdx-1]) {
            arr[currIdx] = arr[currIdx-1];
            currIdx--;
        }
        arr[currIdx] = currVal;
    }
}
```

### 3.4 算法分析

插入排序在实现上，通常采用 `in-place` 排序（即只需用到 `O(1)` 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。

## 4、希尔排序（Shell Sort）

1959 年 Shell 发明，第一个突破 `O(n2)` 的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫**缩小增量排序**。

> core: 分组插入排序，看下图吧。

### 4.1 算法描述

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

* 选择一个增量序列 `t1，t2，…，tk`，其中 `ti>tj`，`tk=1`；
* 按增量序列个数 `k`，对序列进行 `k` 趟排序；
* 每趟排序，根据对应的增量 `ti`，将待排序列分割成若干长度为 `m` 的子序列，分别对各子表进行直接插入排序。仅增量因子为 `1` 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

### 4.2 动图演示

![shellsort](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20180331170017421-364506073.gif)

### 4.3 代码实现

```cpp
void shellSort(vector<int> &arr) {
    int len = arr.size();
    int currVal, currIdx;
    /* gap 就是上面的 t1, t2, ... , tk，也是动图中两个相同颜色方框的间距 */
    for (int gap = len/2; gap > 0; gap = gap/2) {
        /* 希尔排序是基于插入排序，下面的过程和插入排序一致，
         * 通过 gap 实现了分组插入排序
         * 这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行 */
        for(int i = gap; i < len; i++) {
            currIdx = i;
            currVal = arr[i];
            while(currIdx-gap >= 0 && currVal < arr[currIdx-gap]) {
                arr[currIdx] = arr[currIdx-gap];
                currIdx -= gap;
            }
            arr[currIdx] = currVal;
        }
    }
}
```

### 4.4 算法分析

希尔排序的核心在于间隔序列的设定。既可以提前设定好间隔序列，也可以动态的定义间隔序列。动态定义间隔序列的算法是《算法（第 4 版）》的合著者 Robert Sedgewick 提出的。

## 5、归并排序（Merge Sort）

归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 **2-路归并**。

### 5.1 算法描述

* 把长度为 `n` 的输入序列分成两个长度为 `n/2` 的子序列；
* 对这两个子序列分别采用归并排序；
* 将两个排序好的子序列合并成一个最终的排序序列。

### 5.2 动图演示

![mergesort](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015230557043-37375010.gif)

### 5.3 代码实现

```c
/* 对外提供的接口只传入数组 */
void mergeSort(vector<int> &arr) {
    int len = arr.size();
    if (len > 2)
        mergeSortSplit(arr, 0, len-1);
}

/* 拆分数组，不能用额外空间，就只有记录左右下标 */
void mergeSortSplit(vector<int> &arr, int l, int r) {
    if (l >= r)
        return;
    /* 还可拆分就继续分 */
    int mid = l + (r-l)/2; /* or l + ((r-l)>>1); 注意 >> 优先级低于 + */
    mergeSortSplit(arr, l, mid);
    mergeSortSplit(arr, mid+1, r);
    /* 到此就可以保证 (l,mid), (mid+1,r) 这两个数组是有序的了，
     * 现在要将这两个有序数组合并为一个有序数组 */
    merge(arr, l, r, mid);
}

/* 合并两个有序数组 (l,mid), (mid+1,r)
 * 下面是借助一个额外数组的合并方法，一般都用此方法 */
void merge(vector<int> &arr, int l, int r, int mid) {
    vector<int> tmp(r-l+1);
    int i = l, j = mid+1, t = 0;
    while(i <= mid && j <= r) {
        if (arr[i] < arr[j]) {
            tmp[t++] = arr[i++];
        } else {
            tmp[t++] = arr[j++];
        }
    }
    while(i <= mid) tmp[t++] = arr[i++];
    while(j <= r) tmp[t++] = arr[j++];

    for (i = l; i <= r; i++) {
        arr[i] = tmp[i-l];
    }
}

/**********************************************/

/* 合并两个有序数组 (l,mid), (mid+1,r)
 * 下面是原地合并方法，不过时间复杂度较高 */
void merge(vector<int> & arr, int l, int r, int mid) {
    int i = l;
    int j = mid + 1;
    while (i <= mid && j <= r) {
        // 比较两个数组的当前元素，将较小的加入结果数组
        if (arr[i] < arr[j]) {
            i++;
        } else {
            int temp = arr[j]; // 保存第二个数组的当前元素
            // 将第一个数组中 i 到 j-1 的所有元素向后移动一位
            for (int k = j-1; k >= i; k--) {
                arr[k+1] = arr[k];
            }
            // 将第二个数组的当前元素插入到第一个数组的当前位置
            arr[i] = temp;
            // 更新指针位置
            i++;
            mid++;
            j++;
        }
    }
}
```

### 5.4 算法分析

归并排序是一种稳定的排序方法。和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn）的时间复杂度。代价是需要额外的内存空间。

在递归过程中，每层递归都需要使用一个临时数组来存储合并的结果。但是，归并排序的递归深度最多是 `logn` 层，因此使用的临时数组的总数也是 `logn` 个。所以，空间复杂度是 `O(nlogn)`。但是，由于常数较小，在实际使用中空间复杂度通常被认为是 `O(n)`。

## 6、快速排序（Quick Sort）

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

> core: 选择基准，调整数组使得比基准值小的摆放在基准前面，比基准值大的摆在基准的后面。在递归处理子数组。

### 6.1 算法描述

快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：

* 从数列中挑出一个元素，称为 “基准”（`pivot`）；
* 重新排序数列，**所有元素比基准值小的摆放在基准前面**，**所有元素比基准值大的摆在基准的后面**（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（`partition`）操作；
* 递归地（`recursive`）把小于基准值元素的子数列和大于基准值元素的子数列排序。

### 6.2 动图演示

> [如果觉得太快，可在该网页逐步查看过程](https://visualgo.net/zh/sorting)

![quicksort](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015230936371-1413523412.gif)

### 6.3 代码实现

```c
void quickSort(vector<int> &arr, int l, int r)
{
    if (l >= r) return;

    int mid = partition(arr, l, r);
    quickSort(arr, l, mid-1);
    quickSort(arr, mid+1, r);
}

/* 动图中的算法，如果不理解可以点开那个可视化的网页，可以逐步查看 */
int partition(vector<int> &arr, int l, int r) {
    int pivot = arr[l];
    int bigIdx = l+1; /* 记录第一个大于pivot的值的下标, -1表示不存在 */

    /* 找到pivot右边第一个大于pivot的下标 */
    while(bigIdx <= r && arr[bigIdx] <= pivot) bigIdx++;

    /* 如果pivot右边不存在大于pivot的数，该循环不会进行，bigIdx为r+1 */
    for (int i = bigIdx+1; i <= r; i++) {
        if (arr[i] <= pivot) {
            swap(arr[i], arr[bigIdx]);
            bigIdx++;
        }
    }

    /* 无论pivot右边是否存在大于pivot的数，bigIdx-1都是合法的下标
     * 如果存在，就将最后一个小于等于pivot的数和pivot交换
     * 如果不存在，就将数组最后一个数（也是最后一个小于等于pivot的数）和pivot交换 */
    swap(arr[bigIdx-1], arr[l]);
    return bigIdx-1;
}

/************************************************************/

/* 注意：此处的实现与动图中不一样！
 * 以arr[start]为基准pivot，实现arr中左边的数都小于pivot,
 * arr右边的数都大于pivot，返回pivot的下标。
 * 后续再对 pivot 的左右数组分别排序 */
int partition(vector<int> &arr, int start, int end)
{
    int l = start, r = end, pivot = arr[start];
    while (l < r) {
        while(l < r && pivot <= arr[r]) r--; // 从右向左找到第一个小于基准数的数
        if (l < r) {
            arr[l++] = arr[r];
        }

        while(l < r && pivot >= arr[l]) l++; // 从左向右找到第一个大于基准数的数
        if (l < r) {
            arr[r--] = arr[l];
        }
    }
    arr[l] = pivot;
    return l;
}
```

## 7、堆排序（Heap Sort）

堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。

### 7.1 算法描述

* 将初始待排序关键字序列 (`R1,R2...Rn`) 构**建成大顶堆**，此堆为初始的无序区；
* 将堆顶元素 `R[1]`与最后一个元素 `R[n]`交换，此时得到新的无序区 (`R1,R2,……Rn-1`) 和新的有序区(`Rn`), 且满足 `R[1,2…n-1]<=R[n]`；
* 由于交换后新的堆顶 `R[1]`可能违反堆的性质，因此需要对当前无序区 (`R1,R2,……Rn-1`) 调整为新堆，然后再次将 `R[1]`与无序区最后一个元素交换，得到新的无序区 (`R1,R2….Rn-2`) 和新的有序区(`Rn-1,Rn`)。不断重复此过程直到有序区的元素个数为 `n-1`，则整个排序过程完成。

### 7.2 动图演示

> [堆排序在线演示](https://www.cs.usfca.edu/~galles/visualization/HeapSort.html)

![heapsort](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015231308699-356134237.gif)

### 7.3 代码实现

```c
/* 数组本身就可以表示堆（完全二叉树） */
void heapSort(vector<int> &arr) {
    int n = arr.size();
    /* 构建大顶堆 */
    for (int i = n / 2 - 1; i >= 0; i--) {
        /* 从第一个非叶子结点从下至上，从右至左调整结构 */
        adjustHeap(arr, i, n);
    }

    /* 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端 */
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        /* 重新对堆进行调整 */
        adjustHeap(arr, 0, i);
    }
}

void adjustHeap(vector<int> &arr, int i, int n) {
    int child;
    int temp;
    for (temp = arr[i]; 2 * i + 1 < n; i = child) {
        child = 2 * i + 1;
        // 如果有右孩子，且右孩子大于左孩子
        if (child + 1 < n && arr[child] < arr[child + 1]) {
            child++;
        }
        // 如果父节点大于任何一个孩子的值，则直接跳出
        if (temp >= arr[child]) {
            break;
        }
        // 把较大的孩子往上移动，替换它的父节点
        arr[i] = arr[child];
    }
    arr[i] = temp;
}
```

## 8、计数排序（Counting Sort）

计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

### 8.1 算法描述

* 找出待排序的数组中最大和最小的元素；
* 统计数组中每个值为 i 的元素出现的次数，存入数组 C 的第 i 项；
* 对所有的计数累加（从 C 中的第一个元素开始，每一项和前一项相加）；
* 反向填充目标数组：将每个元素 i 放在新数组的第 C(i) 项，每放一个元素就将 C(i) 减去 1。

### 8.2 动图演示

![counting sort](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015231740840-6968181.gif)

### 8.3 代码实现

```cpp
void countingSort(vector<int> &arr, int maxValue) {
    int t = 0;
    vector<int> count(maxValue+1, 0);
    /* 计数 */
    for (int i = 0; i < arr.size(); i++)
        count[arr[i]]++;

    /* 重建 */
    for (int i = 0; i <= maxValue; i++) {
        while(count[i]--)
            arr[t++] = i;
    }
}
```

### 8.4 算法分析

计数排序是一个稳定的排序算法。当输入的元素是 n 个 0 到 k 之间的整数时，时间复杂度是 O(n+k)，空间复杂度也是 O(n+k)，其排序速度快于任何比较排序算法。当 k 不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。

## 9、桶排序（Bucket Sort）

桶排序是计数排序的升级版。它利用了函数的映射关系，高**效与否的关键就在于这个映射函数的确定**。桶排序 (Bucket sort) 的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

**桶排序最重要的原则：将数据分到桶的过程中，`映射函数`，必须保证 第`i-1`个桶中的数 < 第 `i` 个桶中的数 < 第 `i+1` 个桶中的数**，这样才能使合并过程更加高效。比如使用映射函数：`int bucketIndex = (int)(nums[i] * bucketNum / (maxNum - minNum + 1));`

### 9.1 算法描述

* 设置一个定量的数组当作空桶；
* 遍历输入数据，并且把数据一个一个放到对应的桶里去；
* 对每个不是空的桶进行排序；
* 从不是空的桶里把排好序的数据拼接起来。

### 9.2 图片演示

> [动态演示的网页](https://www.cs.usfca.edu/~galles/visualization/BucketSort.html)

![bucketsort](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015232107090-1920702011.png)

### 9.3 代码实现

```c
void bucketSort(vector<int> &arr) {
    int bucketNum = 10; /* 桶的数量 */
    int bucketIndex;
    vector<vector<int>> bucket(bucketNum, vector<int>());

    /* 获取数组的最大值和最小值 */
    int maxNum = arr[0], minNum = arr[0];
    for (int i = 1; i < arr.size(); i++) {
        maxNum = max(maxNum, arr[i]);
        minNum = min(minNum, arr[i]);
    }

    /* 将数据映射到桶中 */
    for (int i = 0; i < arr.size(); i++) {
        bucketIndex = (int)(arr[i] * bucketNum / (maxNum - minNum + 1));
        /* 这里可能出现 bucketIndex == bucketNum，需要特殊处理 */
        if (bucketIndex == bucketNum) --bucketIndex;
        bucket[bucketIndex].emplace_back(arr[i]);
    }

    /* 对每个桶中的数据排序，可以选用快排等，这里为了简洁直接调用sort */
    for (int i = 0; i < bucketNum; i++) {
        sort(bucket[i].begin(), bucket[i].end());
    }

    /* 将各个桶中的数据按顺序取出，得到排序后的数组
     * 之所以合并过程不需要再次判断，是因为前面映射函数保证了
     * 第 i-1 个桶中的数 < 第 i 个桶中的数 < 第 i+1 个桶中的数 */
    int t = 0;
    for (int i = 0; i < bucketNum; i++) {
        for (int & v : bucket[i])
            arr[t++] = v;
    }
}
```

### 9.4 算法分析

桶排序最好情况下使用线性时间 `O(n)`，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 `O(n)`。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。

## 10、基数排序（Radix Sort）

基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。

### 10.1 算法描述

* 取得数组中的最大数，并取得位数；
* `arr` 为原始数组，从最低位开始取每个位组成 `radix` 数组；
* 对 `radix` 进行计数排序（利用计数排序适用于小范围数的特点）；

### 10.2 动图演示

> 注意看，重建时，采用的FIFO的方式

![radixsort](../images/%E5%8D%81%E5%A4%A7%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%8A%A8%E5%9B%BE%E6%BC%94%E7%A4%BA%EF%BC%89/849589-20171015232453668-1397662527.gif)

### 10.3 代码实现

```c
void radixSort(vector<int> &arr) {
    int count = 1; /* 用于判断是否继续比较高位 */
    int mod = 10, dev = 1;
    int len = arr.size();
    vector<queue<int>> radix(10, queue<int>());

    while(count) {
        count = 0;
        /* 放到桶中 */
        for (int i = 0; i < len; i++) {
            radix[(arr[i]%mod)/dev].push(arr[i]);
            if (arr[i]/mod > 0)
                ++count;
        }
        mod *= 10;
        dev *= 10;

        /* 重建 arr */
        int t = 0;
        for (int i = 0; i < 10; i++) {
            while(!radix[i].empty()) {
                arr[t++] = radix[i].front();
                radix[i].pop();
            }
        }
    }
}
```

### 10.4 算法分析

基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 `O(n)` 的时间复杂度，而且分配之后得到新的关键字序列又需要 `O(n)` 的时间复杂度。假如待排数据可以分为 `d` 个关键字，则基数排序的时间复杂度将是 `O(d*2n)` ，当然 `d` 要远远小于 `n`，因此基本上还是线性级别的。

基数排序的空间复杂度为 `O(n+k)`，其中 `k` 为桶的数量。一般来说 `n>>k`，因此额外空间需要大概 `n` 个左右。

## 测试代码

```cpp
#include <bits/stdc++.h>

using namespace std;

void bubbleSort(vector<int> &arr) {
    int len = arr.size();
    for (int i = 0; i < len-1; i++) {
        for (int j = 0; j < len-1-i; j++) {
            if (arr[j] > arr[j+1])
                swap(arr[j], arr[j+1]);
        }
    }
}

void selectionSort(vector<int> &arr) {
    int len = arr.size();
    int minIdx;
    for (int i = 0; i < len-1; i++) {
        minIdx = i;
        for (int j = i+1; j < len; j++) {
            if (arr[j] < arr[minIdx])
                minIdx = j;
        }

        if (minIdx != i)
            swap(arr[minIdx], arr[i]);
    }
}

void insertionSort(vector<int> &arr) {
    int len = arr.size();
    int currVal, currIdx;
    for (int i = 1; i < len; i++) {
        currIdx = i;
        currVal = arr[i];
        while(currIdx > 0 && currVal < arr[currIdx-1]) {
            arr[currIdx] = arr[currIdx-1];
            currIdx--;
        }
        arr[currIdx] = currVal;
    }
}

void shellSort(vector<int> &arr) {
    int len = arr.size();
    int currVal, currIdx;
    /* gap 就是上面的 t1, t2, ... , tk，也是动图中两个相同颜色方框的间距 */
    for (int gap = len/2; gap > 0; gap = gap/2) {
        /* 希尔排序是基于插入排序，下面的过程和插入排序一致，
         * 通过 gap 实现了分组插入排序
         * 这里和动图演示的不一样，动图是分组执行，实际操作是多个分组交替执行 */
        for(int i = gap; i < len; i++) {
            currIdx = i;
            currVal = arr[i];
            while(currIdx-gap >= 0 && currVal < arr[currIdx-gap]) {
                arr[currIdx] = arr[currIdx-gap];
                currIdx -= gap;
            }
            arr[currIdx] = currVal;
        }
    }
}

/* 合并两个有序数组 (l,mid), (mid+1,r)
 * 下面是借助一个额外数组的合并方法，一般都用此方法 */
void merge(vector<int> &arr, int l, int r, int mid) {
    vector<int> tmp(r-l+1);
    int i = l, j = mid+1, t = 0;
    while(i <= mid && j <= r) {
        if (arr[i] < arr[j]) {
            tmp[t++] = arr[i++];
        } else {
            tmp[t++] = arr[j++];
        }
    }
    while(i <= mid) tmp[t++] = arr[i++];
    while(j <= r) tmp[t++] = arr[j++];

    for (i = l; i <= r; i++) {
        arr[i] = tmp[i-l];
    }
}

/* 拆分数组，不能用额外空间，就只有记录左右下标 */
void mergeSortSplit(vector<int> &arr, int l, int r) {
    if (l >= r)
        return;
    /* 还可拆分就继续分 */
    int mid = l + (r-l)/2; /* or l + ((r-l)>>1); 注意 >> 优先级低于 + */
    mergeSortSplit(arr, l, mid);
    mergeSortSplit(arr, mid+1, r);
    /* 到此就可以保证 (l,mid), (mid+1,r) 这两个数组是有序的了，
     * 现在要将这两个有序数组合并为一个有序数组 */
    merge(arr, l, r, mid);
}

/* 对外提供的接口只传入数组 */
void mergeSort(vector<int> &arr) {
    int len = arr.size();
    if (len > 2)
        mergeSortSplit(arr, 0, len-1);
}

/* 动图中的算法，如果不理解可以点开那个可视化的网页，可以逐步查看 */
int partition(vector<int> &arr, int l, int r) {
    int pivot = arr[l];
    int bigIdx = l+1; /* 记录第一个大于pivot的值的下标, -1表示不存在 */

    /* 找到pivot右边第一个大于pivot的下标 */
    while(bigIdx <= r && arr[bigIdx] <= pivot) bigIdx++;

    /* 如果pivot右边不存在大于pivot的数，该循环不会进行，bigIdx为r+1 */
    for (int i = bigIdx+1; i <= r; i++) {
        if (arr[i] <= pivot) {
            swap(arr[i], arr[bigIdx]);
            bigIdx++;
        }
    }

    /* 无论pivot右边是否存在大于pivot的数，bigIdx-1都是合法的下标
     * 如果存在，就将最后一个小于等于pivot的数和pivot交换
     * 如果不存在，就将数组最后一个数（也是最后一个小于等于pivot的数）和pivot交换 */
    swap(arr[bigIdx-1], arr[l]);
    return bigIdx-1;
}

void quickSort(vector<int> &arr, int l, int r)
{
    if (l >= r) return;

    int mid = partition(arr, l, r);
    quickSort(arr, l, mid-1);
    quickSort(arr, mid+1, r);
}

void adjustHeap(vector<int> &arr, int i, int n) {
    int child;
    int temp;
    for (temp = arr[i]; 2 * i + 1 < n; i = child) {
        child = 2 * i + 1;
        // 如果有右孩子，且右孩子大于左孩子
        if (child + 1 < n && arr[child] < arr[child + 1]) {
            child++;
        }
        // 如果父节点大于任何一个孩子的值，则直接跳出
        if (temp >= arr[child]) {
            break;
        }
        // 把较大的孩子往上移动，替换它的父节点
        arr[i] = arr[child];
    }
    arr[i] = temp;
}

/* 数组本身就可以表示堆（完全二叉树） */
void heapSort(vector<int> &arr) {
    int n = arr.size();
    /* 构建大顶堆 */
    for (int i = n / 2 - 1; i >= 0; i--) {
        /* 从第一个非叶子结点从下至上，从右至左调整结构 */
        adjustHeap(arr, i, n);
    }

    /* 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端 */
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        /* 重新对堆进行调整 */
        adjustHeap(arr, 0, i);
    }
}

void countingSort(vector<int> &arr, int maxValue) {
    int t = 0;
    vector<int> count(maxValue+1, 0);
    /* 计数 */
    for (int i = 0; i < arr.size(); i++)
        count[arr[i]]++;

    /* 重建 */
    for (int i = 0; i <= maxValue; i++) {
        while(count[i]--)
            arr[t++] = i;
    }
}

void bucketSort(vector<int> &arr) {
    int bucketNum = 10; /* 桶的数量 */
    int bucketIndex;
    vector<vector<int>> bucket(bucketNum, vector<int>());

    /* 获取数组的最大值和最小值 */
    int maxNum = arr[0], minNum = arr[0];
    for (int i = 1; i < arr.size(); i++) {
        maxNum = max(maxNum, arr[i]);
        minNum = min(minNum, arr[i]);
    }

    /* 将数据映射到桶中 */
    for (int i = 0; i < arr.size(); i++) {
        bucketIndex = (int)(arr[i] * bucketNum / (maxNum - minNum + 1));
        /* 这里可能出现 bucketIndex == bucketNum，需要特殊处理 */
        if (bucketIndex == bucketNum) --bucketIndex;
        bucket[bucketIndex].emplace_back(arr[i]);
    }

    /* 对每个桶中的数据排序，可以选用快排等，这里为了简洁直接调用sort */
    for (int i = 0; i < bucketNum; i++) {
        sort(bucket[i].begin(), bucket[i].end());
    }

    /* 将各个桶中的数据按顺序取出，得到排序后的数组
     * 之所以合并过程不需要再次判断，是因为前面映射函数保证了
     * 第 i-1 个桶中的数 < 第 i 个桶中的数 < 第 i+1 个桶中的数 */
    int t = 0;
    for (int i = 0; i < bucketNum; i++) {
        for (int & v : bucket[i])
            arr[t++] = v;
    }
}

void radixSort(vector<int> &arr) {
    int count = 1; /* 用于判断是否继续比较高位 */
    int mod = 10, dev = 1;
    int len = arr.size();
    vector<queue<int>> radix(10, queue<int>());

    while(count) {
        count = 0;
        /* 放到桶中 */
        for (int i = 0; i < len; i++) {
            radix[(arr[i]%mod)/dev].push(arr[i]);
            if (arr[i]/mod > 0)
                ++count;
        }
        mod *= 10;
        dev *= 10;

        /* 重建 arr */
        int t = 0;
        for (int i = 0; i < 10; i++) {
            while(!radix[i].empty()) {
                arr[t++] = radix[i].front();
                radix[i].pop();
            }
        }
    }
}

void printArray(vector<int> &arr) {
    for (int i = 0; i < arr.size(); i++)
        cout << arr[i] << ", ";
    cout << endl;
}

int main() {

    vector<int> arr = {1,5,67,23,9,3,34,65,23,4,1};

    // bubbleSort(arr);
    // selectionSort(arr);
    // insertionSort(arr);
    // shellSort(arr);
    // mergeSort(arr);
    // quickSort(arr, 0, arr.size()-1);
    // heapSort(arr);
    // countingSort(arr, 67);
    // bucketSort(arr);
    radixSort(arr);

    printArray(arr);
    return 0;
}
```
