<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Linux configfs | (╯°□°）╯︵ ┻━┻ </title><meta name="author" content="(ง'̀-'́)ง"><meta name="copyright" content="(ง'̀-'́)ง"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="translate from https:&amp;#x2F;&amp;#x2F;www.kernel.org&amp;#x2F;doc&amp;#x2F;Documentation&amp;#x2F;filesystems&amp;#x2F;configfs&amp;#x2F;configfs.txt   configfs - 用户空间驱动的内核对象配置乔尔·贝克尔 &amp;amp;#x6a;&amp;amp;#x6f;&amp;amp;#x65;&amp;amp;#x6c;&amp;amp;#"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yo-gurts.github.io/2024/09/22/Linux-configfs/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":600},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux configfs',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-09-22 10:37:46'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="google-site-verification" content="MP347_Nl-SqfnOi3FZSI69WSb8J_rk_jEsa3jL4ODCI" /><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2024/09/17/3NdhvxIcPRVpufD.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="(╯°□°）╯︵ ┻━┻ "><span class="site-name">(╯°□°）╯︵ ┻━┻ </span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux configfs</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-09-22T02:37:42.000Z" title="发表于 2024-09-22 10:37:42">2024-09-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-09-22T02:37:46.000Z" title="更新于 2024-09-22 10:37:46">2024-09-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux configfs"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/09/22/Linux-configfs/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>translate from <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/filesystems/configfs/configfs.txt">https://www.kernel.org/doc/Documentation/filesystems/configfs/configfs.txt</a></p>
</blockquote>
<hr>
<h2 id="configfs-用户空间驱动的内核对象配置"><a href="#configfs-用户空间驱动的内核对象配置" class="headerlink" title="configfs - 用户空间驱动的内核对象配置"></a>configfs - 用户空间驱动的内核对象配置</h2><p>乔尔·贝克尔 <a href="mailto:&#x6a;&#x6f;&#x65;&#x6c;&#x2e;&#98;&#101;&#99;&#x6b;&#101;&#114;&#64;&#111;&#114;&#97;&#x63;&#108;&#101;&#x2e;&#99;&#111;&#109;">&#x6a;&#x6f;&#x65;&#x6c;&#x2e;&#98;&#101;&#99;&#x6b;&#101;&#114;&#64;&#111;&#114;&#97;&#x63;&#108;&#101;&#x2e;&#99;&#111;&#109;</a></p>
<p>更新日期：2005年3月31日</p>
<p>版权所有 (c) 2005 Oracle Corporation,<br>乔尔·贝克尔 <a href="mailto:&#x6a;&#x6f;&#101;&#x6c;&#x2e;&#x62;&#x65;&#99;&#x6b;&#101;&#114;&#x40;&#x6f;&#114;&#97;&#99;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;">&#x6a;&#x6f;&#101;&#x6c;&#x2e;&#x62;&#x65;&#99;&#x6b;&#101;&#114;&#x40;&#x6f;&#114;&#97;&#99;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;</a></p>
<hr>
<h2 id="什么是-configfs？"><a href="#什么是-configfs？" class="headerlink" title="什么是 configfs？"></a>什么是 configfs？</h2><p><code>configfs</code> 是基于内存的文件系统，它提供与 <code>sysfs</code> 相反的功能。<code>sysfs</code> 提供的是内核对象的文件系统视图，而 <code>configfs</code> 则是内核对象或 <code>config_items</code> 的文件系统管理器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">configfs is a ram-based filesystem that provides the converse of</span><br><span class="line">sysfs&#x27;s functionality. Where sysfs is a filesystem-based view of</span><br><span class="line">kernel objects, configfs is a filesystem-based manager of kernel</span><br><span class="line">objects, or config_items.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>view VS manager</strong> 的区别。</p>
</blockquote>
<p>在 <code>sysfs</code> 中，当一个对象在内核中创建时（例如，发现一个设备），它会被注册到 <code>sysfs</code> 中。它的属性会出现在 <code>sysfs</code> 中，允许用户空间通过 <code>readdir(3)</code>&#x2F;<code>read(2)</code> 读取这些属性。某些属性也许可以通过 <code>write(2)</code> 进行修改。重要的是，内核控制着这些对象的生命周期，<code>sysfs</code> 仅仅是这些操作的一个窗口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">With sysfs, an object is created in kernel (for example, when a device</span><br><span class="line">is discovered) and it is registered with sysfs. Its attributes then</span><br><span class="line">appear in sysfs, allowing userspace to read the attributes via</span><br><span class="line">readdir(3)/read(2). It may allow some attributes to be modified via</span><br><span class="line">write(2). The important point is that the object is created and</span><br><span class="line">destroyed in kernel, the kernel controls the lifecycle of the sysfs</span><br><span class="line">representation, and sysfs is merely a window on all this.</span><br></pre></td></tr></table></figure>

<p>而 <code>configfs</code> 的 <code>config_item</code> 是通过用户空间的显式操作创建的：使用 <code>mkdir(2)</code>。它通过 <code>rmdir(2)</code> 删除。属性在 <code>mkdir(2)</code> 操作时出现，可以通过 <code>read(2)</code> 和 <code>write(2)</code> 进行读取和修改。与 <code>sysfs</code> 类似，<code>readdir(3)</code> 可以查询项目和&#x2F;或属性的列表，<code>symlink(2)</code> 可以用于将项目分组。与 <code>sysfs</code> 不同的是，表示的<strong>生命周期完全由用户空间控制</strong>，内核模块必须对此作出响应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A configfs config_item is created via an explicit userspace operation:</span><br><span class="line">mkdir(2). It is destroyed via rmdir(2). The attributes appear at</span><br><span class="line">mkdir(2) time, and can be read or modified via read(2) and write(2).</span><br><span class="line">As with sysfs, readdir(3) queries the list of items and/or attributes.</span><br><span class="line">symlink(2) can be used to group items together. Unlike sysfs, the</span><br><span class="line">lifetime of the representation is completely driven by userspace. The</span><br><span class="line">kernel modules backing the items must respond to this.</span><br></pre></td></tr></table></figure>

<p><code>sysfs</code> 和 <code>configfs</code> 可以并且应该共存于同一系统上，它们互不替代。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Both sysfs and configfs can and should exist together on the same</span><br><span class="line">system. One is not a replacement for the other.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="使用-configfs"><a href="#使用-configfs" class="headerlink" title="使用 configfs"></a>使用 configfs</h2><p><code>configfs</code> 可以作为模块编译，也可以编译到内核中。可以通过以下方式访问它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t configfs none /config</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">configfs can be compiled as a module or into the kernel. You can access</span><br><span class="line">it by doing</span><br><span class="line"></span><br><span class="line">	mount -t configfs none /config</span><br></pre></td></tr></table></figure>

<p>除非加载了客户端模块，否则 <code>configfs</code> 树是空的。这些模块会将它们的项目类型注册为 <code>configfs</code> 的子系统。一旦客户端子系统被加载，它会作为 <code>/config</code> 下的一个（或多个）子目录出现。和 <code>sysfs</code> 一样，<code>configfs</code> 树始终存在，无论是否挂载到 <code>/config</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The configfs tree will be empty unless client modules are also loaded.</span><br><span class="line">These are modules that register their item types with configfs as</span><br><span class="line">subsystems. Once a client subsystem is loaded, it will appear as a</span><br><span class="line">subdirectory (or more than one) under /config. Like sysfs, the</span><br><span class="line">configfs tree is always there, whether mounted on /config or not.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果打开了某个子模块的 configfs 配置，在 mount configfs 之后，就能在对应的目录看到。比如 <code>CONFIG_USB_CONFIGFS=y</code> 开启之后，<code>/config/usb</code> 就会出现。</p>
</blockquote>
<p>一个项目可以通过 <code>mkdir(2)</code> 创建。项目的属性也会在此时出现。可以通过 <code>readdir(3)</code> 确定属性，<code>read(2)</code> 查询默认值，<code>write(2)</code> 存储新值。不要在一个属性文件中混合多个属性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">An item is created via mkdir(2). The item&#x27;s attributes will also</span><br><span class="line">appear at this time. readdir(3) can determine what the attributes are,</span><br><span class="line">read(2) can query their default values, and write(2) can store new</span><br><span class="line">values. Don&#x27;t mix more than one attribute in one attribute file.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>比如：<a href="./Linux-USBmtp.md#2-%E5%88%9B%E5%BB%BA%E5%A4%8D%E5%90%88%E8%AE%BE%E5%A4%87">Linux-USBmtp</a></p>
</blockquote>
<p><code>configfs</code> 属性有两种类型：</p>
<ol>
<li>正常属性，与 <code>sysfs</code> 属性类似，是小型 ASCII 文本文件，最大大小为一页（<code>PAGE_SIZE</code>，在 i386 上为 4096 字节）。每个文件中最好只包含一个值，并且遵循 <code>sysfs</code> 的相同注意事项。<code>configfs</code> 期望 <code>write(2)</code> 在一次操作中写入整个缓冲区。当写入正常的 <code>configfs</code> 属性时，<strong>用户空间进程应首先读取整个文件，修改他们想要更改的部分，然后写回整个缓冲区</strong>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">There are two types of configfs attributes:</span><br><span class="line"></span><br><span class="line">* Normal attributes, which similar to sysfs attributes, are small ASCII text</span><br><span class="line">files, with a maximum size of one page (PAGE_SIZE, 4096 on i386). Preferably</span><br><span class="line">only one value per file should be used, and the same caveats from sysfs apply.</span><br><span class="line">Configfs expects write(2) to store the entire buffer at once. When writing to</span><br><span class="line">normal configfs attributes, userspace processes should first read the entire</span><br><span class="line">file, modify the portions they wish to change, and then write the entire</span><br><span class="line">buffer back.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>二进制属性，与 <code>sysfs</code> 二进制属性类似，但语义上有一些细微变化。<code>PAGE_SIZE</code> 限制不适用，但整个二进制项必须适合单个内核 <code>vmalloc</code> 分配的缓冲区。来自用户空间的 <code>write(2)</code> 调用是缓冲的，属性的 <code>write_bin_attribute</code> 方法将在最终关闭时被调用，因此用户空间必须检查 <code>close(2)</code> 的返回码以验证操作是否成功完成。为了防止恶意用户导致内核内存不足，每个二进制属性都有最大缓冲区大小限制。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* Binary attributes, which are somewhat similar to sysfs binary attributes,</span><br><span class="line">but with a few slight changes to semantics. The PAGE_SIZE limitation does not</span><br><span class="line">apply, but the whole binary item must fit in single kernel vmalloc&#x27;ed buffer.</span><br><span class="line">The write(2) calls from user space are buffered, and the attributes&#x27;</span><br><span class="line">write_bin_attribute method will be invoked on the final close, therefore it is</span><br><span class="line">imperative for user-space to check the return code of close(2) in order to</span><br><span class="line">verify that the operation finished successfully.</span><br><span class="line">To avoid a malicious user OOMing the kernel, there&#x27;s a per-binary attribute</span><br><span class="line">maximum buffer value.</span><br></pre></td></tr></table></figure>

<p>当需要销毁一个项目时，使用 <code>rmdir(2)</code> 删除它。如果有其他项目通过 <code>symlink(2)</code> 链接到该项目，它是不能被删除的。链接可以通过 <code>unlink(2)</code> 删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">When an item needs to be destroyed, remove it with rmdir(2). An</span><br><span class="line">item cannot be destroyed if any other item has a link to it (via</span><br><span class="line">symlink(2)). Links can be removed via unlink(2).</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="配置-FakeNBD-一个例子"><a href="#配置-FakeNBD-一个例子" class="headerlink" title="配置 FakeNBD: 一个例子"></a>配置 FakeNBD: 一个例子</h2><p>假设有一个网络块设备（NBD）驱动程序允许您访问远程块设备，称之为 FakeNBD。FakeNBD 使用 <code>configfs</code> 进行配置。显然，会有一个专门的程序供系统管理员使用来配置 FakeNBD，但该程序必须通过某种方式与驱动程序通信。这时 <code>configfs</code> 就派上用场了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Configuring FakeNBD: an Example]</span><br><span class="line"></span><br><span class="line">Imagine there&#x27;s a Network Block Device (NBD) driver that allows you to</span><br><span class="line">access remote block devices. Call it FakeNBD. FakeNBD uses configfs</span><br><span class="line">for its configuration. Obviously, there will be a nice program that</span><br><span class="line">sysadmins use to configure FakeNBD, but somehow that program has to tell</span><br><span class="line">the driver about it. Here&#x27;s where configfs comes in.</span><br></pre></td></tr></table></figure>

<p>当加载 FakeNBD 驱动程序时，它会注册到 <code>configfs</code>。使用 <code>readdir(3)</code> 可以看到这一点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls /config</span></span><br><span class="line">fakenbd</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">When the FakeNBD driver is loaded, it registers itself with configfs.</span><br><span class="line">readdir(3) sees this just fine:</span><br><span class="line"></span><br><span class="line">	# ls /config</span><br><span class="line">	fakenbd</span><br></pre></td></tr></table></figure>

<p>可以使用 <code>mkdir(2)</code> 创建一个 fakenbd 连接。名称是任意的，但该工具可能会使用这个名称。也许它是一个 <code>uuid</code> 或磁盘名称：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkdir /config/fakenbd/disk1</span></span><br><span class="line"><span class="comment"># ls /config/fakenbd/disk1</span></span><br><span class="line">target device rw</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A fakenbd connection can be created with mkdir(2). The name is</span><br><span class="line">arbitrary, but likely the tool will make some use of the name. Perhaps</span><br><span class="line">it is a uuid or a disk name:</span><br><span class="line"></span><br><span class="line"># mkdir /config/fakenbd/disk1</span><br><span class="line"># ls /config/fakenbd/disk1</span><br><span class="line">target device rw</span><br></pre></td></tr></table></figure>

<p><code>target</code> 属性包含 FakeNBD 将连接的服务器的 IP 地址。<code>device</code> 属性是服务器上的设备。显然，<code>rw</code> 属性决定了连接是只读还是读写。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># echo 10.0.0.1 &gt; /config/fakenbd/disk1/target</span></span><br><span class="line"><span class="comment"># echo /dev/sda1 &gt; /config/fakenbd/disk1/device</span></span><br><span class="line"><span class="comment"># echo 1 &gt; /config/fakenbd/disk1/rw</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The target attribute contains the IP address of the server FakeNBD will</span><br><span class="line">connect to. The device attribute is the device on the server.</span><br><span class="line">Predictably, the rw attribute determines whether the connection is</span><br><span class="line">read-only or read-write.</span><br><span class="line"></span><br><span class="line"># echo 10.0.0.1 &gt; /config/fakenbd/disk1/target</span><br><span class="line"># echo /dev/sda1 &gt; /config/fakenbd/disk1/device</span><br><span class="line"># echo 1 &gt; /config/fakenbd/disk1/rw</span><br></pre></td></tr></table></figure>

<p>就是这样，仅此而已。现在，设备已配置好，并通过 shell 完成。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">That&#x27;s it. That&#x27;s all there is. Now the device is configured, via the</span><br><span class="line">shell no less.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="使用-configfs-编码"><a href="#使用-configfs-编码" class="headerlink" title="使用 configfs 编码"></a>使用 configfs 编码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Coding With configfs]</span><br></pre></td></tr></table></figure>

<p>在 <code>configfs</code> 中，每个对象都是一个 <code>config_item</code>。一个 <code>config_item</code> 反映了子系统中的一个对象。它具有与该对象的值匹配的属性。<code>configfs</code> 处理该对象及其属性的文件系统表示形式，允许子系统忽略除基本 <code>show/store</code> 交互以外的所有操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Every object in configfs is a config_item. A config_item reflects an</span><br><span class="line">object in the subsystem. It has attributes that match values on that</span><br><span class="line">object. configfs handles the filesystem representation of that object</span><br><span class="line">and its attributes, allowing the subsystem to ignore all but the</span><br><span class="line">basic show/store interaction.</span><br></pre></td></tr></table></figure>

<p>项目是在 <code>config_group</code> 中创建和销毁的。<code>group</code> 是一组具有相同属性和操作的项目。项目通过 <code>mkdir(2)</code> 创建，通过 <code>rmdir(2)</code> 移除，但 <code>configfs</code> 处理这些操作。<code>group</code> 有一组操作来执行这些任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Items are created and destroyed inside a config_group. A group is a</span><br><span class="line">collection of items that share the same attributes and operations.</span><br><span class="line">Items are created by mkdir(2) and removed by rmdir(2), but configfs</span><br><span class="line">handles that. The group has a set of operations to perform these tasks.</span><br></pre></td></tr></table></figure>

<p>子系统是客户端模块的顶层。在初始化期间，客户端模块将子系统注册到 <code>configfs</code>，子系统将作为 <code>configfs</code> 文件系统顶部的一个目录出现。子系统也是一个 <code>config_group</code>，并且可以执行 <code>config_group</code> 能做的所有操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A subsystem is the top level of a client module. During initialization,</span><br><span class="line">the client module registers the subsystem with configfs, the subsystem</span><br><span class="line">appears as a directory at the top of the configfs filesystem. A</span><br><span class="line">subsystem is also a config_group, and can do everything a config_group</span><br><span class="line">can.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>USB CONFIGFS</code> 就是一个 <code>config_group/subsystem</code> 。</p>
</blockquote>
<hr>
<h3 id="struct-config-item"><a href="#struct-config-item" class="headerlink" title="struct config_item"></a><code>struct config_item</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_item</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>                    *ci_name;</span><br><span class="line">	<span class="type">char</span>                    ci_namebuf[UOBJ_NAME_LEN];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kref</span>             <span class="title">ci_kref</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">ci_entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">config_item</span>      *<span class="title">ci_parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">config_group</span>     *<span class="title">ci_group</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> *<span class="title">ci_type</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span>           *<span class="title">ci_dentry</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">config_item_init</span><span class="params">(<span class="keyword">struct</span> config_item *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">config_item_init_type_name</span><span class="params">(<span class="keyword">struct</span> config_item *,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> config_item_type *type)</span>;</span><br><span class="line"><span class="keyword">struct</span> config_item *<span class="title function_">config_item_get</span><span class="params">(<span class="keyword">struct</span> config_item *)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">config_item_put</span><span class="params">(<span class="keyword">struct</span> config_item *)</span>;</span><br></pre></td></tr></table></figure>

<p>一般来说，<code>struct config_item</code> 被嵌入到一个容器结构中，后者实际上表示子系统正在执行的操作。该结构中的 <code>config_item</code> 部分是对象与 <code>configfs</code> 交互的方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Generally, struct config_item is embedded in a container structure, a</span><br><span class="line">structure that actually represents what the subsystem is doing. The</span><br><span class="line">config_item portion of that structure is how the object interacts with</span><br><span class="line">configfs.</span><br></pre></td></tr></table></figure>

<p>无论是在源文件中静态定义还是由父 <code>config_group</code> 创建，都必须调用 <code>_init()</code> 函数之一对 <code>config_item</code> 进行初始化。这会初始化引用计数并设置相应的字段。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Whether statically defined in a source file or created by a parent</span><br><span class="line">config_group, a config_item must have one of the _init() functions</span><br><span class="line">called on it. This initializes the reference count and sets up the</span><br><span class="line">appropriate fields.</span><br></pre></td></tr></table></figure>

<hr>
<p>所有 <code>config_item</code> 的用户都应该通过 <code>config_item_get()</code> 获取其引用，并在使用完成后通过 <code>config_item_put()</code> 释放引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">All users of a config_item should have a reference on it via</span><br><span class="line">config_item_get(), and drop the reference when they are done via</span><br><span class="line">config_item_put().</span><br></pre></td></tr></table></figure>

<p>仅仅有一个 <code>config_item</code>，它除了出现在 <code>configfs</code> 中以外，几乎不能做任何事情。通常子系统希望该项目显示和&#x2F;或存储属性，以及执行其他操作。为此，它需要一个类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">By itself, a config_item cannot do much more than appear in configfs.</span><br><span class="line">Usually a subsystem wants the item to display and/or store attributes,</span><br><span class="line">among other things. For that, it needs a type.</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="struct-config-item-type"><a href="#struct-config-item-type" class="headerlink" title="struct config_item_type"></a><code>struct config_item_type</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_item_operations</span> &#123;</span></span><br><span class="line">	<span class="type">void</span> (*release)(<span class="keyword">struct</span> config_item *);</span><br><span class="line">	<span class="type">int</span> (*allow_link)(<span class="keyword">struct</span> config_item *src,</span><br><span class="line">			  <span class="keyword">struct</span> config_item *target);</span><br><span class="line">	<span class="type">void</span> (*drop_link)(<span class="keyword">struct</span> config_item *src,</span><br><span class="line">			 <span class="keyword">struct</span> config_item *target);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>                           *<span class="title">ct_owner</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">configfs_item_operations</span>         *<span class="title">ct_item_ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">configfs_group_operations</span>        *<span class="title">ct_group_ops</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span>               **<span class="title">ct_attrs</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">configfs_bin_attribute</span>		**<span class="title">ct_bin_attrs</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>config_item_type</code> 的最基本功能是定义可以对 <code>config_item</code> 执行的操作。所有动态分配的项目都需要提供 <code>ct_item_ops-&gt;release()</code> 方法。当 <code>config_item</code> 的引用计数降为零时，会调用此方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The most basic function of a config_item_type is to define what</span><br><span class="line">operations can be performed on a config_item. All items that have been</span><br><span class="line">allocated dynamically will need to provide the ct_item_ops-&gt;release()</span><br><span class="line">method. This method is called when the config_item&#x27;s reference count</span><br><span class="line">reaches zero.</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="struct-configfs-attribute"><a href="#struct-configfs-attribute" class="headerlink" title="struct configfs_attribute"></a><code>struct configfs_attribute</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>                    *ca_name;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">module</span>           *<span class="title">ca_owner</span>;</span></span><br><span class="line">	<span class="type">umode_t</span>                  ca_mode;</span><br><span class="line">	<span class="type">ssize_t</span> (*show)(<span class="keyword">struct</span> config_item *, <span class="type">char</span> *);</span><br><span class="line">	<span class="type">ssize_t</span> (*store)(<span class="keyword">struct</span> config_item *, <span class="type">const</span> <span class="type">char</span> *, <span class="type">size_t</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当 <code>config_item</code> 希望某个属性作为文件出现在其 <code>configfs</code> 目录中时，它必须定义一个描述该属性的 <code>configfs_attribute</code>。然后它将该属性添加到 <code>config_item_type-&gt;ct_attrs</code> 的以 NULL 结尾的数组中。当项目出现在 <code>configfs</code> 中时，属性文件将以 <code>configfs_attribute-&gt;ca_name</code> 文件名出现。<code>configfs_attribute-&gt;ca_mode</code> 指定文件权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">When a config_item wants an attribute to appear as a file in the item&#x27;s</span><br><span class="line">configfs directory, it must define a configfs_attribute describing it.</span><br><span class="line">It then adds the attribute to the NULL-terminated array</span><br><span class="line">config_item_type-&gt;ct_attrs. When the item appears in configfs, the</span><br><span class="line">attribute file will appear with the configfs_attribute-&gt;ca_name</span><br><span class="line">filename. configfs_attribute-&gt;ca_mode specifies the file permissions.</span><br></pre></td></tr></table></figure>

<p>如果属性是可读的并且提供了 <code>-&gt;show</code> 方法，则每当用户空间请求读取该属性时，该方法将被调用。如果属性是可写的并且提供了 <code>-&gt;store</code> 方法，则每当用户空间请求写入该属性时，该方法将被调用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">If an attribute is readable and provides a -&gt;show method, that method will</span><br><span class="line">be called whenever userspace asks for a read(2) on the attribute. If an</span><br><span class="line">attribute is writable and provides a -&gt;store method, that method will be</span><br><span class="line">be called whenever userspace asks for a write(2) on the attribute.</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="struct-configfs-bin-attribute"><a href="#struct-configfs-bin-attribute" class="headerlink" title="struct configfs_bin_attribute"></a><code>struct configfs_bin_attribute</code></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_bin_attribute</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span>	<span class="title">cb_attr</span>;</span></span><br><span class="line">	<span class="type">void</span>				*cb_private;</span><br><span class="line">	<span class="type">size_t</span>				cb_max_size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当需要一个二进制 blob 作为文件内容出现在项目的 <code>configfs</code> 目录中时，可以使用 <code>configfs_bin_attribute</code>。要实现这一点，将二进制属性添加到 <code>config_item_type-&gt;ct_bin_attrs</code> 的以 NULL 结尾的数组中，当项目出现在 <code>configfs</code> 中时，属性文件将以 <code>configfs_bin_attribute-&gt;cb_attr.ca_name</code> 文件名出现。<code>configfs_bin_attribute-&gt;cb_attr.ca_mode</code> 指定文件权限。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">The binary attribute is used when the one needs to use a binary blob to</span><br><span class="line">appear as the contents of a file in the item&#x27;s configfs directory.</span><br><span class="line">To do so, add the binary attribute to the NULL-terminated array</span><br><span class="line">config_item_type-&gt;ct_bin_attrs, and the item appears in configfs, the</span><br><span class="line">attribute file will appear with the configfs_bin_attribute-&gt;cb_attr.ca_name</span><br><span class="line">filename. configfs_bin_attribute-&gt;cb_attr.ca_mode specifies the file</span><br><span class="line">permissions.</span><br></pre></td></tr></table></figure>

<p><code>cb_private</code> 成员是为驱动程序使用而提供的，而 <code>cb_max_size</code> 成员指定用于该二进制属性的最大 <code>vmalloc</code> 缓冲区大小。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The cb_private member is provided for use by the driver, while the</span><br><span class="line">cb_max_size member specifies the maximum amount of vmalloc buffer</span><br><span class="line">to be used.</span><br></pre></td></tr></table></figure>

<p>如果二进制属性是可读的，并且 <code>config_item</code> 提供了 <code>ct_item_ops-&gt;read_bin_attribute()</code> 方法，那么每当用户空间请求读取该属性时，将调用该方法。对于 <code>write(2)</code> 也是如此。读&#x2F;写操作是缓冲的，因此只会进行一次读&#x2F;写；属性本身不需要关心这一点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">If binary attribute is readable and the config_item provides a</span><br><span class="line">ct_item_ops-&gt;read_bin_attribute() method, that method will be called</span><br><span class="line">whenever userspace asks for a read(2) on the attribute. The converse</span><br><span class="line">will happen for write(2). The reads/writes are buffered, so only a</span><br><span class="line">single read/write will occur; the attributes need not concern itself</span><br><span class="line">with it.</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="struct-config-group"><a href="#struct-config-group" class="headerlink" title="struct config_group"></a><code>struct config_group</code></h3><p><code>config_item</code> 不能独立存在。创建 <code>config_item</code> 的唯一方法是通过在 <code>config_group</code> 上使用 <code>mkdir(2)</code>，这将触发子项的创建。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">config_group</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">config_item</span>		<span class="title">cg_item</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">cg_children</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> 	*<span class="title">cg_subsys</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">default_groups</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>		<span class="title">group_entry</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">config_group_init</span><span class="params">(<span class="keyword">struct</span> config_group *group)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">config_group_init_type_name</span><span class="params">(<span class="keyword">struct</span> config_group *group,</span></span><br><span class="line"><span class="params">				 <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">				 <span class="keyword">struct</span> config_item_type *type)</span>;</span><br></pre></td></tr></table></figure>

<p><code>config_group</code> 结构包含一个 <code>config_item</code>。适当配置该项意味着 <code>group</code> 可以作为自己的项目发挥作用。不过，它可以做更多：它可以创建子项目或子组。这是通过在组的 <code>config_item_type</code> 上指定的组操作来实现的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The config_group structure contains a config_item. Properly configuring</span><br><span class="line">that item means that a group can behave as an item in its own right.</span><br><span class="line">However, it can do more: it can create child items or groups. This is</span><br><span class="line">accomplished via the group operations specified on the group&#x27;s</span><br><span class="line">config_item_type.</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_group_operations</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">config_item</span> *(*<span class="title">make_item</span>)(<span class="keyword">struct</span> <span class="title">config_group</span> *<span class="title">group</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>);</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">config_group</span> *(*<span class="title">make_group</span>)(<span class="keyword">struct</span> <span class="title">config_group</span> *<span class="title">group</span>,</span></span><br><span class="line"><span class="class">					   <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>);</span></span><br><span class="line">	<span class="type">int</span> (*commit_item)(<span class="keyword">struct</span> config_item *item);</span><br><span class="line">	<span class="type">void</span> (*disconnect_notify)(<span class="keyword">struct</span> config_group *group,</span><br><span class="line">				  <span class="keyword">struct</span> config_item *item);</span><br><span class="line">	<span class="type">void</span> (*drop_item)(<span class="keyword">struct</span> config_group *group,</span><br><span class="line">			  <span class="keyword">struct</span> config_item *item);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<p>如果组提供了 <code>ct_group_ops-&gt;make_item()</code> 方法，则通过 <code>mkdir(2)</code> 在组的目录中调用该方法创建子项。子系统分配一个新的 <code>config_item</code>（或更可能是其容器结构），对其进行初始化并返回给 <code>configfs</code>。然后 <code>configfs</code> 将填充文件系统树以反映新项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A group creates child items by providing the</span><br><span class="line">ct_group_ops-&gt;make_item() method. If provided, this method is called from mkdir(2) in the group&#x27;s directory. The subsystem allocates a new</span><br><span class="line">config_item (or more likely, its container structure), initializes it,</span><br><span class="line">and returns it to configfs. Configfs will then populate the filesystem</span><br><span class="line">tree to reflect the new item.</span><br></pre></td></tr></table></figure>

<p>如果子系统希望子项本身也是一个组，则子系统会提供 <code>ct_group_ops-&gt;make_group()</code> 方法。其他所有行为相同，使用组的 <code>_init()</code> 函数对该组进行初始化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">If the subsystem wants the child to be a group itself, the subsystem</span><br><span class="line">provides ct_group_ops-&gt;make_group(). Everything else behaves the same,</span><br><span class="line">using the group _init() functions on the group.</span><br></pre></td></tr></table></figure>

<p>最后，当用户空间在该项或组上调用 <code>rmdir(2)</code> 时，<code>ct_group_ops-&gt;drop_item()</code> 方法将被调用。由于 <code>config_group</code> 也是一个 <code>config_item</code>，因此不需要单独的 <code>drop_group()</code> 方法。子系统必须在项目分配时初始化的引用上调用 <code>config_item_put()</code>。如果子系统没有任何工作要做，则可以省略 <code>ct_group_ops-&gt;drop_item()</code> 方法，<code>configfs</code> 将代表子系统在该项上调用 <code>config_item_put()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Finally, when userspace calls rmdir(2) on the item or group,</span><br><span class="line">ct_group_ops-&gt;drop_item() is called. As a config_group is also a</span><br><span class="line">config_item, it is not necessary for a separate drop_group() method.</span><br><span class="line">The subsystem must config_item_put() the reference that was initialized</span><br><span class="line">upon item allocation. If a subsystem has no work to do, it may omit</span><br><span class="line">the ct_group_ops-&gt;drop_item() method, and configfs will call</span><br><span class="line">config_item_put() on the item on behalf of the subsystem.</span><br></pre></td></tr></table></figure>

<p>重要提示：<code>drop_item()</code> 是 <code>void</code> 函数，因此不能返回失败。当调用 <code>rmdir(2)</code> 时，<code>configfs</code> 将从文件系统树中删除该项（假设没有子项保持它忙碌）。子系统负责对此做出响应。如果子系统在其他线程中引用了该项，则内存是安全的。该项实际上可能需要一些时间才能从子系统的使用中消失。但它已经从 <code>configfs</code> 中删除。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IMPORTANT: drop_item() is void, and as such cannot fail. When rmdir(2)</span><br><span class="line">is called, configfs WILL remove the item from the filesystem tree</span><br><span class="line">(assuming that it has no children to keep it busy). The subsystem is</span><br><span class="line">responsible for responding to this. If the subsystem has references to</span><br><span class="line">the item in other threads, the memory is safe. It may take some time</span><br><span class="line">for the item to actually disappear from the subsystem&#x27;s usage. But it</span><br><span class="line">is gone from configfs.</span><br></pre></td></tr></table></figure>

<p>当调用 <code>drop_item()</code> 时，项的链接已经被拆除。它不再拥有其父项的引用，并且在项目层次结构中没有位置。如果客户端需要在这种拆除发生之前进行一些清理操作，子系统可以实现 <code>ct_group_ops-&gt;disconnect_notify()</code> 方法。该方法在 <code>configfs</code> 从文件系统视图中删除该项后，但在从其父组中删除之前调用。与 <code>drop_item()</code> 一样，<code>disconnect_notify()</code> 是 <code>void</code> 函数，不能返回失败。客户端子系统不应在这里删除任何引用，因为它们仍然必须在 <code>drop_item()</code> 中执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">When drop_item() is called, the item&#x27;s linkage has already been torn</span><br><span class="line">down. It no longer has a reference on its parent and has no place in</span><br><span class="line">the item hierarchy. If a client needs to do some cleanup before this</span><br><span class="line">teardown happens, the subsystem can implement the</span><br><span class="line">ct_group_ops-&gt;disconnect_notify() method. The method is called after</span><br><span class="line">configfs has removed the item from the filesystem view but before the</span><br><span class="line">item is removed from its parent group. Like drop_item(),</span><br><span class="line">disconnect_notify() is void and cannot fail. Client subsystems should</span><br><span class="line">not drop any references here, as they still must do it in drop_item().</span><br></pre></td></tr></table></figure>

<p>如果 <code>config_group</code> 仍有子项，则无法将其删除。这在 <code>configfs</code> 的 <code>rmdir(2)</code> 代码中实现。不会调用 <code>-&gt;drop_item()</code>，因为该项尚未被删除。<code>rmdir(2)</code> 将失败，因为目录不为空。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A config_group cannot be removed while it still has child items. This</span><br><span class="line">is implemented in the configfs rmdir(2) code. -&gt;drop_item() will not be</span><br><span class="line">called, as the item has not been dropped. rmdir(2) will fail, as the</span><br><span class="line">directory is not empty.</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="struct-configfs-subsystem"><a href="#struct-configfs-subsystem" class="headerlink" title="struct configfs_subsystem"></a><code>struct configfs_subsystem</code></h3><p>🔥🔥 <strong>子系统必须在模块初始化期间注册自身。这会告诉 <code>configfs</code> 将子系统显示在文件树中</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">config_group</span>	<span class="title">su_group</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">su_mutex</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">configfs_register_subsystem</span><span class="params">(<span class="keyword">struct</span> configfs_subsystem *subsys)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">configfs_unregister_subsystem</span><span class="params">(<span class="keyword">struct</span> configfs_subsystem *subsys)</span>;</span><br></pre></td></tr></table></figure>

<p>一个子系统由一个顶层 <code>config_group</code> 和一个互斥锁组成。该组是创建子 <code>config_items</code> 的位置。对于子系统来说，这个组通常是静态定义的。在调用 <code>configfs_register_subsystem()</code> 之前，子系统必须通过常规的组初始化函数初始化该组，并且还必须初始化互斥锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A subsystem consists of a toplevel config_group and a mutex.</span><br><span class="line">The group is where child config_items are created. For a subsystem,</span><br><span class="line">this group is usually defined statically. Before calling</span><br><span class="line">configfs_register_subsystem(), the subsystem must have initialized the</span><br><span class="line">group via the usual group _init() functions, and it must also have</span><br><span class="line">initialized the mutex.</span><br></pre></td></tr></table></figure>

<p>当注册调用返回时，子系统变为活动状态，并通过 <code>configfs</code> 可见。此时，可以调用 <code>mkdir(2)</code>，子系统必须准备好处理它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">When the register call returns, the subsystem is live, and it</span><br><span class="line">will be visible via configfs. At that point, mkdir(2) can be called and</span><br><span class="line">the subsystem must be ready for it.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>这些基本概念的最佳示例是 <code>samples/configfs/configfs_sample.c</code> 中的 <code>simple_children</code> 子系统&#x2F;组和 <code>simple_child</code> 项。它展示了一个显示和存储属性的简单对象，以及一个创建和销毁这些子项的简单组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[An Example]</span><br><span class="line"></span><br><span class="line">The best example of these basic concepts is the simple_children</span><br><span class="line">subsystem/group and the simple_child item in</span><br><span class="line">samples/configfs/configfs_sample.c. It shows a trivial object displaying</span><br><span class="line">and storing an attribute, and a simple group creating and destroying</span><br><span class="line">these children.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.186/source/samples/configfs/configfs_sample.c">https://elixir.bootlin.com/linux/v5.10.186/source/samples/configfs/configfs_sample.c</a><br>可以试试编译，加一些日志看看。</p>
<p>这里起来时，将 configfs 挂载到了 &#x2F;tmp&#x2F;usb 目录。不好，有歧义🌚。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@milkv-duo]~# ls</span><br><span class="line">configfs_sample.ko</span><br><span class="line">[root@milkv-duo]~# ls /tmp/usb</span><br><span class="line">usb_gadget</span><br><span class="line">[root@milkv-duo]~# insmod configfs_sample.ko</span><br><span class="line">[root@milkv-duo]~# ls /tmp/usb</span><br><span class="line">01-childless  02-simple-children  03-group-children  usb_gadget</span><br><span class="line">[root@milkv-duo]~# cd /tmp/usb/</span><br><span class="line">[root@milkv-duo]/tmp/usb# tree 0*</span><br><span class="line">01-childless</span><br><span class="line">├── description</span><br><span class="line">├── showme</span><br><span class="line">└── storeme</span><br><span class="line">02-simple-children</span><br><span class="line">└── description</span><br><span class="line">03-group-children</span><br><span class="line">└── description</span><br><span class="line"></span><br><span class="line">0 directories, 5 files</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="00-init"><a href="#00-init" class="headerlink" title="00-init"></a>00-init</h3><p>我们现在已经完成了子系统的定义。为了方便起见，这里列出了所有的子系统。这使得初始化函数可以轻松注册它们。大多数模块只包含一个子系统，并且只会直接调用 <code>register_subsystem</code> 进行注册。</p>
<blockquote>
<p>如前面 <a href="#struct-configfs_subsystem"><code>struct configfs_subsystem</code></a> 的描述，通过调用</p>
<ul>
<li><code>config_group_init(&amp;subsys-&gt;su_group);</code></li>
<li><code>mutex_init(&amp;subsys-&gt;su_mutex);</code></li>
<li><code>configfs_register_subsystem(subsys);</code></li>
</ul>
<p>来完成configfs 子系统的注册。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * We&#x27;re now done with our subsystem definitions.</span></span><br><span class="line"><span class="comment"> * For convenience in this module, here&#x27;s a list of them all.  It</span></span><br><span class="line"><span class="comment"> * allows the init function to easily register them.  Most modules</span></span><br><span class="line"><span class="comment"> * will only have one subsystem, and will only call register_subsystem</span></span><br><span class="line"><span class="comment"> * on it directly.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> *<span class="title">example_subsys</span>[] =</span> &#123;</span><br><span class="line">	&amp;childless_subsys.subsys,</span><br><span class="line">	&amp;simple_children_subsys,</span><br><span class="line">	&amp;group_children_subsys,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">configfs_example_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> *<span class="title">subsys</span>;</span></span><br><span class="line">	<span class="type">int</span> ret, i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; example_subsys[i]; i++) &#123;</span><br><span class="line">		subsys = example_subsys[i];</span><br><span class="line"></span><br><span class="line">		config_group_init(&amp;subsys-&gt;su_group);</span><br><span class="line">		mutex_init(&amp;subsys-&gt;su_mutex);</span><br><span class="line">		ret = configfs_register_subsystem(subsys);</span><br><span class="line">		<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">			pr_err(<span class="string">&quot;Error %d while registering subsystem %s\n&quot;</span>,</span><br><span class="line">			       ret, subsys-&gt;su_group.cg_item.ci_namebuf);</span><br><span class="line">			<span class="keyword">goto</span> out_unregister;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out_unregister:</span><br><span class="line">	<span class="keyword">for</span> (i--; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">		configfs_unregister_subsystem(example_subsys[i]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">configfs_example_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; example_subsys[i]; i++)</span><br><span class="line">		configfs_unregister_subsystem(example_subsys[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(configfs_example_init);</span><br><span class="line">module_exit(configfs_example_exit);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="01-childless"><a href="#01-childless" class="headerlink" title="01-childless"></a>01-childless</h3><p>这个第一个例子是一个没有子项的子系统。它不能创建任何 <code>config_items</code>，只包含属性。</p>
<p>请注意，我们将 <code>configfs_subsystem</code> 封装在一个容器中。如果子系统本身没有直接的属性，这并不是必须的。可以参考下一个例子，02-simple-children，来了解这种子系统。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 01-childless</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This first example is a childless subsystem.  It cannot create</span></span><br><span class="line"><span class="comment"> * any config_items.  It just has attributes.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that we are enclosing the configfs_subsystem inside a container.</span></span><br><span class="line"><span class="comment"> * This is not necessary if a subsystem has no attributes directly</span></span><br><span class="line"><span class="comment"> * on the subsystem.  See the next example, 02-simple-children, for</span></span><br><span class="line"><span class="comment"> * such a subsystem.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">childless</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> <span class="title">subsys</span>;</span></span><br><span class="line">	<span class="type">int</span> showme;</span><br><span class="line">	<span class="type">int</span> storeme;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> childless *<span class="title function_">to_childless</span><span class="params">(<span class="keyword">struct</span> config_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> container_of(to_configfs_subsystem(to_config_group(item)),</span><br><span class="line">			    <span class="keyword">struct</span> childless, subsys);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">childless_showme_show</span><span class="params">(<span class="keyword">struct</span> config_item *item, <span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">childless</span> *<span class="title">childless</span> =</span> to_childless(item);</span><br><span class="line">	<span class="type">ssize_t</span> pos;</span><br><span class="line"></span><br><span class="line">	pos = <span class="built_in">sprintf</span>(page, <span class="string">&quot;%d\n&quot;</span>, childless-&gt;showme);</span><br><span class="line">	childless-&gt;showme++;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">childless_storeme_show</span><span class="params">(<span class="keyword">struct</span> config_item *item, <span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(page, <span class="string">&quot;%d\n&quot;</span>, to_childless(item)-&gt;storeme);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">childless_storeme_store</span><span class="params">(<span class="keyword">struct</span> config_item *item,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="type">char</span> *page, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">childless</span> *<span class="title">childless</span> =</span> to_childless(item);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = kstrtoint(page, <span class="number">10</span>, &amp;childless-&gt;storeme);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">childless_description_show</span><span class="params">(<span class="keyword">struct</span> config_item *item, <span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(page,</span><br><span class="line"><span class="string">&quot;[01-childless]\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;The childless subsystem is the simplest possible subsystem in\n&quot;</span></span><br><span class="line"><span class="string">&quot;configfs.  It does not support the creation of child config_items.\n&quot;</span></span><br><span class="line"><span class="string">&quot;It only has a few attributes.  In fact, it isn&#x27;t much different\n&quot;</span></span><br><span class="line"><span class="string">&quot;than a directory in /proc.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* https://elixir.bootlin.com/linux/v5.10.186/source/include/linux/configfs.h#L134</span></span><br><span class="line"><span class="comment">#define CONFIGFS_ATTR(_pfx, _name)			\</span></span><br><span class="line"><span class="comment">static struct configfs_attribute _pfx##attr_##_name = &#123;	\</span></span><br><span class="line"><span class="comment">	.ca_name	= __stringify(_name),		\</span></span><br><span class="line"><span class="comment">	.ca_mode	= S_IRUGO | S_IWUSR,		\</span></span><br><span class="line"><span class="comment">	.ca_owner	= THIS_MODULE,			\</span></span><br><span class="line"><span class="comment">	.show		= _pfx##_name##_show,		\</span></span><br><span class="line"><span class="comment">	.store		= _pfx##_name##_store,		\</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define CONFIGFS_ATTR_RO(_pfx, _name)			\</span></span><br><span class="line"><span class="comment">static struct configfs_attribute _pfx##attr_##_name = &#123;	\</span></span><br><span class="line"><span class="comment">	.ca_name	= __stringify(_name),		\</span></span><br><span class="line"><span class="comment">	.ca_mode	= S_IRUGO,			\</span></span><br><span class="line"><span class="comment">	.ca_owner	= THIS_MODULE,			\</span></span><br><span class="line"><span class="comment">	.show		= _pfx##_name##_show,		\</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#define CONFIGFS_ATTR_WO(_pfx, _name)			\</span></span><br><span class="line"><span class="comment">static struct configfs_attribute _pfx##attr_##_name = &#123;	\</span></span><br><span class="line"><span class="comment">	.ca_name	= __stringify(_name),		\</span></span><br><span class="line"><span class="comment">	.ca_mode	= S_IWUSR,			\</span></span><br><span class="line"><span class="comment">	.ca_owner	= THIS_MODULE,			\</span></span><br><span class="line"><span class="comment">	.store		= _pfx##_name##_store,		\</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当项目出现在 configfs 中时，属性文件将以 configfs_attribute-&gt;ca_name 文件名出现。</span></span><br><span class="line"><span class="comment">// configfs_attribute-&gt;ca_mode 指定文件权限。</span></span><br><span class="line"><span class="comment">// ✨✨✨ 注意这里宏中，指定了 .show/.store 对应的处理函数。</span></span><br><span class="line">CONFIGFS_ATTR_RO(childless_, showme);</span><br><span class="line">CONFIGFS_ATTR(childless_, storeme);</span><br><span class="line">CONFIGFS_ATTR_RO(childless_, description);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[root@milkv-duo]/tmp/usb/01-childless# ls -lh</span></span><br><span class="line"><span class="comment">total 0</span></span><br><span class="line"><span class="comment">-r--r--r-- 1 root root 4.0K Jan  1 05:15 description</span></span><br><span class="line"><span class="comment">-r--r--r-- 1 root root 4.0K Jan  1 05:15 showme</span></span><br><span class="line"><span class="comment">-rw-r--r-- 1 root root 4.0K Jan  1 05:15 storeme</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当 config_item 希望某个属性作为文件出现在其 configfs 目录中时，</span></span><br><span class="line"><span class="comment">// 它必须定义一个描述该属性的 configfs_attribute。然后它将该属性添加到</span></span><br><span class="line"><span class="comment">// config_item_type-&gt;ct_attrs 的以 NULL 结尾的数组中。</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span> *<span class="title">childless_attrs</span>[] =</span> &#123;</span><br><span class="line">	&amp;childless_attr_showme,</span><br><span class="line">	&amp;childless_attr_storeme,</span><br><span class="line">	&amp;childless_attr_description,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> <span class="title">childless_type</span> =</span> &#123;</span><br><span class="line">	.ct_attrs	= childless_attrs,</span><br><span class="line">	.ct_owner	= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">childless</span> <span class="title">childless_subsys</span> =</span> &#123;</span><br><span class="line">	.subsys = &#123;</span><br><span class="line">		.su_group = &#123;</span><br><span class="line">			.cg_item = &#123;</span><br><span class="line">				.ci_namebuf = <span class="string">&quot;01-childless&quot;</span>,</span><br><span class="line">				<span class="comment">// config_item_type 的最基本功能是定义可以对 config_item 执行的操作</span></span><br><span class="line">				.ci_type = &amp;childless_type,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>倒着看代码，注意配合看前面的介绍。属性基本只有 <code>show/store</code> 两种操作，对应读写，可通过 <code>echo/cat</code> 测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">[root@milkv-duo]/tmp/usb<span class="comment"># ls</span></span><br><span class="line">01-childless  02-simple-children  03-group-children  usb_gadget</span><br><span class="line">[root@milkv-duo]/tmp/usb<span class="comment"># cd 01-childless/</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># ls -lh</span></span><br><span class="line">total 0</span><br><span class="line">-r--r--r-- 1 root root 4.0K Jan  1 05:15 description</span><br><span class="line">-r--r--r-- 1 root root 4.0K Jan  1 05:15 showme</span><br><span class="line">-rw-r--r-- 1 root root 4.0K Jan  1 05:15 storeme</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">0</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">1</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">2</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">3</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">4</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat storeme</span></span><br><span class="line">0</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat storeme</span></span><br><span class="line">0</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat description</span></span><br><span class="line">[01-childless]</span><br><span class="line"></span><br><span class="line">The childless subsystem is the simplest possible subsystem <span class="keyword">in</span></span><br><span class="line">configfs.  It does not support the creation of child config_items.</span><br><span class="line">It only has a few attributes.  In fact, it isn<span class="string">&#x27;t much different</span></span><br><span class="line"><span class="string">than a directory in /proc.</span></span><br><span class="line"><span class="string">[root@milkv-duo]/tmp/usb/01-childless# echo 0 &gt; showme</span></span><br><span class="line"><span class="string">-sh: can&#x27;</span>t create showme: Permission denied</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat showme</span></span><br><span class="line">5</span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># echo 3 &gt; storeme</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/01-childless<span class="comment"># cat storeme</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="02-simple-children"><a href="#02-simple-children" class="headerlink" title="02-simple-children"></a>02-simple-children</h3><p>这个例子仅包含一个简单的、带有单一属性的子项。注意，这里没有额外的属性结构，因为子项的属性一开始就是已知的。此外，子系统没有容器，因为它自身没有任何属性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 02-simple-children</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This example merely has a simple one-attribute child.  Note that</span></span><br><span class="line"><span class="comment"> * there is no extra attribute structure, as the child&#x27;s attribute is</span></span><br><span class="line"><span class="comment"> * known from the get-go.  Also, there is no container for the</span></span><br><span class="line"><span class="comment"> * subsystem, as it has no attributes of its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simple_child</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">config_item</span> <span class="title">item</span>;</span></span><br><span class="line">	<span class="type">int</span> storeme;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> simple_child *<span class="title function_">to_simple_child</span><span class="params">(<span class="keyword">struct</span> config_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> container_of(item, <span class="keyword">struct</span> simple_child, item);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">simple_child_storeme_show</span><span class="params">(<span class="keyword">struct</span> config_item *item, <span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(page, <span class="string">&quot;%d\n&quot;</span>, to_simple_child(item)-&gt;storeme);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">simple_child_storeme_store</span><span class="params">(<span class="keyword">struct</span> config_item *item,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="type">char</span> *page, <span class="type">size_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">simple_child</span> *<span class="title">simple_child</span> =</span> to_simple_child(item);</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	ret = kstrtoint(page, <span class="number">10</span>, &amp;simple_child-&gt;storeme);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONFIGFS_ATTR(simple_child_, storeme);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span> *<span class="title">simple_child_attrs</span>[] =</span> &#123;</span><br><span class="line">	&amp;simple_child_attr_storeme,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">simple_child_release</span><span class="params">(<span class="keyword">struct</span> config_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">	kfree(to_simple_child(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_item_operations</span> <span class="title">simple_child_item_ops</span> =</span> &#123;</span><br><span class="line">	.release	= simple_child_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> <span class="title">simple_child_type</span> =</span> &#123;</span><br><span class="line">	.ct_item_ops	= &amp;simple_child_item_ops,</span><br><span class="line">	.ct_attrs	= simple_child_attrs,</span><br><span class="line">	.ct_owner	= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">simple_children</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">config_group</span> <span class="title">group</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> simple_children *<span class="title function_">to_simple_children</span><span class="params">(<span class="keyword">struct</span> config_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> container_of(to_config_group(item),</span><br><span class="line">			    <span class="keyword">struct</span> simple_children, group);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> config_item *<span class="title function_">simple_children_make_item</span><span class="params">(<span class="keyword">struct</span> config_group *group,</span></span><br><span class="line"><span class="params">		<span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">simple_child</span> *<span class="title">simple_child</span>;</span></span><br><span class="line"></span><br><span class="line">	simple_child = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> simple_child), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!simple_child)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	config_item_init_type_name(&amp;simple_child-&gt;item, name,</span><br><span class="line">				   &amp;simple_child_type);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;simple_child-&gt;item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">simple_children_description_show</span><span class="params">(<span class="keyword">struct</span> config_item *item,</span></span><br><span class="line"><span class="params">		<span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(page,</span><br><span class="line"><span class="string">&quot;[02-simple-children]\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;This subsystem allows the creation of child config_items.  These\n&quot;</span></span><br><span class="line"><span class="string">&quot;items have only one attribute that is readable and writeable.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONFIGFS_ATTR_RO(simple_children_, description);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span> *<span class="title">simple_children_attrs</span>[] =</span> &#123;</span><br><span class="line">	&amp;simple_children_attr_description,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">simple_children_release</span><span class="params">(<span class="keyword">struct</span> config_item *item)</span></span><br><span class="line">&#123;</span><br><span class="line">	kfree(to_simple_children(item));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_item_operations</span> <span class="title">simple_children_item_ops</span> =</span> &#123;</span><br><span class="line">	.release	= simple_children_release,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note that, since no extra work is required on -&gt;drop_item(),</span></span><br><span class="line"><span class="comment"> * no -&gt;drop_item() is provided.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 如果组提供了 ct_group_ops-&gt;make_item() 方法，则通过 mkdir(2) 在组的目录中调用该方法创建子项。</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_group_operations</span> <span class="title">simple_children_group_ops</span> =</span> &#123;</span><br><span class="line">	.make_item	= simple_children_make_item,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> <span class="title">simple_children_type</span> =</span> &#123;</span><br><span class="line">	.ct_item_ops	= &amp;simple_children_item_ops,</span><br><span class="line">	.ct_group_ops	= &amp;simple_children_group_ops,</span><br><span class="line">	.ct_attrs	= simple_children_attrs,</span><br><span class="line">	.ct_owner	= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> <span class="title">simple_children_subsys</span> =</span> &#123;</span><br><span class="line">	.su_group = &#123;</span><br><span class="line">		.cg_item = &#123;</span><br><span class="line">			.ci_namebuf = <span class="string">&quot;02-simple-children&quot;</span>,</span><br><span class="line">			.ci_type = &amp;simple_children_type,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="#struct-config_group">config_group 结构包含一个 config_item。适当配置该项意味着 group 可以作为自己的项目发挥作用。不过，它可以做更多：它可以创建子项目或子组。这是通过在组的 config_item_type 上指定的组操作来实现的。</a></p>
<p>这个例子，可以通过 mkdir 创建子项，子项有一个可读写的 storeme 属性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># cat description</span></span><br><span class="line">[02-simple-children]</span><br><span class="line"></span><br><span class="line">This subsystem allows the creation of child config_items.  These</span><br><span class="line">items have only one attribute that is readable and writeable.</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># mkdir test01</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># tree .</span></span><br><span class="line">.</span><br><span class="line">├── description</span><br><span class="line">└── test01</span><br><span class="line">    └── storeme</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># echo xxx &gt; test01/storeme</span></span><br><span class="line">sh: write error: Invalid argument</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># echo 30 &gt; test01/storeme</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># cat test01/storeme</span></span><br><span class="line">30</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># mkdir test02</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># mkdir test03</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># tree .</span></span><br><span class="line">.</span><br><span class="line">├── description</span><br><span class="line">├── test01</span><br><span class="line">│   └── storeme</span><br><span class="line">├── test02</span><br><span class="line">│   └── storeme</span><br><span class="line">└── test03</span><br><span class="line">    └── storeme</span><br><span class="line"></span><br><span class="line">3 directories, 4 files</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># cat test02/storeme</span></span><br><span class="line">0</span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># rmdir test03</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/02-simple-children<span class="comment"># ls</span></span><br><span class="line">description  test01  test02</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="03-group-children"><a href="#03-group-children" class="headerlink" title="03-group-children"></a>03-group-children</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 03-group-children</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This example reuses the simple_children group from above.  However,</span></span><br><span class="line"><span class="comment"> * the simple_children group is not the subsystem itself, it is a</span></span><br><span class="line"><span class="comment"> * child of the subsystem.  Creation of a group in the subsystem creates</span></span><br><span class="line"><span class="comment"> * a new simple_children group.  That group can then have simple_child</span></span><br><span class="line"><span class="comment"> * children of its own.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">struct</span> config_group *<span class="title function_">group_children_make_group</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> config_group *group, <span class="type">const</span> <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">simple_children</span> *<span class="title">simple_children</span>;</span></span><br><span class="line"></span><br><span class="line">	simple_children = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> simple_children),</span><br><span class="line">				  GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!simple_children)</span><br><span class="line">		<span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line"></span><br><span class="line">	config_group_init_type_name(&amp;simple_children-&gt;group, name,</span><br><span class="line">				    &amp;simple_children_type);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;simple_children-&gt;group;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">group_children_description_show</span><span class="params">(<span class="keyword">struct</span> config_item *item,</span></span><br><span class="line"><span class="params">		<span class="type">char</span> *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">sprintf</span>(page,</span><br><span class="line"><span class="string">&quot;[03-group-children]\n&quot;</span></span><br><span class="line"><span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="string">&quot;This subsystem allows the creation of child config_groups.  These\n&quot;</span></span><br><span class="line"><span class="string">&quot;groups are like the subsystem simple-children.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONFIGFS_ATTR_RO(group_children_, description);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_attribute</span> *<span class="title">group_children_attrs</span>[] =</span> &#123;</span><br><span class="line">	&amp;group_children_attr_description,</span><br><span class="line">	<span class="literal">NULL</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note that, since no extra work is required on -&gt;drop_item(),</span></span><br><span class="line"><span class="comment"> * no -&gt;drop_item() is provided.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_group_operations</span> <span class="title">group_children_group_ops</span> =</span> &#123;</span><br><span class="line">	.make_group	= group_children_make_group,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_item_type</span> <span class="title">group_children_type</span> =</span> &#123;</span><br><span class="line">	.ct_group_ops	= &amp;group_children_group_ops,</span><br><span class="line">	.ct_attrs	= group_children_attrs,</span><br><span class="line">	.ct_owner	= THIS_MODULE,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">configfs_subsystem</span> <span class="title">group_children_subsys</span> =</span> &#123;</span><br><span class="line">	.su_group = &#123;</span><br><span class="line">		.cg_item = &#123;</span><br><span class="line">			.ci_namebuf = <span class="string">&quot;03-group-children&quot;</span>,</span><br><span class="line">			.ci_type = &amp;group_children_type,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="#sturct-config_group">如果子系统希望子项本身也是一个组，则子系统会提供 <code>ct_group_ops-&gt;make_group()</code> 方法。</a></p>
<p>这个例子中，可以通过 mkdir 去创建 group。</p>
<blockquote>
<p>❓❓一个问题：如果 <code>ct_group_ops</code> 中同时指定了 <code>make_group</code> 和 <code>make_item</code> ，那么调用 <code>mkdir</code> 时是执行哪一个呢？可以从源码中找答案：<a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.186/source/fs/configfs">https://elixir.bootlin.com/linux/v5.10.186/source/fs/configfs</a>  <code>configfs</code> 的实现看起来有点简单，代码量并不大。</p>
<p><a target="_blank" rel="noopener" href="https://elixir.bootlin.com/linux/v5.10.186/source/fs/configfs/dir.c#L1353">https://elixir.bootlin.com/linux/v5.10.186/source/fs/configfs/dir.c#L1353</a> 在 configfs_mkdir() 中，<code>make_group</code> 优先调用。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># cat description</span></span><br><span class="line">[03-group-children]</span><br><span class="line"></span><br><span class="line">This subsystem allows the creation of child config_groups.  These</span><br><span class="line"><span class="built_in">groups</span> are like the subsystem simple-children.</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># mkdir grp1</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># tree .</span></span><br><span class="line">.</span><br><span class="line">├── description</span><br><span class="line">└── grp1</span><br><span class="line">    └── description</span><br><span class="line"></span><br><span class="line">1 directory, 2 files</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># cat grp1/description</span></span><br><span class="line">[02-simple-children]</span><br><span class="line"></span><br><span class="line">This subsystem allows the creation of child config_items.  These</span><br><span class="line">items have only one attribute that is readable and writeable.</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># mkdir grp1/item1</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># mkdir grp1/item2</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># tree .</span></span><br><span class="line">.</span><br><span class="line">├── description</span><br><span class="line">└── grp1</span><br><span class="line">    ├── description</span><br><span class="line">    ├── item1</span><br><span class="line">    │   └── storeme</span><br><span class="line">    └── item2</span><br><span class="line">        └── storeme</span><br><span class="line"></span><br><span class="line">3 directories, 4 files</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># rmdir grp1</span></span><br><span class="line"><span class="built_in">rmdir</span>: failed to remove <span class="string">&#x27;grp1&#x27;</span>: Directory not empty</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># cd grp1/</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children/grp1<span class="comment"># rmdir item1</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children/grp1<span class="comment"># rmdir item2</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children/grp1<span class="comment"># cd ..</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># rmdir grp1</span></span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment"># ls</span></span><br><span class="line">description</span><br><span class="line">[root@milkv-duo]/tmp/usb/03-group-children<span class="comment">#</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="层次结构导航和子系统互斥锁"><a href="#层次结构导航和子系统互斥锁" class="headerlink" title="层次结构导航和子系统互斥锁"></a>层次结构导航和子系统互斥锁</h2><p><code>configfs</code> 提供了一个额外的好处。由于 <code>config_groups</code> 和 <code>config_items</code> 出现在文件系统中，因此它们被排列成层次结构。子系统<strong>永远</strong>不应触及文件系统部分，但子系统可能对该层次结构感兴趣。为此，层次结构通过 <code>config_group-&gt;cg_children</code> 和 <code>config_item-&gt;ci_parent</code> 结构成员进行镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Hierarchy Navigation and the Subsystem Mutex]</span><br><span class="line"></span><br><span class="line">There is an extra bonus that configfs provides. The config_groups and</span><br><span class="line">config_items are arranged in a hierarchy due to the fact that they</span><br><span class="line">appear in a filesystem. A subsystem is NEVER to touch the filesystem</span><br><span class="line">parts, but the subsystem might be interested in this hierarchy. For</span><br><span class="line">this reason, the hierarchy is mirrored via the config_group-&gt;cg_children</span><br><span class="line">and config_item-&gt;ci_parent structure members.</span><br></pre></td></tr></table></figure>

<p>子系统可以在保护子系统互斥锁的情况下导航 <code>cg_children</code> 列表和 <code>ci_parent</code> 指针，以查看由子系统创建的树。这可能会与 <code>configfs</code> 对层次结构的管理产生竞争，因此 <code>configfs</code> 使用子系统互斥锁来保护修改。每当子系统想要导航层次结构时，必须在子系统互斥锁的保护下进行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A subsystem can navigate the cg_children list and the ci_parent pointer</span><br><span class="line">to see the tree created by the subsystem. This can race with configfs&#x27;</span><br><span class="line">management of the hierarchy, so configfs uses the subsystem mutex to</span><br><span class="line">protect modifications. Whenever a subsystem wants to navigate the</span><br><span class="line">hierarchy, it must do so under the protection of the subsystem</span><br><span class="line">mutex.</span><br></pre></td></tr></table></figure>

<p>只要新分配的项尚未链接到层次结构中，子系统将无法获取互斥锁。同样，只要正在删除的项尚未从层次结构中解除链接，它将无法获取互斥锁。这意味着只要该项在 <code>configfs</code> 中，其 <code>ci_parent</code> 指针就永远不会为 NULL，并且该项在其父项的 <code>cg_children</code> 列表中存在的时间也是</p>
<p>相同的。这使子系统在持有互斥锁时可以信任 <code>ci_parent</code> 和 <code>cg_children</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A subsystem will be prevented from acquiring the mutex while a newly</span><br><span class="line">allocated item has not been linked into this hierarchy. Similarly, it</span><br><span class="line">will not be able to acquire the mutex while a dropping item has not</span><br><span class="line">yet been unlinked. This means that an item&#x27;s ci_parent pointer will</span><br><span class="line">never be NULL while the item is in configfs, and that an item will only</span><br><span class="line">be in its parent&#x27;s cg_children list for the same duration. This allows</span><br><span class="line">a subsystem to trust ci_parent and cg_children while they hold the</span><br><span class="line">mutex.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="通过-symlink-2-实现项的聚合"><a href="#通过-symlink-2-实现项的聚合" class="headerlink" title="通过 symlink(2) 实现项的聚合"></a>通过 <code>symlink(2)</code> 实现项的聚合</h2><p><code>configfs</code> 通过 <code>group-&gt;item</code> 的父&#x2F;子关系提供了一个简单的分组。然而，在更大的环境中，通常需要超出父&#x2F;子连接的聚合。这可以通过 <code>symlink(2)</code> 实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Item Aggregation Via symlink(2)]</span><br><span class="line"></span><br><span class="line">configfs provides a simple group via the group-&gt;item parent/child</span><br><span class="line">relationship. Often, however, a larger environment requires aggregation</span><br><span class="line">outside of the parent/child connection. This is implemented via</span><br><span class="line">symlink(2).</span><br></pre></td></tr></table></figure>

<p><code>config_item</code> 可以提供 <code>ct_item_ops-&gt;allow_link()</code> 和 <code>ct_item_ops-&gt;drop_link()</code> 方法。如果存在 <code>-&gt;allow_link()</code> 方法，可以将 <code>symlink(2)</code> 调用配置项作为链接的源。链接只允许在 <code>configfs</code> 的 <code>config_items</code> 之间进行。任何在 <code>configfs</code> 文件系统之外的 <code>symlink(2)</code> 尝试都将被拒绝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A config_item may provide the ct_item_ops-&gt;allow_link() and</span><br><span class="line">ct_item_ops-&gt;drop_link() methods. If the -&gt;allow_link() method exists,</span><br><span class="line">symlink(2) may be called with the config_item as the source of the link.</span><br><span class="line">These links are only allowed between configfs config_items. Any</span><br><span class="line">symlink(2) attempt outside the configfs filesystem will be denied.</span><br></pre></td></tr></table></figure>

<p>当调用 <code>symlink(2)</code> 时，源 <code>config_item</code> 的 <code>-&gt;allow_link()</code> 方法将与自身和目标项一起调用。如果源项允许链接到目标项，它将返回 0。源项可能希望拒绝链接，如果它只希望链接到某一类对象（例如，只能链接到自己的子系统中的对象）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">When symlink(2) is called, the source config_item&#x27;s -&gt;allow_link()</span><br><span class="line">method is called with itself and a target item. If the source item</span><br><span class="line">allows linking to target item, it returns 0. A source item may wish to</span><br><span class="line">reject a link if it only wants links to a certain type of object (say,</span><br><span class="line">in its own subsystem).</span><br></pre></td></tr></table></figure>

<p>当在符号链接上调用 <code>unlink(2)</code> 时，源项将通过 <code>-&gt;drop_link()</code> 方法收到通知。与 <code>-&gt;drop_item()</code> 方法一样，这是一个 <code>void</code> 函数，不能返回失败。子系统负责对更改作出响应。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">When unlink(2) is called on the symbolic link, the source item is</span><br><span class="line">notified via the -&gt;drop_link() method. Like the -&gt;drop_item() method,</span><br><span class="line">this is a void function and cannot return failure. The subsystem is</span><br><span class="line">responsible for responding to the change.</span><br></pre></td></tr></table></figure>

<p>只要链接到其他项，或其他项链接到它，就无法移除 <code>config_item</code>。<code>configfs</code> 不允许出现悬空的符号链接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A config_item cannot be removed while it links to any other item, nor</span><br><span class="line">can it be removed while an item links to it. Dangling symlinks are not</span><br><span class="line">allowed in configfs.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="自动创建的子组"><a href="#自动创建的子组" class="headerlink" title="自动创建的子组"></a>自动创建的子组</h2><p>一个新的 <code>config_group</code> 可能希望拥有两种类型的子 <code>config_items</code>。虽然这可以通过 <code>-&gt;make_item()</code> 方法中的“魔法名称”实现，但通过一种用户空间可以看到这种分歧的方法更加明确。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[Automatically Created Subgroups]</span><br><span class="line"></span><br><span class="line">A new config_group may want to have two types of child config_items.</span><br><span class="line">While this could be codified by magic names in -&gt;make_item(), it is much</span><br><span class="line">more explicit to have a method whereby userspace sees this divergence.</span><br></pre></td></tr></table></figure>

<p>与其拥有一个行为不同的项，不如让 <code>configfs</code> 提供一种方法，即在创建父组时，自动在父组中创建一个或多个子组。因此，<code>mkdir(&quot;parent&quot;)</code> 结果是 <code>&quot;parent&quot;</code>，<code>&quot;parent/subgroup1&quot;</code>，依次到 <code>&quot;parent/subgroupN&quot;</code>。类型 1 的项现在可以在 <code>&quot;parent/subgroup1&quot;</code> 中创建，类型 N 的项可以在 <code>&quot;parent/subgroupN&quot;</code> 中创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rather than have a group where some items behave differently than</span><br><span class="line">others, configfs provides a method whereby one or many subgroups are</span><br><span class="line">automatically created inside the parent at its creation. Thus,</span><br><span class="line">mkdir(&quot;parent&quot;) results in &quot;parent&quot;, &quot;parent/subgroup1&quot;, up through</span><br><span class="line">&quot;parent/subgroupN&quot;. Items of type 1 can now be created in</span><br><span class="line">&quot;parent/subgroup1&quot;, and items of type N can be created in</span><br><span class="line">&quot;parent/subgroupN&quot;.</span><br></pre></td></tr></table></figure>

<p>这些自动子组（或默认组）不会排除父组的其他子项。如果存在 <code>ct_group_ops-&gt;make_group()</code> 方法，可以直接在父组中创建其他子组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">These automatic subgroups, or default groups, do not preclude other</span><br><span class="line">children of the parent group. If ct_group_ops-&gt;make_group() exists,</span><br><span class="line">other child groups can be created on the parent group directly.</span><br></pre></td></tr></table></figure>

<p><code>configfs</code> 子系统通过使用 <code>configfs_add_default_group()</code> 函数将它们添加到父 <code>config_group</code> 结构中来指定默认组。每个添加的组将在父组创建时同时填充到 <code>configfs</code> 树中。类似地，它们将在父组移除时一起被删除。没有额外的通知。当 <code>-&gt;drop_item()</code> 方法通知子系统父组正在消失时，这也意味着与该父组关联的每个默认组子项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A configfs subsystem specifies default groups by adding them using the</span><br><span class="line">configfs_add_default_group() function to the parent config_group</span><br><span class="line">structure. Each added group is populated in the configfs tree at the same</span><br><span class="line">time as the parent group. Similarly, they are removed at the same time</span><br><span class="line">as the parent. No extra notification is provided. When a -&gt;drop_item()</span><br><span class="line">method call notifies the subsystem the parent group is going away, it</span><br><span class="line">also means every default group child associated with that parent group.</span><br></pre></td></tr></table></figure>

<p>因此，默认组不能直接通过 <code>rmdir(2)</code> 删除。在父组上执行 <code>rmdir(2)</code> 时，它们也不会被视为子项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">As a consequence of this, default groups cannot be removed directly via</span><br><span class="line">rmdir(2). They also are not considered when rmdir(2) on the parent</span><br><span class="line">group is checking for children.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="依赖子系统"><a href="#依赖子系统" class="headerlink" title="依赖子系统"></a>依赖子系统</h2><p>有时其他驱动程序依赖于特定的 <code>configfs</code> 项。例如，<code>ocfs2</code> 挂载依赖于心跳区域项。如果该区域项通过 <code>rmdir(2)</code> 被移除，<code>ocfs2</code> 挂载必须 <code>BUG</code> 或切换到只读模式。这并不理想。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Dependent Subsystems]</span><br><span class="line"></span><br><span class="line">Sometimes other drivers depend on particular configfs items. For</span><br><span class="line">example, ocfs2 mounts depend on a heartbeat region item. If that</span><br><span class="line">region item is removed with rmdir(2), the ocfs2 mount must BUG or go</span><br><span class="line">readonly. Not happy.</span><br></pre></td></tr></table></figure>

<p><code>configfs</code> 提供了两个额外的 API 调用：<code>configfs_depend_item()</code> 和 <code>configfs_undepend_item()</code>。客户端驱动程序可以调用 <code>configfs_depend_item()</code> 来告知 <code>configfs</code> 它依赖某个现有项。之后，<code>configfs</code> 将在 <code>rmdir(2)</code> 调用时返回 <code>-EBUSY</code> 错误。当该项不再被依赖时，客户端驱动程序调用 <code>configfs_undepend_item()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">configfs provides two additional API calls: configfs_depend_item() and</span><br><span class="line">configfs_undepend_item(). A client driver can call</span><br><span class="line">configfs_depend_item() on an existing item to tell configfs that it is</span><br><span class="line">depended on. configfs will then return -EBUSY from rmdir(2) for that</span><br><span class="line">item. When the item is no longer depended on, the client driver calls</span><br><span class="line">configfs_undepend_item() on it.</span><br></pre></td></tr></table></figure>

<p>这些 API 不能在任何 <code>configfs</code> 回调中调用，因为它们会产生冲突。它们可能会阻塞和分配内存。客户端驱动程序可能不应自行调用它们，而应该提供供外部子系统调用的 API。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">These API cannot be called underneath any configfs callbacks, as</span><br><span class="line">they will conflict. They can block and allocate. A client driver</span><br><span class="line">probably shouldn&#x27;t calling them of its own gumption. Rather it should</span><br><span class="line">be providing an API that external subsystems call.</span><br></pre></td></tr></table></figure>

<p>这个过程如何工作？想象一下 <code>ocfs2</code> 的挂载过程。当它挂载时，它请求一个心跳区域项。这是通过调用心跳代码来实现的。在心跳代码中，查找区域项。在这里，心跳代码调用 <code>configfs_depend_item()</code>。如果调用成功，心跳知道该区域是安全的，可以分配给 <code>ocfs2</code>。如果失败，则表示该区域正在被拆除，心跳代码可以优雅地返回一个错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">How does this work? Imagine the ocfs2 mount process. When it mounts,</span><br><span class="line">it asks for a heartbeat region item. This is done via a call into the</span><br><span class="line">heartbeat code. Inside the heartbeat code, the region item is looked</span><br><span class="line">up. Here, the heartbeat code calls configfs_depend_item(). If it</span><br><span class="line">succeeds, then heartbeat knows the region is safe to give to ocfs2.</span><br><span class="line">If it fails, it was being torn down anyway, and</span><br><span class="line"></span><br><span class="line"> heartbeat can gracefully</span><br><span class="line">pass up an error.</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="可提交项"><a href="#可提交项" class="headerlink" title="可提交项"></a>可提交项</h2><p>注意：可提交项当前未实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Committable Items]</span><br><span class="line"></span><br><span class="line">NOTE: Committable items are currently unimplemented.</span><br></pre></td></tr></table></figure>

<p>某些 <code>config_items</code> 无法拥有有效的初始状态。也就是说，无法为项目的属性指定默认值，以使项目能够执行其工作。用户空间必须配置一个或多个属性，之后子系统才能启动该项目所代表的实体。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Some config_items cannot have a valid initial state. That is, no</span><br><span class="line">default values can be specified for the item&#x27;s attributes such that the</span><br><span class="line">item can do its work. Userspace must configure one or more attributes,</span><br><span class="line">after which the subsystem can start whatever entity this item</span><br><span class="line">represents.</span><br></pre></td></tr></table></figure>

<p>考虑上面的 FakeNBD 设备。没有目标地址和目标设备，子系统无法知道要导入哪个块设备。简单示例假设子系统仅在所有属性都配置完成后连接。这确实可以工作，但现在每个属性存储都必须检查属性是否已初始化。一旦满足条件，每个属性存储都必须触发连接。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Consider the FakeNBD device from above. Without a target address *and*</span><br><span class="line">a target device, the subsystem has no idea what block device to import.</span><br><span class="line">The simple example assumes that the subsystem merely waits until all the</span><br><span class="line">appropriate attributes are configured, and then connects. This will,</span><br><span class="line">indeed, work, but now every attribute store must check if the attributes</span><br><span class="line">are initialized. Every attribute store must fire off the connection if</span><br><span class="line">that condition is met.</span><br></pre></td></tr></table></figure>

<p>更好的方式是使用一个明确的操作通知子系统 <code>config_item</code> 已准备好。更重要的是，明确的操作可以让子系统提供反馈，说明属性是否以合理的方式进行了初始化。<code>configfs</code> 通过可提交项提供了此功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Far better would be an explicit action notifying the subsystem that the</span><br><span class="line">config_item is ready to go. More importantly, an explicit action allows</span><br><span class="line">the subsystem to provide feedback as to whether the attributes are</span><br><span class="line">initialized in a way that makes sense. configfs provides this as</span><br><span class="line">committable items.</span><br></pre></td></tr></table></figure>

<p><code>configfs</code> 仍然仅使用正常的文件系统操作。通过 <code>rename(2)</code> 提交一个项。该项从可以修改的目录移动到不能修改的目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">configfs still uses only normal filesystem operations. An item is</span><br><span class="line">committed via rename(2). The item is moved from a directory where it</span><br><span class="line">can be modified to a directory where it cannot.</span><br></pre></td></tr></table></figure>

<p>任何提供 <code>ct_group_ops-&gt;commit_item()</code> 方法的组都拥有可提交的项。当该组出现在 <code>configfs</code> 中时，不能直接在组中使用 <code>mkdir(2)</code>。相反，该组将有两个子目录：“live”和“pending”。<code>live</code> 目录不支持 <code>mkdir(2)</code> 或 <code>rmdir(2)</code>。它只允许 <code>rename(2)</code>。<code>pending</code> 目录允许 <code>mkdir(2)</code> 和 <code>rmdir(2)</code>。一个项在 <code>pending</code> 目录中创建。其属性可以随意修改。用户空间通过将项重命名到 <code>live</code> 目录来提交该项。这时，子系统收到 <code>-&gt;commit_item()</code> 回调。如果所有必需属性都已填写，方法返回 0，项被移动到 <code>live</code> 目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Any group that provides the ct_group_ops-&gt;commit_item() method has</span><br><span class="line">committable items. When this group appears in configfs, mkdir(2) will</span><br><span class="line">not work directly in the group. Instead, the group will have two</span><br><span class="line">subdirectories: &quot;live&quot; and &quot;pending&quot;. The &quot;live&quot; directory does not</span><br><span class="line">support mkdir(2) or rmdir(2) either. It only allows rename(2). The</span><br><span class="line">&quot;pending&quot; directory does allow mkdir(2) and rmdir(2). An item is</span><br><span class="line">created in the &quot;pending&quot; directory. Its attributes can be modified at</span><br><span class="line">will. Userspace commits the item by renaming it into the &quot;live&quot;</span><br><span class="line">directory. At this point, the subsystem receives the -&gt;commit_item()</span><br><span class="line">callback. If all required attributes are filled to satisfaction, the</span><br><span class="line">method returns zero and the item is moved to the &quot;live&quot; directory.</span><br></pre></td></tr></table></figure>

<p>由于在 <code>live</code> 目录中无法使用 <code>rmdir(2)</code>，必须关闭或“取消提交”该项。同样，这可以通过 <code>rename(2)</code> 完成，这次是从 <code>live</code> 目录重命名回 <code>pending</code> 目录。子系统通过 <code>ct_group_ops-&gt;uncommit_object()</code> 方法收到通知。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">As rmdir(2) does not work in the &quot;live&quot; directory, an item must be</span><br><span class="line">shutdown, or &quot;uncommitted&quot;. Again, this is done via rename(2), this</span><br><span class="line">time from the &quot;live&quot; directory back to the &quot;pending&quot; one. The subsystem</span><br><span class="line">is notified by the ct_group_ops-&gt;uncommit_object() method.</span><br></pre></td></tr></table></figure>

<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yo-gurts.github.io">(ง'̀-'́)ง</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yo-gurts.github.io/2024/09/22/Linux-configfs/">https://yo-gurts.github.io/2024/09/22/Linux-configfs/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yo-gurts.github.io" target="_blank">(╯°□°）╯︵ ┻━┻ </a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux/">Linux</a><a class="post-meta__tags" href="/tags/configfs/">configfs</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/11/17/NGf2mpwasOYzVIA.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/09/17/Linux-USBmtp/" title="Linux USB mtp"><img class="cover" src="https://s2.loli.net/2022/11/17/NGf2mpwasOYzVIA.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux USB mtp</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/22/Linux-USBconfigfs/" title="Linux USB gadget_configfs"><img class="cover" src="https://s2.loli.net/2022/11/17/hF7KodYmE6iPWqg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux USB gadget_configfs</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/09/22/Linux-USBfunctionfs/" title="Linux USB functionfs"><img class="cover" src="https://s2.loli.net/2022/11/17/jypq1GDmIVfl8WM.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-22</div><div class="title">Linux USB functionfs</div></div></a></div><div><a href="/2024/09/22/Linux-USBconfigfs/" title="Linux USB gadget_configfs"><img class="cover" src="https://s2.loli.net/2022/11/17/hF7KodYmE6iPWqg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-22</div><div class="title">Linux USB gadget_configfs</div></div></a></div><div><a href="/2024/10/06/Cvitek-SDK%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/" title="Cvitek SDK 编译环境"><img class="cover" src="https://s2.loli.net/2022/11/17/9ZBEesyr14aJhPM.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-06</div><div class="title">Cvitek SDK 编译环境</div></div></a></div><div><a href="/2022/09/19/Cpp%E4%B8%89%E6%96%B9%E5%BA%93/" title="C++三方库"><img class="cover" src="https://s2.loli.net/2022/11/17/hF7KodYmE6iPWqg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-19</div><div class="title">C++三方库</div></div></a></div><div><a href="/2023/11/16/Cvitek-buildroot/" title="buildroot 打包 rootfs"><img class="cover" src="https://s2.loli.net/2022/11/17/UeWP8jCq6dJZSGD.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-11-16</div><div class="title">buildroot 打包 rootfs</div></div></a></div><div><a href="/2024/09/11/Cvitek-reboot/" title="Cvitek-busybox init&#x2F;reboot&#x2F;poweroff"><img class="cover" src="https://s2.loli.net/2022/11/17/NGf2mpwasOYzVIA.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-11</div><div class="title">Cvitek-busybox init&#x2F;reboot&#x2F;poweroff</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2024/09/17/3NdhvxIcPRVpufD.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">(ง'̀-'́)ง</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">9</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yo-gurts"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yo-gurts" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:yusong1117.u@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#configfs-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E9%A9%B1%E5%8A%A8%E7%9A%84%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E9%85%8D%E7%BD%AE"><span class="toc-number">1.</span> <span class="toc-text">configfs - 用户空间驱动的内核对象配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-configfs%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是 configfs？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-configfs"><span class="toc-number">3.</span> <span class="toc-text">使用 configfs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-FakeNBD-%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">4.</span> <span class="toc-text">配置 FakeNBD: 一个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-configfs-%E7%BC%96%E7%A0%81"><span class="toc-number">5.</span> <span class="toc-text">使用 configfs 编码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-config-item"><span class="toc-number">5.1.</span> <span class="toc-text">struct config_item</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-config-item-type"><span class="toc-number">5.2.</span> <span class="toc-text">struct config_item_type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-configfs-attribute"><span class="toc-number">5.3.</span> <span class="toc-text">struct configfs_attribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-configfs-bin-attribute"><span class="toc-number">5.4.</span> <span class="toc-text">struct configfs_bin_attribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-config-group"><span class="toc-number">5.5.</span> <span class="toc-text">struct config_group</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-configfs-subsystem"><span class="toc-number">5.6.</span> <span class="toc-text">struct configfs_subsystem</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.</span> <span class="toc-text">示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#00-init"><span class="toc-number">6.1.</span> <span class="toc-text">00-init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01-childless"><span class="toc-number">6.2.</span> <span class="toc-text">01-childless</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#02-simple-children"><span class="toc-number">6.3.</span> <span class="toc-text">02-simple-children</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#03-group-children"><span class="toc-number">6.4.</span> <span class="toc-text">03-group-children</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%AF%BC%E8%88%AA%E5%92%8C%E5%AD%90%E7%B3%BB%E7%BB%9F%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">7.</span> <span class="toc-text">层次结构导航和子系统互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-symlink-2-%E5%AE%9E%E7%8E%B0%E9%A1%B9%E7%9A%84%E8%81%9A%E5%90%88"><span class="toc-number">8.</span> <span class="toc-text">通过 symlink(2) 实现项的聚合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E7%9A%84%E5%AD%90%E7%BB%84"><span class="toc-number">9.</span> <span class="toc-text">自动创建的子组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">10.</span> <span class="toc-text">依赖子系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E6%8F%90%E4%BA%A4%E9%A1%B9"><span class="toc-number">11.</span> <span class="toc-text">可提交项</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/06/Cvitek-SDK%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/" title="Cvitek SDK 编译环境"><img src="https://s2.loli.net/2022/11/17/9ZBEesyr14aJhPM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Cvitek SDK 编译环境"/></a><div class="content"><a class="title" href="/2024/10/06/Cvitek-SDK%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83/" title="Cvitek SDK 编译环境">Cvitek SDK 编译环境</a><time datetime="2024-10-06T06:02:04.000Z" title="发表于 2024-10-06 14:02:04">2024-10-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/24/Linux-sysfs/" title="Linux sysfs"><img src="https://s2.loli.net/2022/11/17/hF7KodYmE6iPWqg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux sysfs"/></a><div class="content"><a class="title" href="/2024/09/24/Linux-sysfs/" title="Linux sysfs">Linux sysfs</a><time datetime="2024-09-24T14:37:59.000Z" title="发表于 2024-09-24 22:37:59">2024-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/22/Linux-USBfunctionfs/" title="Linux USB functionfs"><img src="https://s2.loli.net/2022/11/17/jypq1GDmIVfl8WM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux USB functionfs"/></a><div class="content"><a class="title" href="/2024/09/22/Linux-USBfunctionfs/" title="Linux USB functionfs">Linux USB functionfs</a><time datetime="2024-09-22T14:31:05.000Z" title="发表于 2024-09-22 22:31:05">2024-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/22/Linux-USBconfigfs/" title="Linux USB gadget_configfs"><img src="https://s2.loli.net/2022/11/17/hF7KodYmE6iPWqg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux USB gadget_configfs"/></a><div class="content"><a class="title" href="/2024/09/22/Linux-USBconfigfs/" title="Linux USB gadget_configfs">Linux USB gadget_configfs</a><time datetime="2024-09-22T13:44:30.000Z" title="发表于 2024-09-22 21:44:30">2024-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/22/Linux-configfs/" title="Linux configfs"><img src="https://s2.loli.net/2022/11/17/NGf2mpwasOYzVIA.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux configfs"/></a><div class="content"><a class="title" href="/2024/09/22/Linux-configfs/" title="Linux configfs">Linux configfs</a><time datetime="2024-09-22T02:37:42.000Z" title="发表于 2024-09-22 10:37:42">2024-09-22</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By (ง'̀-'́)ง</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initGitalk = () => {
    const gitalk = new Gitalk(Object.assign({
      clientID: 'b740056c42e9eadf273e',
      clientSecret: 'e5f185fa9a6e27927f7a2672469435c68a288c95',
      repo: 'Yo-gurts.github.io',
      owner: 'yo-gurts',
      admin: ['yo-gurts'],
      id: 'd90e2dd85dba328c8ba59c3dee8237a0',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async() => {
    if (typeof Gitalk === 'function') initGitalk()
    else {
      await getCSS('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.css')
      await getScript('https://cdn.jsdelivr.net/npm/gitalk@1.8.0/dist/gitalk.min.js')
      initGitalk()
    }
  }
  
  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>