<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>(╯°□°）╯︵ ┻━┻  - !</title><meta name="author" content="(ง'̀-'́)ง"><meta name="copyright" content="(ง'̀-'́)ง"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yo-gurts.github.io/page/2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":600},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '(╯°□°）╯︵ ┻━┻ ',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2024-09-24 23:55:52'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="google-site-verification" content="MP347_Nl-SqfnOi3FZSI69WSb8J_rk_jEsa3jL4ODCI" /><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2024/09/17/3NdhvxIcPRVpufD.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background: transparent"><nav id="nav"><span id="blog-info"><a href="/" title="(╯°□°）╯︵ ┻━┻ "><span class="site-name">(╯°□°）╯︵ ┻━┻ </span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">(╯°□°）╯︵ ┻━┻ </h1><div id="site-subtitle"><span id="subtitle"></span></div><div id="site_social_icons"><a class="social-icon" href="https://github.com/yo-gurts" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:yusong1117.u@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="post_cover left"><a href="/2022/09/19/Cpp%E4%B8%89%E6%96%B9%E5%BA%93/" title="C++三方库"><img class="post-bg" src="https://s2.loli.net/2022/11/17/Zm4kDRxypb5ez3q.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++三方库"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/09/19/Cpp%E4%B8%89%E6%96%B9%E5%BA%93/" title="C++三方库">C++三方库</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-09-19T13:57:30.000Z" title="发表于 2022-09-19 21:57:30">2022-09-19</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Redis/">Redis</a></span></div><div class="content">fmt格式化字符串，好像已经纳入C++20标准库，使用很方便！而且说是比printf还快~
12345678910git clone --depth=1 https://github.com/fmtlib/fmt.gitcd fmt/mkdir buildcd buildcmake ..make -jsudo make install# g++ test.cpp -o debug -lfmt


github 仓库，README中文档也较详细、使用简单
官方文档、有代码示例

fmtlog基于fmt的日志库，可以很方便的以fmt的方式格式化日志输出。
12345678git clone https://github.com/MengRao/fmtlog.gitcd fmtloggit submodule initgit submodule update./build.sh# g++ test.cpp -o debug -lfmt -lfmtlog-static # 好像只能使用静态库


官方仓库，也只有这里的README作为官方文档

spdlog同样支持fmt格式输出的日志库，相对 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/08/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="Linux网络编程-并发服务器"><img class="post-bg" src="https://s2.loli.net/2022/11/17/jypq1GDmIVfl8WM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux网络编程-并发服务器"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/08/02/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="Linux网络编程-并发服务器">Linux网络编程-并发服务器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-08-02T06:07:42.000Z" title="发表于 2022-08-02 14:07:42">2022-08-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/socket/">socket</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/select/">select</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/poll/">poll</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/epoll/">epoll</a></span></div><div class="content">前面socket中创建的server只有一个主线程，只能连接一个客户端。要实现可同时连接多个客户端，有几种方法：

为每一个连接创建一个子进程处理。
为每一个连接创建一个子线程处理。
单线程，但使用select, poll, epoll等 IO 复用算法。

多进程并发每产生一个连接时，就创建一个子进程去处理，父进程只负责监听以及回收子进程！
回收子进程不能放在父进程的循环逻辑中，一种办法是通过注册信号SIGCHLD捕捉函数，在信号处理函数中完成子进程回收。
1234567891011121314151617181. socket()             // 创建监听套接字 lfd2. bind()3. listen()4. while(1) &#123;    cfd = accept()      // 与客户端通信的 socket fd    pid = fork()        // 创建子进程    if (pid == 0) &#123;     // 子进程        close(lfd)      // 关闭用于建立连接的套接字 lfd        rea ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/07/30/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BD%91%E5%8D%A1%E6%94%B6%E5%8C%85/" title="Linux网络编程-网卡收包"><img class="post-bg" src="https://s2.loli.net/2022/11/17/UeWP8jCq6dJZSGD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux网络编程-网卡收包"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/30/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BD%91%E5%8D%A1%E6%94%B6%E5%8C%85/" title="Linux网络编程-网卡收包">Linux网络编程-网卡收包</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-30T01:43:08.000Z" title="发表于 2022-07-30 09:43:08">2022-07-30</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a></span></div><div class="content">在开始之前，我们先用一张图解释 linux 系统接收网络报文的过程。

首先网络报文通过物理网线发送到网卡，
网络驱动程序会把网络中的报文读出来放到 ring buffer 中，这个过程使用 DMA（Direct Memory Access），不需要 CPU 参与
内核从 ring buffer 中读取报文进行处理，执行 IP 和 TCP/UDP 层的逻辑，最后把报文放到应用程序的 socket buffer 中
应用程序从 socket buffer 中读取报文进行处理

注意图中的几个 buffer 缓冲区！

step1：网卡到ringbufferNIC 在接收到数据包之后，首先需要将数据同步到内核中，这中间的桥梁是 rx ring buffer。它是由 NIC 和驱动程序（内核）共享的一片区域，事实上，rx ring buffer 存储的并不是实际的 packet 数据，而是一个描述符，这个描述符指向了它真正的存储地址，具体流程如下：

驱动在内存中分配一片缓冲区用来接收数据包，叫做 sk_buffer；
将上述缓冲区的地址和大小（即接收描述符），加入到 rx ring buf ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/07/18/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/" title="OpenVSwitch-测试拓扑"><img class="post-bg" src="https://s2.loli.net/2022/11/17/9ZBEesyr14aJhPM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenVSwitch-测试拓扑"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/18/OpenVSwitch-%E6%B5%8B%E8%AF%95%E6%8B%93%E6%89%91/" title="OpenVSwitch-测试拓扑">OpenVSwitch-测试拓扑</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-18T02:57:20.000Z" title="发表于 2022-07-18 10:57:20">2022-07-18</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/OpenVSwitch/">OpenVSwitch</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/OpenVSwitch/">OpenVSwitch</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DPDK/">DPDK</a></span></div><div class="content">


topo1






topo2





topo3





topo4





topo5





topo1
1234567891011121314151617## 删除之前的配置文件rm /usr/local/etc/openvswitch/*rm /usr/local/var/run/openvswitch/*rm /usr/local/var/log/openvswitch/*ovs-ctl --no-ovs-vswitchd start --system-id=randomovs-vsctl --no-wait set Open_vSwitch . other_config:pmd-cpu-mask=0x02ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-socket-mem=&quot;1024&quot;ovs-vsctl --no-wait set Open_vSwitch . other_config:dpdk-init=trueovs-ctl --no-ovsdb-server -- ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/07/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" title="Linux网络编程-分析工具"><img class="post-bg" src="https://s2.loli.net/2022/11/17/jypq1GDmIVfl8WM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux网络编程-分析工具"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/07/17/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/" title="Linux网络编程-分析工具">Linux网络编程-分析工具</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-07-17T11:32:32.000Z" title="发表于 2022-07-17 19:32:32">2022-07-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a></span></div><div class="content">


名称
功能



dstat
查看各种系统资源的统计信息，可保存到文件！


iftop
display bandwidth usage on an interface by host. 可指定TCP&#x2F;UDP端口


ip
show &#x2F; manipulate routing, network devices, interfaces and tunnels


ip link



ip route



iptables
administration tool for IPv4&#x2F;IPv6 packet filtering and NAT


lsof
list open files. 查看端口被谁占用


nc
arbitrary TCP and UDP connections and listens.


netstat
打印网络连接、路由表、连接的数据统计、伪装连接以及广播域成员


ss
another utility to investigate sockets.


tcpdump
抓包工具


telnet
user interface  ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/06/24/Redis%E7%AC%94%E8%AE%B0/" title="Redis笔记"><img class="post-bg" src="https://s2.loli.net/2022/11/17/jypq1GDmIVfl8WM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Redis笔记"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/06/24/Redis%E7%AC%94%E8%AE%B0/" title="Redis笔记">Redis笔记</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-06-24T06:00:44.000Z" title="发表于 2022-06-24 14:00:44">2022-06-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Redis/">Redis</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Redis/">Redis</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Docker/">Docker</a></span></div><div class="content">Redis 是一个高性能的、键值对数据库，数据直接存储在内存中，只有需要持久化时才写入硬盘。
安装启动ubuntu 下使用 apt 安装的 redis 版本较老，可采用源码安装。
123456wget https://download.redis.io/releases/redis-6.2.6.tar.gz &amp;&amp; tar xzf redis-6.2.6.tar.gzcd redis-stable &amp;&amp; make -jmake testsudo make installsudo mkdir /etc/redis &amp;&amp; sudo cp redis.conf /etc/redis # 复制配置文件到 /etc

安装完成后，会有以下命令可用：

redis-cli: Redis客户端
redis-server: Redis服务器启动命令
redis-benchmark: 性能测试工具
redis-check-aof: 修复有问题的AOF文件
redis-check-rdb: 修复有问题的RDB文件
redis-sentinel: Redis集群 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/06/03/OpenVSwitch-%E6%8E%A7%E5%88%B6%E5%99%A8ONOS/" title="OpenVSwitch-控制器ONOS"><img class="post-bg" src="https://s2.loli.net/2022/11/17/hF7KodYmE6iPWqg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenVSwitch-控制器ONOS"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/06/03/OpenVSwitch-%E6%8E%A7%E5%88%B6%E5%99%A8ONOS/" title="OpenVSwitch-控制器ONOS">OpenVSwitch-控制器ONOS</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-06-03T03:13:30.000Z" title="发表于 2022-06-03 11:13:30">2022-06-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/OpenVSwitch/">OpenVSwitch</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/OpenVSwitch/">OpenVSwitch</a></span></div><div class="content">安装启动直接使用 docker 安装最方便！
1docker pull onosproject/onos

启动，做端口映射，不需要的可以去掉
1docker run -t -d -p 8181:8181 -p 8101:8101 -p 6653:6653 -p 6640:6640 --name onos onosproject/onos


8181 - REST API 和 GUI
8101 - ONOS CLI
9876 - 集群内通信
6653 - Openflow 通信，OVS 连接控制器使用此端口（流表相关操作）
6640 - OVSDB，OVS 网桥、端口相关的配置

启用应用，用于控制OVS时，打开下面的应用，可通过UI 界面操作，也可在容器中用命令行方式启用。
12345678docker exec -it onos bashcd bin./onos-app localhost activate org.onosproject.openflow-base./onos-app localhost activate org.onosproject.ofagent./ono ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/05/23/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" title="OpenVSwitch-DPDK-性能测试"><img class="post-bg" src="https://s2.loli.net/2022/11/17/Zm4kDRxypb5ez3q.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenVSwitch-DPDK-性能测试"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/23/OpenVSwitch-DPDK-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" title="OpenVSwitch-DPDK-性能测试">OpenVSwitch-DPDK-性能测试</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-05-23T13:55:09.000Z" title="发表于 2022-05-23 21:55:09">2022-05-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/OpenVSwitch/">OpenVSwitch</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/OpenVSwitch/">OpenVSwitch</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DPDK/">DPDK</a></span></div><div class="content">
OVS基于DPDK的数据通路绕过了内核协议栈，并且做了很多优化，带来了一定的性能提升，但也引入了很多需要配置的参数，而且这些参数和性能密切相关。

参数说明
ovsdb 官方文档，下面的参数表格只是简单翻译了一下作用，仅供参考，具体信息还得看官方文档

ovsdb中存储着OVS所有配置信息，并按结构划分为一张张表TABLE，这里只关注其中与dpdk有关的配置参数。
Open_vSwitch Table
table th:first-of-type {
    width: 40%;
}
table th:nth-of-type(2) {
    width: 60%;
}





参数
说明



other_config:dpdk-init=true
是否启用dpdk数据通路


other_config:dpdk-lcore-mask=0x1
指定在哪些core上创建lcore线程，该线程用于dpdk库内部消息处理，如日志等；若没有指定，则默认为cpu affinity list中的第一个。为达到最佳性能，最好将其设置在单个core上


other_config:pmd-cp ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/05/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="Linux网络编程-线程池"><img class="post-bg" src="https://s2.loli.net/2022/11/17/ljOdg6ZMc8H9Y5r.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux网络编程-线程池"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/16/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="Linux网络编程-线程池">Linux网络编程-线程池</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-05-16T05:42:10.000Z" title="发表于 2022-05-16 13:42:10">2022-05-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></span></div><div class="content">在多任务并发处理的场景下，如果每来一个任务，就新建一个线程来处理，虽然功能上没问题，但由于线程的创建和销毁会带来很大的开销。线程池就是通过预先创建一定数量的线程，当有任务来时，就将任务分配给一个线程去处理！
线程池模型下面是线程池的结构！
123456789101112131415161718192021222324struct threadpool_t &#123;    pthread_mutex_t lock;           /* 用于锁住本结构体 */    pthread_mutex_t thread_counter; /* 记录忙状态线程个数的锁 */    pthread_cond_t queue_not_full;  /* 当任务队列满时，添加任务任务的线程阻塞，等待此条件变量 */    pthread_cond_t queue_not_empty; /* 任务队列不为空时，通知等待任务的线程 */    pthread_t *threads;             /* 存放线程池中每个线程的 tid 数组 */    pthread_t adjust_ti ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/05/12/OpenVSwitch-%E7%BC%96%E8%AF%91%E5%8F%8A%E5%90%AF%E5%8A%A8/" title="OpenVSwitch-编译及启动"><img class="post-bg" src="https://s2.loli.net/2022/11/17/BeiQmkw4Ya1gvPx.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="OpenVSwitch-编译及启动"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/12/OpenVSwitch-%E7%BC%96%E8%AF%91%E5%8F%8A%E5%90%AF%E5%8A%A8/" title="OpenVSwitch-编译及启动">OpenVSwitch-编译及启动</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-05-12T11:24:45.000Z" title="发表于 2022-05-12 19:24:45">2022-05-12</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/OpenVSwitch/">OpenVSwitch</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/OpenVSwitch/">OpenVSwitch</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/DPDK/">DPDK</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Docker/">Docker</a></span></div><div class="content">基于内核的OVS首先验证内核版本uname -r与你下载的OVS版本是否匹配（必须），目前 ovs-2.16 最高只支持内核5.8！
linux内核与ovs版本匹配关系、ovs版本与DPDK版本匹配关系
以 OVS-2.16.0 为例，编译过程如下：
1234567891011121314151617181920212223242526# 获取源码wget https://github.com/openvswitch/ovs/archive/refs/tags/v2.16.0.zip &amp;&amp; unzip v2.16.0.zip# 安装依赖包sudo apt install build-essential fakerootdpkg-checkbuilddeps # 检查依赖并手动安装缺少的模块#####################################################cd ovs-2.16.0./boot.sh./configure --with-linux=/lib/modules/$(uname -r)/buildmake -j     # ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/05/08/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/" title="Linux网络编程-socket"><img class="post-bg" src="https://s2.loli.net/2022/11/17/BeiQmkw4Ya1gvPx.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux网络编程-socket"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/08/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket/" title="Linux网络编程-socket">Linux网络编程-socket</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-05-08T14:41:39.000Z" title="发表于 2022-05-08 22:41:39">2022-05-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/socket/">socket</a></span></div><div class="content">socket 套接字
图中两个虚线框表示两个套接字，在网络通信中，套接字一定是成对出现的。一端的发送缓冲区对应对端的接收缓冲区。
一个socket只有一个文件描述符，即发送缓冲区和接收缓冲区使用同一个文件描述符。
网络套接字本质：一个文件描述符指向一个套接字（该套接字内部由内核借助两个缓冲区实现）。
网络地址字节序转换由于历史遗留问题，网络数据流采用大端字节序，而 pc 本地一般采用的小段字节序，所以在网络通信中，需要转换字节序。

小端法：（pc本地存储）高位存高地址，地位存低地址。
大端法：（网络存储）高位存低地址，地位存高地址。

字节序只影响不同字节间的顺序，如果只看单字节内部，大小端都一样。不存在00001111变为11110000！
12345678910111213141516#include &lt;arpa/inet.h&gt;// h: host, to, n: network, l: long, s: short// hton也就是主机到网络的转换，ntoh是网络到主机的转换// l, s 对应 32位和 16位数据，也就是 ipv4 地址 和 端口号uint32 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/05/06/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%94%81/" title="Linux系统编程-同步与锁"><img class="post-bg" src="https://s2.loli.net/2022/11/17/UeWP8jCq6dJZSGD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程-同步与锁"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/06/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%94%81/" title="Linux系统编程-同步与锁">Linux系统编程-同步与锁</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-05-06T14:00:59.000Z" title="发表于 2022-05-06 22:00:59">2022-05-06</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E5%90%8C%E6%AD%A5/">同步</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E9%94%81/">锁</a></span></div><div class="content">编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次序运行
线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。
线程同步可以通过锁来实现！与锁相关的部分函数的man page需要单独安装。
1sudo apt install manpages-posix-dev

mutex 互斥量（互斥锁）每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。
资源还是共享的，线程间也还是竞争的，但通过“锁”就将资源的访问变成互斥操作。
互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。因此，即使有了 mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。
尽量保证锁的粒度，越小越好（访问共享数据前，加锁。访问结束立即解锁）。
123456789101112131415#include &lt;pthread.h&gt;// 静态初始化pthead_mut ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/" title="Linux系统编程-线程"><img class="post-bg" src="https://s2.loli.net/2022/11/17/nuDZ3dsB6z4bfVJ.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程-线程"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/04/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E7%BA%BF%E7%A8%8B/" title="Linux系统编程-线程">Linux系统编程-线程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-05-04T13:19:30.000Z" title="发表于 2022-05-04 21:19:30">2022-05-04</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B/">线程</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a></span></div><div class="content">线程概念
虽然可以使用诸多进程来相互协作实现需要并发才能完成的功能，但进程间的协作有着重要的限制：每个进程有自己的独立空间。这种限制导致进程之间的协作存在明显缺陷：如果相互协作的进程需要动态共享大量的数据，则操作起来十分麻烦。就像一群人之间的协作一样，由于每个人都是独立的个体，各有不同的喜好和习惯，协作难免产生误解和沟通困难。如果一件事情让一个人来处理，协作上就不会发生问题。因此，如果能够让一个进程内部实现并发来完成一个复杂的任务，协作上的难度就会少很多。
在进程内部实现并发就是进程出现的动机，如下图所示：


Linux 下，线程又称为LWP: light weight process，轻量级进程。



进程
线程



有独立的进程地址空间
没有独立的地址空间，多个线程共享


有独立的 PCB
有独立的 PCB （但PCB中指向内存资源的三级页表相同）


分配资源的最小单位
CPU 执行的最小单位


查看 ps aux / ps ajx
查看线程号 ps -Lf 进程id


传统意义上的 UNIX 进程只是多线程程序的一个特例，该进程只包含一个线程。
进程中创建线程后，原 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/" title="Linux系统编程-信号"><img class="post-bg" src="https://s2.loli.net/2022/11/17/9ZBEesyr14aJhPM.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程-信号"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/05/02/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/" title="Linux系统编程-信号">Linux系统编程-信号</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-05-02T13:49:35.000Z" title="发表于 2022-05-02 21:49:35">2022-05-02</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a></span></div><div class="content">信号
信号是软件层面上的“中断”。一旦信号产生，无论程序执行到什么位置，必须立即停止运行，处理信号，处理结束，再继续执行后续指令。
所有信号的产生及处理全部都是由【内核】完成的。
简单、不能携带大量信息、满足条件才发送。

信号的生命周期
产生：
未决：产生与递达之间状态。
递达：产生并且送达到进程。直接被内核处理掉。
处理：执行默认处理动作、忽略、捕捉（自定义）

阻塞信号集（信号屏蔽字）：进程控制块PCB中的变量（位图），用来记录信号的屏蔽状态。被屏蔽的信号，在解除屏蔽前，一直处于未决态。
未决信号集：进程控制块PCB中的变量（位图），用来记录信号的处理状态。

信号产生时，未决信号集中对应位立刻翻转为1，表示信号处于未决状态。信号被处理后对应位翻转回0，这一过程往往非常短暂。
信号产生后，由于某些原因（主要是阻塞）不能递达，一直处理未决状态。
设置阻塞后，同一信号多次产生，也只能记录一次（也只会被处理一次）。

1234567891011121314struct task_struct &#123;    /* Signal handlers: */    struct sign ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/04/25/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" title="Linux系统编程-进程通信"><img class="post-bg" src="https://s2.loli.net/2022/11/17/Zm4kDRxypb5ez3q.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程-进程通信"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/25/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" title="Linux系统编程-进程通信">Linux系统编程-进程通信</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-25T13:24:09.000Z" title="发表于 2022-04-25 21:24:09">2022-04-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a></span></div><div class="content">进程通信进程之间是存在内存隔离的，所以进程间通信相对于线程间通信比较麻烦，对于两个完全隔离的事物肯定是没办法进行通信的！不过好在进程并不是完全隔离的，每个进程的地址空间中都有一段共用的内核空间，这就相当于在两个进程之间架了一座桥。所以下面介绍的很多通信方法都是基于这座桥（内核）实现的。


本文中的部分图片来源于：小林coding

标识不过内核地址空间也不能随便给各个进程用，而且空间那么大，进程怎么知道要去哪里读写呢？第一个问题好解决，每当’我’需要和其他进程通信，我就先向内核申请一块“中继内存”，然后就可以向该地址中写数据了。不过第二个问题，其他需要读数据的进程怎么知道去哪里读呢？给读进程指定内存地址？但进程未启动的时候是不可能知道’我’向内核申请的内存地址信息的。唉，圆不了话了，反正就是想一想文件的使用，我同样不知道文件的内存地址，但我只要知道文件的路径，不管开多少个进程去打开该文件，读到的都是相同的内容（虽然文件是存储在磁盘而不是内存上，不过道理类似）。
这里的“路径+文件名”就构成了这个文件对象的唯一标识，我们在进程通信时，也需要一个能唯一标识“中继内存”的标识符，实际上，U ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/04/25/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/" title="Linux系统编程-进程"><img class="post-bg" src="https://s2.loli.net/2022/11/17/nuDZ3dsB6z4bfVJ.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程-进程"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/25/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E8%BF%9B%E7%A8%8B/" title="Linux系统编程-进程">Linux系统编程-进程</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-25T10:23:12.000Z" title="发表于 2022-04-25 18:23:12">2022-04-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E8%BF%9B%E7%A8%8B/">进程</a></span></div><div class="content">
下面的内容如果想要深入、全面地了解，还是建议看书。书上解释得更全面，也可能会有更多例子方便理解，此博客只是为了方便我自己理解以及后续回顾。

进程进程管理、内存管理和文件管理是操作系统的三大核心功能。那么什么是进程呢？顾名思义，进程就是进展中的程序，或者说进程是执行中的程序。那么什么是程序？程序就是一段机器指令，它规定了计算机要做哪些事。

计算机程序的运行实际上是一件十分复杂的事情，牵扯到方方面面。
首先，当然得进行编程，而编程需要计算机程序设计语言作为基础。对于绝大多数编写程序的人来说，使用的编程语言称为高级程序设计语言，如C、C++、Java等。但由于计算机并不认识高级语言编写的程序，编好的程序需要进行编译变成计算机能够识别的机器语言程序，而这需要编译器和汇编器的帮助。其次，机器语言程序需要加载到内存，形成一个运动中的程序，即进程，而这需要操作系统的帮助。进程需要在计算机芯片CPU上执行才算是真正在执行，而将进程调度到CPU上运行也由操作系统完成。最后，在CPU上执行的机器语言指令需要变成能够在一个个时钟脉冲里执行的基本操作，这需要指令集结构和计算机硬件的支持，而整个程序的执行 ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/04/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6/" title="Linux系统编程-文件"><img class="post-bg" src="https://s2.loli.net/2022/11/17/Zm4kDRxypb5ez3q.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程-文件"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E6%96%87%E4%BB%B6/" title="Linux系统编程-文件">Linux系统编程-文件</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-24T09:51:02.000Z" title="发表于 2022-04-24 17:51:02">2022-04-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%96%87%E4%BB%B6/">文件</a></span></div><div class="content">应用程序的系统调用过程：应用程序-&gt;库函数-&gt;系统调用-&gt;驱动-&gt;硬件（磁盘、网卡等）
内核态和用户态现代处理器架构一般允许 CPU 至少在两种不同状态下运行，即：用户态和核心态（有时也称之为监管态 supervisor mode）。执行硬件指令可使 CPU 在两种状态间来回切换。与之对应，可将虚拟内存区域划分（标记）为用户空间部分或内核空间部分。在用户态下运行时，CPU 只能访问被标记为用户空间的内存，试图访问属于内核空间的内存会引发硬件异常。当运行于核心态时，CPU 既能访问用户空间内存，也能访问内核空间内存。
仅当处理器在核心态运行时，才能执行某些特定操作。这样的例子包括：执行宕机（halt）指令去关闭系统，访问内存管理硬件，以及设备 I&#x2F;O 操作的初始化等。实现者们利用这一硬件设计，将操作系统置于内核空间。这确保了用户进程既不能访问内核指令和数据结构，也无法执行不利于系统运行的操作。
系统调用系统调用是受控的内核入口，借助于这一机制，进程可以请求内核以自己的名义去执行某些动作。以应用程序编程接口（API）的形式，内核提供有一系列服务供程序访问。 ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/04/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93/" title="Linux系统编程-静态库动态库"><img class="post-bg" src="https://s2.loli.net/2022/11/17/HCU2TbOi7a1nqLl.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux系统编程-静态库动态库"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/24/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93/" title="Linux系统编程-静态库动态库">Linux系统编程-静态库动态库</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-24T06:40:35.000Z" title="发表于 2022-04-24 14:40:35">2022-04-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Linux/">Linux</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/Makefile/">Makefile</a></span></div><div class="content">静态库文件名格式为：lib&#123;name&#125;.a，只有 {name} 部分可自定义。
动态库文件名格式为：lib&#123;name&#125;.so，只有 {name} 部分可自定义。
静态库和动态库的区别：

静态库会被链接到程序中，而动态库则只记录了库的名称，程序运行时才去对应的路径中加载库。
静态库加载速度快，但较消耗内存，动态库则相反。

gcc 编译流程

-I 指定头文件所在目录位置
-c 只做预处理，编译，汇编。得到二进制文件
-g 编译时添加调试文件，用于 gdb 调试
-Wall 显示所有警告信息
-D 向程序中“动态”注册宏定义
-l 指定动态库库名
-L 指定动态库路径
-O0 关闭优化 (默认)
-O1/-O 让可执⾏⽂件更⼩，速度更快
-O2 采⽤⼏乎所有的优化⼿段

静态库静态库在生成时应提供一个头文件（包含函数声明），以便其他人知晓库提供的方法，方便使用库。

写好源代码 mymath.c,  mymath.h
 12345678910111213141516171819202122232425262728// mymath.cint ad ...</div></div></div><div class="recent-post-item"><div class="post_cover left"><a href="/2022/04/23/ProgramBasic_STL/" title="STL容器"><img class="post-bg" src="https://s2.loli.net/2022/11/17/ljOdg6ZMc8H9Y5r.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="STL容器"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/23/ProgramBasic_STL/" title="STL容器">STL容器</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-23T05:28:02.000Z" title="发表于 2022-04-23 13:28:02">2022-04-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/C/">C++</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/C/">C++</a><span class="article-meta-link">•</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/STL/">STL</a></span></div><div class="content">线程安全：

这里列出的C++ 标准库中的容器都不是线程安全的！多个线程读时不需要加锁，但有一个线程写时，所有读写线程都需要加锁！

效率说明：

emplace_back() 是c11新加的，功能与 push_back() 一样，但效率更高，推荐优先使用

序列式容器
序列式容器 hackingcpp

Array
固定大小的数组，必须在建立时就指明其大小。

.front()：返回第一元素的引用，你可以使用这些操作函数更改元素内容
.back()：返回最末元素的引用，c.back() = 10

Vector
Vector 是一个 dynamic array。
大小可变，但内存重新分配很耗时间。
在Vector尾部附加元素或移除元素都很快速，但是在Vector的中段或起始段安插元素就比较费时

.front()：返回第一元素的引用 (不检查是否存在第一元素)
.back()：返回最末元素的引用 (不检查是否存在最末元素)，c.back() = 10
.push_back(elem)：尾部附加元素
.pop_back()：移除最后一个元素
.insert(pos, elem)：在it ...</div></div></div><div class="recent-post-item"><div class="post_cover right"><a href="/2022/04/23/DS_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%91%98%E8%A6%81/" title="数据结构摘要"><img class="post-bg" src="https://s2.loli.net/2022/11/17/ljOdg6ZMc8H9Y5r.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构摘要"></a></div><div class="recent-post-info"><a class="article-title" href="/2022/04/23/DS_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%91%98%E8%A6%81/" title="数据结构摘要">数据结构摘要</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-04-23T01:55:02.000Z" title="发表于 2022-04-23 09:55:02">2022-04-23</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span><span class="article-meta tags"><span class="article-meta-separator">|</span><i class="fas fa-tag"></i><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="content">只有重点、简洁的介绍，方便查阅！

数据结构可视化网站：部分结构如树，点击后需要手动添加节点，且能看到其变化的过程。另一个可视化数据结构和算法的网站：visualgo.net&#x2F;zh

树
树是由根节点和若干颗子树构成。
每个节点都只有有限个子节点或无子节点。
没有父节点的节点称为根节点。没有子节点的节点称为叶子节点。
树的深度&#x2F;高度：根节点到最远叶子节点的最长路径上的节点数。

二叉树
每个节点最多只有两个子节点的树。

满二叉树
树中的每个节点仅包含 0 或 2 个子节点。

完全二叉树
除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。
重要性质：
在二叉树上的第i层上至多有 $2^{i-1}, i&gt;&#x3D;1$个节点。
深度为k的二叉树至多有 $2^k-1, k &gt;&#x3D; 1$个节点。
具有n个节点的完全二叉树的深度为 floor&#123; log2(n) &#125; + 1 。


对一颗具有n个节点的完全二叉树中的节点从0开始按层序编号，对任意节点i：
其父节点编号为：floor&#123; (i-1) ...</div></div></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fas fa-chevron-left fa-fw"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/#content-inner">3</a><a class="extend next" rel="next" href="/page/3/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2024/09/17/3NdhvxIcPRVpufD.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">(ง'̀-'́)ง</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">48</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yo-gurts"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/yo-gurts" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:yusong1117.u@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/24/Linux-sysfs/" title="Linux sysfs"><img src="https://s2.loli.net/2022/11/17/nuDZ3dsB6z4bfVJ.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux sysfs"/></a><div class="content"><a class="title" href="/2024/09/24/Linux-sysfs/" title="Linux sysfs">Linux sysfs</a><time datetime="2024-09-24T14:37:59.000Z" title="发表于 2024-09-24 22:37:59">2024-09-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/22/Linux-USBfunctionfs/" title="Linux USB functionfs"><img src="https://s2.loli.net/2022/11/17/UeWP8jCq6dJZSGD.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux USB functionfs"/></a><div class="content"><a class="title" href="/2024/09/22/Linux-USBfunctionfs/" title="Linux USB functionfs">Linux USB functionfs</a><time datetime="2024-09-22T14:31:05.000Z" title="发表于 2024-09-22 22:31:05">2024-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/22/Linux-USBconfigfs/" title="Linux USB gadget_configfs"><img src="https://s2.loli.net/2022/11/17/hF7KodYmE6iPWqg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux USB gadget_configfs"/></a><div class="content"><a class="title" href="/2024/09/22/Linux-USBconfigfs/" title="Linux USB gadget_configfs">Linux USB gadget_configfs</a><time datetime="2024-09-22T13:44:30.000Z" title="发表于 2024-09-22 21:44:30">2024-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/22/Linux-configfs/" title="Linux configfs"><img src="https://s2.loli.net/2022/11/17/Zm4kDRxypb5ez3q.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux configfs"/></a><div class="content"><a class="title" href="/2024/09/22/Linux-configfs/" title="Linux configfs">Linux configfs</a><time datetime="2024-09-22T02:37:42.000Z" title="发表于 2024-09-22 10:37:42">2024-09-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/17/Linux-USBmtp/" title="Linux USB mtp"><img src="https://s2.loli.net/2022/11/17/BeiQmkw4Ya1gvPx.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux USB mtp"/></a><div class="content"><a class="title" href="/2024/09/17/Linux-USBmtp/" title="Linux USB mtp">Linux USB mtp</a><time datetime="2024-09-17T12:02:15.000Z" title="发表于 2024-09-17 20:02:15">2024-09-17</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Alios/"><span class="card-category-list-name">Alios</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/C/"><span class="card-category-list-name">C++</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Cvitek/"><span class="card-category-list-name">Cvitek</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Linux/"><span class="card-category-list-name">Linux</span><span class="card-category-list-count">19</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/OpenVSwitch/"><span class="card-category-list-name">OpenVSwitch</span><span class="card-category-list-count">5</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Redis/"><span class="card-category-list-name">Redis</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Scripts/"><span class="card-category-list-name">Scripts</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Tensorflow/"><span class="card-category-list-name">Tensorflow</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/uboot/" style="font-size: 1.1em; color: #999">uboot</a> <a href="/tags/openssl/" style="font-size: 1.1em; color: #999">openssl</a> <a href="/tags/%E5%90%8C%E6%AD%A5/" style="font-size: 1.1em; color: #999">同步</a> <a href="/tags/Cvitek/" style="font-size: 1.26em; color: #999fa8">Cvitek</a> <a href="/tags/%E8%AE%BE%E5%A4%87%E6%A0%91/" style="font-size: 1.1em; color: #999">设备树</a> <a href="/tags/%E9%94%81/" style="font-size: 1.1em; color: #999">锁</a> <a href="/tags/Tensorflow/" style="font-size: 1.1em; color: #999">Tensorflow</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 1.18em; color: #999ca1">线程</a> <a href="/tags/DTS/" style="font-size: 1.1em; color: #999">DTS</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.1em; color: #999">数据结构</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.1em; color: #999">算法</a> <a href="/tags/poweroff/" style="font-size: 1.1em; color: #999">poweroff</a> <a href="/tags/Docker/" style="font-size: 1.18em; color: #999ca1">Docker</a> <a href="/tags/select/" style="font-size: 1.1em; color: #999">select</a> <a href="/tags/c/" style="font-size: 1.1em; color: #999">c</a> <a href="/tags/%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/" style="font-size: 1.1em; color: #999">日志系统</a> <a href="/tags/epoll/" style="font-size: 1.1em; color: #999">epoll</a> <a href="/tags/STL/" style="font-size: 1.1em; color: #999">STL</a> <a href="/tags/OpenVSwitch/" style="font-size: 1.42em; color: #99a6b7">OpenVSwitch</a> <a href="/tags/aes/" style="font-size: 1.1em; color: #999">aes</a> <a href="/tags/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/" style="font-size: 1.1em; color: #999">启动流程</a> <a href="/tags/Rootfs/" style="font-size: 1.1em; color: #999">Rootfs</a> <a href="/tags/Kernel/" style="font-size: 1.1em; color: #999">Kernel</a> <a href="/tags/socket/" style="font-size: 1.18em; color: #999ca1">socket</a> <a href="/tags/Uboot/" style="font-size: 1.1em; color: #999">Uboot</a> <a href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" style="font-size: 1.1em; color: #999">线程池</a> <a href="/tags/poll/" style="font-size: 1.1em; color: #999">poll</a> <a href="/tags/USB/" style="font-size: 1.5em; color: #99a9bf">USB</a> <a href="/tags/rsa/" style="font-size: 1.1em; color: #999">rsa</a> <a href="/tags/configfs/" style="font-size: 1.26em; color: #999fa8">configfs</a> <a href="/tags/sha256/" style="font-size: 1.1em; color: #999">sha256</a> <a href="/tags/%E6%96%87%E4%BB%B6/" style="font-size: 1.1em; color: #999">文件</a> <a href="/tags/sysfs/" style="font-size: 1.1em; color: #999">sysfs</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 1.1em; color: #999">排序</a> <a href="/tags/Makefile/" style="font-size: 1.1em; color: #999">Makefile</a> <a href="/tags/gdb/" style="font-size: 1.1em; color: #999">gdb</a> <a href="/tags/Clang/" style="font-size: 1.1em; color: #999">Clang</a> <a href="/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 1.26em; color: #999fa8">进程</a> <a href="/tags/git/" style="font-size: 1.1em; color: #999">git</a> <a href="/tags/C/" style="font-size: 1.34em; color: #99a3b0">C++</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/09/"><span class="card-archive-list-date">九月 2024</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/08/"><span class="card-archive-list-date">八月 2024</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/06/"><span class="card-archive-list-date">六月 2024</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><span class="card-archive-list-count">3</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">41</div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">185.2k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2024-09-24T15:55:52.179Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By (ง'̀-'́)ง</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>window.typedJSFn = {
  init: (str) => {
    window.typed = new Typed('#subtitle', Object.assign({
      strings: str,
      startDelay: 300,
      typeSpeed: 150,
      loop: true,
      backSpeed: 50,
    }, null))
  },
  run: (subtitleType) => {
    if (false) {
      if (typeof Typed === 'function') {
        subtitleType()
      } else {
        getScript('https://cdn.jsdelivr.net/npm/typed.js@2.1.0/dist/typed.umd.min.js').then(subtitleType)
      }
    } else {
      subtitleType()
    }
  }
}
</script><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(result =>{
      if (false) {
        const sub = []
        const content = result.data.content
        sub.unshift(content)
        typedJSFn.init(sub)
      } else {
        document.getElementById('subtitle').textContent = result.data.content
      }
    })
  })
}
typedJSFn.run(subtitleType)
</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>